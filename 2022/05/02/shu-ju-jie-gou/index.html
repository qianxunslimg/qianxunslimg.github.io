<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/MTMRB7P@G[WVCWEB9W([}FT.png >
    <title>
        qianxunslimgのblog
    </title>
    <meta name="description" content= 欢迎访问我的博客， >
    <meta name="keywords" content= qianxunslimg,blog,job,面试,找工作 >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            数据结构
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB-Tree"></a>RB-Tree</h2><h3 id="概念明确"><a href="#概念明确" class="headerlink" title="概念明确"></a>概念明确</h3><h4 id="二叉搜索树（二叉查找树）-BST"><a href="#二叉搜索树（二叉查找树）-BST" class="headerlink" title="二叉搜索树（二叉查找树） BST"></a>二叉搜索树（二叉查找树） BST</h4><p>二叉查找树是一种特殊的<strong>二叉树</strong>，因此其也有递归定义：</p>
<ul>
<li>二叉搜索树是一颗空树</li>
<li>二叉搜索树由根结点、左子树、右子树组成，其中左子树、右子树都是二叉查找树，且左子树上<strong>所有结点的数据域均小于或等于根结点的数据域</strong>，右子树上<strong>所有结点的数据域均大于根结点的数据域</strong>。</li>
</ul>
<h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h4><p>本质：仍是一棵<code>二叉搜索树</code>，只不过增加了平衡的要求</p>
<p>特点：使树的高度在每次插入元素后仍能保持O(logn)级别</p>
<p>平衡：对于树中任意结点，其<strong>左子树与右子树的高度之差的绝对值</strong>不大于1</p>
<p>平衡因子：<strong>结点的左子树与右子树的高度之差</strong></p>
<h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><p>红黑树是一种含有红黑结点并能<code>自平衡的二叉查找树</code>。</p>
<ul>
<li>性质1：每个节点要么是黑色，要么是红色。</li>
<li>性质2：根节点是黑色。</li>
<li>性质3：每个叶子节点（NIL）是黑色。</li>
<li>性质4：每个红色结点的两个子结点一定都是黑色。</li>
<li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li>
<li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li>
</ul>
<p><strong>黑是真正的节点，而红只不过是用来表示两个键是属于一个3-节点。</strong></p>
<p>红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</p>
<ul>
<li><p><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。（<code>右子节点的左岔连自己 右子节点当爹</code>）</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-a95db442f1b47f8a.png" alt="img"></p>
</li>
<li><p><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。（<code>左子节点的右岔连自己 左子节点当爹</code>）</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-0676a8e2a12e2a0b.png" alt="img"></p>
</li>
<li><p><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</p>
</li>
</ul>
<p>红黑树的维护可以简要地概括为三句话：</p>
<ol>
<li>如果右子节点是红色的，而左子节点是黑色的，进行左旋转。</li>
<li>如果左子节点是红色的，且它的左子节点也是红色的，进行右旋转。</li>
<li>如果左右子节点均为红色,进行颜色转换</li>
</ol>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ol>
<li>从根结点开始查找，把根结点设置为当前结点；</li>
<li>若当前结点为空，返回null；</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较；</li>
<li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li>
</ol>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-07b47eb3722981e6.png" alt="img"></p>
<h2 id="b树和b-树"><a href="#b树和b-树" class="headerlink" title="b树和b+树"></a>b树和b+树</h2><h3 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h3><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），<code>数据库索引技术</code>里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p>
<p>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
<p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_r.jpg" alt="img"></p>
<h4 id="B树的查询流程"><a href="#B树的查询流程" class="headerlink" title="B树的查询流程"></a>B树的查询流程</h4><p>如上图我要从上图中找到E字母，查找流程如下</p>
<p>（1）获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p>
<p>（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</p>
<p>（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
<h4 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a>B树的插入节点流程</h4><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28、53 这些数字构建出一个5阶树出来;</p>
<p>遵循规则：</p>
<p>（1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）；</p>
<p>（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;</p>
<p>先插入 3、8、31、11</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-66a9896538aac51fa9e5e3675ac22fe7_r.jpg" alt="img"></p>
<p>再插入23、29</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-29884e575bff8a49898eae6ab0e5a1aa_r.jpg" alt="img"></p>
<p>再插入50、28、53</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-611a75c925af37f8e6f18dfc0f8a0760_r.jpg" alt="img"></p>
<h4 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a>B树节点的删除</h4><h5 id="规则："><a href="#规则：" class="headerlink" title="规则："></a><strong>规则：</strong></h5><p>（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于 ceil(m/2)-1（所以这里关键字数&lt;2就要进行节点合并）；</p>
<p>（2）满足节点本身比左边节点大，比右边节点小的排序规则;</p>
<p>（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-a8712ab2bded1411726efea37ae20223_r.jpg" alt="img"></p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h5><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><code>B+树是B树的一个升级版</code>，相对于B树来说B+树<code>更充分的利用了节点的空间</code>，<code>让查询速度更加稳定</code>，<code>其速度完全接近于二分法查找</code>。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p>
<p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-5f069fd820637db1b877fdd6799a2b67_r.jpg" alt="img"></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_r.jpg" alt="img"></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p>
<p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p>
<p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p>
<p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: qianxunslimg | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
