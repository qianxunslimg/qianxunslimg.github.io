

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/avatar.png">
  <link rel="icon" href="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="qianxunslimg">
  <meta name="keywords" content="">
  
    <meta name="description" content="框架for 状态1 in 状态1的所有取值：     for 状态2 in 状态2的所有取值：         for ...             dp[状态1][状态2][...] &#x3D; 择优(选择1，选择2...)  一些dp问题剑指 Offer II 088. 爬楼梯的最少成本难度简单38英文版讨论区 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（">
<meta property="og:type" content="article">
<meta property="og:title" content="dp">
<meta property="og:url" content="https://qianxunslimg.github.io/2022/04/14/dp/index.html">
<meta property="og:site_name" content="qianxunslimgのblog">
<meta property="og:description" content="框架for 状态1 in 状态1的所有取值：     for 状态2 in 状态2的所有取值：         for ...             dp[状态1][状态2][...] &#x3D; 择优(选择1，选择2...)  一些dp问题剑指 Offer II 088. 爬楼梯的最少成本难度简单38英文版讨论区 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220501231554023.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132135089.gif">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132138328.gif">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132145601.jpeg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob1-tree.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob2-tree.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202101101032124.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220505094926693.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416161203581.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20201221201553618.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1631176639-giAMKQ-image.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/robot_maze.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/minpath.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/max1grid.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417172957421.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173007635.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173040449.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg">
<meta property="article:published_time" content="2022-04-13T17:52:49.000Z">
<meta property="article:modified_time" content="2022-07-08T11:37:47.035Z">
<meta property="article:author" content="qianxunslimg">
<meta property="article:tag" content="算法总结">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220501231554023.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>dp - qianxunslimgのblog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"qianxunslimg.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>qianxunslimg</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="dp"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-04-14 01:52" pubdate>
          2022年4月14日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">dp</h1>
            
            <div class="markdown-body">
              
              <h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：
    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：
        <span class="hljs-keyword">for</span> ...
            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)</code></pre></div>

<h1 id="一些dp问题"><a href="#一些dp问题" class="headerlink" title="一些dp问题"></a>一些dp问题</h1><h3 id="剑指-Offer-II-088-爬楼梯的最少成本"><a href="#剑指-Offer-II-088-爬楼梯的最少成本" class="headerlink" title="剑指 Offer II 088. 爬楼梯的最少成本"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/GzCJIP/">剑指 Offer II 088. 爬楼梯的最少成本</a></h3><p>难度简单38英文版讨论区</p>
<p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 <code>0</code> 开始）。</p>
<p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span>
输出：15
解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。</code></pre></div>

<p> <strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span>
输出：6
解释：最低花费方式是从 cost<span class="hljs-comment">[0]</span> 开始，逐个经过那些 1 ，跳过 cost<span class="hljs-comment">[3]</span> ，一共花费 6 。</code></pre></div>

<h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>dp</p>
<ol>
<li>dp数组含义： dp[i]表示到达当前台阶的最小花费</li>
<li>状态转移： 当前台阶由之前两个台阶跳跃抵达dp[i] = min(dp[i-1] + nums[i-1], dp[i-2] + nums[i-2]);</li>
<li>base case: 第一和第二的花费为0</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() + <span class="hljs-number">1</span>)</span></span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; i++){
        dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i<span class="hljs-number">-2</span>]);
      }
      <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-091-粉刷房子"><a href="#剑指-Offer-II-091-粉刷房子" class="headerlink" title="剑指 Offer II 091. 粉刷房子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/JEj789/">剑指 Offer II 091. 粉刷房子</a></h3><p>难度中等35英文版讨论区</p>
<p>假如有一排房子，共 <code>n</code> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <code>n x 3</code> 的正整数矩阵 <code>costs</code> 来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成绿色的花费，以此类推。</p>
<p>请计算出粉刷完所有房子最少的花费成本。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入: costs = <span class="hljs-string">[[17,2,17],[16,16,5],[14,3,19]]</span>
输出: <span class="hljs-number">10</span>
解释: 将 <span class="hljs-number">0</span> 号房子粉刷成蓝色，<span class="hljs-number">1</span> 号房子粉刷成绿色，<span class="hljs-number">2</span> 号房子粉刷成蓝色。
     最少花费: <span class="hljs-number">2</span> + <span class="hljs-number">5</span> + <span class="hljs-number">3</span> = <span class="hljs-number">10</span>。</code></pre></div>

<h4 id="解法-dp"><a href="#解法-dp" class="headerlink" title="解法 dp"></a>解法 dp</h4><ol>
<li>dp数组含义：dp[i] [j]表示粉刷到第i个房子 用第j个颜色的最小花费</li>
<li>状态转移方程：当前房子当前颜色 的值 为上一个房子 其他颜色中的最小值</li>
<li>base case：第一个房子 的花费 结尾当前颜色的cost</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; costs)</span> </span>{
      <span class="hljs-keyword">int</span> m = costs.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">int</span> n = m == <span class="hljs-number">0</span>?<span class="hljs-number">0</span>:costs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));
      dp[<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++){
          <span class="hljs-keyword">int</span> tempMin = INT_MAX;
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k&lt;n; k++){
            <span class="hljs-keyword">if</span>(k != j){
              tempMin = <span class="hljs-built_in">min</span>(tempMin, dp[i<span class="hljs-number">-1</span>][k]);
            }
          } 
          dp[i][j] = costs[i][j] + tempMin;
        }
      }
      <span class="hljs-keyword">return</span> *<span class="hljs-built_in">min_element</span>(dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">end</span>());
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-092-翻转字符"><a href="#剑指-Offer-II-092-翻转字符" class="headerlink" title="剑指 Offer II 092. 翻转字符"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cyJERH/">剑指 Offer II 092. 翻转字符</a></h3><p>难度中等28英文版讨论区</p>
<p>如果一个由 <code>'0'</code> 和 <code>'1'</code> 组成的字符串，是以一些 <code>'0'</code>（可能没有 <code>'0'</code>）后面跟着一些 <code>'1'</code>（也可能没有 <code>'1'</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p>
<p>我们给出一个由字符 <code>'0'</code> 和 <code>'1'</code> 组成的字符串 s，我们可以将任何 <code>'0'</code> 翻转为 <code>'1'</code> 或者将 <code>'1'</code> 翻转为 <code>'0'</code>。</p>
<p>返回使 s <strong>单调递增</strong> 的最小翻转次数。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs erlang">输入：s = <span class="hljs-string">"00110"</span>
输出：<span class="hljs-number">1</span>
解释：我们翻转最后一位得到 <span class="hljs-number">00111</span>.</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"010110"</span>
输出：<span class="hljs-number">2</span>
解释：我们翻转得到 <span class="hljs-number">011111</span>，或者是 <span class="hljs-number">000111</span>。</code></pre></div>

<h4 id="dp解法"><a href="#dp解法" class="headerlink" title="dp解法"></a>dp解法</h4><ol>
<li><p>dp数组含义：单调递增的子字符串 ：dp[0] [i]最后一个是0   dp[1] [i]最后一个是1</p>
</li>
<li><p>状态转移方程：</p>
<p>当前为0 = 之前为0 + 现在的数（是1的话 需要反转+1，0的话则不需要加）</p>
<p>当前为1 = 之前为0 和 之前为1 中的小值 + 现在的数（是1的话 不需要反转，0的话需要反转+1）</p>
</li>
<li><p>base case：</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));
      dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;
      dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">'1'</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
        dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] + (s[i] == <span class="hljs-string">'0'</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>);
        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>], dp[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>]) + (s[i] == <span class="hljs-string">'1'</span>?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>], dp[<span class="hljs-number">1</span>][n<span class="hljs-number">-1</span>]);
    }
};</code></pre></div>

<h4 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();
      <span class="hljs-comment">//dp[i][0]表示i 变为0 最小反转次数</span>
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
      dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>? <span class="hljs-number">0</span>: <span class="hljs-number">1</span>;
      dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">'0'</span>? <span class="hljs-number">1</span>: <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'0'</span>){
          dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
          dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>{
          dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
          dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-093-最长斐波那契数列"><a href="#剑指-Offer-II-093-最长斐波那契数列" class="headerlink" title="剑指 Offer II 093. 最长斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/Q91FMA/">剑指 Offer II 093. 最长斐波那契数列</a></h3><p>难度中等31英文版讨论区</p>
<p>如果序列 <code>X_1, X_2, ..., X_n</code> 满足下列条件，就说它是 <em>斐波那契式</em> 的：</p>
<ul>
<li><code>n &gt;= 3</code></li>
<li>对于所有 <code>i + 2 &lt;= n</code>，都有 <code>X_i + X_{i+1} = X_{i+2}</code></li>
</ul>
<p>给定一个<strong>严格递增</strong>的正整数数组形成序列 <code>arr</code> ，找到 <code>arr</code> 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p>
<p><em>（回想一下，子序列是从原序列 <code>arr</code> 中派生出来的，它从 <code>arr</code> 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， <code>[3, 5, 8]</code> 是 <code>[3, 4, 5, 6, 7, 8]</code> 的一个子序列）</em></p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs dns">输入: arr = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>]
输出: <span class="hljs-number">5</span>
解释: 最长的斐波那契式子序列为 [<span class="hljs-number">1,2,3,5</span>,<span class="hljs-number">8</span>] 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: arr = <span class="hljs-comment">[1,3,7,11,12,14,18]</span>
输出: 3
解释: 最长的斐波那契式子序列有 <span class="hljs-comment">[1,11,12]</span>、<span class="hljs-comment">[3,11,14]</span> 以及 <span class="hljs-comment">[7,11,18]</span> 。</code></pre></div>

<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>因为是斐波那契 所以两个数就可以确定整个序列</p>
<p>暴力也就是枚举所有的两个数的组合 然后交替查找下一个数是否在nums中 并更新ans</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>{
        <span class="hljs-keyword">int</span> N = A.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">S</span><span class="hljs-params">(A.begin(), A.end())</span></span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; N; ++j) {
                <span class="hljs-keyword">int</span> x = A[j], y = A[i] + A[j];
                <span class="hljs-keyword">int</span> length = <span class="hljs-number">2</span>;
                <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">find</span>(y) != S.<span class="hljs-built_in">end</span>()) {
                    <span class="hljs-keyword">int</span> z = x + y;
                    x = y;
                    y = z;
                    ans = <span class="hljs-built_in">max</span>(ans, ++length);
                }
            }

        <span class="hljs-keyword">return</span> ans &gt;= <span class="hljs-number">3</span> ? ans : <span class="hljs-number">0</span>;
    }
};</code></pre></div>

<p>二刷暴力</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
      <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sett</span><span class="hljs-params">(arr.begin(), arr.end())</span></span>;
      <span class="hljs-keyword">int</span> maxx = *(arr.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>);
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;arr.<span class="hljs-built_in">size</span>(); j++){
          <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">fibor</span>(sett, arr[i], arr[j], maxx);
          <span class="hljs-comment">//cout&lt;&lt;cnt&lt;&lt;" ";</span>
          ans = <span class="hljs-built_in">max</span>(ans, cnt&gt;=<span class="hljs-number">3</span>? cnt:<span class="hljs-number">0</span>);
        }
      }
      <span class="hljs-comment">//cout&lt;&lt;endl;</span>
      <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fibor</span><span class="hljs-params">(unordered_set&lt;<span class="hljs-keyword">int</span>&gt;&amp; sett, <span class="hljs-keyword">int</span> dp0, <span class="hljs-keyword">int</span> dp1, <span class="hljs-keyword">int</span> maxx)</span></span>{
      <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">2</span>;
      <span class="hljs-keyword">int</span> temp = dp0;
      <span class="hljs-keyword">while</span>(dp1 &lt;= maxx){
        temp = dp1;
        dp1 = dp0 + dp1;
        dp0 = temp;
        <span class="hljs-keyword">if</span>(sett.<span class="hljs-built_in">count</span>(dp1))
          cnt++;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">return</span> cnt;
    }
};</code></pre></div>

<h4 id="dp解法-1"><a href="#dp解法-1" class="headerlink" title="dp解法"></a>dp解法</h4><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220501231554023.png" srcset="/img/loading.gif" lazyload alt="image-20220501231554023" style="zoom: 67%;">

<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">2</span>));
      unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mapp;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)
        mapp[nums[i]] = i;
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;n; j++){
          <span class="hljs-keyword">int</span> diff = nums[j] - nums[i];
          <span class="hljs-keyword">if</span>(mapp.<span class="hljs-built_in">count</span>(diff)){
            <span class="hljs-keyword">int</span> preIndex = mapp[diff];
            <span class="hljs-keyword">if</span>(preIndex&lt;i)
              dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[preIndex][i] + <span class="hljs-number">1</span>);
          }
          ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);
        }
      }
      <span class="hljs-keyword">return</span> ans&gt;<span class="hljs-number">2</span>?ans:<span class="hljs-number">0</span>;
    }
};</code></pre></div>



<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132135089.gif" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: numRows = 5
输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span></code></pre></div>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>dp迭代 生成二维ans数组</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-keyword">int</span> numRows) {
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;numRows; i++){
            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(i+<span class="hljs-number">1</span>)</span></span>;
            temp[<span class="hljs-number">0</span>] = temp[i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//首位数据是确定的 base case</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;i; j++){
                <span class="hljs-comment">//状态转移方程</span>
                temp[j] = ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + ans[i<span class="hljs-number">-1</span>][j];
            }
            ans.<span class="hljs-built_in">push_back</span>(temp);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II "></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II </a></h3><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132138328.gif" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>示例 1:</p>
<p>输入: rowIndex = 3<br>输出: [1,3,3,1]</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>注意 此处的rowIndex 从0开始</li>
</ol>
<h4 id="朴素的dp解法"><a href="#朴素的dp解法" class="headerlink" title="朴素的dp解法"></a>朴素的dp解法</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//dp解法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>{
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">C</span>(rowIndex + <span class="hljs-number">1</span>); <span class="hljs-comment">//这道题rowindex从0开始</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowIndex; ++i) {
            C[i].<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);
            C[i][<span class="hljs-number">0</span>] = C[i][i] = <span class="hljs-number">1</span>; <span class="hljs-comment">//base case 首尾必定是1</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) {
                C[i][j] = C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + C[i - <span class="hljs-number">1</span>][j];
            }
        }
        <span class="hljs-keyword">return</span> C[rowIndex];
    }
};</code></pre></div>

<h4 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>{
        vector&lt;<span class="hljs-keyword">int</span>&gt; pre, cur;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowIndex; ++i) {
            cur.<span class="hljs-built_in">resize</span>(i + <span class="hljs-number">1</span>);
            cur[<span class="hljs-number">0</span>] = cur[i] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) {
                cur[j] = pre[j - <span class="hljs-number">1</span>] + pre[j];
            }
            pre = cur;
        }
        <span class="hljs-keyword">return</span> pre;
    }
};</code></pre></div>

<h4 id="继续优化-从后到前"><a href="#继续优化-从后到前" class="headerlink" title="继续优化 从后到前"></a>继续优化 从后到前</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(rowIndex + <span class="hljs-number">1</span>)</span></span>;
        row[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; ++i) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; --j) {
                row[j] += row[j - <span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-keyword">return</span> row;
    }
};</code></pre></div>

<h4 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h4><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132145601.jpeg" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;">

<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">row</span><span class="hljs-params">(rowIndex + <span class="hljs-number">1</span>)</span></span>;
        row[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= rowIndex; ++i) {
          	<span class="hljs-comment">//杨辉三角 组合数规律</span>
            row[i] = <span class="hljs-number">1LL</span> * row[i - <span class="hljs-number">1</span>] * (rowIndex - i + <span class="hljs-number">1</span>) / i;
        }
        <span class="hljs-keyword">return</span> row;
    }
};</code></pre></div>



<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h3 id="剑指-Offer-II-089-房屋偷盗"><a href="#剑指-Offer-II-089-房屋偷盗" class="headerlink" title="剑指 Offer II 089. 房屋偷盗"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></h3><p>难度中等19</p>
<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：nums = [1,2,3,1]
输出：4
解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。
     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。
     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。</code></pre></div>

<h4 id="解法1-dp"><a href="#解法1-dp" class="headerlink" title="解法1 dp"></a>解法1 dp</h4><ol>
<li>dp含义：dp[i] 表示0 - i个房屋 能够偷的最多钱</li>
<li>状态转移：max（偷当前房屋（这家存款 + 前前dp），不偷当前房屋（前dp）)</li>
<li>base case：   dp[0] = nums[0]; dp[1] = max(dp[0], nums[1]);</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">front</span>();
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;
      dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
      dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;n; i++){
        dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i]);
      }
      <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-090-环形房屋偷盗"><a href="#剑指-Offer-II-090-环形房屋偷盗" class="headerlink" title="剑指 Offer II 090. 环形房屋偷盗"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/PzWKhm/">剑指 Offer II 090. 环形房屋偷盗</a></h3><p>难度中等17</p>
<p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组 <code>nums</code> ，请计算 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。
     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。</code></pre></div>

<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首尾房间不能同时被抢，那么只可能有三种不同情况：</p>
<ul>
<li>要么都不被抢；</li>
<li>要么第一间房子被抢最后一间不抢；</li>
<li>要么最后一间房子被抢第一间不抢。</li>
</ul>
<p>所以只需要计算 <code>第一家不抢和最后一家不抢</code>的 情况 取最大值</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//首尾房间不能同时被抢，那么只可能有三种不同情况：</span>
    <span class="hljs-comment">//要么都不被抢；</span>
    <span class="hljs-comment">//要么第一间房子被抢最后一间不抢；</span>
    <span class="hljs-comment">//要么最后一间房子被抢第一间不抢。</span>
    <span class="hljs-comment">//所以只需要计算 第一家不抢和最后一家不抢的 情况 取最大值</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">front</span>();
      <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;
      <span class="hljs-comment">// 从第二家 抢到最后</span>
      dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];
      dp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">2</span>]);
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i&lt;n; i++){
        dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>]);
      }
      <span class="hljs-keyword">int</span> tempMax = dp[n<span class="hljs-number">-1</span>];
      <span class="hljs-comment">//第一家抢到倒数第二家</span>
      dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
      dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;n - <span class="hljs-number">1</span>; i++){
        dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>]);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tempMax, dp[n<span class="hljs-number">-2</span>]);
    }
};</code></pre></div>

<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=337">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/#">思路</a></p>
<p>难度中等1272</p>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob1-tree.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入: root = [3,2,3,null,3,null,1]
输出:<span class="hljs-number"> 7 </span>
解释: 小偷一晚能够盗取的最高金额<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>= 7</code></pre></div>

<p><strong>示例 2:</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob2-tree.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [3,4,5,1,3,null,1]</span>
<span class="hljs-section">输出: 9</span>
<span class="hljs-section">解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</span></code></pre></div>

<h4 id="解法1-记忆化递归"><a href="#解法1-记忆化递归" class="headerlink" title="解法1 记忆化递归"></a>解法1 记忆化递归</h4><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p>与198.打家劫舍，213.打家劫舍II一样，关键是要讨论当前节点抢还是不抢。</p>
<p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（<strong>注意这里说的是“考虑”</strong>）</p>
<p>使用一个map把计算过的结果保存一下，这样如果计算过孙子了，那么计算孩子的时候可以复用孙子节点的结果。不然会超时</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; mapp;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>{
      <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> root-&gt;val;
      <span class="hljs-keyword">if</span>(mapp[root]) <span class="hljs-keyword">return</span> mapp[root];
      <span class="hljs-comment">//偷父节点</span>
      <span class="hljs-keyword">int</span> val1 = root-&gt;val;
      <span class="hljs-keyword">if</span>(root-&gt;left) val1 += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);
      <span class="hljs-keyword">if</span>(root-&gt;right) val1 += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);
      <span class="hljs-comment">//不偷父节点</span>
      <span class="hljs-keyword">int</span> val2 = <span class="hljs-built_in">rob</span>(root-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right);
      mapp[root] = <span class="hljs-built_in">max</span>(val1, val2);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(val1, val2);
    }
};</code></pre></div>

<h4 id="解法2-树形dp"><a href="#解法2-树形dp" class="headerlink" title="解法2 树形dp"></a>解法2 树形dp</h4><p>dp含义：使用一个pair记录当前节点 偷 与 不偷 可以获得的最大金钱</p>
<p>状态转移：偷当前节点（当前val + 左子树不偷 + 右子树不偷），不偷当前（左子树偷 + 右子树偷）</p>
<p>base case：节点为空 偷不偷都为0</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>{
      pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; ans = <span class="hljs-built_in">helper</span>(root);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans.first, ans.second);
    }
    <span class="hljs-comment">//first偷 second不偷</span>
    <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* node)</span></span>{
      <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
      pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; left = <span class="hljs-built_in">helper</span>(node-&gt;left);
      pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; right = <span class="hljs-built_in">helper</span>(node-&gt;right);
      <span class="hljs-comment">//偷父节点</span>
      <span class="hljs-keyword">int</span> val1 = node-&gt;val + left.second + right.second;
      <span class="hljs-comment">//不偷父节点</span>
      <span class="hljs-keyword">int</span> val2 = <span class="hljs-built_in">max</span>(left.first, left.second) + <span class="hljs-built_in">max</span>(right.first, right.second);
      <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(val1, val2);
    }
};</code></pre></div>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//递归暴力</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
      <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      
      <span class="hljs-keyword">int</span> res = INT_MAX;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;coins.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">int</span> subproblem = <span class="hljs-built_in">coinChange</span>(coins, amount - coins[i]);
        <span class="hljs-keyword">if</span>(subproblem == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
        res = <span class="hljs-built_in">min</span>(res, subproblem+<span class="hljs-number">1</span>);
      }
      <span class="hljs-keyword">return</span> res==INT_MAX?<span class="hljs-number">-1</span>:res;
    }

    <span class="hljs-comment">// //递归优化</span>
    vector&lt;<span class="hljs-keyword">int</span>&gt; memo;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
      memo = vector&lt;<span class="hljs-keyword">int</span>&gt;(amount+<span class="hljs-number">1</span>, <span class="hljs-number">-666</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(coins, amount);
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
      <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      
      <span class="hljs-comment">// 查备忘录，防止重复计算</span>
      <span class="hljs-keyword">if</span> (memo[amount] != <span class="hljs-number">-666</span>)
        <span class="hljs-keyword">return</span> memo[amount];

      <span class="hljs-keyword">int</span> res = INT_MAX;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;coins.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">int</span> subproblem = <span class="hljs-built_in">dp</span>(coins, amount - coins[i]);
        <span class="hljs-keyword">if</span>(subproblem == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
        res = <span class="hljs-built_in">min</span>(res, subproblem+<span class="hljs-number">1</span>);
      }
      memo[amount] = res==INT_MAX?<span class="hljs-number">-1</span>:res;
      <span class="hljs-keyword">return</span> memo[amount];
    }

    <span class="hljs-comment">//dp</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
      <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>)</span></span>;

      dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 外层 for 循环在遍历所有状态的所有取值</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;dp.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-comment">// 内层 for 循环在求所有选择的最小值</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins){
          <span class="hljs-comment">//子问题无解 跳过</span>
          <span class="hljs-keyword">if</span>(i - coin &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
          dp[i] = <span class="hljs-built_in">min</span>(dp[i], <span class="hljs-number">1</span>+dp[i-coin]);
        }
      }
      <span class="hljs-keyword">return</span> (dp[amount] == amount + <span class="hljs-number">1</span>) ? <span class="hljs-number">-1</span> : dp[amount];
    }
};</code></pre></div>

<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="背包递推公式"><a href="#背包递推公式" class="headerlink" title="背包递推公式"></a>背包递推公式</h3><p>问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">动态规划：416.分割等和子集(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li>
</ul>
<p>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">动态规划：474.一和零(opens new window)</a></li>
</ul>
<p>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322.零钱兑换(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></li>
</ul>
<h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="#遍历顺序"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F">#</a>遍历顺序</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="#01背包"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#_01%E8%83%8C%E5%8C%85">#</a>01背包</h4><p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">01背包</a>中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>和<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">01背包（滚动数组）</a>中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p>
<p><strong>一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！</strong></p>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="#完全背包"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">#</a>完全背包</h4><p>说完01背包，再看看完全背包。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">完全背包</a>中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p>
<p><u><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</u></p>
<p><u><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</u></p>
<p>相关题目如下：</p>
<ul>
<li>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II(opens new window)</a></li>
<li>求排列数：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA">动态规划：377. 组合总和 Ⅳ (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：</p>
<ul>
<li>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></li>
</ul>
<h2 id="01背包-1"><a href="#01背包-1" class="headerlink" title="01背包"></a>01背包</h2><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>背包最大重量为4， 每个物品只能用一次，问背包能装的最大价值？</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202101101032124.png" srcset="/img/loading.gif" lazyload alt="动态规划-背包问题5"></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>{
    vector&lt;<span class="hljs-keyword">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    vector&lt;<span class="hljs-keyword">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};
    <span class="hljs-keyword">int</span> bagweight = <span class="hljs-number">4</span>;

    <span class="hljs-comment">// 二维数组</span>
    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), vector&lt;<span class="hljs-keyword">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));

    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {
        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];
    }

    <span class="hljs-comment">// weight数组的大小 就是物品个数</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span>
            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);

        }
    }

    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">test_2_wei_bag_problem1</span>();
}</code></pre></div>

<h4 id="滚动一维数组"><a href="#滚动一维数组" class="headerlink" title="滚动一维数组"></a>滚动一维数组</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_1_wei_bag_problem</span><span class="hljs-params">()</span> </span>{
    vector&lt;<span class="hljs-keyword">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    vector&lt;<span class="hljs-keyword">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};
    <span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;

    <span class="hljs-comment">// 初始化</span>
  	<span class="hljs-comment">//dp[i]表示前*个物品 背包容量为i时的最大价值</span>
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span>
            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);  <span class="hljs-comment">//dp复用</span>
        }
    }
    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">test_1_wei_bag_problem</span>();
}</code></pre></div>

<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h3><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
<p>示例 2：</p>
<p>输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p>
</blockquote>
<p>这也是一道经典的背包题</p>
<p>理解：</p>
<blockquote>
<p>背包的最大重量为sum/2</p>
<p>物品的重量为nums[i]</p>
<p>物品的价值为nums[i]</p>
<p><code>每个物品只有一个 求背包装最大的价值</code></p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> allSum = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span>(allSum%<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> target = allSum/<span class="hljs-number">2</span>;
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(nums.<span class="hljs-built_in">size</span>(), vector&lt;<span class="hljs-keyword">int</span>&gt;(target+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = nums[<span class="hljs-number">0</span>]; j&lt;=target; j++){
        dp[<span class="hljs-number">0</span>][j] = nums[<span class="hljs-number">0</span>];
      }

      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;=target; j++){
          <span class="hljs-keyword">if</span>(j &lt; nums[i]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];
          <span class="hljs-keyword">else</span>{
            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j-nums[i]] + nums[i]);            
          }
        }
      }
      <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][target] == target;
    }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> allSum = <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">begin</span>(nums), <span class="hljs-built_in">end</span>(nums), <span class="hljs-number">0</span>);
      <span class="hljs-keyword">if</span>(allSum%<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> target = allSum/<span class="hljs-number">2</span>;

      <span class="hljs-comment">// dp[i]中的i表示背包内总和</span>
      <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span>
      <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以</span>
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;
      <span class="hljs-comment">//begin 0/1</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = target; j&gt;=nums[i]; j--){
          dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-nums[i]] + nums[i]);
        }
      }
      <span class="hljs-keyword">return</span> dp[target] == target;
    }
};</code></pre></div>

<h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h3><p>难度中等449收藏分享切换为英文接收动态反馈</p>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[2,7,4,1,8,1]</span>
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 <span class="hljs-comment">[2,7,1,8,1]</span>，
组合 7 和 8，得到 1，所以数组转化为 <span class="hljs-comment">[2,1,1,1]</span>，
组合 2 和 1，得到 1，所以数组转化为 <span class="hljs-comment">[1,1,1]</span>，
组合 1 和 1，得到 0，所以数组转化为 <span class="hljs-comment">[1]</span>，这就是最优值。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：stones = <span class="hljs-string">[31,26,33,21,40]</span>
输出：<span class="hljs-number">5</span></code></pre></div>

<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>转换为等和子集问题，尽量一半一半的放，看凑的最接近一半的重量是多少</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);
      <span class="hljs-keyword">int</span> target = sum/<span class="hljs-number">2</span>;
      <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = target; j&gt;=nums[i]; j--){
          dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-nums[i]] + nums[i]);
        }
      }
      <span class="hljs-comment">//sum - dp是另一半 最后结果是另一半-这一半</span>
      <span class="hljs-keyword">return</span> sum - dp[target] - dp[target];
    }
};</code></pre></div>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=494">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/#">思路</a></p>
<p>难度中等1201收藏分享切换为英文接收动态反馈</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有<span class="hljs-number"> 5 </span>种方法让最终目标和为<span class="hljs-number"> 3 </span>。
-1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3
+1 -<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3
+1 +<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3
+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 3
+1 +<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 1 </span>= 3</code></pre></div>

<ol>
<li>确定dp数组以及下标的含义 dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</li>
<li>例如：dp[j]，j 为5，<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li>
</ul>
</li>
<li>dp数组如何初始化  dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
      <span class="hljs-keyword">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);
      <span class="hljs-keyword">int</span> summ = sum+target;
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(summ%<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      target = summ/<span class="hljs-number">2</span>;
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
      <span class="hljs-comment">//装满容量为0的背包，有1种方法，就是装0件物品</span>
      dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = target; j&gt;=nums[i]; j--){
          dp[j] += dp[j - nums[i]];
        }
      }
      <span class="hljs-keyword">return</span> dp[target];
    }
};</code></pre></div>

<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/"><code>474. 一和零</code></a></h3><p>难度中等715收藏分享切换为英文接收动态反馈</p>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">strs</span> = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0001"</span>, <span class="hljs-string">"111001"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"0"</span>], <span class="hljs-attr">m</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span>
输出：<span class="hljs-number">4</span>
解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} ，因此答案是 <span class="hljs-number">4</span> 。
其他满足题意但较小的子集包括 {<span class="hljs-string">"0001"</span>,<span class="hljs-string">"1"</span>} 和 {<span class="hljs-string">"10"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>} 。{<span class="hljs-string">"111001"</span>} 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 n 的值 <span class="hljs-number">3</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">strs</span> = [<span class="hljs-string">"10"</span>, <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>], <span class="hljs-attr">m</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span>
输出：<span class="hljs-number">2</span>
解释：最大的子集是 {<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>} ，所以答案是 <span class="hljs-number">2</span></code></pre></div>

<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<p>dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]。</p>
</li>
<li><p>确定递推公式</p>
<p>dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p>
<p>dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。</p>
<p>然后我们在遍历的过程中，取dp[i][j]的最大值。</p>
<p>所以递推公式：dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);</p>
<p>此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p>
<p><strong>这就是一个典型的01背包！</strong> 只不过物品的重量有了两个维度而已。</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
      <span class="hljs-comment">//dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</span>
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 默认初始化0</span>
      <span class="hljs-keyword">for</span>(string str: strs){<span class="hljs-comment">// 遍历物品</span>
        <span class="hljs-keyword">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch: str){
          <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'0'</span>) zeroNum++;
          <span class="hljs-keyword">else</span> oneNum++;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i&gt;=zeroNum; i--){ <span class="hljs-comment">// 遍历背包容量且从后向前遍历！</span>
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j&gt;=oneNum; j--){
            dp[i][j] =  <span class="hljs-built_in">max</span>(dp[i][j], dp[i-zeroNum][j-oneNum] + <span class="hljs-number">1</span>);
          }
        }
      }
      <span class="hljs-keyword">return</span> dp[m][n];
    }
};</code></pre></div>

<h2 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h2><p>背包最大重量为4， <strong>每件商品都有无限个</strong>，问背包能装的最大价值？</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>01背包和完全背包唯一不同就是体现在<code>遍历顺序</code>上</p>
<p><code>反过来了</code></p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。   1 2 和 2 1一样  （爬楼梯）</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。    1 2 和 2 1 不同 （爬楼梯）</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 组合数  先遍历物品，在遍历背包</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>{
    vector&lt;<span class="hljs-keyword">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    vector&lt;<span class="hljs-keyword">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};
    <span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = weight[i]; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span>
            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">test_CompletePack</span>();
}


<span class="hljs-comment">// 排列数 先遍历背包，再遍历物品</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_CompletePack</span><span class="hljs-params">()</span> </span>{
    vector&lt;<span class="hljs-keyword">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    vector&lt;<span class="hljs-keyword">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};
    <span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;

    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++) { <span class="hljs-comment">// 遍历背包容量</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span>
            <span class="hljs-keyword">if</span> (j - weight[i] &gt;= <span class="hljs-number">0</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">test_CompletePack</span>();
}</code></pre></div>

<h3 id="剑指-Offer-II-103-最少的硬币数目"><a href="#剑指-Offer-II-103-最少的硬币数目" class="headerlink" title="剑指 Offer II 103. 最少的硬币数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a></h3><p>难度中等34收藏分享切换为英文接收动态反馈</p>
<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">11</span>
输出：<span class="hljs-number">3</span> 
解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>
输出：-<span class="hljs-number">1</span></code></pre></div>

<h4 id="解法-完全背包"><a href="#解法-完全背包" class="headerlink" title="解法 完全背包"></a>解法 完全背包</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt;= amount; j++) { <span class="hljs-comment">// 遍历背包</span>
                dp[j] += dp[j - coins[i]];
            }
        }
        <span class="hljs-keyword">return</span> dp[amount];
    }
};</code></pre></div>

<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>难度中等636收藏分享切换为英文接收动态反馈</p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">4</span>
输出：<span class="hljs-number">7</span>
解释：
所有可能的组合为：
(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)
(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)
请注意，顺序不同的序列被视作不同的组合。</code></pre></div>

<h4 id="解法-回溯-记忆化-dp"><a href="#解法-回溯-记忆化-dp" class="headerlink" title="解法 回溯 记忆化 dp"></a>解法 回溯 记忆化 dp</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//回溯</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> ans;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        ans = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, target);
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> nowSum, <span class="hljs-keyword">int</span> target)</span></span>{
        <span class="hljs-keyword">if</span>(nowSum&gt;target) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span>(nowSum == target){
            ans++;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-built_in">backtrack</span>(nums, nowSum+nums[i], target);
        }
    }
};

<span class="hljs-comment">//记忆化回溯</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, target);
    }
    <span class="hljs-comment">//备忘录，保存每层递归的计算结果，用于实现记忆化。</span>
    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; memo;
    <span class="hljs-comment">//dfs(target)的定义： 用nums中的元素凑成总和为target（每个元素可以使用多次），用多少中凑法。</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span>{
        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(memo.<span class="hljs-built_in">count</span>(target) == <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> memo[target];
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){
            res += <span class="hljs-built_in">dfs</span>(nums, target - nums[i]);
        }
        memo[target] = res;
        <span class="hljs-keyword">return</span> res;
    }
};

<span class="hljs-comment">//完全背包dp</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-comment">//使用dp数组，dp[i]代表组合数为i时使用nums中的数能组成的组合数的个数</span>
        <span class="hljs-comment">//dp[i]=dp[i-nums[0]]+dp[i-nums[1]]+dp[i=nums[2]]+...</span>
        <span class="hljs-comment">//举个例子比如nums=[1,3,4],target=7;</span>
        <span class="hljs-comment">//dp[7]=dp[6]+dp[4]+dp[3]</span>
        <span class="hljs-comment">//其实就是说7的组合数可以由三部分组成，1和dp[6]，3和dp[4],4和dp[3];</span>
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target+<span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-comment">//是为了算上自己的情况，比如dp[1]可以由dp【0】和1这个数的这种情况组成。</span>
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=target; i++)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)
                <span class="hljs-comment">//dp用int的话 有一个很傻逼的越界，需要 &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i]</span>
                <span class="hljs-keyword">if</span>(i&gt;=num)  
                    dp[i] += dp[i-num];
        <span class="hljs-keyword">return</span> dp[target];
    }
};</code></pre></div>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/"><code>70. 爬楼梯</code></a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/#">思路</a></p>
<p>难度简单2410</p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶
2.<span class="hljs-number"> 2 </span>阶</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶
2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶
3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶</code></pre></div>

<h4 id="解法1-斐波那契"><a href="#解法1-斐波那契" class="headerlink" title="解法1 斐波那契"></a>解法1 斐波那契</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> ;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i&lt;=n; ++i){
          dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];
        }
        <span class="hljs-keyword">return</span> dp[n];
    }
};</code></pre></div>

<h4 id="解法2-完全背包"><a href="#解法2-完全背包" class="headerlink" title="解法2 完全背包"></a>解法2 完全背包</h4><p>1 2 中 和为n的排列数</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) { <span class="hljs-comment">// 遍历背包</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 遍历物品</span>
                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];
            }
        }
        <span class="hljs-keyword">return</span> dp[n];
    }
};</code></pre></div>

<h4 id="扩展-每次可以跳-a-b-阶"><a href="#扩展-每次可以跳-a-b-阶" class="headerlink" title="扩展 每次可以跳 a-b 阶"></a><code>扩展 每次可以跳 a-b 阶</code></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <span class="hljs-comment">// 遍历背包</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = a; j &lt;= b; j++)  <span class="hljs-comment">// 遍历物品</span>
                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];
        <span class="hljs-keyword">return</span> dp[n];
    }
};</code></pre></div>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：n = 12
输出：3 
解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">13</span>
输出：<span class="hljs-number">2</span>
解释：<span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9</span></code></pre></div>

<h4 id="解法-完全背包-1"><a href="#解法-完全背包-1" class="headerlink" title="解法 完全背包"></a>解法 完全背包</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++){
            <span class="hljs-keyword">int</span> minVal = INT_MAX;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j*j&lt;=i; j++){
                <span class="hljs-comment">//i-j*j是从大到小的遍历dp,这样才可以保证最小次数</span>
                minVal = <span class="hljs-built_in">min</span>(minVal, dp[i-j*j]);  
            }
            dp[i] = minVal + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> dp[n];
    }
};

<span class="hljs-comment">//相比上面 耗时较多 难度是数组的赋值比较费时间？</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++){ <span class="hljs-comment">// 遍历背包</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j*j&lt;=i; j++){ <span class="hljs-comment">// 遍历物品</span>
                <span class="hljs-comment">//i-j*j是从大到小的遍历dp,这样才可以保证最小次数</span>
                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-j*j] + <span class="hljs-number">1</span>);  
            }
        }
        <span class="hljs-keyword">return</span> dp[n];
    }
};

<span class="hljs-comment">// 先物品 再背包</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) { <span class="hljs-comment">// 遍历物品</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) { <span class="hljs-comment">// 遍历背包</span>
                <span class="hljs-keyword">if</span> (j - i * i &gt;= <span class="hljs-number">0</span>) {
                    dp[j] = <span class="hljs-built_in">min</span>(dp[j - i * i] + <span class="hljs-number">1</span>, dp[j]);
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[n];
    }
};</code></pre></div>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/"><code>139. 单词拆分</code></a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/#">思路</a></p>
<p>难度中等1615收藏分享切换为英文接收动态反馈</p>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"leetcode"</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">"leet"</span>, <span class="hljs-string">"code"</span>]
输出: <span class="hljs-literal">true</span>
解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">"leetcode"</span> 可以由 <span class="hljs-string">"leet"</span> 和 <span class="hljs-string">"code"</span> 拼接成。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"applepenapple"</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">"apple"</span>, <span class="hljs-string">"pen"</span>]
输出: <span class="hljs-literal">true</span>
解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">"applepenapple"</span> 可以由 <span class="hljs-string">"apple"</span> <span class="hljs-string">"pen"</span> <span class="hljs-string">"apple"</span> 拼接成。
     注意，你可以重复使用字典中的单词。</code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"catsandog"</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">"cats"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"sand"</span>, <span class="hljs-string">"and"</span>, <span class="hljs-string">"cat"</span>]
输出: <span class="hljs-literal">false</span></code></pre></div>

<h1 id="炒股专题"><a href="#炒股专题" class="headerlink" title="炒股专题"></a>炒股专题</h1><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220505094926693.png" srcset="/img/loading.gif" lazyload alt="image-20220505094926693" style="zoom: 67%;">

<h3 id="121-买卖股票的最佳时机-一次买卖"><a href="#121-买卖股票的最佳时机-一次买卖" class="headerlink" title="121. 买卖股票的最佳时机 一次买卖"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机 <code>一次买卖</code></a></h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]
输出：5
解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span>
输出：<span class="hljs-number">0</span>
解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。</code></pre></div>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>贪心 一次遍历 得到 当前值和当前之前的最小值做差 取max</p>
</li>
<li><p>动态规划</p>
<blockquote>
<p>dp数组的含义</p>
<ol>
<li><p>dp{i}{0}表述第i天手中==没有==股票 时 的最大利润    = max(昨天手中就没有股票， 昨天手中有股票但是今天(i)给==卖==了)</p>
</li>
<li><p>dp{i}{1}表述第i天手中==有==股票 时 的最大利润       = max(昨天手中就有股票， 昨天手中没有股票但是今天(i)==买==了)</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++">dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i]);</code></pre></div></blockquote>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//dp</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
                <span class="hljs-comment">//base case</span>
                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                dp[i][<span class="hljs-number">1</span>] = -prices[i];
                <span class="hljs-keyword">continue</span>;
            }
            dp[i][<span class="hljs-number">0</span>]= <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
            <span class="hljs-comment">//注意这里不能时dp[i-1][0],因为只有一次操作</span>
            <span class="hljs-comment">//前面没有股票买卖 没有利润</span>
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i]);
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_i_1 = -prices[i];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span>
            dp_i_0 = <span class="hljs-built_in">max</span>(dp_i_0, dp_i_1 + prices[i]);
            <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span>
            dp_i_1 = <span class="hljs-built_in">max</span>(dp_i_1, -prices[i]);
        }
        <span class="hljs-keyword">return</span> dp_i_0;
    }
};

<span class="hljs-comment">//贪心</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n =prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(right&lt;n){
            <span class="hljs-keyword">if</span>(prices[left]&lt;prices[right])
                ans = <span class="hljs-built_in">max</span>(ans, prices[right] - prices[left]);
            <span class="hljs-keyword">else</span> left = right;
            right++;            
        }
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{    
        <span class="hljs-keyword">int</span> mmin = INT_MAX;<span class="hljs-comment">//遇到最小的数</span>
        <span class="hljs-keyword">int</span> mmax = <span class="hljs-number">0</span>;<span class="hljs-comment">//差值最大数</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : prices) {
            mmin = <span class="hljs-built_in">min</span>(i, mmin); 
            mmax = <span class="hljs-built_in">max</span>(i - mmin, mmax);
        }
        <span class="hljs-keyword">return</span> mmax ;
    }
};</code></pre></div>



<h3 id="122-买卖股票的最佳时机-无限次买卖"><a href="#122-买卖股票的最佳时机-无限次买卖" class="headerlink" title="122. 买卖股票的最佳时机 无限次买卖"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 <code>无限次买卖</code></a></h3><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以购买它，然后在 <strong>同一天</strong> 出售。<br>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。
随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。</code></pre></div>

<p><strong>示例 2:</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。
注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre></div>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>贪心 每次相邻两天涨价都卖股票</p>
</li>
<li><p>dp 同上 但是更为贴近经典模板 允许多次买卖 注意状态方程</p>
<div class="code-wrapper"><pre><code class="hljs c++">dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);</code></pre></div></li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//没有购买次数的限制</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                dp[i][<span class="hljs-number">1</span>] = -prices[i];
                <span class="hljs-keyword">continue</span>;
            }
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
    }

    <span class="hljs-comment">//滚动优化</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_i_1 = INT_MIN;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">int</span> temp = dp_i_0; <span class="hljs-comment">//临时存储上个dp_i_0     dp_i_1写在dp_i_0之前则无需temp </span>
            dp_i_0 = <span class="hljs-built_in">max</span>(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = <span class="hljs-built_in">max</span>(dp_i_1, temp - prices[i]);
        }
        <span class="hljs-keyword">return</span> dp_i_0;
    }
    
    <span class="hljs-comment">//贪心 每次相邻两天涨价都卖股票</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i++){
            <span class="hljs-keyword">if</span>(prices[i]&lt;prices[i+<span class="hljs-number">1</span>]){
                max+=prices[i+<span class="hljs-number">1</span>]-prices[i];
            }  
        }   
        <span class="hljs-keyword">return</span> max;
    }
};</code></pre></div>

<h3 id="714-买卖股票的最佳时机-含手续费"><a href="#714-买卖股票的最佳时机-含手续费" class="headerlink" title="714. 买卖股票的最佳时机 含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机 <code>含手续费</code></a></h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：prices = <span class="hljs-comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices<span class="hljs-comment">[0]</span> = 1
在此处卖出 prices<span class="hljs-comment">[3]</span> = 8
在此处买入 prices<span class="hljs-comment">[4]</span> = 4
在此处卖出 prices<span class="hljs-comment">[5]</span> = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">prices</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">fee</span> = <span class="hljs-number">3</span>
输出：<span class="hljs-number">6</span></code></pre></div>

<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>一样的套路 只是注意 -fee -fee…….在dp0上可能引发的越界问题 除非给定特别合适的初始值（-1？错）</p>
<blockquote>
<p>[9,8,7,1,2] 3</p>
<p>例如上面那个 会导致dp1错误  老老实实放在dp1上吧   -1000000是可以通过的</p>
</blockquote>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> fee)</span> </span>{
      <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
          dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
          dp[i][<span class="hljs-number">1</span>] = -prices[i]-fee;
          <span class="hljs-keyword">continue</span>;
        }
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]);
        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-prices[i]-fee);
      }
      <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
    }
  
  
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> fee)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> dp_0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_1 = INT_MIN;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">int</span> temp = dp_0;
            <span class="hljs-comment">//注意 这里-fee最好不要写在dp0上 不然INT_MIN可能越界，不好控制初始值</span>
            dp_0 = <span class="hljs-built_in">max</span>(dp_0, dp_1 + prices[i]);
            dp_1 = <span class="hljs-built_in">max</span>(dp_1, temp - prices[i] - fee);
        }
        <span class="hljs-keyword">return</span> dp_0;
    }
};</code></pre></div>

<h3 id="309-最佳买卖股票时机-含冷冻期"><a href="#309-最佳买卖股票时机-含冷冻期" class="headerlink" title="309. 最佳买卖股票时机 含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机 <code>含冷冻期</code></a></h3><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [1,2,3,0,2]</span>
<span class="hljs-section">输出: 3 </span>
<span class="hljs-section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span></code></pre></div>

<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>0 1单独判断  注意代码中的状态方程</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
      <span class="hljs-keyword">int</span> cooldown = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
          dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
          dp[i][<span class="hljs-number">1</span>] = -prices[i];
          <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-comment">//冷冻期内 的base case 和之前无关联</span>
        <span class="hljs-keyword">if</span>(i &lt; cooldown+<span class="hljs-number">1</span>){
          dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
          dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i]);
          <span class="hljs-keyword">continue</span>;
        }
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
        dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>-cooldown][<span class="hljs-number">0</span>]-prices[i]);
      }
      <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_i_1 = INT_MIN;
        <span class="hljs-keyword">int</span> dp_pre_0 = <span class="hljs-number">0</span>; <span class="hljs-comment">//代表dp[i-2][0];</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">int</span> temp = dp_i_0;
            dp_i_0 = <span class="hljs-built_in">max</span>(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = <span class="hljs-built_in">max</span>(dp_i_1, dp_pre_0 - prices[i]);       
            dp_pre_0 = temp;    
        }
        <span class="hljs-keyword">return</span> dp_i_0;
    }
};</code></pre></div>

<h3 id="123-买卖股票的最佳时机-限制两笔交易"><a href="#123-买卖股票的最佳时机-限制两笔交易" class="headerlink" title="123. 买卖股票的最佳时机 限制两笔交易"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 <code>限制两笔交易</code></a></h3><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第<span class="hljs-number"> 4 </span>天（股票价格 = 0）的时候买入，在第<span class="hljs-number"> 6 </span>天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。
     随后，在第<span class="hljs-number"> 7 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 8 </span>天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 =<span class="hljs-number"> 3 </span>。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]
输出：4
解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。   
     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre></div>

<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol>
<li>有次数限制k for循环加一层k</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> maxk = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(maxk+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>)));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k&lt;=maxk; k++){
                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
                    dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                    dp[i][k][<span class="hljs-number">1</span>] = -prices[i];
                    <span class="hljs-keyword">continue</span>;
                }
              	<span class="hljs-comment">// 注意 一次买卖才算一次交易 所以我们只让他买的时候次数-1</span>
                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
                dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);
            }
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][maxk][<span class="hljs-number">0</span>];
    }

    <span class="hljs-comment">//滚动优化</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> dp_i10 = <span class="hljs-number">0</span>, dp_i20 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_i11 = INT_MIN, dp_i21 = INT_MIN;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> price: prices){
            dp_i20 = <span class="hljs-built_in">max</span>(dp_i20, dp_i21 + price);
            dp_i21 = <span class="hljs-built_in">max</span>(dp_i21, dp_i10 - price);
            dp_i10 = <span class="hljs-built_in">max</span>(dp_i10, dp_i11 + price);
            dp_i11 = <span class="hljs-built_in">max</span>(dp_i11, -price);
        }
        <span class="hljs-keyword">return</span> dp_i20;
    }
};</code></pre></div>

<h3 id="188-买卖股票的最佳时机-限制k笔交易"><a href="#188-买卖股票的最佳时机-限制k笔交易" class="headerlink" title="188. 买卖股票的最佳时机 限制k笔交易"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 <code>限制k笔交易</code></a></h3><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">k</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">prices</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]
输出：<span class="hljs-number">2</span>
解释：在第 <span class="hljs-number">1</span> 天 (股票价格 = <span class="hljs-number">2</span>) 的时候买入，在第 <span class="hljs-number">2</span> 天 (股票价格 = <span class="hljs-number">4</span>) 的时候卖出，这笔交易所能获得利润 = <span class="hljs-number">4</span><span class="hljs-attr">-2</span> = <span class="hljs-number">2</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第<span class="hljs-number"> 2 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 3 </span>天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 =<span class="hljs-number"> 4 </span>。
     随后，在第<span class="hljs-number"> 5 </span>天 (股票价格 = 0) 的时候买入，在第<span class="hljs-number"> 6 </span>天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。</code></pre></div>

<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxk, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(maxk&gt;n/<span class="hljs-number">2</span>){<span class="hljs-comment">//一次交易完成需要两天</span>
            <span class="hljs-comment">//复用之前交易次数k没有限制的情况</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">maxProfit_k_inf</span>(prices);
        }

        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(maxk+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>)));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k&lt;=maxk; k++){
                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
                    dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                    dp[i][k][<span class="hljs-number">1</span>] = -prices[i];
                    <span class="hljs-keyword">continue</span>;
                }
                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
                dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]);
            }
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][maxk][<span class="hljs-number">0</span>];
    }

    <span class="hljs-comment">//不限制次数k的买卖</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_inf</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> dp_i_1 = INT_MIN;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            dp_i_1 = <span class="hljs-built_in">max</span>(dp_i_1, dp_i_0 - prices[i]);
            dp_i_0 = <span class="hljs-built_in">max</span>(dp_i_0, dp_i_1 + prices[i]);
        }
        <span class="hljs-keyword">return</span> dp_i_0;
    }
};</code></pre></div>

<h3 id="万法归一"><a href="#万法归一" class="headerlink" title="万法归一"></a><code>万法归一</code></h3><p>输入股票价格数组 <code>prices</code>，你最多进行 <code>max_k</code> 次交易，每次交易需要额外消耗 <code>fee</code> 的手续费，而且每次交易之后需要经过 <code>cooldown</code> 天的冷冻期才能进行下一次交易，请你计算并返回可以获得的最大利润。</p>
<p>怎么样，有没有被吓到？如果你直接给别人出一道这样的题目，估计对方要当场吐血，不过我们这样一步步做过来，你应该很容易发现这道题目就是之前我们探讨的几种情况的组合体嘛。</p>
<p>所以，我们只要把之前实现的几种代码掺和到一块，<strong>在 base case 和状态转移方程中同时加上 <code>cooldown</code> 和 <code>fee</code> 的约束就行了</strong>：</p>
<p>==怕难以理解 此处全用完整dp数组==</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_all_in_one</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxk, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> cooldown, <span class="hljs-keyword">int</span> fee)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(maxk&gt;n/<span class="hljs-number">2</span>){<span class="hljs-comment">//一次交易完成需要两天</span>
            <span class="hljs-comment">//复用之前交易次数k没有限制的情况</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">maxProfit_k_inf_cool</span>(prices, cooldown, fee);
        }

        vector&lt;vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(maxk+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>)));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k&lt;=maxk; k++){
            	<span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> == <span class="hljs-number">-1</span>){
                	dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                	dp[i][k][<span class="hljs-number">1</span>] = -prices[i];
                	<span class="hljs-keyword">continue</span>;
            	}
            	<span class="hljs-comment">// 包含 cooldown 的 base case</span>
            	<span class="hljs-keyword">if</span>(i-cooldown <span class="hljs-number">-1</span>&lt; <span class="hljs-number">0</span>){
            		dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
                	<span class="hljs-comment">// 别忘了减 fee</span>
                	dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], -prices[i]- fee);
                	<span class="hljs-keyword">continue</span>;
            	}
                dp[i][k][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>] + prices[i]);
                dp[i][k][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][k][<span class="hljs-number">1</span>], dp[i-cooldown<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i] -fee);
            }
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][maxk][<span class="hljs-number">0</span>];
    }
    
    <span class="hljs-comment">// k 无限制，包含手续费和冷冻期</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_inf_cool</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> cooldown, <span class="hljs-keyword">int</span> fee)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;prices.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>){
                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                dp[i][<span class="hljs-number">1</span>] = -prices[i];
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// 包含 cooldown 的 base case</span>
            <span class="hljs-keyword">if</span>(i-cooldown <span class="hljs-number">-1</span>&lt; <span class="hljs-number">0</span>){
                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
                <span class="hljs-comment">// 别忘了减 fee</span>
                dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], -prices[i]- fee);
                <span class="hljs-keyword">continue</span>;
            }
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + prices[i]);
            <span class="hljs-comment">// 同时考虑 cooldown 和 fee</span>
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i-cooldown<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - prices[i]- fee);
        }
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];
    }
};</code></pre></div>

<h1 id="子序列-x2F-子数组专题"><a href="#子序列-x2F-子数组专题" class="headerlink" title="子序列/子数组专题"></a>子序列/子数组专题</h1><h2 id="题目总结-最长上升子序列"><a href="#题目总结-最长上升子序列" class="headerlink" title="题目总结 最长上升子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pile-box-lcci/solution/ti-mu-zong-jie-zui-chang-shang-sheng-zi-7jfd3/">题目总结 最长上升子序列</a></h2><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/?qno=300">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/#">思路</a></p>
<p>难度中等2362收藏分享切换为英文接收动态反馈</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]
输出：<span class="hljs-number">4</span>
解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span>
输出：<span class="hljs-number">4</span></code></pre></div>

<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ol>
<li>dp数组：注意 递增子序列与当前数字的大小有关 所以dp的含义为 以<code>当前数结尾的最长子序列长度</code></li>
<li>状态转移：当前比之前的大  则更新dp[i] 为max(dp[j+1] , dp[i])</li>
<li>base case: 所有单个数字的序列dp均为1</li>
</ol>
<blockquote>
<p>这不就是暴力吗？好像？</p>
</blockquote>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//主要是注意dp数组的含义</span>
    <span class="hljs-comment">//`当前数结尾的最长子序列长度`</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">int</span> nowI = nums[i];<span class="hljs-comment">//因为是nums[i]去比较的</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-keyword">if</span>(nowI&gt;nums[j]){
                    dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);
                }
            }
            ans = <span class="hljs-built_in">max</span>(dp[i], ans);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h4 id="答案都看不懂啊-操他妈"><a href="#答案都看不懂啊-操他妈" class="headerlink" title="答案都看不懂啊 操他妈"></a>答案都看不懂啊 操他妈</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/</a></p>
<p>二分的思路是这样的<a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/3/24/77/">动态规划设计：最长递增子序列 :: labuladong的算法小抄</a></p>
<p>大佬的文章中提到了扑克牌的思路，其中有几个点</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416161203581.png" srcset="/img/loading.gif" lazyload alt="image-20220416161203581"></p>
<ol>
<li><p>每一堆扑克牌的最上方纸牌 是单调递增的</p>
</li>
<li><p>结论：扑克牌的堆数 就是LIS的大小</p>
</li>
<li><p>思路：因为每次放一张扑克牌，堆顶都是单调递增的</p>
<p>所以可以每次去<code>二分查找</code>放在哪一堆（即找到<code>最接近的</code> 大于当前的 牌的 index），如果没有找到（即index == 堆的size）</p>
<p><code>开辟新的一堆</code></p>
</li>
<li><p>因此，使用的左边界的二分查找！</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      	<span class="hljs-comment">//最多n堆</span>
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">top</span><span class="hljs-params">(nums.size())</span></span>;
        <span class="hljs-comment">//牌堆初始化为0</span>
        <span class="hljs-keyword">int</span> piles = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) {
            <span class="hljs-comment">//要处理的扑克牌</span>
            <span class="hljs-keyword">int</span> poker = num;
            <span class="hljs-comment">//搜索左边界的二分查找 确定插入位置</span>
            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = piles;
            <span class="hljs-keyword">while</span>(left &lt; right) {
                <span class="hljs-keyword">int</span> m = (left + right) / <span class="hljs-number">2</span>;
                <span class="hljs-keyword">if</span>(top[m] &lt; num) left = m + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> right = m;  <span class="hljs-comment">//左边界 在于 等于的时候仍然收缩有边界</span>
            }
            <span class="hljs-comment">// 没找到合适的牌堆，新建一堆</span>
            <span class="hljs-keyword">if</span>(piles == left) piles++;
            <span class="hljs-comment">//将这张牌放到了 某一堆的最上方，也就是这堆的最小值</span>
            top[left] = num; 
        }
        <span class="hljs-keyword">return</span> piles;
    }
};</code></pre></div>

<p>使用lower_bound的写法</p>
<p>比如序列是78912345，前三个遍历完以后tail是789，这时候遍历到1，就得把1放到合适的位置，于是在tail二分查找1的位置，变成了189（如果序列在此时结束，因为res不变，所以依旧输出3），再遍历到2成为129，然后是123直到12345 </p>
<ol>
<li><p>lower_bound查找超范围的判断</p>
<div class="code-wrapper"><pre><code class="hljs c++">    vector&lt;<span class="hljs-keyword">int</span>&gt; v{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>);
    <span class="hljs-keyword">int</span> pos = it - v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// pos = 5 返回的就是查找区间的大小</span>
    <span class="hljs-keyword">if</span> (pos == v.<span class="hljs-built_in">size</span>())
      cout &lt;&lt; <span class="hljs-string">"超范围了。。。查找的元素比所有元素都大"</span> &lt;&lt; endl;
  	<span class="hljs-comment">//或者</span>
<span class="hljs-keyword">if</span>(it == v.<span class="hljs-built_in">end</span>())
      cout&lt;&lt;<span class="hljs-string">"超了..."</span>;</code></pre></div></li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>{
      <span class="hljs-comment">//最多有多少堆 全递增的情况最多</span>
	    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">top</span><span class="hljs-params">(nums.size())</span></span>;
	    <span class="hljs-comment">//牌堆初始化为0</span>
	    <span class="hljs-keyword">int</span> piles = <span class="hljs-number">0</span>;
	    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) {
	    	<span class="hljs-comment">//要处理的扑克牌</span>
	    	<span class="hljs-keyword">int</span> poker = num;
	    	<span class="hljs-comment">//搜索左边界的二分查找</span>
	    	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(top.<span class="hljs-built_in">begin</span>(), top.<span class="hljs-built_in">begin</span>() + piles, poker);
	    	<span class="hljs-keyword">int</span> pos = it - top.<span class="hljs-built_in">begin</span>();
	    	<span class="hljs-comment">// 没找到合适的牌堆，新建一堆</span>
        <span class="hljs-comment">//pos == piles表示在最后 也就是需要新建一堆</span>
	    	<span class="hljs-keyword">if</span> (pos == piles) {  <span class="hljs-comment">//或者写做 it == top.begin() + piles</span>
	    		piles++;
	    	}
	    	<span class="hljs-comment">//将这张牌放到了 某一堆的最上方，也就是这堆的最小值</span>
	    	top[pos] = num;
	    }
	    <span class="hljs-keyword">return</span> piles;
    }
};</code></pre></div>



<h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=354">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/russian-doll-envelopes/#">思路</a></p>
<p>难度困难705</p>
<p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p>
<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p><strong>注意</strong>：不允许旋转信封。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：envelopes = <span class="hljs-comment">[<span class="hljs-comment">[5,4]</span>,<span class="hljs-comment">[6,4]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[2,3]</span>]</span>
输出：3
解释：最多信封的个数为 3, 组合为: <span class="hljs-comment">[2,3]</span> =&gt; <span class="hljs-comment">[5,4]</span> =&gt; <span class="hljs-comment">[6,7]</span>。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入：envelopes = <span class="hljs-string">[[1,1],[1,1],[1,1]]</span>
输出：<span class="hljs-number">1</span></code></pre></div>

<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ol>
<li>按照LIS进行dp</li>
<li>按照LIS进行优化 二分查找</li>
</ol>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//按最长递增子序列进行升序 dp</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>{
        <span class="hljs-keyword">int</span> m = envelopes.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)-&gt;<span class="hljs-keyword">bool</span>{<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>];});
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++){
            vector&lt;<span class="hljs-keyword">int</span>&gt; now = envelopes[i];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-comment">//if(j == i) continue;</span>
                <span class="hljs-keyword">if</span>(now[<span class="hljs-number">0</span>]&gt;envelopes[j][<span class="hljs-number">0</span>] &amp;&amp; now[<span class="hljs-number">1</span>]&gt;envelopes[j][<span class="hljs-number">1</span>]){
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
                }
            }
            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};

<span class="hljs-comment">//二分做法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>{
        <span class="hljs-keyword">if</span> (envelopes.<span class="hljs-built_in">empty</span>()) 
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">int</span> n = envelopes.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2) {
            <span class="hljs-keyword">return</span> e1[<span class="hljs-number">0</span>] &lt; e2[<span class="hljs-number">0</span>] || (e1[<span class="hljs-number">0</span>] == e2[<span class="hljs-number">0</span>] &amp;&amp; e1[<span class="hljs-number">1</span>] &gt; e2[<span class="hljs-number">1</span>]);
        });

        vector&lt;<span class="hljs-keyword">int</span>&gt; f = {envelopes[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> num = envelopes[i][<span class="hljs-number">1</span>]; num &gt; f.<span class="hljs-built_in">back</span>()) {
                f.<span class="hljs-built_in">push_back</span>(num);
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//第一个&gt;=num的位置</span>
                <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), num);
                *it = num;
            }
        }
        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">size</span>();
    }
};</code></pre></div>

<h3 id="面试题-08-13-堆箱子"><a href="#面试题-08-13-堆箱子" class="headerlink" title="面试题 08.13. 堆箱子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pile-box-lcci/">面试题 08.13. 堆箱子</a></h3><p>难度困难66收藏分享切换为英文接收动态反馈</p>
<p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>
<p>输入使用数组<code>[wi, di, hi]</code>表示每个箱子。</p>
<p><strong>示例1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入：box = <span class="hljs-string">[[1, 1, 1], [2, 2, 2], [3, 3, 3]]</span>
输出：<span class="hljs-number">6</span></code></pre></div>

<p><strong>示例2:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：box = <span class="hljs-comment">[<span class="hljs-comment">[1, 1, 1]</span>, <span class="hljs-comment">[2, 3, 4]</span>, <span class="hljs-comment">[2, 6, 7]</span>, <span class="hljs-comment">[3, 4, 5]</span>]</span>
输出：10</code></pre></div>

<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>简简单单的 LIS dp dp[i]表示 箱子<code>i在最上</code>的 累积的最大高度</p>
<p>注意 和套娃一样 由于存在相等的情况 所以需要排序</p>
<h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// LIS dp</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pileBox</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; box)</span> </span>{
        <span class="hljs-built_in">sort</span>(box.<span class="hljs-built_in">begin</span>(), box.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">int</span> n = box.<span class="hljs-built_in">size</span>();
        <span class="hljs-comment">//dp[i]表示 箱子i在最上的 累积的最大高度</span>
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n , <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-comment">//初始化dp base为箱子本身的高度</span>
            dp[i] = box[i][<span class="hljs-number">2</span>]; 
        }
        <span class="hljs-comment">//注意 ans在i=0时没有比较 需要初始化为dp[0]</span>
        <span class="hljs-keyword">int</span> ans = dp[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-comment">//下面箱子的宽度、高度和深度必须大于上面的箱子</span>
                <span class="hljs-keyword">if</span>(box[i][<span class="hljs-number">0</span>]&gt;box[j][<span class="hljs-number">0</span>] &amp;&amp; box[i][<span class="hljs-number">1</span>]&gt;box[j][<span class="hljs-number">1</span>] &amp;&amp; box[i][<span class="hljs-number">2</span>]&gt;box[j][<span class="hljs-number">2</span>])
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + box[i][<span class="hljs-number">2</span>]);
            }
            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="面试题-17-08-马戏团人塔"><a href="#面试题-17-08-马戏团人塔" class="headerlink" title="面试题 17.08. 马戏团人塔"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/circus-tower-lcci/">面试题 17.08. 马戏团人塔</a></h3><p>难度中等88英文版讨论区</p>
<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><code class="hljs gcode">输入：height = [<span class="hljs-number">65</span>,<span class="hljs-number">70</span>,<span class="hljs-number">56</span>,<span class="hljs-number">75</span>,<span class="hljs-number">60</span>,<span class="hljs-number">68</span>] weight = [<span class="hljs-number">100</span>,<span class="hljs-number">150</span>,<span class="hljs-number">90</span>,<span class="hljs-number">190</span>,<span class="hljs-number">95</span>,<span class="hljs-number">110</span>]
输出：<span class="hljs-number">6</span>
解释：从上往下数，叠罗汉最多能叠 <span class="hljs-number">6</span> 层：<span class="hljs-comment">(56,90)</span>, <span class="hljs-comment">(60,95)</span>, <span class="hljs-comment">(65,100)</span>, <span class="hljs-comment">(68,110)</span>, <span class="hljs-comment">(70,150)</span>, <span class="hljs-comment">(75,190)</span></code></pre></div>

<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ul>
<li>先排序：高度升序排列，相同高度的宽度降序排列</li>
<li>然后DP数组下标 i 位置记录长为 i+1 最长递增序列末尾数字最小值</li>
<li>最后返回DP数组长度</li>
<li>PS（新瓶装旧酒，和 俄罗斯套娃信封 问题一样）</li>
</ul>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bestSeqAtIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; weight)</span> </span>{
        <span class="hljs-keyword">int</span> n = weight.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; matrix = <span class="hljs-built_in">build</span>(height, weight);
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>(), [](vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)
            -&gt;<span class="hljs-keyword">bool</span>{<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>]; });
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-keyword">if</span>(matrix[j][<span class="hljs-number">0</span>]&lt;matrix[i][<span class="hljs-number">0</span>] &amp;&amp; matrix[j][<span class="hljs-number">1</span>] &lt; matrix[i][<span class="hljs-number">1</span>])
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);
        }
        <span class="hljs-keyword">return</span> ans;
    }

    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">build</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; weight){
        <span class="hljs-keyword">int</span> n = weight.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            res[i][<span class="hljs-number">0</span>] = height[i];
            res[i][<span class="hljs-number">1</span>] = weight[i];
        }
        <span class="hljs-keyword">return</span> res;
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bestSeqAtIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; weight)</span> </span>{
        vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; tmp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) tmp.<span class="hljs-built_in">push_back</span>({height[i], weight[i]});
        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &amp;b) {
            <span class="hljs-keyword">return</span> a.first == b.first ? a.second &gt; b.second : a.first &lt; b.first;
        });
        vector&lt;<span class="hljs-keyword">int</span>&gt; dp; <span class="hljs-comment">//长度为N的地方 最小的数字</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;[h, w]: tmp) {
            <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">lower_bound</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), w);  <span class="hljs-comment">//二分查找第一个大于等于的地方</span>
            <span class="hljs-keyword">if</span>(p == dp.<span class="hljs-built_in">end</span>()) dp.<span class="hljs-built_in">push_back</span>(w);
            <span class="hljs-keyword">else</span> *p = w;
        }
        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">size</span>();
    }
};</code></pre></div>

<h2 id="重叠区间问题"><a href="#重叠区间问题" class="headerlink" title="重叠区间问题"></a>重叠区间问题</h2><h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=435">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/#">思路</a></p>
<p>难度中等663</p>
<p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 * 需要移除区间的最小数量，使剩余区间互不重叠* </p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,3]</span>]</span>
输出: 1
解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。</code></pre></div>

<p><strong>示例 2:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span>
输出: 2
解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。</code></pre></div>

<p><strong>示例 3:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: intervals = <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span>
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre></div>

<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>反向推断 移除区间的最小数量 只需要计算 满足不重复条件的区间的最大数量 LIS dp</p>
</li>
<li><p>贪心 也是反向查找的思路 不过是按照右边界 拼接查找无重叠的最大区间数</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20201221201553618.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;">

<p>如图 按照右边界排序 可以简单的找出无重叠的最大区间序列 1 4 6</p>
<p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（==<u>这样留给下一个区间的空间就越大</u>==），所以第一条分割线就是区间1结束的位置。</p>
<p>接下来就是找大于区间1结束位置的区间，是从区间4开始。那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了。</p>
<p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p>
<p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p>
</li>
</ol>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//LIS dp 反向推断</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-comment">//dp含义 不重叠的最大子区间个数</span>
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-comment">//反向思考 可以装入 即 不重叠</span>
                <span class="hljs-keyword">if</span>(matrix[j][<span class="hljs-number">1</span>]&lt;=matrix[i][<span class="hljs-number">0</span>])
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-keyword">return</span> n - dp[n<span class="hljs-number">-1</span>];
    }
};

<span class="hljs-comment">//按右端排序 贪心</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>(), 
            [](<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)-&gt;<span class="hljs-keyword">bool</span>{<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];});
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> maxNotOverlap = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> beginVal = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            <span class="hljs-comment">// 丑陋的代码 脑子不转。。</span>
            <span class="hljs-comment">// while(i&lt;n &amp;&amp; matrix[i][0]&lt;beginVal){</span>
            <span class="hljs-comment">//     i++;</span>
            <span class="hljs-comment">// }</span>
            <span class="hljs-comment">// if(i == n) break;</span>
            <span class="hljs-comment">// beginVal = matrix[i][1];</span>
            <span class="hljs-comment">// maxNotOverlap++;</span>

            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>]&gt;=beginVal){
                beginVal = matrix[i][<span class="hljs-number">1</span>];
                maxNotOverlap++;
            }
        }
        <span class="hljs-keyword">return</span> n - maxNotOverlap;
    }
};</code></pre></div>

<h3 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h3><p>难度中等214</p>
<p>给出 <code>n</code> 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p>
<p>现在，我们定义一种跟随关系，当且仅当 <code>b &lt; c</code> 时，数对<code>(c, d)</code> 才可以跟在 <code>(a, b)</code> 后面。我们用这种形式来构造一个数对链。</p>
<p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[3,4]</span>]</span>
输出：2
解释：最长的数对链是 <span class="hljs-comment">[1,2]</span> -&gt; <span class="hljs-comment">[3,4]</span></code></pre></div>

<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol>
<li>LIS dp</li>
<li>贪心 按右端排序 同上</li>
</ol>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//dp解法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>());
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-keyword">if</span>(matrix[j][<span class="hljs-number">1</span>] &lt; matrix[i][<span class="hljs-number">0</span>])
                    dp[i] = <span class="hljs-built_in">max</span>(dp[j] + <span class="hljs-number">1</span>, dp[i]);
            }
        }
        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
    }
};

<span class="hljs-comment">//贪心解法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)-&gt;
             <span class="hljs-keyword">bool</span>{ <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>]? a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>]; });
        <span class="hljs-keyword">int</span> beginVal = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] &gt; beginVal){
                beginVal = matrix[i][<span class="hljs-number">1</span>];
                ans++;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=452">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/#">思路</a></p>
<p>难度中等561收藏分享切换为英文接收动态反馈英文版讨论区</p>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span>
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球<span class="hljs-comment">[2,8]</span>和<span class="hljs-comment">[1,6]</span>。
-在x = 11处发射箭，击破气球<span class="hljs-comment">[10,16]</span>和<span class="hljs-comment">[7,12]</span>。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,8]</span>]</span>
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。</code></pre></div>

<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>LIS我特么射爆 其实不算LIS吧</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//贪心正解</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)-&gt;
             <span class="hljs-keyword">bool</span>{ <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>]? a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>] : a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>]; });
        <span class="hljs-keyword">int</span> beginVal = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            <span class="hljs-comment">//出范围 需要额外用一只箭</span>
            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] &gt; beginVal){
                beginVal = matrix[i][<span class="hljs-number">1</span>];
                ans++;
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};

<span class="hljs-comment">//dp超时</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">sort</span>(matrix.<span class="hljs-built_in">begin</span>(), matrix.<span class="hljs-built_in">end</span>());
        <span class="hljs-comment">//dp[i]表示射爆当前及其之前所有气球 需要的箭数</span>
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;i; j++){
                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] &gt; matrix[j][<span class="hljs-number">1</span>])
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
    }
};</code></pre></div>

<h3 id="960-删列造序-III"><a href="#960-删列造序-III" class="headerlink" title="960. 删列造序 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-columns-to-make-sorted-iii/">960. 删列造序 III</a></h3><p>难度困难64收藏分享切换为英文接收动态反馈英文版讨论区</p>
<p>给定由 <code>n</code> 个小写字母字符串组成的数组 <code>strs</code> ，其中每个字符串长度相等。</p>
<p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p>
<p>比如，有 <code>strs = ["abcdef","uvwxyz"]</code> ，删除索引序列 <code>{0, 2, 3}</code> ，删除后为 <code>["bef", "vyz"]</code> 。</p>
<p>假设，我们选择了一组删除索引 <code>answer</code> ，那么在执行删除操作之后，最终得到的数组的行中的 <strong>每个元素</strong> 都是按<strong>字典序</strong>排列的（即 <code>(strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])</code> 和 <code>(strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])</code> ，依此类推）。</p>
<p>请返回 <em><code>answer.length</code> 的最小可能值</em> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：strs = [<span class="hljs-string">"babca"</span>,<span class="hljs-string">"bbazb"</span>]
输出：<span class="hljs-number">3</span>
解释：
删除 <span class="hljs-number">0</span>、<span class="hljs-number">1</span> 和 <span class="hljs-number">4</span> 这三列后，最终得到的数组是 <span class="hljs-symbol">A</span> = [<span class="hljs-string">"bc"</span>, <span class="hljs-string">"az"</span>]。
这两行是分别按字典序排列的（即，<span class="hljs-symbol">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;= <span class="hljs-symbol">A</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] 且 <span class="hljs-symbol">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;= <span class="hljs-symbol">A</span>[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]）。
注意，<span class="hljs-symbol">A</span>[<span class="hljs-number">0</span>] &gt; <span class="hljs-symbol">A</span>[<span class="hljs-number">1</span>] —— 数组 <span class="hljs-symbol">A</span> 不一定是按字典序排列的。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">"edcba"</span>]
输出：<span class="hljs-number">4</span>
解释：如果删除的列少于 <span class="hljs-number">4</span> 列，则剩下的行都不会按字典序排列。</code></pre></div>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h3><p>难度<code>简单</code>269英文版讨论区</p>
<p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span>
输出：3
解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。
尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span>
输出：1
解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
      <span class="hljs-comment">//dp表示 当前为结束的递增子序列的长度</span>
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;
      <span class="hljs-keyword">int</span> maxx = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i<span class="hljs-number">-1</span>])
          dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
        maxx = <span class="hljs-built_in">max</span>(dp[i], maxx);
      }
      <span class="hljs-keyword">return</span> maxx;
    }
};</code></pre></div>

<h3 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. <code>最长重复子数组</code></a></h3><p>难度中等673</p>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,2,1]</span>, nums2 = <span class="hljs-comment">[3,2,1,4,7]</span>
输出：3
解释：长度最长的公共子数组是 <span class="hljs-comment">[3,2,1]</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[0,0,0,0,0]</span>, nums2 = <span class="hljs-string">[0,0,0,0,0]</span>
输出：<span class="hljs-number">5</span></code></pre></div>

<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/">思路</a></h4><ol>
<li><p>dp数组的含义：dp[i] [j] 表示 以0 - i-1  0 - j-1的子数组中，以i-1和j-1为结尾的最大重复子数组的长度</p>
</li>
<li><p>base case: i == 0 || j == 0 时 则二者没有公共部分 dp[i] [j] = 0;</p>
</li>
<li><p>状态转移： </p>
<ul>
<li>dp[i] [j] ：长度为i，末尾项为A[i-1]的子数组，与长度为j，末尾项为B[j-1]的子数组，二者的最大公共后缀子数组长度。<br>如果 A[i-1] != B[j-1]， 有 dp[i] [j] = 0<br>如果 A[i-1] == B[j-1] ， 有 dp[i] [j] = dp[i-1] [j-1] + 1</li>
</ul>
</li>
</ol>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
      <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();
      <span class="hljs-comment">//dp[i][j]表示 0-i 0-j 以最后数字结尾的 最长重复子数组的长度</span>
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n; j++){
          <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]){
            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
            ans = <span class="hljs-built_in">max</span>(dp[i][j], ans);
          }
        }
      }
      <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=516">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/#">思路</a></p>
<p>难度中等777收藏分享切换为英文接收动态反馈英文版讨论区</p>
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"bbbab"</span>
输出：<span class="hljs-number">4</span>
解释：一个可能的最长回文子序列为 <span class="hljs-string">"bbbb"</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"cbbd"</span>
输出：<span class="hljs-number">2</span>
解释：一个可能的最长回文子序列为 <span class="hljs-string">"bb"</span> 。</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();
      <span class="hljs-comment">//在子串 s[i..j] 中，最长回文子序列的长度为 dp[i][j]。</span>
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)
        dp[i][i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//base case</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;n; j++){
          <span class="hljs-comment">//状态转移</span>
          <span class="hljs-keyword">if</span>(s[i] == s[j])
            dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;
          <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j]);
        }
      }
      <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-095-最长公共子序列"><a href="#剑指-Offer-II-095-最长公共子序列" class="headerlink" title="剑指 Offer II 095. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列</a></h3><p>难度中等65英文版讨论区</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">"abcde"</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">"ace"</span> 
输出：<span class="hljs-number">3</span>  
解释：最长公共子序列是 <span class="hljs-string">"ace"</span> ，它的长度为 <span class="hljs-number">3</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">"abc"</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">"abc"</span>
输出：<span class="hljs-number">3</span>
解释：最长公共子序列是 <span class="hljs-string">"abc"</span> ，它的长度为 <span class="hljs-number">3</span></code></pre></div>

<h4 id="dp解法-2"><a href="#dp解法-2" class="headerlink" title="dp解法"></a>dp解法</h4><ol>
<li><p>dp数组含义：dp[i] [j]表示 substr分别到 i和j的最大公共子序列长度</p>
</li>
<li><p>状态转移方程：</p>
<p>当前字符相同时：dp[i] [j] = dp[i-1] [j-1] + 1;</p>
<p>当前字符不同时：dp[i] [j] = max(dp[i-1] [j], dp[i] [j-1]);</p>
</li>
<li><p>base case：处理第一行和第一列</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>{
      <span class="hljs-keyword">int</span> m = text1.<span class="hljs-built_in">size</span>(), n = text2.<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++){
        <span class="hljs-keyword">if</span>(text1[i] == text2[<span class="hljs-number">0</span>])
          <span class="hljs-keyword">while</span>(i&lt;m)
            dp[i++][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(text1[<span class="hljs-number">0</span>] == text2[i])
          <span class="hljs-keyword">while</span>(i&lt;n)
            dp[<span class="hljs-number">0</span>][i++] = <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;n ; j++){
          <span class="hljs-keyword">if</span>(text1[i] == text2[j]){
            <span class="hljs-comment">//注意 这里 是在-1-1的基础上加1</span>
            <span class="hljs-comment">//例如 abcce ace 两个c的情况</span>
            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
          }<span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);
        }
      }
      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];
    }
};</code></pre></div>

<p>base case的简单写法 前插一行一列为0</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>{
      <span class="hljs-keyword">int</span> m = text1.<span class="hljs-built_in">size</span>(), n = text2.<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n ; j++){
          <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>]){
            <span class="hljs-comment">//注意 这里 是在-1-1的基础上加1</span>
            <span class="hljs-comment">//例如 abcce ace 两个c的情况</span>
            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
          }<span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);
        }
      }
      <span class="hljs-keyword">return</span> dp[m][n];
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-096-字符串交织"><a href="#剑指-Offer-II-096-字符串交织" class="headerlink" title="剑指 Offer II 096. 字符串交织"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/IY6buf/">剑指 Offer II 096. 字符串交织</a></h3><p>难度中等14</p>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请判断 <code>s3</code> 能不能由 <code>s1</code> 和 <code>s2</code> <strong>交织（交错）</strong> 组成。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交织</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交织</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">"aabcc"</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">"dbbca"</span>, <span class="hljs-attr">s3</span> = <span class="hljs-string">"aadbbcbcac"</span>
输出：<span class="hljs-literal">true</span></code></pre></div>

<h4 id="dp解法-3"><a href="#dp解法-3" class="headerlink" title="dp解法"></a>dp解法</h4><ol>
<li>dp数组含义：前i j个元素可以构成s3前i+j个</li>
<li>状态转移方程：见代码 </li>
<li>base case：dp[0] [0] = 1，初始化第一行第一列</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(string s1, string s2, string s3)</span> </span>{
      <span class="hljs-keyword">int</span> m = s1.<span class="hljs-built_in">size</span>(), n = s2.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">int</span> nn = s3.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(m + n != nn) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-comment">//dp含义 前i j个元素可以构成s3前i+j个</span>
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>));
      dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
        <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] != s3[i<span class="hljs-number">-1</span>])
          <span class="hljs-keyword">break</span>;
        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      }
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++){
        <span class="hljs-keyword">if</span>(s2[i<span class="hljs-number">-1</span>] != s3[i<span class="hljs-number">-1</span>])
          <span class="hljs-keyword">break</span>;
        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;
      }

      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n; j++){
          <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>])
            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];
          <span class="hljs-keyword">if</span>(s2[j<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>])
            dp[i][j] = dp[i][j] || dp[i][j<span class="hljs-number">-1</span>];
        }
      }
      <span class="hljs-keyword">return</span> dp[m][n];
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-097-子序列的数目"><a href="#剑指-Offer-II-097-子序列的数目" class="headerlink" title="剑指 Offer II 097. 子序列的数目"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/21dk04/">剑指 Offer II 097. 子序列的数目</a></h3><p>难度困难20收藏分享切换为英文接收动态反馈</p>
<p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而 <code>"AEC"</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"rabbbit"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"rabbit"</span>
输出：<span class="hljs-number">3</span>
解释：
如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">"rabbit"</span> 的方案。
rabbbit
rabbbit
rabbbit</code></pre></div>

<h4 id="dp解法-4"><a href="#dp解法-4" class="headerlink" title="dp解法"></a>dp解法</h4><ol>
<li><p>dp数组含义：s的前i 对应t的钱j 的子序列数目</p>
</li>
<li><p>状态转移方程</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1631176639-giAMKQ-image.png" srcset="/img/loading.gif" lazyload alt="image.png" style="zoom: 50%;">
</li>
<li><p>base case：dp[0] [0] = 1,dp[all] [0] = 1;</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>{
        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; t.<span class="hljs-built_in">size</span>())
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        vector&lt;vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) {
            dp[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i &amp;&amp; j &lt; t.<span class="hljs-built_in">size</span>(); ++j) 
                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (s[i] == t[j]) ? dp[i][j] + dp[i][j + <span class="hljs-number">1</span>] : dp[i][j + <span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();
    }
};</code></pre></div>

<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=53">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/#">思路</a></p>
<p>难度简单4973</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]
输出：6
解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。</code></pre></div>

<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><h5 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h5><ol>
<li>dp数组：<strong>以 <code>nums[i]</code> 为结尾的「最大子数组和」为 <code>dp[i]</code>。</strong></li>
<li>base case：dp[0] = nums[0];</li>
<li>状态转移：<code>dp[i]</code> 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;
      dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">int</span> ans = dp[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
        dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i]);
        ans = <span class="hljs-built_in">max</span>(ans, dp[i]);
      }
      <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<p>dp优化</p>
<p>优化空间的dp解法</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>{
      <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
        dp = <span class="hljs-built_in">max</span>(dp + nums[i], nums[i]);
        ans = <span class="hljs-built_in">max</span>(ans, dp);
      }
      <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h5 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
      <span class="hljs-comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span>
      <span class="hljs-keyword">int</span> result = INT_MIN;
      <span class="hljs-keyword">int</span> numsSize = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(nums.<span class="hljs-built_in">size</span>());
      result = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, <span class="hljs-number">0</span>, numsSize - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArrayHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
      <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> nums[left];
      <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">int</span> leftSum = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, left, mid);
      <span class="hljs-comment">//注意这里应是mid + 1，否则left + 1 = right时，会无线循环</span>
      <span class="hljs-keyword">int</span> rightSum = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, mid + <span class="hljs-number">1</span>, right);
      <span class="hljs-keyword">int</span> midSum = <span class="hljs-built_in">findMaxCrossingSubarray</span>(nums, left, mid, right);
      <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(leftSum, rightSum), midSum);
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">//跨越mid 找区间的最大值</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxCrossingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>{
      <span class="hljs-keyword">int</span> leftSum = INT_MIN;
      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid; i &gt;= left; i--) {
        sum += nums[i];
        leftSum = <span class="hljs-built_in">max</span>(leftSum, sum);
      }

      <span class="hljs-keyword">int</span> rightSum = INT_MIN;
      sum = <span class="hljs-number">0</span>;
      <span class="hljs-comment">//注意这里i = mid + 1，避免重复用到nums[i]</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= right; i++) {
        sum += nums[i];
        rightSum = <span class="hljs-built_in">max</span>(rightSum, sum);
      }
      <span class="hljs-keyword">return</span> (leftSum + rightSum);
    }
};</code></pre></div>



<h1 id="二维矩阵dp"><a href="#二维矩阵dp" class="headerlink" title="二维矩阵dp"></a>二维矩阵dp</h1><h3 id="62-不同路径-经典简单的二维dp"><a href="#62-不同路径-经典简单的二维dp" class="headerlink" title="62. 不同路径 经典简单的二维dp"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径 经典简单的二维dp</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/robot_maze.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">7</span>
输出：<span class="hljs-number">28</span></code></pre></div>

<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>dp的含义：当前位置可以到达的路径数</p>
<p>所以base case为横竖1</p>
</li>
<li><p>状态转移方程 dp [i] [j] = dp[i-1] [j] + dp[i] [j-1]</p>
</li>
</ol>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++){
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;m; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;n; j++){
                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];
            }
        }
        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];
    }
};</code></pre></div>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=64&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/#">思路</a></p>
<p>难度中等1191</p>
<p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/minpath.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span>
输出：<span class="hljs-number">7</span>
解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span>
输出：<span class="hljs-number">12</span></code></pre></div>

<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><ol>
<li>可以记一下这个短路的万能写法</li>
<li>横 竖的 路径和是确定的 所以 这是base case</li>
<li>状态转移方程 dp[i] [j] = min(dp[i-1] [j], dp[i] [j-1]) + grid[i] [j];</li>
</ol>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><ol>
<li>回溯超时</li>
<li>dp</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// vector&lt;int&gt; allAns;</span>
    <span class="hljs-comment">// int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {</span>
    <span class="hljs-comment">//   int ans = 0;</span>
    <span class="hljs-comment">//   int m = grid.size();</span>
    <span class="hljs-comment">//   int n = grid[0].size();</span>
    <span class="hljs-comment">//   goWay(ans, grid, 0 , 0);</span>
    <span class="hljs-comment">//   return *std::min_element(allAns.begin(), allAns.end());</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-comment">// void goWay(int tempans, vector&lt;vector&lt;int&gt;&gt; grid, int x, int y){</span>
    <span class="hljs-comment">//   if(x == grid.size()-1 &amp;&amp; y == grid[0].size()-1){</span>
    <span class="hljs-comment">//     tempans+=grid[x][y];</span>
    <span class="hljs-comment">//     allAns.push_back(tempans);       </span>
    <span class="hljs-comment">//   }</span>
    <span class="hljs-comment">//   if(x &gt;= grid.size() || y &gt;= grid[0].size())</span>
    <span class="hljs-comment">//     return;</span>
    <span class="hljs-comment">//   tempans += grid[x][y];</span>
    <span class="hljs-comment">//   goWay(tempans, grid, x+1, y);</span>
    <span class="hljs-comment">//   goWay(tempans, grid, x, y+1);</span>
    <span class="hljs-comment">// }</span>

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{
        <span class="hljs-comment">//这个判断应该比较万能</span>
        <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">auto</span> dp = vector &lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m, vector &lt;<span class="hljs-keyword">int</span>&gt; (n));
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];
            }
        }
        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
    }
};</code></pre></div>

<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h3><p>难度中等995</p>
<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
 <span class="hljs-number"> 3 </span>4
<span class="hljs-number"> 6 </span>5 7
4<span class="hljs-number"> 1 </span>8 3
自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span>
输出：<span class="hljs-number">-10</span></code></pre></div>

<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>同上</p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;nums)</span> </span>{
		<span class="hljs-keyword">int</span> ans = INT_MAX;
		<span class="hljs-keyword">int</span> m = nums.<span class="hljs-built_in">size</span>();
		<span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
			<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span>;
			<span class="hljs-comment">// base case</span>
			<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {
				temp[<span class="hljs-number">0</span>] = nums[i][<span class="hljs-number">0</span>];
				dp[i] = temp;
				<span class="hljs-keyword">continue</span>;
			}
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) {
				<span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)
					temp[j] = dp[i - <span class="hljs-number">1</span>][j] + nums[i][j];
				<span class="hljs-keyword">if</span> (j == i)
					temp[j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + nums[i][j];
				<span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span> &amp;&amp; j != i)
					temp[j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + nums[i][j];
			}
			dp[i] = temp;
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp[m - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-comment">//cout &lt;&lt; dp[m - 1][i] &lt;&lt; endl;</span>
			ans = <span class="hljs-built_in">min</span>(ans, dp[m - <span class="hljs-number">1</span>][i]);
		}
		<span class="hljs-keyword">return</span> ans;
	}
};</code></pre></div>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h3><p>难度中等1091英文版讨论区</p>
<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/max1grid.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>],[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],[<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"1"</span>],[<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"0"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"0"</span>]]
输出：<span class="hljs-number">4</span></code></pre></div>

<h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><ol>
<li>dp含义： 当前点 之上 的最大正方形的面积</li>
<li>状态转移：之前三方向的 最小dp值（最小说明受这个方向的限制） + 1</li>
<li>base case: 第一行第一列 为1的位置</li>
</ol>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>{
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
      vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n; j++){
          <span class="hljs-keyword">if</span>(matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-string">'1'</span>){
            dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;
            ans = <span class="hljs-built_in">max</span>(ans, dp[i][j]);
          }
        }
      }
      <span class="hljs-keyword">return</span> ans*ans;
    }
};</code></pre></div>

<h1 id="二叉树的dp"><a href="#二叉树的dp" class="headerlink" title="二叉树的dp"></a>二叉树的dp</h1><p>二叉树的种类情况存在状态方程 随意有些dp的题目</p>
<h3 id="n个节点不超过m高度的二叉树种类数"><a href="#n个节点不超过m高度的二叉树种类数" class="headerlink" title="n个节点不超过m高度的二叉树种类数"></a>n个节点不超过m高度的二叉树种类数</h3><p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/aaefe5896cce4204b276e213e725f3ea">https://www.nowcoder.com/questionTerminal/aaefe5896cce4204b276e213e725f3ea</a></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417172957421.png" srcset="/img/loading.gif" lazyload alt="image-20220417172957421"></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173007635.png" srcset="/img/loading.gif" lazyload alt="image-20220417173007635"></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173040449.png" srcset="/img/loading.gif" lazyload alt="image-20220417173040449"></p>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>动态规划：</p>
<ol>
<li>dp[i] [j]的含义为 i个节点 最大高度为j的二叉树种类数</li>
<li>状态转移方程：</li>
</ol>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 节点个数</span>
    <span class="hljs-keyword">int</span> m; <span class="hljs-comment">// 最大高度</span>
    cin &gt;&gt; n &gt;&gt; m;
    
    <span class="hljs-comment">// dp[i][j] 表示 i 个节点能够组成的高度不超过 j 的树的个数</span>
    vector&lt;vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(m + <span class="hljs-number">1</span>));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) {
        dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) {
            <span class="hljs-comment">// 选取一个节点作为根节点</span>
            <span class="hljs-comment">// k 个节点作为左子树，i - k - 1 个节点作为右子树</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; i; ++k) {
                dp[i][j] = (dp[i][j] + dp[k][j - <span class="hljs-number">1</span>] * dp[i - k - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] % MOD) % MOD;
            }
        }
    }
    
    cout &lt;&lt; dp[n][m] &lt;&lt; endl;
}</code></pre></div>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/">97. 交错字符串</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/#">思路</a></p>
<p>难度中等698收藏分享切换为英文接收动态反馈</p>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">"aabcc"</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">"dbbca"</span>, <span class="hljs-attr">s3</span> = <span class="hljs-string">"aadbbcbcac"</span>
输出：<span class="hljs-literal">true</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s1</span> = <span class="hljs-string">"aabcc"</span>, <span class="hljs-attr">s2</span> = <span class="hljs-string">"dbbca"</span>, <span class="hljs-attr">s3</span> = <span class="hljs-string">"aadbbbaccc"</span>
输出：<span class="hljs-literal">false</span></code></pre></div>

<h4 id="解法-dp-1"><a href="#解法-dp-1" class="headerlink" title="解法 dp"></a>解法 dp</h4><p>很简单的就能想到应该用dp 但是dp的实现：大小 basecase初始化 状态转移方程需要注意下</p>
<ol>
<li>dp数组含义：dpij 标识 s1的前i个字母 s2的前j个字母 可不可以构成s3的前i+j</li>
<li>basecase：初始化dp00为真 不能太纠结这东西 重点是初始化第一行第一列</li>
<li>状态转移：dp[i] [j] = （dp[i-1] [j]为真 并且s1的当前字母等于当前s3的字母） || （dp[i] [j-1]为真 并且s2的当前字母等于当前s3的字母）</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(string s1, string s2, string s3)</span> </span>{
      <span class="hljs-keyword">int</span> m1 = s1.<span class="hljs-built_in">size</span>(), m2 = s2.<span class="hljs-built_in">size</span>(), n = s3.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(m1 + m2 != n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-comment">//dp[i][j]表示s1[0~i-1]和s2[0~j-1]能否交错组成s3[0~i+j-1]。 想好边缘条件，字符串涉及子串匹配啥的统统dp完事。</span>
      vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(m2 + <span class="hljs-number">1</span>));
      dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m1; i++){
        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &amp;&amp; (s1[i<span class="hljs-number">-1</span>] == s3[i<span class="hljs-number">-1</span>]);
      }
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=m2; j++){
        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] &amp;&amp; (s2[j<span class="hljs-number">-1</span>] == s3[j<span class="hljs-number">-1</span>]);
      }
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m1; i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=m2; j++){
          dp[i][j] = (dp[i<span class="hljs-number">-1</span>][j] &amp;&amp; s1[i<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>]) || (dp[i][j<span class="hljs-number">-1</span>] &amp;&amp; s2[j<span class="hljs-number">-1</span>] == s3[i+j<span class="hljs-number">-1</span>]);
        }
      }
      <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();
    }
};</code></pre></div>

<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=72&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/#">思路</a></p>
<p>难度困难2239英文版讨论区</p>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， * 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数* 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">"horse"</span>, word2 = <span class="hljs-string">"ros"</span>
输出：<span class="hljs-number">3</span>
解释：
<span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">'h'</span> 替换为 <span class="hljs-string">'r'</span>)
<span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">'r'</span>)
<span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">'e'</span>)</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">"intention"</span>, word2 = <span class="hljs-string">"execution"</span>
输出：<span class="hljs-number">5</span>
解释：
<span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">'t'</span>)
<span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">'i'</span> 替换为 <span class="hljs-string">'e'</span>)
<span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">'n'</span> 替换为 <span class="hljs-string">'x'</span>)
<span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">'n'</span> 替换为 <span class="hljs-string">'c'</span>)
<span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">'u'</span>)</code></pre></div>

<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>dp含义：由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]**。</p>
</li>
<li><p>状态方程：</p>
<ul>
<li><p>如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。</p>
</li>
<li><p>如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：</p>
<ul>
<li>如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;</li>
<li>如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;</li>
<li>如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有<strong>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>base case: 当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</p>
</li>
</ol>
<blockquote>
<p>大佬：90%的字符串问题都可以用dp解决</p>
<p>我：** * **</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>{
        <span class="hljs-keyword">int</span> m = word1.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> n = word2.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++)
            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=n; i++)
            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=m; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n; j++){
                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];
                <span class="hljs-keyword">else</span>
                    dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">return</span> dp[m][n];
    }
};</code></pre></div>

<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=10&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/#">思路</a></p>
<p>难度困难2842英文版讨论区</p>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//背这个</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>{
        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">empty</span>();
        <span class="hljs-comment">//当前位置匹配</span>
        <span class="hljs-keyword">auto</span> first_match = !s.<span class="hljs-built_in">empty</span>() &amp;&amp; (s[<span class="hljs-number">0</span>] == p[<span class="hljs-number">0</span>] || p[<span class="hljs-number">0</span>] == <span class="hljs-string">'.'</span>);
        
        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">length</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; p[<span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) {
            <span class="hljs-comment">//通配符匹配0次 || 通配符匹配多次</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isMatch</span>(s, p.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>)) || (first_match &amp;&amp; <span class="hljs-built_in">isMatch</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>), p));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//无通配符，向前匹配</span>
            <span class="hljs-keyword">return</span> first_match &amp;&amp; <span class="hljs-built_in">isMatch</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>), p.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>));
        }
    }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; memo;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(s, <span class="hljs-number">0</span>, p, <span class="hljs-number">0</span>);
    }
	<span class="hljs-comment">/* 计算 p[j..] 是否匹配 s[i..] */</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dp</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> i, string&amp; p, <span class="hljs-keyword">int</span> j)</span> </span>{
        <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>(), n = p.<span class="hljs-built_in">size</span>();
        <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">if</span> (j == n) {
            <span class="hljs-keyword">return</span> i == m;
        }
        <span class="hljs-keyword">if</span> (i == m) {
            <span class="hljs-comment">// 如果能匹配空串，一定是字符和 * 成对儿出现</span>
            <span class="hljs-keyword">if</span> ((n - j) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            <span class="hljs-comment">// 检查是否为 x*y*z* 这种形式</span>
            <span class="hljs-keyword">for</span> (; j + <span class="hljs-number">1</span> &lt; n; j += <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">if</span> (p[j + <span class="hljs-number">1</span>] != <span class="hljs-string">'*'</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    
        <span class="hljs-comment">// 记录状态 (i, j)，消除重叠子问题</span>
        string key = <span class="hljs-built_in">to_string</span>(i) + <span class="hljs-string">","</span> + <span class="hljs-built_in">to_string</span>(j);
        <span class="hljs-keyword">if</span> (memo.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> memo[key];
    
        <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">false</span>;
    
        <span class="hljs-keyword">if</span> (s[i] == p[j] || p[j] == <span class="hljs-string">'.'</span>) {
            <span class="hljs-comment">// 匹配</span>
            <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) {
			   <span class="hljs-comment">// 1.1 通配符匹配 0 次或多次</span>
                res = <span class="hljs-built_in">dp</span>(s, i, p, j + <span class="hljs-number">2</span>) || <span class="hljs-built_in">dp</span>(s, i + <span class="hljs-number">1</span>, p, j);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 1.2 常规匹配 1 次</span>
                res = <span class="hljs-built_in">dp</span>(s, i + <span class="hljs-number">1</span>, p, j + <span class="hljs-number">1</span>);
            }
        } <span class="hljs-keyword">else</span> {
             <span class="hljs-comment">// 不匹配</span>
            <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>) {
                <span class="hljs-comment">// 2.1 通配符匹配 0 次</span>
                res = <span class="hljs-built_in">dp</span>(s, i, p, j + <span class="hljs-number">2</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 2.2 无法继续匹配</span>
                res = <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-comment">// 将当前结果记入备忘录</span>
        memo[key] = res;
        <span class="hljs-keyword">return</span> res;
    }
};</code></pre></div>

<h3 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>难度中等448</p>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs 1c">输入: <span class="hljs-number">12258</span>
输出: <span class="hljs-number">5</span>
解释: <span class="hljs-number">12258</span>有<span class="hljs-number">5</span>种不同的翻译，分别是<span class="hljs-string">"bccfi"</span>, <span class="hljs-string">"bwfi"</span>, <span class="hljs-string">"bczi"</span>, <span class="hljs-string">"mcfi"</span>和<span class="hljs-string">"mzi"</span></code></pre></div>

<h4 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a><code>青蛙跳台阶</code></h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
      string s = <span class="hljs-built_in">to_string</span>(num);
      <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size())</span></span>;
      dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
      dp[<span class="hljs-number">1</span>] = (s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) &gt;=<span class="hljs-string">"10"</span> &amp;&amp; s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)&lt;=<span class="hljs-string">"25"</span>)?<span class="hljs-number">2</span>:<span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">int</span> temp = (s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">'0'</span>)*<span class="hljs-number">10</span> + (s[i]-<span class="hljs-string">'0'</span>);
        <span class="hljs-keyword">if</span>(temp&lt;<span class="hljs-number">10</span> || temp&gt;<span class="hljs-number">25</span>)
          dp[i] = dp[i<span class="hljs-number">-1</span>];
        <span class="hljs-keyword">else</span> dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];
      }
      <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];
    }
};</code></pre></div>

<h3 id="926-将字符串翻转到单调递增"><a href="#926-将字符串翻转到单调递增" class="headerlink" title="926. 将字符串翻转到单调递增"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. 将字符串翻转到单调递增</a></h3><p>难度中等251</p>
<p>如果一个二进制字符串，是以一些 <code>0</code>（可能没有 <code>0</code>）后面跟着一些 <code>1</code>（也可能没有 <code>1</code>）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p>
<p>给你一个二进制字符串 <code>s</code>，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p>
<p>返回使 <code>s</code> 单调递增的最小翻转次数。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs erlang">输入：s = <span class="hljs-string">"00110"</span>
输出：<span class="hljs-number">1</span>
解释：翻转最后一位得到 <span class="hljs-number">00111</span>.</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"010110"</span>
输出：<span class="hljs-number">2</span>
解释：翻转得到 <span class="hljs-number">011111</span>，或者是 <span class="hljs-number">000111</span>。</code></pre></div>

<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>简单DP思路：如果<code>s[i] == '1'</code>，那么这个字符不影响翻转次数，故有：<code>dp[i] = dp[i - 1]</code>。若<code>s[i] == '0'</code>，那我们有两种情况：1. 将<code>s[i]</code>由0翻转到1。2. 将前面的字符串<code>s[0:i-1]</code>中所有1翻转到0，两种情况取最小值，有<code>dp[i] = min{dp[i - 1] + 1, oneCount}</code>。所以我们还得用一个变量记录1的数量。</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minFlipsMonoIncr</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-keyword">int</span> dp = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'1'</span>)
          cnt++;
        <span class="hljs-keyword">else</span> dp = <span class="hljs-built_in">min</span>(dp+<span class="hljs-number">1</span>, cnt);
      }
      <span class="hljs-keyword">return</span> dp;
    }
};</code></pre></div>


              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="category-chain-item">算法整理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">#算法总结</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>dp</div>
      <div>https://qianxunslimg.github.io/2022/04/14/dp/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>qianxunslimg</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年4月14日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/14/nan/" title="-nan">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">-nan</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/13/tan-xin/" title="贪心">
                        <span class="hidden-mobile">贪心</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
