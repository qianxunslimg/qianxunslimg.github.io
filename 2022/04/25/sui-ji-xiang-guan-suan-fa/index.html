<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/MTMRB7P@G[WVCWEB9W([}FT.png >
    <title>
        qianxunslimgのblog
    </title>
    <meta name="description" content= 欢迎访问我的博客， >
    <meta name="keywords" content= qianxunslimg,blog,job,面试,找工作 >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            随机算法
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h3 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382. 链表随机节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=382">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-random-node/#">思路</a></p>
<p>难度中等270</p>
<p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li><code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li>
<li><code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>
</ul>
<p><strong>示例：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/getrand-linked-list.jpg" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入
[<span class="hljs-string">"Solution"</span>, <span class="hljs-string">"getRandom"</span>, <span class="hljs-string">"getRandom"</span>, <span class="hljs-string">"getRandom"</span>, <span class="hljs-string">"getRandom"</span>, <span class="hljs-string">"getRandom"</span>]
[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [], [], [], [], []]
输出
[null, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre></div>

<h4 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-random-node/solution/xu-shui-chi-chou-yang-suan-fa-by-jackwener/">蓄水池抽样算法</a></h4><p>当内存无法加载全部数据时，如何从包含<code>未知大小的数据流</code>中<code>随机选取k个数据</code>，并且要保证每个数据被抽取到的概率相等。</p>
<p>当 k = 1 时，即此题的情况<br>也就是说，我们每次只能读一个数据。</p>
<p>假设数据流含有N个数，我们知道如果要保证所有的数被抽到的概率相等，那么每个数抽到的概率应该为 1/N</p>
<p>那如何保证呢？</p>
<p>先说方案：</p>
<p>每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数。</p>
<p>举例说明： 1 - 10</p>
<p>遇到1，概率为1，保留第一个数。<br>遇到2，概率为1/2，这个时候，1和2各1/2的概率被保留<br>遇到3，3被保留的概率为1/3，(之前剩下的数假设1被保留)，2/3的概率 1 被保留，(此时1被保留的总概率为 2/3 * 1/2 = 1/3)<br>遇到4，4被保留的概率为1/4，(之前剩下的数假设1被保留)，3/4的概率 1 被保留，(此时1被保留的总概率为 3/4 * 2/3 * 1/2 = 1/4)<br>以此类推，每个数被保留的概率都是1/N。</p>
<p>证明使用数学归纳法即可</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220425010136581.png" alt="image-20220425010136581" style="zoom: 33%;">

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    ListNode* head;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Solution</span>(ListNode* head) {
        <span class="hljs-keyword">this</span>-&gt;head = head;
    }
    
    <span class="hljs-comment">/** Returns a random node's value. */</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>{
        ListNode* phead = <span class="hljs-keyword">this</span>-&gt;head;
        <span class="hljs-keyword">int</span> val = phead-&gt;val;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (phead){
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % count++ == <span class="hljs-number">0</span>)
                val = phead-&gt;val;
            phead = phead-&gt;next;
        }
        <span class="hljs-keyword">return</span> val;
    }
};</code></pre></div>

<h3 id="398-随机数索引"><a href="#398-随机数索引" class="headerlink" title="398. 随机数索引"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/random-pick-index/">398. 随机数索引</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=398">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/random-pick-index/#">思路</a></p>
<p>难度中等146英文版讨论区</p>
<p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p>
<p><strong>注意：</strong><br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p>
<p><strong>示例:</strong></p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>};
Solution solution = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Solution(<span class="hljs-params">nums</span>)</span>;

<span class="hljs-comment">// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。</span>
solution.pick(<span class="hljs-number">3</span>);

<span class="hljs-comment">// pick(1) 应该返回 0。因为只有nums[0]等于1。</span>
solution.pick(<span class="hljs-number">1</span>);</code></pre></div>

<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums) : <span class="hljs-built_in">nums</span>(nums) {}

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> ans;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) {
            <span class="hljs-keyword">if</span> (nums[i] == target) {
                ++cnt; <span class="hljs-comment">// 第 cnt 次遇到 target</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % cnt == <span class="hljs-number">0</span>) {
                    ans = i;
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h3><p>难度中等273</p>
<p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的。</p>
<p>实现 <code>Solution</code> class:</p>
<ul>
<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>
<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>
<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>
</ul>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入
[<span class="hljs-string">"Solution"</span>, <span class="hljs-string">"shuffle"</span>, <span class="hljs-string">"reset"</span>, <span class="hljs-string">"shuffle"</span>]
[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [], [], []]
输出
[null, [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]]</code></pre></div>

<h4 id="Fisher–Yates-shuffle-洗牌算法"><a href="#Fisher–Yates-shuffle-洗牌算法" class="headerlink" title="Fisher–Yates shuffle 洗牌算法"></a><code>Fisher–Yates shuffle 洗牌算法</code></h4><h5 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h5><p>Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。</p>
<p>现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。<strong>这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后</strong>。这样就将时间复杂度从 O(n^2) 减小到了 **O(n)**。算法的伪代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs smali">-- To shuffle an<span class="hljs-built_in"> array </span>a of n elements (indices 0..n-1):
for i from n−1 downto 1 do
     j ← random integer such that 0 ≤ j ≤ i
     exchange a[j]<span class="hljs-built_in"> and </span>a[i]</code></pre></div>

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="迭代步骤演示"><a href="#迭代步骤演示" class="headerlink" title="迭代步骤演示"></a>迭代步骤演示</h6><p>根据每次迭代次数可以用下面的表格，描述这个算法的执行过程</p>
<table>
<thead>
<tr>
<th align="left">随机数取值范围</th>
<th align="left">随机数</th>
<th align="right">原始数据</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="right">1 2 3 4 5 6 7 8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">1-8</td>
<td align="left">6</td>
<td align="right">1 2 3 4 5 7 8</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">1-7</td>
<td align="left">2</td>
<td align="right">1 7 3 4 5 8</td>
<td align="left">2 6</td>
</tr>
<tr>
<td align="left">1–6</td>
<td align="left">6</td>
<td align="right">1 7 3 4 5</td>
<td align="left">8 2 6</td>
</tr>
<tr>
<td align="left">1–5</td>
<td align="left">1</td>
<td align="right">5 7 3 4</td>
<td align="left">1 8 2 6</td>
</tr>
<tr>
<td align="left">1–4</td>
<td align="left">3</td>
<td align="right">5 7 4</td>
<td align="left">3 1 8 2 6</td>
</tr>
<tr>
<td align="left">1–3</td>
<td align="left">3</td>
<td align="right">5 7</td>
<td align="left">4 3 1 8 2 6</td>
</tr>
<tr>
<td align="left">1–2</td>
<td align="left">1</td>
<td align="right">7</td>
<td align="left">5 4 3 1 8 2 6</td>
</tr>
</tbody></table>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
		vector&lt;<span class="hljs-keyword">int</span>&gt; nums;
		vector&lt;<span class="hljs-keyword">int</span>&gt; origin;
  
    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) {
        <span class="hljs-keyword">this</span>-&gt;nums = nums;
        <span class="hljs-keyword">this</span>-&gt;origin.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());
        <span class="hljs-built_in">copy</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), origin.<span class="hljs-built_in">begin</span>());
    }
    
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">copy</span>(origin.<span class="hljs-built_in">begin</span>(), origin.<span class="hljs-built_in">end</span>(), nums.<span class="hljs-built_in">begin</span>());
        <span class="hljs-keyword">return</span> nums;
    }
    
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">int</span> j =i+ <span class="hljs-built_in">rand</span>()%(nums.<span class="hljs-built_in">size</span>()-i);
            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);
        }
        <span class="hljs-keyword">return</span> nums;
    }
};</code></pre></div>

<h3 id="剑指-Offer-II-071-按权重生成随机数"><a href="#剑指-Offer-II-071-按权重生成随机数" class="headerlink" title="剑指 Offer II 071. 按权重生成随机数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cuyjEf/">剑指 Offer II 071. 按权重生成随机数</a></h3><p>难度中等19英文版讨论区</p>
<p>给定一个正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表下标 <code>i</code> 的权重（下标从 <code>0</code> 开始），请写一个函数 <code>pickIndex</code> ，它可以随机地获取下标 <code>i</code>，选取下标 <code>i</code> 的概率与 <code>w[i]</code> 成正比。</p>
<p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，75%）。</p>
<p>也就是说，选取下标 <code>i</code> 的概率为 <code>w[i] / sum(w)</code> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：
inputs = [<span class="hljs-string">"Solution"</span>,<span class="hljs-string">"pickIndex"</span>]
inputs = [[[<span class="hljs-number">1</span>]],[]]
输出：
[null,<span class="hljs-number">0</span>]
解释：
<span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>]);
solution.pickIndex(); // 返回 <span class="hljs-number">0</span>，因为数组中只有一个元素，所以唯一的选择是返回下标 <span class="hljs-number">0</span>。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：
inputs = [<span class="hljs-string">"Solution"</span>,<span class="hljs-string">"pickIndex"</span>,<span class="hljs-string">"pickIndex"</span>,<span class="hljs-string">"pickIndex"</span>,<span class="hljs-string">"pickIndex"</span>,<span class="hljs-string">"pickIndex"</span>]
inputs = [[[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]],[],[],[],[],[]]
输出：
[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]
解释：
<span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]);
solution.pickIndex(); // 返回 <span class="hljs-number">1</span>，返回下标 <span class="hljs-number">1</span>，返回该下标概率为 <span class="hljs-number">3</span>/<span class="hljs-number">4</span> 。
solution.pickIndex(); // 返回 <span class="hljs-number">1</span>
solution.pickIndex(); // 返回 <span class="hljs-number">1</span>
solution.pickIndex(); // 返回 <span class="hljs-number">1</span>
solution.pickIndex(); // 返回 <span class="hljs-number">0</span>，返回下标 <span class="hljs-number">0</span>，返回该下标概率为 <span class="hljs-number">1</span>/<span class="hljs-number">4</span> 。

由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:
[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]
[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
[null,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
......
诸若此类。</code></pre></div>

<h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>前缀和 + 二分 主要注意二分查找的值的选择</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    vector&lt;<span class="hljs-keyword">int</span>&gt; preSum;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; w) {
      preSum.<span class="hljs-built_in">resize</span>(w.<span class="hljs-built_in">size</span>());
      <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;preSum.<span class="hljs-built_in">size</span>(); i++){
        preSum[i] = pre + w[i];
        pre = preSum[i];
      }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">//假设1 1 1 presum: 1 2 3 </span>
      <span class="hljs-comment">//取随机数的size应该就是 3 但是查找随机数应该在随机数+1</span>
      <span class="hljs-comment">//从最后一个看 rand最大为2 永远取不到最后一个 且多取到1次0</span>
      <span class="hljs-keyword">int</span> val = <span class="hljs-built_in">rand</span>()%(preSum.<span class="hljs-built_in">back</span>());
      <span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">lower_bound</span>(preSum.<span class="hljs-built_in">begin</span>(), preSum.<span class="hljs-built_in">end</span>(), val + <span class="hljs-number">1</span>) - preSum.<span class="hljs-built_in">begin</span>();
      <span class="hljs-keyword">return</span> pos;
    }
};</code></pre></div>

<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>蓄水池抽样 超时了 想起来更简单 但是每次都是On 总体时间超时了 试了下随机中断他，通过不了 可能中断思路不对吧</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; w) : <span class="hljs-built_in">nums</span>(w){}
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">int</span> ans;
      <span class="hljs-keyword">int</span> preSum = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
        preSum += nums[i];
        ans = <span class="hljs-built_in">rand</span>()%preSum &lt; nums[i]?i:ans;
      }
      <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="497-非重叠矩形中的随机点"><a href="#497-非重叠矩形中的随机点" class="headerlink" title="497. 非重叠矩形中的随机点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. 非重叠矩形中的随机点</a></h3><p>难度中等130</p>
<p>给定一个由非重叠的轴对齐矩形的数组 <code>rects</code> ，其中 <code>rects[i] = [ai, bi, xi, yi]</code> 表示 <code>(ai, bi)</code> 是第 <code>i</code> 个矩形的左下角点，<code>(xi, yi)</code> 是第 <code>i</code> 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。</p>
<p>在给定的矩形覆盖的空间内的任何整数点都有可能被返回。</p>
<p><strong>请注意</strong> ，整数点是具有整数坐标的点。</p>
<p>实现 <code>Solution</code> 类:</p>
<ul>
<li><code>Solution(int[][] rects)</code> 用给定的矩形数组 <code>rects</code> 初始化对象。</li>
<li><code>int[] pick()</code> 返回一个随机的整数点 <code>[u, v]</code> 在给定的矩形所覆盖的空间内。</li>
</ul>
<p><strong>示例 1：</strong></p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/lc-pickrandomrec.jpg" alt="img" style="zoom:50%;">

<div class="code-wrapper"><pre><code class="hljs prolog">输入: 
[<span class="hljs-string">"Solution"</span>, <span class="hljs-string">"pick"</span>, <span class="hljs-string">"pick"</span>, <span class="hljs-string">"pick"</span>, <span class="hljs-string">"pick"</span>, <span class="hljs-string">"pick"</span>]
[[[[<span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]]], [], [], [], [], []]
输出: 
[null, [<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>], [<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]

解释：
<span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([[<span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]]);
solution.pick(); // 返回 [<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>]
solution.pick(); // 返回 [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
solution.pick(); // 返回 [<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>]
solution.pick(); // 返回 [<span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>]
solution.pick(); // 返回 [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre></div>

<h4 id="蓄水池-再随机"><a href="#蓄水池-再随机" class="headerlink" title="蓄水池 再随机"></a>蓄水池 再随机</h4><p>用蓄水池选中矩形 然后再在矩形内随机选点</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">private</span>:
  vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; recs;

<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">Solution</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;rects) { recs = rects; }

  <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">-1</span>, cur = <span class="hljs-number">0</span>, curSum = <span class="hljs-number">0</span>, n = recs.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
      <span class="hljs-keyword">int</span> x1 = recs[i][<span class="hljs-number">0</span>], y1 = recs[i][<span class="hljs-number">1</span>], x2 = recs[i][<span class="hljs-number">2</span>], y2 = recs[i][<span class="hljs-number">3</span>];
      cur = (x2 - x1 + <span class="hljs-number">1</span>) * (y2 - y1 + <span class="hljs-number">1</span>);
      curSum += cur;
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % curSum &lt; cur)
        idx = i;
    }
    <span class="hljs-keyword">int</span> x1 = recs[idx][<span class="hljs-number">0</span>], y1 = recs[idx][<span class="hljs-number">1</span>], x2 = recs[idx][<span class="hljs-number">2</span>],
        y2 = recs[idx][<span class="hljs-number">3</span>];
    <span class="hljs-keyword">return</span> {x1 + <span class="hljs-built_in">rand</span>() % (x2 - x1 + <span class="hljs-number">1</span>), y1 + <span class="hljs-built_in">rand</span>() % (y2 - y1 + <span class="hljs-number">1</span>)};
  }
};</code></pre></div>

<h4 id="前缀和-二分"><a href="#前缀和-二分" class="headerlink" title="前缀和+二分"></a>前缀和+二分</h4><ol>
<li>先处理出前缀和数组 （注意前缀和有没有一开始的0，体现在最后的位置要不要减减）</li>
<li>然后pick随机取一个数a 查找前缀和数组中第一个&gt;=a的第一个位置 从而确定选中的是哪个矩形 然后在矩形中随机选点</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">private</span>:
  vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; rects;
  vector&lt;<span class="hljs-keyword">int</span>&gt; preS;

<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">Solution</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;rects) {
    <span class="hljs-keyword">this</span>-&gt;rects = rects;
    preS.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;rec : rects) {
      <span class="hljs-keyword">int</span> x1 = rec[<span class="hljs-number">0</span>], y1 = rec[<span class="hljs-number">1</span>], x2 = rec[<span class="hljs-number">2</span>], y2 = rec[<span class="hljs-number">3</span>];
      preS.<span class="hljs-built_in">push_back</span>(preS.<span class="hljs-built_in">back</span>() + (x2 - x1 + <span class="hljs-number">1</span>) * (y2 - y1 + <span class="hljs-number">1</span>));
    }
  }

  <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> w = <span class="hljs-built_in">rand</span>() % preS.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">lower_bound</span>(preS.<span class="hljs-built_in">begin</span>(), preS.<span class="hljs-built_in">end</span>(), w) - preS.<span class="hljs-built_in">begin</span>();
    l--;
    <span class="hljs-keyword">int</span> x1 = rects[l][<span class="hljs-number">0</span>], y1 = rects[l][<span class="hljs-number">1</span>], x2 = rects[l][<span class="hljs-number">2</span>], y2 = rects[l][<span class="hljs-number">3</span>];
    <span class="hljs-keyword">return</span> {x1 + <span class="hljs-built_in">rand</span>() % (x2 - x1 + <span class="hljs-number">1</span>), y1 + <span class="hljs-built_in">rand</span>() % (y2 - y1 + <span class="hljs-number">1</span>)};
  }
};
</code></pre></div>


    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: qianxunslimg | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
