

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/avatar.png">
  <link rel="icon" href="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="qianxunslimg">
  <meta name="keywords" content="">
  
    <meta name="description" content="一些题目797. 所有可能的路径难度中等262收藏分享切换为英文接收动态反馈 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）  graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。 示例 1：  输入：graph &#x3D; [[1,2],[3],[3],[]]">
<meta property="og:type" content="article">
<meta property="og:title" content="图论">
<meta property="og:url" content="https://qianxunslimg.github.io/2022/03/15/tu-lun/index.html">
<meta property="og:site_name" content="qianxunslimgのblog">
<meta property="og:description" content="一些题目797. 所有可能的路径难度中等262收藏分享切换为英文接收动态反馈 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）  graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。 示例 1：  输入：graph &#x3D; [[1,2],[3],[3],[]]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_1.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_2.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi2.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi1.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph1.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph2.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/xogrid.jpg">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676174-hOEVUL-image.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676179-kGxcmu-image.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220531213843273.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514145218925.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/d.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/c.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514162922825.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220531214329298.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/931_example_1.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex1.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex2.png">
<meta property="og:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex3.png">
<meta property="article:published_time" content="2022-03-15T12:12:49.000Z">
<meta property="article:modified_time" content="2022-07-12T12:36:14.945Z">
<meta property="article:author" content="qianxunslimg">
<meta property="article:tag" content="算法总结">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_1.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>图论 - qianxunslimgのblog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"qianxunslimg.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>qianxunslimg</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="图论"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-15 20:12" pubdate>
          2022年3月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">图论</h1>
            
            <div class="markdown-body">
              
              <h1 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h1><h3 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h3><p>难度中等262收藏分享切换为英文接收动态反馈</p>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_2.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>类似多叉树的遍历</li>
<li>for内for外两种写法</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="两种写法"><a href="#两种写法" class="headerlink" title="两种写法"></a>两种写法</h5><ol>
<li>==push pop在for外 但是最后需要pop==</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) {</span><br><span class="line">        <span class="built_in">traverse</span>(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        path.<span class="built_in">push_back</span>(s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == graph.<span class="built_in">size</span>()<span class="number">-1</span>){</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">//！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[s]){</span><br><span class="line">            <span class="built_in">traverse</span>(graph, v);</span><br><span class="line">        }</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><u>==push pop在for内 但是第一个元素需要先压入==</u></li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) {</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//!</span></span><br><span class="line">        <span class="built_in">traverse</span>(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(s == graph.<span class="built_in">size</span>()<span class="number">-1</span>){</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : graph[s]){</span><br><span class="line">            path.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="built_in">traverse</span>(graph, v);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="剑指-Offer-II-111-计算除法"><a href="#剑指-Offer-II-111-计算除法" class="headerlink" title="剑指 Offer II 111. 计算除法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vlzXQL/">剑指 Offer II 111. 计算除法</a></h3><p>难度中等13</p>
<p>给定一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p>
<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>
<p><strong>注意：</strong>输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="解法-建邻接表-dfs"><a href="#解法-建邻接表-dfs" class="headerlink" title="解法 建邻接表 dfs"></a>解法 建邻接表 dfs</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="comment">// equations中每一个equation，代表两者的相互关系已知，</span></span><br><span class="line">    <span class="comment">// 用有向图保存，将equation中的两者间建边，边的权重分别为两者的商/商的倒数</span></span><br><span class="line">    <span class="comment">// queries中，首先检查是否都出现过， 再检查是否联通</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(unordered_map&lt;string, vector&lt;pair&lt;string, <span class="keyword">double</span>&gt;&gt;&gt;&amp; graph, unordered_set&lt;string&gt;&amp; visted, string start, string end, <span class="keyword">double</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (start == end) </span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        visted.<span class="built_in">insert</span>(start); </span><br><span class="line">        <span class="comment">// 遍历当前点能走到的所有点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : graph[start]){</span><br><span class="line">            <span class="keyword">if</span> (!visted.<span class="built_in">count</span>(node.first)) { </span><br><span class="line">                <span class="keyword">double</span> res = <span class="built_in">dfs</span>(graph, visted, node.first, end, node.second * val); </span><br><span class="line">                <span class="comment">// res = -1代表该通路无解，如果该通路有解则返回</span></span><br><span class="line">                <span class="keyword">if</span> (res &gt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 可以更新graph，方便下一次查找</span></span><br><span class="line">                    <span class="comment">// graph[node.first].push_back</span></span><br><span class="line">                    <span class="keyword">return</span> res; </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="keyword">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>{</span><br><span class="line">        <span class="comment">//快速查找的映射，key  是起点，value 是与 {该点联通的点终点, 权重}</span></span><br><span class="line">        unordered_map&lt;string, vector&lt;pair&lt;string, <span class="keyword">double</span>&gt;&gt;&gt; graph; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); ++i) { </span><br><span class="line">            graph[equations[i][<span class="number">0</span>]].<span class="built_in">push_back</span>({equations[i][<span class="number">1</span>], values[i]});</span><br><span class="line">            graph[equations[i][<span class="number">1</span>]].<span class="built_in">push_back</span>({equations[i][<span class="number">0</span>], <span class="number">1</span> / values[i]}); </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">res</span><span class="params">(queries.size(), <span class="number">-1.0</span>)</span></span>; </span><br><span class="line">        unordered_set&lt;string&gt; visted;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">            <span class="comment">// 首先两者确认都出现过</span></span><br><span class="line">            <span class="keyword">if</span> (graph.<span class="built_in">count</span>(queries[i][<span class="number">0</span>]) &amp;&amp; graph.<span class="built_in">count</span>(queries[i][<span class="number">1</span>])) { </span><br><span class="line">                <span class="comment">// 因为是有环图，用visited来防止重复走</span></span><br><span class="line">                visted.<span class="built_in">clear</span>();</span><br><span class="line">                res[i] = <span class="built_in">dfs</span>(graph, visted, queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>], <span class="number">1</span>); <span class="comment">//确定起点和终点，进入递归，起点终点可能相等，默认是 1</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h1 id="环检测和拓扑排序"><a href="#环检测和拓扑排序" class="headerlink" title="环检测和拓扑排序"></a><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/2/20/48/">环检测和拓扑排序</a></h1><p>一个讲的很好的bfs拓扑排序</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135094687">图文详解面试常考算法 —— 拓扑排序 - 知乎 (zhihu.com)</a></p>
<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=207&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/#">思路</a></p>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h4 id="dfs查环"><a href="#dfs查环" class="headerlink" title="dfs查环"></a>dfs查环</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; visited;  <span class="comment">//记录的是遍历过的 用于终止遍历 提高效率 不加会超时 用 visited 数组防止走回头路</span></span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; onPath;   <span class="comment">//记录每次遍历过的节点，用于查环</span></span><br><span class="line">    <span class="keyword">bool</span> hasCycle;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: prerequisites){</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        }</span><br><span class="line">        visited = vector&lt;<span class="keyword">bool</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        onPath = vector&lt;<span class="keyword">bool</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++){</span><br><span class="line">            <span class="comment">//遍历所有节点</span></span><br><span class="line">            <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> !hasCycle;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(onPath[s]) <span class="comment">//出现环</span></span><br><span class="line">            hasCycle = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[s] || hasCycle)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//前序代码位置</span></span><br><span class="line">        visited[s] = <span class="number">1</span>;</span><br><span class="line">        onPath[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : graph[s])</span><br><span class="line">            <span class="built_in">traverse</span>(graph, t);</span><br><span class="line">        <span class="comment">//后序遍历位置</span></span><br><span class="line">        onPath[s] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="bfs数入度为0的点的个数"><a href="#bfs数入度为0的点的个数" class="headerlink" title="bfs数入度为0的点的个数"></a>bfs数入度为0的点的个数</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(numCourses);</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">indeg</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; info : prerequisites){</span><br><span class="line">        edge[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        indeg[info[<span class="number">0</span>]]++;</span><br><span class="line">      }</span><br><span class="line">      queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;indeg.<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)</span><br><span class="line">          que.<span class="built_in">push</span>(i);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> visited = <span class="number">0</span>; <span class="comment">//记录的是 可以走到的 也就是入度为0的节点数</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">        visited++;</span><br><span class="line">        <span class="keyword">int</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; v : edge[node]){</span><br><span class="line">          indeg[v]--;</span><br><span class="line">          <span class="keyword">if</span>(indeg[v] == <span class="number">0</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(v);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=210&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/#">思路</a></p>
<p>难度中等582收藏分享切换为英文接收动态反馈</p>
<p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="dfs拓扑排序-代码"><a href="#dfs拓扑排序-代码" class="headerlink" title="dfs拓扑排序 代码"></a>dfs拓扑排序 代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; postOrder;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: prerequisites){</span><br><span class="line">            <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">            graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        }</span><br><span class="line">        visited = vector&lt;<span class="keyword">bool</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        onPath = vector&lt;<span class="keyword">bool</span>&gt;(numCourses, <span class="number">0</span>);</span><br><span class="line">        hasCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++){</span><br><span class="line">            <span class="comment">//遍历所有节点</span></span><br><span class="line">            <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(hasCycle)  <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{};</span><br><span class="line">        <span class="built_in">reverse</span>(postOrder.<span class="built_in">begin</span>(), postOrder.<span class="built_in">end</span>());  <span class="comment">//拓扑排序是后序遍历的反转 注意 后序的常规理解图的后序遍历</span></span><br><span class="line">        <span class="keyword">return</span> postOrder;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(onPath[s]) <span class="comment">//出现环</span></span><br><span class="line">            hasCycle = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[s] || hasCycle)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//前序代码位置</span></span><br><span class="line">        visited[s] = <span class="number">1</span>;</span><br><span class="line">        onPath[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t : graph[s])</span><br><span class="line">            <span class="built_in">traverse</span>(graph, t);</span><br><span class="line">        <span class="comment">//后序遍历位置</span></span><br><span class="line">        onPath[s] = <span class="number">0</span>;</span><br><span class="line">        postOrder.<span class="built_in">push_back</span>(s); <span class="comment">//记录后序遍历</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="bfs拓扑排序代码"><a href="#bfs拓扑排序代码" class="headerlink" title="bfs拓扑排序代码"></a>bfs拓扑排序代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edge</span>(numCourses);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : prerequisites){</span><br><span class="line">        inDegree[num[<span class="number">0</span>]]++;  <span class="comment">//统计所有节点的入度</span></span><br><span class="line">        edge[num[<span class="number">1</span>]].<span class="built_in">push_back</span>(num[<span class="number">0</span>]); <span class="comment">//构建邻接表</span></span><br><span class="line">      }</span><br><span class="line">      </span><br><span class="line">      queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)</span><br><span class="line">          que.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="keyword">int</span> curr = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        res[i++] = curr;</span><br><span class="line">        <span class="comment">//移除所有curr节点指向节点的1个入度，为0push</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : edge[curr]){</span><br><span class="line">            inDegree[num]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[num] == <span class="number">0</span>)</span><br><span class="line">              que.<span class="built_in">push</span>(num);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> i == numCourses ? res : vector&lt;<span class="keyword">int</span>&gt;{};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="剑指-Offer-II-114-外星文字典"><a href="#剑指-Offer-II-114-外星文字典" class="headerlink" title="剑指 Offer II 114. 外星文字典"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h3><p>难度困难83</p>
<p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p>
<p>给定一个字符串列表 <code>words</code> ，作为这门语言的词典，<code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p>
<p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>""</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p>
<p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p>
<ul>
<li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么 <code>s</code> 的字典顺序小于 <code>t</code> 。</li>
<li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时，<code>s</code> 的字典顺序也小于 <code>t</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["wrt","wrf","er","ett","rftt"]</span><br><span class="line">输出："wertf"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["z","x"]</span><br><span class="line">输出："zx"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：words = ["z","x","z"]</span><br><span class="line">输出：""</span><br><span class="line">解释：不存在合法字母顺序，因此返回 "" 。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="bfs拓扑排序"><a href="#bfs拓扑排序" class="headerlink" title="bfs拓扑排序"></a>bfs拓扑排序</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 每个节点的入度</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">g</span>(<span class="number">26</span>); <span class="comment">// 建图</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">st</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 字母是否出现</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 字母出现的数量</span></span><br><span class="line">        <span class="keyword">for</span> (string&amp; word: words) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span>&amp; ch: word) {</span><br><span class="line">                <span class="keyword">if</span> (st[ch - <span class="string">'a'</span>] == <span class="literal">false</span>) cnt ++ ;</span><br><span class="line">                st[ch - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) {</span><br><span class="line">            string s = words[i], p = words[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> lens = s.<span class="built_in">size</span>(), lenp = p.<span class="built_in">size</span>(), minn = <span class="built_in">min</span>(lens, lenp);</span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">false</span>; <span class="comment">// 是否有不同的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minn; j ++ ) {</span><br><span class="line">                <span class="keyword">if</span> (s[j] == p[j]) <span class="keyword">continue</span>;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">                in[p[j] - <span class="string">'a'</span>] ++ ;</span><br><span class="line">                g[s[j] - <span class="string">'a'</span>].<span class="built_in">push_back</span>(p[j] - <span class="string">'a'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!ok &amp;&amp; lens &gt; lenp) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// 后一个是前一个的前缀</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) {</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span> &amp;&amp; st[i] == <span class="literal">true</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        string res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> p = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(p + <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u : g[p]) </span><br><span class="line">                <span class="keyword">if</span> ( -- in[u] == <span class="number">0</span>) </span><br><span class="line">                    q.<span class="built_in">push</span>(u);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>() == cnt ? res : <span class="string">""</span>; <span class="comment">// 出现的单词都要在答案中</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>





<h1 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/2/20/40/">二分图判定</a></h1><h3 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=785&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/#">思路</a></p>
<p>难度中等347收藏分享切换为英文接收动态反馈</p>
<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>
<ul>
<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>
<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>
<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>
<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>
</ul>
<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>
<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi2.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：graph = [[1,3],[0,2],[1,3],[0,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对整个图进行交替染色 若可以完全染色 则为二分图</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 给图上色 如果可以完全上色 则表示为二分图</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>{</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">color</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v&lt;n; v++){</span><br><span class="line">            <span class="keyword">if</span>(!used[v])</span><br><span class="line">                <span class="built_in">traverse</span>(graph, v, used, color, ok);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, vector&lt;<span class="keyword">bool</span>&gt;&amp; color, <span class="keyword">bool</span>&amp; ok)</span></span>{</span><br><span class="line">        <span class="comment">//如果确定不是二分图了 就不用再浪费时间遍历了</span></span><br><span class="line">        <span class="keyword">if</span>(!ok) <span class="keyword">return</span>;</span><br><span class="line">        used[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : graph[v]){</span><br><span class="line">            <span class="keyword">if</span>(!used[w]){</span><br><span class="line">                color[w] = !color[v];</span><br><span class="line">                <span class="built_in">traverse</span>(graph, w, used, color, ok);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(color[w] == color[v]){</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="886-可能的二分法"><a href="#886-可能的二分法" class="headerlink" title="886. 可能的二分法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=886&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/possible-bipartition/#">思路</a></p>
<p>难度中等161</p>
<p>给定一组 <code>n</code> 人（编号为 <code>1, 2, ..., n</code>）， 我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>
<p>给定整数 <code>n</code> 和数组 <code>dislikes</code> ，其中 <code>dislikes[i] = [ai, bi]</code> ，表示不允许将编号为 <code>ai</code> 和 <code>bi</code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：group1 [1,4], group2 [2,3]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先构造邻接表（细节， 编号为1-n）</li>
<li>上色</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; color;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="comment">//注意编号 1-n</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>{</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        color.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">        visited = vector&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dislikess = <span class="built_in">buildGraph</span>(dislikes,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++){</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                <span class="built_in">traverse</span>(dislikess, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个双向图 你恨我 我恨你</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes, <span class="keyword">int</span> n){</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i&lt;dislikes.<span class="built_in">size</span>(); i++){</span><br><span class="line">            res[dislikes[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(dislikes[i][<span class="number">1</span>]);</span><br><span class="line">            res[dislikes[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(dislikes[i][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上色函数 经典 完全一致</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes, <span class="keyword">int</span> index)</span></span>{</span><br><span class="line">       ·</span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> newIndex : dislikes[index]){</span><br><span class="line">            <span class="keyword">if</span>(!visited[newIndex]){</span><br><span class="line">                color[newIndex] = !color[index];</span><br><span class="line">                <span class="built_in">traverse</span>(dislikes, newIndex);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(color[index] == color[newIndex])</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并查集（UNION-FIND）算法"><a href="#并查集（UNION-FIND）算法" class="headerlink" title="并查集（UNION-FIND）算法"></a>并查集（UNION-FIND）算法</h1><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//连同分量的个数</span></span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">	<span class="built_in">UF</span>(<span class="keyword">int</span> n) {</span><br><span class="line">		cnt = n;</span><br><span class="line">		parent.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			parent[i] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//联通节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		parent[rootQ] = rootP;</span><br><span class="line">		cnt--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回节点 x 的连通分量根节点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x) {</span><br><span class="line">			<span class="comment">// 进行路径压缩</span></span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">			x = parent[x];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{ <span class="keyword">return</span> cnt; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h3><p>难度中等747</p>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph1.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph2.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>标准的并查集题目 模板直接使用</li>
<li>转换成邻接表dfs</li>
<li>邻接图 dfs 按相连的逻辑去进行dfs 最优</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><ol>
<li>标准的并查集题目 模板直接使用</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//连同分量的个数</span></span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">	<span class="built_in">UF</span>(<span class="keyword">int</span> n) {</span><br><span class="line">		cnt = n;</span><br><span class="line">		parent.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			parent[i] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//联通节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		parent[rootQ] = rootP;  <span class="comment">//注意这里是parent的合并</span></span><br><span class="line">		cnt--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回节点 x 的连通分量根节点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x) {</span><br><span class="line">			<span class="comment">// 进行路径压缩</span></span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">			x = parent[x];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{ <span class="keyword">return</span> cnt; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>{</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(isConnected.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;isConnected.<span class="built_in">size</span>(); i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;isConnected[i].<span class="built_in">size</span>(); j++){</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j])</span><br><span class="line">                    uf.<span class="built_in">unionn</span>(i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uf.<span class="built_in">count</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>转换成邻接表dfs</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(isConnected);</span><br><span class="line">        visited = vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]){</span><br><span class="line">                <span class="built_in">traverse</span>(graph, i);</span><br><span class="line">                ans++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        visited[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> newIndex : graph[index]){</span><br><span class="line">            <span class="keyword">if</span>(!visited[newIndex]){</span><br><span class="line">                <span class="comment">//如果使用全局ans 在此处--是不对的</span></span><br><span class="line">                <span class="built_in">traverse</span>(graph, newIndex); </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected){</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(isConnected.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;isConnected.<span class="built_in">size</span>(); i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;isConnected[i].<span class="built_in">size</span>(); j++){</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] == <span class="number">1</span>){</span><br><span class="line">                    res[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                    res[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>邻接图 dfs</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        visited =vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]){</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected, <span class="keyword">int</span> nowPro)</span></span>{</span><br><span class="line">        visited[nowPro] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;isConnected[nowPro].<span class="built_in">size</span>(); i++){</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; isConnected[nowPro][i] == <span class="number">1</span>){</span><br><span class="line">                <span class="built_in">dfs</span>(isConnected, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p><a href="https://labuladong.gitee.io/plugin-v4/?qno=130&amp;target=gitee">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/#">思路</a></p>
<p>难度中等750收藏分享切换为英文接收动态反馈</p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/xogrid.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]</span><br><span class="line">输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol>
<li>dfs这也是比较常规的 四周开始</li>
<li>并查集 重点理解如何使用这种数据结构</li>
</ol>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h5><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">isIsland</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++){</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>){</span><br><span class="line">                <span class="built_in">effect</span>(board, i, <span class="number">0</span>, isIsland);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(board[i][n<span class="number">-1</span>] == <span class="string">'O'</span>){</span><br><span class="line">                <span class="built_in">effect</span>(board, i, n<span class="number">-1</span>, isIsland);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>){</span><br><span class="line">                <span class="built_in">effect</span>(board, <span class="number">0</span>, i, isIsland);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(board[m<span class="number">-1</span>][i] == <span class="string">'O'</span>){</span><br><span class="line">                <span class="built_in">effect</span>(board, m<span class="number">-1</span>, i, isIsland);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span> &amp;&amp; !isIsland[i][j])</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">effect</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isIsland)</span></span>{</span><br><span class="line">        <span class="comment">//如果不加入island判断就会陷入死循环</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y&lt;<span class="number">0</span> || x&gt;= board.<span class="built_in">size</span>() || y&gt;=board[<span class="number">0</span>].<span class="built_in">size</span>() || board[x][y]!=<span class="string">'O'</span> || isIsland[x][y]){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        isIsland[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">effect</span>(board, x+<span class="number">1</span>, y, isIsland);</span><br><span class="line">        <span class="built_in">effect</span>(board, x<span class="number">-1</span>, y, isIsland);</span><br><span class="line">        <span class="built_in">effect</span>(board, x, y+<span class="number">1</span>, isIsland);</span><br><span class="line">        <span class="built_in">effect</span>(board, x, y<span class="number">-1</span>, isIsland);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p><code>使用node为节点进行连接 将网格上的节点映射到数值上</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n){</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">return</span> rootQ == rootP;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(parent[x]!= x){</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        m = board.<span class="built_in">size</span>();</span><br><span class="line">        n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(m*n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> dumpyNode = m*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++){</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>){</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == m<span class="number">-1</span> || j == n<span class="number">-1</span>)</span><br><span class="line">                        uf.<span class="built_in">unionn</span>(dumpyNode, <span class="built_in">node</span>(i, j));</span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                    <span class="comment">//里面的和上下左右联通</span></span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                        uf.<span class="built_in">unionn</span>(<span class="built_in">node</span>(i, j), <span class="built_in">node</span>(i<span class="number">-1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                        uf.<span class="built_in">unionn</span>(<span class="built_in">node</span>(i, j), <span class="built_in">node</span>(i, j<span class="number">-1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;m<span class="number">-1</span> &amp;&amp; board[i+<span class="number">1</span>][j] == <span class="string">'O'</span>)</span><br><span class="line">                        uf.<span class="built_in">unionn</span>(<span class="built_in">node</span>(i, j), <span class="built_in">node</span>(i+<span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; board[i][j+<span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">                        uf.<span class="built_in">unionn</span>(<span class="built_in">node</span>(i, j), <span class="built_in">node</span>(i, j+<span class="number">1</span>));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++){</span><br><span class="line">                <span class="keyword">if</span>(uf.<span class="built_in">connected</span>(<span class="built_in">node</span>(i, j), dumpyNode))</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                <span class="keyword">else</span> board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span>  x*n + y;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="剑指-Offer-II-118-多余的边"><a href="#剑指-Offer-II-118-多余的边" class="headerlink" title="剑指 Offer II 118. 多余的边"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h3><p>难度中等23收藏分享切换为英文接收动态反馈</p>
<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的边。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676174-hOEVUL-image.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: edges = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676179-kGxcmu-image.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]</span><br><span class="line">输出: [1,4]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="解法-使用并查集"><a href="#解法-使用并查集" class="headerlink" title="解法 使用并查集"></a>解法 使用并查集</h4><p>重复连接的情况下 就直接返回</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//连同分量的个数</span></span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">	<span class="built_in">UF</span>(<span class="keyword">int</span> n) {</span><br><span class="line">		cnt = n;</span><br><span class="line">		parent.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			parent[i] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//联通节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		parent[rootQ] = rootP;</span><br><span class="line">		cnt--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回节点 x 的连通分量根节点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x) {</span><br><span class="line">			<span class="comment">// 进行路径压缩</span></span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">			x = parent[x];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{ <span class="keyword">return</span> cnt; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>{</span><br><span class="line">      <span class="function">UF <span class="title">uni</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> edge : edges){</span><br><span class="line">        <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!uni.<span class="built_in">connected</span>(node1, node2))</span><br><span class="line">          uni.<span class="built_in">unionn</span>(node1, node2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> edge;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Kruskal-最小生成树算法"><a href="#Kruskal-最小生成树算法" class="headerlink" title="Kruskal 最小生成树算法"></a><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w">Kruskal 最小生成树算法</a></h1><p>所谓最小生成树，就是图中若干边的集合（这个集合为 <code>mst</code>，最小生成树的英文缩写），你要保证这些边：</p>
<p>1、包含图中的所有节点。</p>
<p>2、形成的结构是树结构（即不存在环）。</p>
<p>3、权重和最小。</p>
<p><a target="_blank" rel="noopener" href="https://visualgo.net/zh/mst">最小生成树 MST （Prim算法，Kruskal算法） - VisuAlgo</a></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220531213843273.png" srcset="/img/loading.gif" lazyload alt="image-20220531213843273"></p>
<h3 id="1135-最低成本联通所有城市"><a href="#1135-最低成本联通所有城市" class="headerlink" title="1135.最低成本联通所有城市"></a>1135.最低成本联通所有城市</h3><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514145218925.png" srcset="/img/loading.gif" lazyload alt="image-20220514145218925" style="zoom: 80%;">

<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p>
<p>树的判定算法加上按权重排序的逻辑就变成了 Kruskal 算法</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//连同分量的个数</span></span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="comment">// 存储每个节点的父节点</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// n 为图中节点的个数</span></span><br><span class="line">	<span class="built_in">UF</span>(<span class="keyword">int</span> n) {</span><br><span class="line">		cnt = n;</span><br><span class="line">		parent.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			parent[i] = i;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//联通节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		parent[rootQ] = rootP;</span><br><span class="line">		cnt--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回节点 x 的连通分量根节点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">		<span class="keyword">while</span> (parent[x] != x) {</span><br><span class="line">			<span class="comment">// 进行路径压缩</span></span><br><span class="line">			parent[x] = parent[parent[x]];</span><br><span class="line">			x = parent[x];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回图中的连通分量个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{ <span class="keyword">return</span> cnt; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumCost</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>{</span><br><span class="line">      <span class="function">UF <span class="title">uni</span><span class="params">(connections.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">      <span class="keyword">int</span> mst = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">auto</span> cmp = [](vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b){ <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; };</span><br><span class="line">      <span class="built_in">sort</span>(connections.<span class="built_in">begin</span>(), connections.<span class="built_in">end</span>(), cmp);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> edge : connections){</span><br><span class="line">        <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//判断parent是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(uni.<span class="built_in">connected</span>(node1, node2))</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">       	mst += weight;</span><br><span class="line">        uni.<span class="built_in">unionn</span>(node1, node2);</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 因为节点 0 没有被使用，所以 0 会额外占用一个连通分量</span></span><br><span class="line">      <span class="keyword">return</span> uni.<span class="built_in">count</span>() == <span class="number">2</span> ? mst : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=1584">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/#">思路</a></p>
<p>难度中等204</p>
<p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]<br>输出：20<br>解释：</p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/c.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。<br>注意到任意两个点之间只有唯一一条路径互相到达。</p>
<h4 id="解法-并查集-Kruskai"><a href="#解法-并查集-Kruskai" class="headerlink" title="解法 并查集 Kruskai"></a>解法 并查集 Kruskai</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union</span>{</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">  <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Union</span>(<span class="keyword">int</span> n){</span><br><span class="line">    cnt = n;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      parent[i] = i;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> node1, <span class="keyword">int</span> node2)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> root1 = <span class="built_in">find</span>(node1);</span><br><span class="line">    <span class="keyword">int</span> root2 = <span class="built_in">find</span>(node2);</span><br><span class="line">    <span class="keyword">if</span>(root1 == root2)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    parent[root1] = root2;</span><br><span class="line">    cnt--;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(parent[x] != x){</span><br><span class="line">      parent[x] = parent[parent[x]];</span><br><span class="line">      x = parent[x];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>{<span class="keyword">return</span> cnt;}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; all;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;n; j++){</span><br><span class="line">          <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">          temp[<span class="number">0</span>] = i;</span><br><span class="line">          temp[<span class="number">1</span>] = j;</span><br><span class="line">          <span class="keyword">int</span> diss = <span class="built_in">abs</span>(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">          temp[<span class="number">2</span>] = diss;</span><br><span class="line">          all.<span class="built_in">push_back</span>(temp);</span><br><span class="line">          <span class="comment">// cout&lt;&lt;diss&lt;&lt;" ";</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">auto</span> cmp = [](vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b){ <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; };</span><br><span class="line">      <span class="built_in">sort</span>(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>(), cmp);</span><br><span class="line">      <span class="function">Union <span class="title">uni</span><span class="params">(n)</span></span>;</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;all.<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="keyword">int</span> node1 = all[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> node2 = all[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> weight = all[i][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// cout&lt;&lt;weight&lt;&lt;" ";</span></span><br><span class="line">        <span class="keyword">if</span>(uni.<span class="built_in">find</span>(node1) == uni.<span class="built_in">find</span>(node2))</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        uni.<span class="built_in">unionn</span>(node1, node2);</span><br><span class="line">        ans += weight;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="名流问题：邻接矩阵"><a href="#名流问题：邻接矩阵" class="headerlink" title="名流问题：邻接矩阵"></a>名流问题：邻接矩阵</h1><p>图有两种存储形式，一种是邻接表，一种是邻接矩阵，邻接表的主要优势是节约存储空间；邻接矩阵的主要优势是可以迅速判断两个节点是否相邻。</p>
<p>对于名人问题，显然会经常需要判断两个人之间是否认识，也就是两个节点是否相邻，所以我们可以用邻接表来表示人和人之间的社交关系。</p>
<p>那么，把名流问题描述成算法的形式就是这样的：</p>
<p>给你输入一个大小为 <code>n x n</code> 的二维数组（邻接矩阵） <code>graph</code> 表示一幅有 <code>n</code> 个节点的图，每个人都是图中的一个节点，编号为 <code>0</code> 到 <code>n - 1</code>。</p>
<p>如果 <code>graph[i][j] == 1</code> 代表第 <code>i</code> 个人认识第 <code>j</code> 个人，如果 <code>graph[i][j] == 0</code> 代表第 <code>i</code> 个人不认识第 <code>j</code> 个人。</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514162922825.png" srcset="/img/loading.gif" lazyload alt="image-20220514162922825" style="zoom:67%;">

<p>从这个邻接矩阵来看，0认识2 1认识2.。。而2只认识自己 不认识其他人，所以2是名人</p>
<h3 id="277-搜寻名人"><a href="#277-搜寻名人" class="headerlink" title="277. 搜寻名人"></a>277. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-celebrity/">搜寻名人</a></h3><p>只告诉你总人数 <code>n</code>，同时提供一个 API <code>knows</code> 来查询人和人之间的社交关系：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以直接调用，能够返回 i 是否认识 j</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knows</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请你实现：返回「名人」的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cand = <span class="number">0</span>; cand &lt; n; cand++){</span><br><span class="line">      <span class="keyword">int</span> other;</span><br><span class="line">      <span class="keyword">for</span>(other = <span class="number">0</span>; other&lt;n; other++){</span><br><span class="line">        <span class="keyword">if</span>(cand == other) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">knows</span>(cand, other) || !<span class="built_in">knows</span>(other, cand))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span>(other == n) <span class="comment">//cand下other遍历完 说明满足</span></span><br><span class="line">        <span class="keyword">return</span> cand;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><h5 id="排除法"><a href="#排除法" class="headerlink" title="排除法"></a>排除法</h5><p>先一次遍历：如果当前认识其他 或者 其他不认识他 那么他肯定不是名人</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将所有候选人装进队列</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        que.<span class="built_in">push</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 一直排除，直到只剩下一个候选人停止循环</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">// 每次取出两个候选人，排除一个</span></span><br><span class="line">        <span class="keyword">int</span> cand = que.<span class="built_in">front</span>();</span><br><span class="line">      	que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> other = que.<span class="built_in">front</span>();</span><br><span class="line">      	que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">knows</span>(cand, other) || !<span class="built_in">knows</span>(other, cand)) {</span><br><span class="line">            <span class="comment">// cand 不可能是名人，排除，让 other 归队</span></span><br><span class="line">            que.<span class="built_in">push</span>(other);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// other 不可能是名人，排除，让 cand 归队</span></span><br><span class="line">            que.<span class="built_in">push</span>(cand);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在排除得只剩一个候选人，判断他是否真的是名人</span></span><br><span class="line">    <span class="keyword">int</span> cand = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++) {</span><br><span class="line">        <span class="keyword">if</span> (other == cand) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 保证其他人都认识 cand，且 cand 不认识任何其他人</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// cand 是名人</span></span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">	}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="comment">// 先假设 cand 是名人</span></span><br><span class="line">    <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> other = <span class="number">1</span>; other &lt; n; other++) {</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) {</span><br><span class="line">            <span class="comment">// cand 不可能是名人，排除</span></span><br><span class="line">            <span class="comment">// 假设 other 是名人</span></span><br><span class="line">            cand = other;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// other 不可能是名人，排除</span></span><br><span class="line">            <span class="comment">// 什么都不用做，继续假设 cand 是名人</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的 cand 是排除的最后结果，但不能保证一定是名人</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; n; other++) {</span><br><span class="line">        <span class="keyword">if</span> (cand == other) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 需要保证其他人都认识 cand，且 cand 不认识任何其他人</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">knows</span>(other, cand) || <span class="built_in">knows</span>(cand, other)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cand;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="DIJKSTRA-算法"><a href="#DIJKSTRA-算法" class="headerlink" title="DIJKSTRA 算法"></a><a target="_blank" rel="noopener" href="https://labuladong.github.io/algo/2/20/54/">DIJKSTRA 算法</a></h1><p><code>迪杰斯特拉算法</code>(Dijkstra)是由荷兰计算机<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A7%91%E5%AD%A6%E5%AE%B6/1210114">科学家</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89/2828872">狄克斯特拉</a>于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920">最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800">贪心算法</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5/4006">策略</a>，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220531214329298.png" srcset="/img/loading.gif" lazyload alt="image-20220531214329298" style="zoom: 80%;">

<h3 id="动态演示-DIJKSTRA"><a href="#动态演示-DIJKSTRA" class="headerlink" title="动态演示 DIJKSTRA"></a><a target="_blank" rel="noopener" href="https://visualgo.net/zh/sssp">动态演示 DIJKSTRA</a></h3><h3 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/">743. 网络延迟时间</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=743">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/#">思路</a></p>
<p>难度中等550</p>
<p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p>
<p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/931_example_1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：times = [[1,2,1]], n = 2, k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：times = [[1,2,1]], n = 2, k = 2</span><br><span class="line">输出：-1</span><br></pre></td></tr></tbody></table></figure>

<h4 id="dijkstra-算法实现-贪心"><a href="#dijkstra-算法实现-贪心" class="headerlink" title="dijkstra 算法实现 贪心"></a>dijkstra 算法实现 贪心</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span></span>{</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(N+<span class="number">1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">      dis[K]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">using</span> Pair=pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;<span class="comment">//first是距离，second是目标点</span></span><br><span class="line">      priority_queue&lt;Pair,vector&lt;Pair&gt;,greater&lt;Pair&gt;&gt; pq;</span><br><span class="line">      pq.<span class="built_in">emplace</span>(<span class="number">0</span>,K);<span class="comment">//起点先入队</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="keyword">auto</span> e=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();<span class="comment">//e为连接visited和unvisited的最小边</span></span><br><span class="line">        <span class="keyword">if</span>(e.first&gt;dis[e.second]) <span class="keyword">continue</span>;<span class="comment">//如果e的权比K到e.second还大，就可能缩路径了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times.<span class="built_in">size</span>();i++){</span><br><span class="line">          <span class="keyword">if</span>(times[i][<span class="number">0</span>]==e.second){<span class="comment">//遍历一遍所有以e.second为起点的边，做lax，将rel之后的点入队</span></span><br><span class="line">            <span class="keyword">int</span> v=times[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w=e.first+times[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(dis[v]==<span class="number">-1</span>||dis[v]&gt;w){</span><br><span class="line">              dis[v]=w;</span><br><span class="line">              pq.<span class="built_in">emplace</span>(w,v);</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++){</span><br><span class="line">        <span class="keyword">if</span>(dis[i]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dis[i]);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1514-概率最大的路径"><a href="#1514-概率最大的路径" class="headerlink" title="1514. 概率最大的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/">1514. 概率最大的路径</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=1514">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/#">思路</a></p>
<p>难度中等105</p>
<p>给你一个由 <code>n</code> 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 <code>edges[i] = [a, b]</code> 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code> 。</p>
<p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code> ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p>
<p>如果不存在从 <code>start</code> 到 <code>end</code> 的路径，请 <strong>返回 0</strong> 。只要答案与标准答案的误差不超过 <strong>1e-5</strong> ，就会被视作正确答案。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2</span><br><span class="line">输出：0.30000</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1558_ex3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2</span><br><span class="line">输出：0.00000</span><br><span class="line">解释：节点 0 和 节点 2 之间不存在路径</span><br></pre></td></tr></tbody></table></figure>

<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">double</span>&gt;&amp; succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">      vector&lt;vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;edges.<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="keyword">auto</span>&amp; e = edges[i];</span><br><span class="line">        graph[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(succProb[i], e[<span class="number">1</span>]);</span><br><span class="line">        graph[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(succProb[i], e[<span class="number">0</span>]);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      priority_queue&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">      que.<span class="built_in">emplace</span>(<span class="number">1</span>, start);</span><br><span class="line">      <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">prob</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">      prob[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="keyword">auto</span> [pr, node] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(pr &lt; prob[node]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [prNext, nodeNext] : graph[node]){</span><br><span class="line">          <span class="keyword">if</span>(prob[nodeNext] &lt; prob[node]* prNext){</span><br><span class="line">            prob[nodeNext] = prob[node] * prNext;</span><br><span class="line">            que.<span class="built_in">emplace</span>(prob[nodeNext], nodeNext);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> prob[end];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>


              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="category-chain-item">算法整理</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">#算法总结</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>图论</div>
      <div>https://qianxunslimg.github.io/2022/03/15/tu-lun/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>qianxunslimg</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月15日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/15/qian-zhui-he-chai-fen/" title="前缀和/差分">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前缀和/差分</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/15/wei-yun-suan/" title="位运算">
                        <span class="hidden-mobile">位运算</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
