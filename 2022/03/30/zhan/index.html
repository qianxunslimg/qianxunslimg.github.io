<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/MTMRB7P@G[WVCWEB9W([}FT.png >
    <title>
        qianxunslimgのblog
    </title>
    <meta name="description" content= 欢迎访问我的博客， >
    <meta name="keywords" content= qianxunslimg,blog,job,面试,找工作 >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            栈
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h1><h3 id="剑指-Offer-II-037-小行星碰撞"><a href="#剑指-Offer-II-037-小行星碰撞" class="headerlink" title="剑指 Offer II 037. 小行星碰撞"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/XagZNi/">剑指 Offer II 037. 小行星碰撞</a></h3><p>难度中等24收藏分享切换为英文接收动态反馈英文版讨论区</p>
<p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。</p>
<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs tap">输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下<span class="hljs-number"> 10 </span>。<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 10 </span>永远不会发生碰撞。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入：asteroids = <span class="hljs-comment">[8,-8]</span>
输出：<span class="hljs-comment">[]</span>
解释：8 和 -8 碰撞后，两者都发生爆炸。</code></pre></div>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>情况讨论如下：</p>
<p>直接压入栈的情况：</p>
<div class="code-wrapper"><pre><code class="hljs"> a. 栈空；
 b. 栈顶是负数（向左运动的行星）；
 c. 栈顶与asteroids[i]符号相同（当前行星运动方向一致）
</code></pre></div>
<p>栈顶是正数</p>
<div class="code-wrapper"><pre><code class="hljs"> a.如果asteroids[i]的绝对值小于栈顶，++i；
 b.如果相等，则弹出栈顶元素并 ++i；
 c.如果大于，则弹出栈顶元素，asteroids[i]继续进行一轮判断
     （因为每次循环都有++i操作，故进行--i操作）
</code></pre></div>
<p>最初开始用栈实现，其实用vector就可以实现</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>() || ans.<span class="hljs-built_in">back</span>()&lt;<span class="hljs-number">0</span> || ans.<span class="hljs-built_in">back</span>()*nums[i]&gt;<span class="hljs-number">0</span>)
                ans.<span class="hljs-built_in">push_back</span>(nums[i]);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">back</span>() + nums[i] &lt;= <span class="hljs-number">0</span>){
                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">back</span>() + nums[i] &lt; <span class="hljs-number">0</span>) --i;
                ans.<span class="hljs-built_in">pop_back</span>();
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};

<span class="hljs-comment">//我的笨比解法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">asteroidCollision</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span> </span>{
		vector&lt;<span class="hljs-keyword">int</span>&gt; ans;
		stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
		<span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
			<span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) {
				stk.<span class="hljs-built_in">push</span>(nums[i]);
				<span class="hljs-keyword">continue</span>;
			}
			<span class="hljs-comment">//判断是否需要跳过当前for</span>
			<span class="hljs-comment">//撞出0 跳过当前</span>
			<span class="hljs-keyword">bool</span> jump = <span class="hljs-number">0</span>;
			<span class="hljs-comment">//之前向右 当前向左 会撞</span>
			<span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; <span class="hljs-number">0</span>) {
				<span class="hljs-keyword">int</span> temp = nums[i];
				<span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">int</span> flag = temp + stk.<span class="hljs-built_in">top</span>();
					<span class="hljs-comment">//撞出0 出栈并跳过当前</span>
					<span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) {
						stk.<span class="hljs-built_in">pop</span>();
						jump = <span class="hljs-number">1</span>;
						<span class="hljs-keyword">break</span>;
					}
					<span class="hljs-comment">//更新未进栈的行星 并出栈top</span>
					temp = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(stk.<span class="hljs-built_in">top</span>()), <span class="hljs-built_in">abs</span>(temp)) * flag / <span class="hljs-built_in">abs</span>(flag);
					stk.<span class="hljs-built_in">pop</span>();
				}
				<span class="hljs-keyword">if</span> (jump) {
					<span class="hljs-keyword">continue</span>;
				}
				<span class="hljs-comment">//撞剩下的行星入栈</span>
				stk.<span class="hljs-built_in">push</span>(temp);
			}
			<span class="hljs-keyword">else</span> {
				stk.<span class="hljs-built_in">push</span>(nums[i]);
			}
		}
		<span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) {
			ans.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>());
			stk.<span class="hljs-built_in">pop</span>();
		}
		<span class="hljs-keyword">return</span>{ ans.<span class="hljs-built_in">rbegin</span>(), ans.<span class="hljs-built_in">rend</span>() };
	}
};</code></pre></div>

<h3 id="括号题目"><a href="#括号题目" class="headerlink" title="括号题目"></a><code>括号题目</code></h3><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=22">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/#">思路</a></p>
<p>难度中等2723</p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>
输出：[<span class="hljs-string">"((()))"</span>,<span class="hljs-string">"(()())"</span>,<span class="hljs-string">"(())()"</span>,<span class="hljs-string">"()(())"</span>,<span class="hljs-string">"()()()"</span>]</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>
输出：[<span class="hljs-string">"()"</span>]</code></pre></div>

<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>记录剩余的 左右括号的数目</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    vector&lt;string&gt; ans;
    string path;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
      <span class="hljs-built_in">backtrack</span>(n, n);
      <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>{
      <span class="hljs-keyword">if</span>(left&lt;<span class="hljs-number">0</span> || right&lt;<span class="hljs-number">0</span> || left&gt;right)
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>){
        ans.<span class="hljs-built_in">push_back</span>(path);
        <span class="hljs-keyword">return</span>;
      }
      path+=<span class="hljs-string">'('</span>;
      <span class="hljs-built_in">backtrack</span>(left<span class="hljs-number">-1</span>, right);
      path.<span class="hljs-built_in">pop_back</span>();
      path+=<span class="hljs-string">")"</span>;
      <span class="hljs-built_in">backtrack</span>(left, right<span class="hljs-number">-1</span>);
      path.<span class="hljs-built_in">pop_back</span>();
    }
};</code></pre></div>

<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=20">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/#">思路</a></p>
<p>难度简单3349</p>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"()"</span>
输出：<span class="hljs-literal">true</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"()[]{}"</span>
输出：<span class="hljs-literal">true</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"(]"</span>
输出：<span class="hljs-literal">false</span></code></pre></div>

<p><strong>示例 4：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"([)]"</span>
输出：<span class="hljs-literal">false</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      stack&lt;<span class="hljs-keyword">char</span>&gt; stk;
      unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; mapp{{<span class="hljs-string">'('</span>,<span class="hljs-string">')'</span>},{<span class="hljs-string">'{'</span>,<span class="hljs-string">'}'</span>},{<span class="hljs-string">'['</span>,<span class="hljs-string">']'</span>}};
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
          <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'}'</span> || s[i] == <span class="hljs-string">']'</span> || s[i] == <span class="hljs-string">')'</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
          stk.<span class="hljs-built_in">push</span>(s[i]);
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span>(mapp[stk.<span class="hljs-built_in">top</span>()] == s[i]){
          stk.<span class="hljs-built_in">pop</span>();
        }<span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(s[i]);
      }
      <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();
    }
};</code></pre></div>

<h3 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921. 使括号有效的最少添加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=921">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/#">思路</a></p>
<p>难度中等140</p>
<p>只有满足下面几点之一，括号字符串才是有效的：</p>
<ul>
<li>它是一个空字符串，或者</li>
<li>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</li>
<li>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</li>
</ul>
<p>给定一个括号字符串 <code>s</code> ，移动N次，你就可以在字符串的任何位置插入一个括号。</p>
<ul>
<li>例如，如果 <code>s = "()))"</code> ，你可以插入一个开始括号为 <code>"(()))"</code> 或结束括号为 <code>"())))"</code> 。</li>
</ul>
<p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"())"</span>
输出：<span class="hljs-number">1</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"((("</span>
输出：<span class="hljs-number">3</span></code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 只包含 <code>'('</code> 和 <code>')'</code> 字符。</li>
</ul>
<h4 id="栈解法"><a href="#栈解法" class="headerlink" title="栈解法"></a>栈解法</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>{
      stack&lt;<span class="hljs-keyword">char</span>&gt; stk;
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-comment">//其实for循环里面的ans 记录的需要的左括号的个数</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
          <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'('</span>)
            stk.<span class="hljs-built_in">push</span>(<span class="hljs-string">')'</span>);
          <span class="hljs-keyword">else</span> ans++;
        }<span class="hljs-keyword">else</span> { 
          <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">top</span>() == s[i]){
            stk.<span class="hljs-built_in">pop</span>();
          }<span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">')'</span>)
              stk.<span class="hljs-built_in">push</span>(<span class="hljs-string">'('</span>);
            <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(<span class="hljs-string">')'</span>);
          }
        }
      }
      <span class="hljs-comment">//最后剩下的size是需要的右括号的个数</span>
      ans += stk.<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>{
      <span class="hljs-comment">//need 需要括号的个数</span>
      <span class="hljs-keyword">int</span> needL = <span class="hljs-number">0</span>, needR = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++){
        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'('</span>)
          needR++;
        <span class="hljs-keyword">else</span>{
          needR--;
          <span class="hljs-keyword">if</span>(needR == <span class="hljs-number">-1</span>){
            needR = <span class="hljs-number">0</span>;
            needL++;
          }
        }
      }
      <span class="hljs-keyword">return</span> needL + needR;
    }
};</code></pre></div>

<h3 id="1541-平衡括号字符串的最少插入次数"><a href="#1541-平衡括号字符串的最少插入次数" class="headerlink" title="1541. 平衡括号字符串的最少插入次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">1541. 平衡括号字符串的最少插入次数</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=1541">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/#">思路</a></p>
<p>难度中等48</p>
<p>给你一个括号字符串 <code>s</code> ，它只包含字符 <code>'('</code> 和 <code>')'</code> 。一个括号字符串被称为平衡的当它满足：</p>
<ul>
<li>任何左括号 <code>'('</code> 必须对应两个连续的右括号 <code>'))'</code> 。</li>
<li>左括号 <code>'('</code> 必须在对应的连续两个右括号 <code>'))'</code> 之前。</li>
</ul>
<p>比方说 <code>"())"</code>， <code>"())(())))"</code> 和 <code>"(())())))"</code> 都是平衡的， <code>")()"</code>， <code>"()))"</code> 和 <code>"(()))"</code> 都是不平衡的。</p>
<p>你可以在任意位置插入字符 ‘(‘ 和 ‘)’ 使字符串平衡。</p>
<p>请你返回让 <code>s</code> 平衡的最少插入次数。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">"(()))"</span>
输出：<span class="hljs-number">1</span>
解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 <span class="hljs-string">"(())))"</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"())"</span>
输出：<span class="hljs-number">0</span>
解释：字符串已经平衡了。</code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">"))())("</span>
输出：<span class="hljs-number">3</span>
解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</code></pre></div>

<p><strong>示例 4：</strong></p>
<div class="code-wrapper"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">"(((((("</span>
输出：<span class="hljs-number">12</span>
解释：添加 <span class="hljs-number">12</span> 个 ')' 得到平衡字符串。</code></pre></div>

<p><strong>示例 5：</strong></p>
<div class="code-wrapper"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">")))))))"</span>
输出：<span class="hljs-number">5</span>
解释：在字符串开头添加 <span class="hljs-number">4</span> 个 '(' 并在结尾添加 <span class="hljs-number">1</span> 个 ')' ，字符串变成平衡字符串 <span class="hljs-string">"(((())))))))"</span> 。</code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> 只包含 <code>'('</code> 和 <code>')'</code> 。</li>
</ul>
<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/#">思路</a></p>
<p>难度困难1880</p>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"(()"</span>
输出：<span class="hljs-number">2</span>
解释：最长有效括号子串是 <span class="hljs-string">"()"</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">")()())"</span>
输出：<span class="hljs-number">4</span>
解释：最长有效括号子串是 <span class="hljs-string">"()()"</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">""</span>
输出：<span class="hljs-number">0</span></code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>
</ul>
<h3 id="解码-波兰-四则运算"><a href="#解码-波兰-四则运算" class="headerlink" title="解码/波兰/四则运算"></a><code>解码/波兰/四则运算</code></h3><h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>难度中等1202</p>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"3[a]2[bc]"</span>
输出：<span class="hljs-string">"aaabcbc"</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"3[a2[c]]"</span>
输出：<span class="hljs-string">"accaccacc"</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"2[abc]3[cd]ef"</span>
输出：<span class="hljs-string">"abcabccdcdcdef"</span></code></pre></div>

<p><strong>示例 4：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"abc3[cd]xyz"</span>
输出：<span class="hljs-string">"abccdcdcdxyz"</span></code></pre></div>

<h4 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>{
      stack&lt;<span class="hljs-keyword">int</span>&gt; num_stk;     <span class="hljs-comment">//数字栈</span>
      stack&lt;string&gt; str_stk;  <span class="hljs-comment">//字符串栈</span>
      string str;             <span class="hljs-comment">//当前正在累积的字符串</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) {  <span class="hljs-comment">//遇到数字</span>
          <span class="hljs-keyword">int</span> n = s[i] - <span class="hljs-string">'0'</span>;
          <span class="hljs-comment">//数字可能有多位</span>
          <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(s[++i])) n = <span class="hljs-number">10</span> * n + s[i] - <span class="hljs-string">'0'</span>;
          num_stk.<span class="hljs-built_in">push</span>(n);  <span class="hljs-comment">//加入数字栈</span>
          --i;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'['</span>) {
          str_stk.<span class="hljs-built_in">push</span>(str);  <span class="hljs-comment">//将当前累积的字符串入栈</span>
          str = <span class="hljs-string">""</span>;           <span class="hljs-comment">//开始记录新的一段字符串</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">']'</span>) {
          string tmp;
          <span class="hljs-comment">//将当前字符串按数字栈栈顶元素为倍数进行扩展</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_stk.<span class="hljs-built_in">top</span>(); i++) {
            tmp += str;
          }
          str = tmp;
          num_stk.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//数字栈栈顶元素弹出</span>
          <span class="hljs-comment">//字符串栈栈顶元素弹出来并与当前字符串拼接，作为新的当前正在累积的字符串</span>
          str = str_stk.<span class="hljs-built_in">top</span>() + str;
          str_stk.<span class="hljs-built_in">pop</span>();
        } <span class="hljs-keyword">else</span>
          str += s[i];  <span class="hljs-comment">//当前字符串继续累积</span>
      }
      <span class="hljs-keyword">return</span> str;
    }
};</code></pre></div>



<h3 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=224">labuladong 题解</a></p>
<p>难度困难782</p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"1 + 1"</span>
输出：<span class="hljs-number">2</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">" 2-1 + 2 "</span>
输出：<span class="hljs-number">3</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs subunit">输入：s = "(1+(4<span class="hljs-string">+5</span><span class="hljs-string">+2</span>)<span class="hljs-string">-3</span>)+(6<span class="hljs-string">+8</span>)"
输出：23</code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
<li>‘+’ 不能用作一元运算(例如， “+1” 和 <code>"+(2 + 3)"</code> 无效)</li>
<li>‘-‘ 可以用作一元运算(即 “-1” 和 <code>"-(2 + 3)"</code> 是有效的)</li>
<li>输入中不存在两个连续的操作符</li>
<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>
</ul>
<h3 id="带括号的四则运算-字节"><a href="#带括号的四则运算-字节" class="headerlink" title="带括号的四则运算 字节"></a><code>带括号的四则运算 字节</code></h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; pr{{<span class="hljs-string">'+'</span>, <span class="hljs-number">1</span>}, {<span class="hljs-string">'-'</span>, <span class="hljs-number">1</span>}, {<span class="hljs-string">'*'</span>, <span class="hljs-number">2</span>}, {<span class="hljs-string">'/'</span>, <span class="hljs-number">2</span>}};
    stack&lt;<span class="hljs-keyword">int</span>&gt; nums;
    stack&lt;<span class="hljs-keyword">char</span>&gt; op;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">int</span> b = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">int</span> a = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">int</span> c = op.<span class="hljs-built_in">top</span>(); op.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">int</span> res;
        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'+'</span>) res = a + b;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) res = a - b;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'*'</span>) res = a * b;
        <span class="hljs-keyword">else</span> res = a / b;
        nums.<span class="hljs-built_in">push</span>(res);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replace</span><span class="hljs-params">(string &amp;s, string a, string b)</span> </span>{
        <span class="hljs-keyword">int</span> pos = s.<span class="hljs-built_in">find</span>(a), m = a.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">while</span> (pos != <span class="hljs-number">-1</span>) {
            s.<span class="hljs-built_in">replace</span>(pos, m, b);
            pos = s.<span class="hljs-built_in">find</span>(a);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>{
        <span class="hljs-comment">// 处理 s 使之合法</span>
        <span class="hljs-comment">// 去空格</span>
        <span class="hljs-built_in">replace</span>(s, <span class="hljs-string">" "</span>, <span class="hljs-string">""</span>);
        <span class="hljs-comment">// (- 替换为 (0-</span>
        <span class="hljs-built_in">replace</span>(s, <span class="hljs-string">"(-"</span>, <span class="hljs-string">"(0-"</span>);
        <span class="hljs-comment">// (+ 替换为 (0+</span>
        <span class="hljs-built_in">replace</span>(s, <span class="hljs-string">"(+"</span>, <span class="hljs-string">"(0+"</span>);
        <span class="hljs-comment">// 在 nums 中先放个 0 预防开始的符号</span>
        nums.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++ i) {
            <span class="hljs-keyword">char</span> c = s[i];
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) {
                <span class="hljs-keyword">int</span> j = i; <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[j]))
                    num = num * <span class="hljs-number">10</span> + (s[j++] - <span class="hljs-string">'0'</span>);
                i = j - <span class="hljs-number">1</span>;
                nums.<span class="hljs-built_in">push</span>(num);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) {
                op.<span class="hljs-built_in">push</span>(<span class="hljs-string">'('</span>);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) {
                <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">'('</span>) <span class="hljs-built_in">eval</span>();
                op.<span class="hljs-built_in">pop</span>();
            } <span class="hljs-keyword">else</span> { 
                <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">'('</span> &amp;&amp; pr[op.<span class="hljs-built_in">top</span>()] &gt;= pr[c]) <span class="hljs-built_in">eval</span>();
                op.<span class="hljs-built_in">push</span>(c);
            }
        }
        <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();
        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();
    }
};</code></pre></div>





<h3 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.github.io/article/?qno=227">labuladong 题解</a></p>
<p>难度中等585</p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-231, 231 - 1]</code> 的范围内。</p>
<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"3+2*2"</span>
输出：<span class="hljs-number">7</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">" 3/2 "</span>
输出：<span class="hljs-number">1</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">" 3+5 / 2 "</span>
输出：<span class="hljs-number">5</span></code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>
<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li>
<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>{
    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">char</span> sign = <span class="hljs-string">'+'</span>;
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;
    stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) d = d * <span class="hljs-number">10</span> - <span class="hljs-string">'0'</span> + s[i];  <span class="hljs-comment">//先做减法 避免傻逼溢出</span>
      <span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="hljs-string">' '</span>) || i == n - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (sign == <span class="hljs-string">'+'</span>)
          stk.<span class="hljs-built_in">push</span>(d);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sign == <span class="hljs-string">'-'</span>)
          stk.<span class="hljs-built_in">push</span>(-d);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sign == <span class="hljs-string">'*'</span> || sign == <span class="hljs-string">'/'</span>) {
          <span class="hljs-keyword">int</span> tmp = sign == <span class="hljs-string">'*'</span> ? stk.<span class="hljs-built_in">top</span>() * d : stk.<span class="hljs-built_in">top</span>() / d;
          stk.<span class="hljs-built_in">pop</span>();
          stk.<span class="hljs-built_in">push</span>(tmp);
        }
        sign = s[i];  <span class="hljs-comment">//保存当前符号</span>
        d = <span class="hljs-number">0</span>;
      }
    }
    <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) {
      ans += stk.<span class="hljs-built_in">top</span>();
      stk.<span class="hljs-built_in">pop</span>();
    }
    <span class="hljs-keyword">return</span> ans;
  }
};</code></pre></div>



<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/#">思路</a></p>
<p>难度中等559</p>
<p>根据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p>
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">"2"</span>,<span class="hljs-string">"1"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"*"</span>]
输出：<span class="hljs-number">9</span>
解释：该算式转化为常见的中缀算术表达式为：((<span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) = <span class="hljs-number">9</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">tokens</span> = [<span class="hljs-string">"4"</span>,<span class="hljs-string">"13"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"/"</span>,<span class="hljs-string">"+"</span>]
输出：<span class="hljs-number">6</span>
解释：该算式转化为常见的中缀算术表达式为：(<span class="hljs-number">4</span> + (<span class="hljs-number">13</span> / <span class="hljs-number">5</span>)) = <span class="hljs-number">6</span></code></pre></div>

<p><strong>示例 3：</strong></p>
<div class="code-wrapper"><pre><code class="hljs excel">输入：tokens = [<span class="hljs-string">"10"</span>,<span class="hljs-string">"6"</span>,<span class="hljs-string">"9"</span>,<span class="hljs-string">"3"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"-11"</span>,<span class="hljs-string">"*"</span>,<span class="hljs-string">"/"</span>,<span class="hljs-string">"*"</span>,<span class="hljs-string">"17"</span>,<span class="hljs-string">"+"</span>,<span class="hljs-string">"5"</span>,<span class="hljs-string">"+"</span>]
输出：<span class="hljs-number">22</span>
解释：该算式转化为常见的中缀算术表达式为：
  ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / ((<span class="hljs-number">9</span> + <span class="hljs-number">3</span>) * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span>
= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / (<span class="hljs-number">12</span> * -<span class="hljs-number">11</span>))) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span>
= ((<span class="hljs-number">10</span> * (<span class="hljs-number">6</span> / -<span class="hljs-number">132</span>)) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span>
= ((<span class="hljs-number">10</span> * <span class="hljs-number">0</span>) + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span>
= (<span class="hljs-number">0</span> + <span class="hljs-number">17</span>) + <span class="hljs-number">5</span>
= <span class="hljs-number">17</span> + <span class="hljs-number">5</span>
= <span class="hljs-number">22</span></code></pre></div>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>"+"</code>、<code>"-"</code>、<code>"*"</code> 或 <code>"/"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<p>背</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>{
      <span class="hljs-keyword">int</span> n = tokens.<span class="hljs-built_in">size</span>();
      stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
      <span class="hljs-keyword">int</span> secondVal;
      <span class="hljs-keyword">int</span> firstVal;
      <span class="hljs-keyword">int</span> nowVal;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
        <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">"*"</span> || tokens[i] == <span class="hljs-string">"/"</span> || tokens[i] == <span class="hljs-string">"+"</span> || tokens[i] == <span class="hljs-string">"-"</span>){
          secondVal = stk.<span class="hljs-built_in">top</span>();
          stk.<span class="hljs-built_in">pop</span>();
          firstVal = stk.<span class="hljs-built_in">top</span>();
          stk.<span class="hljs-built_in">pop</span>();  
          <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">"*"</span>)
            nowVal = firstVal * secondVal;
          <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">"/"</span>)
            nowVal = firstVal / secondVal;
          <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">"+"</span>)
            nowVal = firstVal + secondVal;
          <span class="hljs-keyword">if</span>(tokens[i] == <span class="hljs-string">"-"</span>)
            nowVal = firstVal - secondVal;    
          stk.<span class="hljs-built_in">push</span>(nowVal);  
        }
        <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));
      }
      <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();
    }
};</code></pre></div>



<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。</p>
<p>时间复杂度为$O(n)$。</p>
<p>例如本题其实就是找找到一个元素右边第一个比自己大的元素。</p>
<p>此时就应该想到用单调栈了。</p>
<p>那么单调栈的原理是什么呢？为什么时间复杂度是$O(n)$就可以找到每一个元素的右边第一个比它大的元素位置呢？</p>
<p>单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素的元素，优点是只需要遍历一次。</p>
<p>在使用单调栈的时候首先要明确如下几点：</p>
<ol>
<li>单调栈里存放的元素是什么？</li>
</ol>
<p>单调栈里只需要存放元素的<code>下标i</code>就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p>
<ol start="2">
<li>单调栈里元素是递增呢？ 还是递减呢？</li>
</ol>
<p><strong>注意一下顺序为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p>
<p>这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。</p>
<p>使用单调栈主要有三个判断条件。</p>
<ul>
<li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ul>
<p>==<u>约定： 递增栈为头到底递增</u>==</p>
<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/?qno=739">labuladong 题解</a></p>
<p>难度中等1081收藏分享切换为英文接收动态反馈</p>
<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">73,74,75,71</span>,<span class="hljs-number">69,72,76,73</span>]
输出: [<span class="hljs-number">1,1,4,2</span>,<span class="hljs-number">1,1,0,0</span>]</code></pre></div>

<p><strong>示例 2:</strong></p>
<div class="code-wrapper"><pre><code class="hljs dns">输入: temperatures = [<span class="hljs-number">30,40,50,60</span>]
输出: [<span class="hljs-number">1,1,1,0</span>]</code></pre></div>

<p><strong>示例 3:</strong></p>
<div class="code-wrapper"><pre><code class="hljs inform7">输入: temperatures = <span class="hljs-comment">[30,60,90]</span>
输出: <span class="hljs-comment">[1,1,0]</span></code></pre></div>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html#%E6%80%9D%E8%B7%AF">思路</a></h4><p>递增单调栈  （元素&lt;=栈顶元素时 入栈）</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-comment">//0特判</span>
            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
                stk.<span class="hljs-built_in">push</span>(i);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">//元素&lt;=栈顶元素时 入栈</span>
            <span class="hljs-keyword">if</span>(nums[i]&lt;=nums[stk.<span class="hljs-built_in">top</span>()]){
                stk.<span class="hljs-built_in">push</span>(i);
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[stk.<span class="hljs-built_in">top</span>()]&lt;nums[i]){
                    <span class="hljs-keyword">int</span> now = stk.<span class="hljs-built_in">top</span>();
                    stk.<span class="hljs-built_in">pop</span>();
                    ans[now] = (i - now);                    
                }
                stk.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 不要忘了入栈</span>
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/?qno=496">labuladong 题解</a></p>
<p>难度简单676英文版讨论区</p>
<p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：nums1 = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>].
输出：[<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]
解释：nums1 中每个值的下一个更大元素如下所述：
- <span class="hljs-number">4</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。
- <span class="hljs-number">1</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。下一个更大元素是 <span class="hljs-number">3</span> 。
- <span class="hljs-number">2</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs prolog">输入：nums1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].
输出：[<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]
解释：nums1 中每个值的下一个更大元素如下所述：
- <span class="hljs-number">2</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。下一个更大元素是 <span class="hljs-number">3</span> 。
- <span class="hljs-number">4</span> ，用加粗斜体标识，nums2 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]。不存在下一个更大元素，所以答案是 <span class="hljs-number">-1</span> 。</code></pre></div>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这道题虽然是简单题 但是难度比每日温度大</li>
<li>用一个哈希记录nums1，再对nums2使用单调栈</li>
</ol>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
        <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m, <span class="hljs-number">-1</span>)</span></span>;
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mapp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;m; i++)
            mapp[nums1[i]] = i;
        <span class="hljs-keyword">int</span> n = nums2.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
                stk.<span class="hljs-built_in">push</span>(i);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span>(nums2[stk.<span class="hljs-built_in">top</span>()]&gt;= nums2[i])
                stk.<span class="hljs-built_in">push</span>(i);
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums2[stk.<span class="hljs-built_in">top</span>()] &lt; nums2[i]){
                    <span class="hljs-keyword">int</span> nowI = stk.<span class="hljs-built_in">top</span>();
                    <span class="hljs-comment">//判断是否是nums1中的元素</span>
                    <span class="hljs-keyword">if</span>(mapp.<span class="hljs-built_in">count</span>(nums2[nowI])){
                        <span class="hljs-keyword">int</span> index = mapp[nums2[nowI]];
                        ans[index] = nums2[i];
                    }
                    stk.<span class="hljs-built_in">pop</span>();
                }
                stk.<span class="hljs-built_in">push</span>(i);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/?qno=503">labuladong 题解</a></p>
<p>难度中等586英文版讨论区</p>
<p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p>
<p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p>
<p><strong>示例 1:</strong></p>
<div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,2,1]</span>
<span class="hljs-section">输出: [2,-1,2]</span>
<span class="hljs-section">解释: 第一个 1 的下一个更大的数是 2；</span>
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre></div>

<p><strong>示例 2:</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[1,2,3,4,3]</span>
输出: <span class="hljs-string">[2,3,4,-1,4]</span></code></pre></div>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>再拼接一个数组 对二倍长度的数组进行统计 最后将结果resize为原大小</li>
<li>循环起来，遍历的时候遍历二倍大小 用%n来进行循环</li>
</ol>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="二倍数组拼接"><a href="#二倍数组拼接" class="headerlink" title="二倍数组拼接"></a>二倍数组拼接</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        n*=<span class="hljs-number">2</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums1</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;
        nums.<span class="hljs-built_in">insert</span>(nums.<span class="hljs-built_in">end</span>(), nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
                stk.<span class="hljs-built_in">push</span>(i);
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-keyword">if</span>(nums[stk.<span class="hljs-built_in">top</span>()]&gt;=nums[i]){
                stk.<span class="hljs-built_in">push</span>(i);
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[stk.<span class="hljs-built_in">top</span>()]&lt;nums[i]){
                    ans[stk.<span class="hljs-built_in">top</span>()] = nums[i];
                    stk.<span class="hljs-built_in">pop</span>();
                }
                stk.<span class="hljs-built_in">push</span>(i);
            }
        }
        ans.<span class="hljs-built_in">resize</span>(n/<span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h5 id="二倍循环-n"><a href="#二倍循环-n" class="headerlink" title="二倍循环%n"></a>二倍循环%n</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n*<span class="hljs-number">2</span>; i++){
            <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>()){
                stk.<span class="hljs-built_in">push</span>(i);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[stk.<span class="hljs-built_in">top</span>()]&lt;nums[i%n]){
                ans[stk.<span class="hljs-built_in">top</span>()] = nums[i%n];
                stk.<span class="hljs-built_in">pop</span>();
            }
            stk.<span class="hljs-built_in">push</span>(i%n);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>

<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/article/?qno=42">labuladong 题解</a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/#">思路</a></p>
<p>难度困难3289英文版讨论区</p>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rainwatertrap.png" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]
输出：<span class="hljs-number">6</span>
解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。</code></pre></div>

<p><strong>示例 2：</strong></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span>
输出：<span class="hljs-number">9</span></code></pre></div>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>On2暴力 </li>
<li>dp 多次遍历 保存最值</li>
<li>最小栈</li>
</ol>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><h5 id="On2暴力"><a href="#On2暴力" class="headerlink" title="On2暴力"></a>On2暴力</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//暴力超时</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
        <span class="hljs-keyword">int</span> n = height.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">int</span> rHeight = height[i];
            <span class="hljs-keyword">int</span> lHeight = height[i];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = i+<span class="hljs-number">1</span>; r&lt;n; r++){
                <span class="hljs-keyword">if</span>(height[r]&gt;rHeight) rHeight = height[r];
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = i<span class="hljs-number">-1</span>; l&gt;=<span class="hljs-number">0</span>; l--){
                <span class="hljs-keyword">if</span>(height[l]&gt;lHeight) lHeight = height[l];
            }
            <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">min</span>(lHeight, rHeight) - height[i];
            <span class="hljs-keyword">if</span>(h&gt;<span class="hljs-number">0</span>) sum+=h;
        }
        <span class="hljs-keyword">return</span> sum;
    }
};</code></pre></div>

<h5 id="dp-多次遍历-保存最值"><a href="#dp-多次遍历-保存最值" class="headerlink" title="dp 多次遍历 保存最值"></a>dp 多次遍历 保存最值</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// dp解法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
        <span class="hljs-keyword">int</span> n = height.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftH</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightH</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
        leftH[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];
        rightH[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            leftH[i] = <span class="hljs-built_in">max</span>(height[i], leftH[i<span class="hljs-number">-1</span>]);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n<span class="hljs-number">-2</span>; i&gt;=<span class="hljs-number">0</span>; i--){
            rightH[i] = <span class="hljs-built_in">max</span>(height[i], rightH[i+<span class="hljs-number">1</span>]);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++){
            <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">min</span>(leftH[i], rightH[i]) - height[i];
            <span class="hljs-keyword">if</span>(h&gt;<span class="hljs-number">0</span>) sum+=h;
        }
        <span class="hljs-keyword">return</span> sum;
    }
};</code></pre></div>

<h5 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//最小栈</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
        <span class="hljs-keyword">int</span> n = height.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;n; i++){
            <span class="hljs-keyword">if</span>(height[i]&lt;height[stk.<span class="hljs-built_in">top</span>()])
                stk.<span class="hljs-built_in">push</span>(i);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(height[i] == height[stk.<span class="hljs-built_in">top</span>()]){
                stk.<span class="hljs-built_in">pop</span>();
                stk.<span class="hljs-built_in">push</span>(i);
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-comment">//每个坑坑洼洼的地方计算一次</span>
                <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i]&gt;height[stk.<span class="hljs-built_in">top</span>()]){
                    <span class="hljs-keyword">int</span> mid = stk.<span class="hljs-built_in">top</span>();
                    stk.<span class="hljs-built_in">pop</span>();
                    <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>()){
                        <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">min</span>(height[stk.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];
                        <span class="hljs-keyword">int</span> w = i - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>;
                        sum += h*w;
                    }
                }
                stk.<span class="hljs-built_in">push</span>(i);
            }
        }
        <span class="hljs-keyword">return</span> sum;
    }
};</code></pre></div>

<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><p>难度困难1849</p>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram.jpg" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span>
输出：<span class="hljs-number">10</span>
解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span></code></pre></div>

<p><strong>示例 2：</strong></p>
<p><img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram-1.jpg" alt="img"></p>
<div class="code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">输入： heights </span>=<span class="hljs-string"> [2,4]</span>
<span class="hljs-string">输出： 4</span></code></pre></div>

<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol>
<li><p>动态规划</p>
<p>本题动态规划的写法整体思路和<a target="_blank" rel="noopener" href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42. 接雨水 (opens new window)</a>是一致的，但要比<a target="_blank" rel="noopener" href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42. 接雨水 (opens new window)</a>难一些。难就难在本题要记录记录每个柱子 左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。所以需要循环查找，也就是下面在寻找的过程中使用了while</p>
</li>
<li><p>单调栈</p>
<p>本地单调栈的解法和接雨水的题目是遥相呼应的。</p>
<p>为什么这么说呢，<a target="_blank" rel="noopener" href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42. 接雨水 (opens new window)</a>是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。</p>
<p><strong>这里就涉及到了单调栈很重要的性质，就是单调栈里的顺序，是从小到大还是从大到小</strong>。</p>
<p>在题解<a target="_blank" rel="noopener" href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42. 接雨水 (opens new window)</a>中我讲解了接雨水的单调栈从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。</p>
<p>那么因为本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！</p>
<p>我来举一个例子，如图：</p>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20210223155303971.jpg" alt="84.柱状图中最大的矩形" style="zoom:50%;">

<p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p>
<p>所以本题单调栈的顺序正好与接雨水反过来。</p>
<p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p>
<p>理解这一点，对单调栈就掌握的比较到位了。</p>
<p>除了栈内元素顺序和接雨水不同，剩下的逻辑就都差不多了，在题解<a target="_blank" rel="noopener" href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html">42. 接雨水 (opens new window)</a>我已经对单调栈的各个方面做了详细讲解，这里就不赘述了。</p>
<p>剩下就是分析清楚如下三种情况：</p>
<ul>
<li>情况一：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况</li>
<li>情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况</li>
<li>情况三：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况</li>
</ul>
</li>
</ol>
<img src="https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220331164646464.png" alt="image-20220331164646464" style="zoom: 67%;">

<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">minLeftIndex</span><span class="hljs-params">(heights.size())</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">minRightIndex</span><span class="hljs-params">(heights.size())</span></span>;
        <span class="hljs-keyword">int</span> size = heights.<span class="hljs-built_in">size</span>();

        <span class="hljs-comment">// 记录每个柱子 左边第一个小于该柱子的下标</span>
        minLeftIndex[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 注意这里初始化，防止下面while死循环</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) {
            <span class="hljs-keyword">int</span> t = i - <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 这里不是用if，而是不断向左寻找的过程</span>
            <span class="hljs-keyword">while</span> (t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
        <span class="hljs-comment">// 记录每个柱子 右边第一个小于该柱子的下标</span>
        minRightIndex[size - <span class="hljs-number">1</span>] = size; <span class="hljs-comment">// 注意这里初始化，防止下面while死循环</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">int</span> t = i + <span class="hljs-number">1</span>;
            <span class="hljs-comment">// 这里不是用if，而是不断向右寻找的过程</span>
            <span class="hljs-keyword">while</span> (t &lt; size &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];
            minRightIndex[i] = t;
        }
        <span class="hljs-comment">// 求和</span>
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
            <span class="hljs-keyword">int</span> sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - <span class="hljs-number">1</span>);
            result = <span class="hljs-built_in">max</span>(sum, result);
        }
        <span class="hljs-keyword">return</span> result;
    }
};</code></pre></div>

<h5 id="单调栈-略微背一下吧"><a href="#单调栈-略微背一下吧" class="headerlink" title="单调栈  略微背一下吧"></a>单调栈  略微背一下吧</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);
        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
        stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;heights.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span>(heights[i]&gt;heights[stk.<span class="hljs-built_in">top</span>()])
                stk.<span class="hljs-built_in">push</span>(i);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heights[i] == heights[stk.<span class="hljs-built_in">top</span>()]){
                stk.<span class="hljs-built_in">pop</span>();
                stk.<span class="hljs-built_in">push</span>(i);
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">while</span>(heights[i] &lt; heights[stk.<span class="hljs-built_in">top</span>()]){
                    <span class="hljs-keyword">int</span> mid = stk.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//当前矩形高的位置</span>
                    stk.<span class="hljs-built_in">pop</span>();
                    <span class="hljs-keyword">int</span> left = stk.<span class="hljs-built_in">top</span>();
                    <span class="hljs-keyword">int</span> right = i;  <span class="hljs-comment">//记录当前值以计算宽</span>
                    <span class="hljs-keyword">int</span> w = right - <span class="hljs-number">1</span> - left;
                    <span class="hljs-keyword">int</span> h = heights[mid];
                    <span class="hljs-comment">//right - 1为右边界 i-1</span>
                    <span class="hljs-comment">//left为左边界 当前栈顶index</span>
                    ans = <span class="hljs-built_in">max</span>(ans, w*h);
                }
                stk.<span class="hljs-built_in">push</span>(i);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};</code></pre></div>


    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: qianxunslimg | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
