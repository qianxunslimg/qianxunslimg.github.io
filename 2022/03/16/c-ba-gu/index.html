<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>c++面试 | qianxunslimgのblog</title><meta name="robots" content="noindex"><meta name="keywords" content="面试"><meta name="author" content="qianxunslimg"><meta name="copyright" content="qianxunslimg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.   语言1.1.  C++和C的区别设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言 语法上： C++具有封装、继承和多态三种特性 C++相比C，增加多许多类型安全的功能，比如强制类型转换 C++支持范式编程，比如模板类、函数模板等 c++更安全 （1）操作符new返回的指针类型严格与对象匹配，而不是void； （2）C中很多以void为参数的函数可以改写为C++模板函数">
<meta property="og:type" content="article">
<meta property="og:title" content="c++面试">
<meta property="og:url" content="http://example.com/2022/03/16/c-ba-gu/index.html">
<meta property="og:site_name" content="qianxunslimgのblog">
<meta property="og:description" content="1.   语言1.1.  C++和C的区别设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言 语法上： C++具有封装、继承和多态三种特性 C++相比C，增加多许多类型安全的功能，比如强制类型转换 C++支持范式编程，比如模板类、函数模板等 c++更安全 （1）操作符new返回的指针类型严格与对象匹配，而不是void； （2）C中很多以void为参数的函数可以改写为C++模板函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/4.jpg">
<meta property="article:published_time" content="2022-03-16T01:46:00.000Z">
<meta property="article:modified_time" content="2022-03-16T13:48:25.539Z">
<meta property="article:author" content="qianxunslimg">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/4.jpg"><link rel="shortcut icon" href="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png"><link rel="canonical" href="http://example.com/2022/03/16/c-ba-gu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c++面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-16 21:48:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qianxunslimgのblog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c++面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-16T01:46:00.000Z" title="发表于 2022-03-16 09:46:00">2022-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-16T13:48:25.539Z" title="更新于 2022-03-16 21:48:25">2022-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>118分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-语言"><a href="#1-语言" class="headerlink" title="1.   语言"></a>1.   语言</h1><h2 id="1-1-C-和C的区别"><a href="#1-1-C-和C的区别" class="headerlink" title="1.1.  C++和C的区别"></a>1.1.  C++和C的区别</h2><p><strong>设计思想上：</strong></p>
<p>C++是<code>面向对象</code>的语言，而C是<code>面向过程</code>的结构化编程语言</p>
<p><strong>语法上：</strong></p>
<p>C++具有<code>封装、继承和多态</code>三种特性</p>
<p>C++相比C，增加多许多类型<code>安全</code>的功能，比如强制类型转换</p>
<p>C++支持<code>范式编程</code>，比如模板类、函数模板等</p>
<p><strong>c++更安全</strong></p>
<p>（1）操作符<code>new</code>返回的指针类型严格与对象匹配，而不是void；</p>
<p>（2）C中很多以void为参数的函数可以改写为C++模板函数，而<code>模板是支持类型检查</code>的；</p>
<p>（3）引入<code>const关键字</code>代替#define constants，它是有<strong>类型、有作用域</strong>的，而#define constants只是简单的<code>文本替换</code>；</p>
<p>（4）一些<code>#define宏可被改写为inline函数</code>，结合函数的<code>重载</code>，可在<code>类型安全</code>的前提下<code>支持多种类型</code>，当然改写为模板也能保证类型安全</p>
<p>（5）C++提供了<code>dynamic_cast关键字，使得转换过程更加安全</code>，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<h2 id="1-2-面向过程和面向对象的区别"><a href="#1-2-面向过程和面向对象的区别" class="headerlink" title="1.2.  面向过程和面向对象的区别"></a>1.2.  面向过程和面向对象的区别</h2><p>==<strong>面向过程</strong>==</p>
<p>优点：<code>性能比面向对象高</code>，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：<code>没有</code>面向对象<code>易维护、易复用、易扩展</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20220226100811279-1163623030.png" alt="img"></p>
<p>==<strong>面向对象</strong>==</p>
<p>优点：<code>易维护、易复用、易扩展</code>，由于面向对象有封装、继承、多态性的特性，可以设计出<code>低耦合</code>的系统，使<code>系统 更加灵活、更加易于维护</code></p>
<p>缺点：<code>性能</code>比面向过程<code>低</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20220226100811278-1076991646.png" alt="img"></p>
<h2 id="1-3-面向对象的六大原则"><a href="#1-3-面向对象的六大原则" class="headerlink" title="1.3.  面向对象的六大原则"></a>1.3.  面向对象的六大原则</h2><p>1.<code>单一职责</code>原则：<code>就一个类而言，应该仅有一个引起它发生变化的原因</code></p>
<p>如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱这个或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，这种高耦合会导致意想不到的变化</p>
<p>2.<code>开放封闭</code>原则:软件实体(类，模块，函数等等)应该<code>可以扩展</code>，<code>但是不能修改</code></p>
<p>面对需求的时候，对程序的改动是通过增加新的代码来完成的，而不是通过对原代码的改变来完成，对于原代码的改变很麻烦，可能会导致意想不到的错误</p>
<p><code>开放封闭原则是面向对象设计的核心所在</code>，遵循这个原则，实现了可维护，可扩展，可复用，灵活性好，开发人员应该进队程序中呈现出频繁变化的那些部分作出抽象，但是也不能可以地对每一个部分进行抽象，拒绝不成熟的抽象一样很重要</p>
<p>个人理解：简单工厂模式并不是属于23中设计模式之一，主要就是因为简单工厂模式不符合开放封闭的原则，在类里面增加switch…case语句，当有新的功能或者是类的时候，就要修改该工厂类，代码的可维护性减低了</p>
<p>3.<code>里氏代换</code>原则：<code>子类型必须能够替换掉他们的父类型</code></p>
<p>只有当子类可以替换到父类，软件单位的功能不受到影响的时候，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为</p>
<p>如果没有里氏代换原则，我们在开发的时候如果改变了子类的行为，同时对父类产生了影响，这样你要修改子类，也就必须要修改父类了。</p>
<p>4.<code>依赖倒转</code>原则：也叫依赖倒置原则，其内容如下：</p>
<p>A：高层模块不应该依赖底层模块，<code>两个都应该抽象</code></p>
<p>B：抽象不应该依赖细节，<code>细节应该依赖抽象</code></p>
<p>倒转，假如用户的需求需要改变，软件开发的时候你用的是db2数据库，但是最后要改为mysql数据库，由于高层的模块依赖的是底层的模块，这就使得底层模块也要做修改。但是如果高层模块依赖的是接口或者是抽象类的话，因为接口和抽象类是不变的，所以如果你要更改数据库的话，就不怕出现混乱，A和B两个说的都是这样的意思。因为依赖的是抽象类或者接口，有里氏代换规则可以知道，子类的变化对于父类造不成影响。</p>
<p>针对上面的例子，我们可以做一个抽象的数据库的类，让db2继承这个抽象类，加入现在要换为mysql数据库，只要让mysql去继承这个类就可以，不管用哪个数据库，我们都建立的是抽象数据类的引用，用它去指向你要访问的类就ok了</p>
<p>5.<code>迪米特</code>法则：如果两个类之间不必发生彼此直接通信，那么这两个类就不应当发生直接的相互引用。如果其中一个类需要调用另一个类的某个方法的话，可以<code>通过第三者转发这个调用</code></p>
<p>对于这个原则，我是这样理解的，两个类之间相互知道了解，就是将一个类直接暴露给了另外一个类，这样子违反了信息的隐藏。如果多个类之间需要两两发生调用的话，那么就需要调用者知道被调用这的全部信息，这是我们可以通过一个中介来转发需要通信的两个类之间的请求，所有的类，只需要将自己暴露给中介就可以了，不需要给被调用者，这样做简化了代码，这也就是设计模式中的中介者模式</p>
<p>这样<code>降低了类与类之间的耦合性</code>，符合我们提倡的低耦合的观点，耦合性越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及</p>
<p>6、<code>接口隔离</code>原则</p>
<p>表明客户端不应该被强迫实现一些他们不会使用的接口，应该把接口中方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是<code>使用多个专门的接口比使用单个接口好很多</code>。</p>
<p>该原则观点如下：<br>1）一个类对另外一个类的依赖性应当是建立在最小的接口上</p>
<p>2）客户端程序不应该依赖它不需要的接口方法。</p>
<h2 id="1-4-C-中，为什么可以函数重载，实现原理"><a href="#1-4-C-中，为什么可以函数重载，实现原理" class="headerlink" title="1.4.  C++中，为什么可以函数重载，实现原理"></a>1.4.  C++中，为什么可以函数重载，实现原理</h2><p><code>c++函数重载的原理:</code></p>
<p>编译器在编译.cpp文件中当前使用的作用域里的同名函数时，根据函数形参的类型和顺序会对函数进行重命名（不同的编译器在编译时对函数的重命名标准不一样）但是总的来说，他们都把文件中的同一个函数名进行了重命名；</p>
<p><strong>在vs编译器中：</strong></p>
<p>根据返回值类型（不起决定性作用）+形参类型和顺序（起决定性作用）的规则重命名并记录在map文件中。</p>
<p>在<strong>linux g++</strong> <strong>编译器中：</strong></p>
<p>根据<code>函数名字的字符数</code>+<code>形参类型和顺序</code>的规则重命名记录在符号表中；从而产生不同的函数名，当外面的函数被调用时，便是根据这个记录的结果去寻找符合要求的函数名,进行调用；</p>
<p><strong>为什么c语言不能实现函数重载</strong></p>
<p><strong>编译器在编译</strong>.c文件时，<code>只会给函数进行简单的重命名</code>；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错；</p>
<h2 id="1-5-C-11有哪些新特性？"><a href="#1-5-C-11有哪些新特性？" class="headerlink" title="1.5.  C++11有哪些新特性？"></a>1.5.  C++11有哪些新特性？</h2><p>C++11 最常用的新特性如下：</p>
<p><code>lambda表达式</code>：</p>
<p><code>auto关键字</code>：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导</p>
<p><code>nullptr关键字</code>：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</p>
<p><code>智能指针</code>：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</p>
<p><code>初始化列表</code>：使用初始化列表来对类进行初始化</p>
<p><code>右值引用</code>：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</p>
<p>atomic原子操作用于多线程资源互斥操作</p>
<p>新增STL容器array以及tuple</p>
<h2 id="1-6-NULL和nullptr的区别"><a href="#1-6-NULL和nullptr的区别" class="headerlink" title="1.6.  NULL和nullptr的区别"></a>1.6.  NULL和nullptr的区别</h2><p>在C语言中，NULL通常被定义为：#define NULL ((void *)0)</p>
<p>C++是强类型语言，void*是不能隐式转换成其他类型的指针的</p>
<p>在C++中，NULL实际上是0. 因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了解决空指针的表示问题，C++引入了nullptr来表示空指针。</p>
<p>为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用nullptr作为实参，确实选择了正确的以void*作为形参的函数版本</p>
<h2 id="1-7-使用初始化列表的好处"><a href="#1-7-使用初始化列表的好处" class="headerlink" title="1.7.  使用初始化列表的好处"></a>1.7.  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyepeng/p/9863763.html">使用初始化列表的好处</a></h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<p>1.类成员中存在常量，如const int a,只能用初始化不能复制</p>
<p>2.类成员中存在引用，同样只能使用初始化不能赋值。</p>
<p>3.提高效率</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span>  <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">NamedPtr</span> {</span></span><br><span class="line"><span class="keyword">public</span>  :</span><br><span class="line">    <span class="built_in">NamedPtr</span>( <span class="keyword">const</span> string&amp; initName, T *initPtr);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> string&amp; name;  <span class="comment">// 必须通过成员初始化列表</span></span><br><span class="line">              <span class="comment">// 进行初始化</span></span><br><span class="line">  T * <span class="keyword">const</span> ptr;  <span class="comment">// 必须通过成员初始化列表</span></span><br><span class="line">          <span class="comment">// 进行初始化</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="built_in">Test1</span>() <span class="comment">// 无参构造函数</span></span><br><span class="line">    { </span><br><span class="line">        cout &lt;&lt; <span class="string">"Construct Test1"</span> &lt;&lt; endl ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test1</span>(<span class="keyword">const</span> Test1&amp; t1) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Copy constructor for Test1"</span> &lt;&lt; endl ;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = t1.a ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Test1&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Test1&amp; t1) <span class="comment">// 赋值运算符</span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"assignment for Test1"</span> &lt;&lt; endl ;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = t1.a ;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a ;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    Test1 test1 ;</span><br><span class="line">    <span class="built_in">Test2</span>(Test1 &amp;t1)</span><br><span class="line">    {</span><br><span class="line">        test1 = t1 ;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是初始化列表 就可以省去计算阶段</span></span><br><span class="line">     <span class="built_in">Test2</span>(Test1 &amp;t1)</span><br><span class="line">    {</span><br><span class="line">        test1 = t1 ;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li><strong>构造函数的两个执行阶段</strong><ol>
<li>初始化阶段：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</li>
<li>计算阶段：如果类成员，初始化列表只用调用类的拷贝构造函数，不使用初始化列表则需先调用默认构造函数构造对象，再给对象赋值，赋值的阶段即为计算阶段，<code>初始化列表可以省去计算阶段</code>从而优化性能</li>
</ol>
</li>
</ul>
<h2 id="1-8-auto-和-decltype区别和联系"><a href="#1-8-auto-和-decltype区别和联系" class="headerlink" title="1.8.  auto 和 decltype区别和联系"></a>1.8.  auto 和 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/4952980.html">decltype</a>区别和联系</h2><p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</p>
<p>当引用被用作初始值的时候，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型。</p>
<p>auto一般会忽略掉顶层const，但底层const会被保留下来，比如当初始值是一个指向常量的指针时：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">//b是一个整数（ci的顶层const特性被忽略掉了)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">//c是一个整数（Cr是ci的别名，ci本身是一个顶层const)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">//d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">//e是一个指向整形常量的指针（对常量对象取地址是一种底层const)</span></span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/4952980.html">decltype</a>的作用是<code>选择并返回操作数的数据类型</code>。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。(主要用在泛型编程中结合auto，用于追踪函数的返回值类型)</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(_Tx x, _Ty y)</span>-&gt;<span class="title">decltype</span><span class="params">(_Tx*_Ty)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内).</p>
<p>如果decltype得到引用则必须初始化。</p>
<p>注意:decltype((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当 variable本身就是一个引用时才是引用。</p>
<h2 id="1-9-C-11右值引用"><a href="#1-9-C-11右值引用" class="headerlink" title="1.9.  C++11右值引用"></a>1.9.  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85668787">C++11右值引用</a></h2><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<p>\1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
<p>\2. 能够更简洁明确地定义泛型函数。</p>
<p>左值和右值的概念：</p>
<p>左值：<code>能对表达式取地址</code>、或具名对象/变量。一般指表达式结束后依然存在的<code>持久对象</code>。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的<code>临时对象</code>。</p>
<p>C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：</p>
<p>T &amp;&amp; a=ReturnRvale();</p>
<p>假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。</p>
<p>可以使用move将对左值进行右值引用</p>
<p> int k = 4;</p>
<p>  int&amp;&amp; s = move(k);</p>
<p>此时s和k地址一样。</p>
<h3 id="1-9-1-移动构造"><a href="#1-9-1-移动构造" class="headerlink" title="1.9.1. 移动构造"></a>1.9.1. 移动构造</h3><p>基于右值引用可以实现转移语义和完美转发新特性。</p>
<p>移动语义：</p>
<ul>
<li><p>对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。</p>
</li>
<li><p>但是如下列代码所示：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtrMem</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">HasPtrMem</span>() : <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>)){</span><br><span class="line">    cout&lt;&lt;<span class="string">"Construct:"</span>&lt;&lt;++n_cstr&lt;&lt;endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">HasPtrMem</span>(<span class="keyword">const</span> HasPtrMem &amp;h) : <span class="built_in">d</span>(<span class="built_in"><span class="keyword">new</span></span> (<span class="built_in"><span class="keyword">int</span></span>(*h.d))){</span><br><span class="line">    cout&lt;&lt;<span class="string">"Copy construct:"</span>&lt;&lt;++n_cptr&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">  ~<span class="built_in">HasPtrMem</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"Destruct:"</span>&lt;&lt;++n_dstr&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">  <span class="keyword">int</span> *d;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> n_cstr;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> n_dstr;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> n_cptr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cstr == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_dstr == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> HasPtrMem::n_cptr == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>{<span class="function">retrun <span class="title">HasPtrMem</span><span class="params">()</span></span>;}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  HasPtrMem a = <span class="built_in">GetTemp</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">HasPtrMem</span>(HasPtrMem &amp;&amp; h) : <span class="built_in">d</span>(h.d){ <span class="comment">//移动构造函数</span></span><br><span class="line">  h.d = <span class="literal">nullptr</span>;										<span class="comment">//将移动值的指针成员置空</span></span><br><span class="line">  cout&lt;&lt;<span class="string">"Move construct:"</span>&lt;&lt;++n_mvtr&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。</p>
</li>
<li><p>而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。</p>
</li>
<li><p>如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。</p>
</li>
<li><p>使用右值引用直接使用h里面的h.d。</p>
<p>否则将会用h.d构造d，因为拷贝构造不能浅拷贝指针，所以不能直接赋值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HasPtrMem</span>(HasPtrMem &amp;&amp; h) : <span class="built_in">d</span>(h.d){ <span class="comment">//移动构造函数</span></span><br><span class="line">  h.d = <span class="literal">nullptr</span>;										<span class="comment">//将移动值的指针成员置空</span></span><br><span class="line">  cout&lt;&lt;<span class="string">"Move construct:"</span>&lt;&lt;++n_mvtr&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20220226100811301-2120007528.png" alt="img"></p>
<h3 id="1-9-2-完美转发"><a href="#1-9-2-完美转发" class="headerlink" title="1.9.2. 完美转发"></a>1.9.2. <a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangbaohui/article/details/103673177">完美转发</a></h3><p>std::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="1-10-push-back-和emplace-back-区别"><a href="#1-10-push-back-和emplace-back-区别" class="headerlink" title="1.10. push_back()和emplace_back()区别"></a>1.10. push_back()和emplace_back()区别</h2><p>如果传入类，push_back()先构造对象，再将对象放到末尾（如果是右值就进行移动构造），emplace_back()直接在末尾构造。</p>
<h2 id="1-11-C-11-Lambda表达式"><a href="#1-11-C-11-Lambda表达式" class="headerlink" title="1.11. C++11 Lambda表达式"></a>1.11. C++11 Lambda表达式</h2><p>Lambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量，其定义如下：</p>
<p><a href="params">capture</a>mutable-&gt;return-type{statement}</p>
<p>其中，</p>
<p>[capture]：捕获列表，捕获上下变量以供lambda使用。编译器根据符号[]判断接下来代码是否是lambda函数。</p>
<p>(Params)：参数列表，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。</p>
<p>mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。</p>
<p>-&gt;return-type:返回类型是返回值类型</p>
<p>{statement}:函数体，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。</p>
<p>Lambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。其形式如下:</p>
<blockquote>
<ul>
<li><p><input disabled="" type="checkbox"> 
[var]表示值传递方式捕捉变量var</p>
</li>
<li><p><input disabled="" type="checkbox"> 
[=]表示值传递方式捕捉所有父作用域的变量（包括this)</p>
</li>
<li><p><input disabled="" type="checkbox"> 
[&amp;var]表示引用传递捕捉变量var</p>
</li>
<li><p><input disabled="" type="checkbox"> 
[&amp;]表示引用传递捕捉所有父作用域的变量（包括this）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
[this]表示值传递方式捕捉当前的this指针</p>
</li>
</ul>
</blockquote>
<p>Lambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于简化仿函数的使用，同时<code>Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口</code>。</p>
<h2 id="1-12-头文件循环引用"><a href="#1-12-头文件循环引用" class="headerlink" title="1.12. 头文件循环引用"></a>1.12. <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22488067/article/details/73195621">头文件循环引用</a></h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　B* m_b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">B.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"A.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　A* m_a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这样是编译不过的，把A.h中的</p>
<p>#include “B.h”</p>
<p>去掉，改为</p>
<p>class B;</p>
<ol>
<li>两个类不能互相include对方的头文件，两者也不能都是实体对象，必须其中一个为指针。 因为两个类相互引用，不管哪个类在前面，都会出现有一个类未定义的情况，所以可以<code>提前声明一个类</code>，而类的声明就是提前告诉编译器，所要引用的是个类，但此时后面的那个类还没有定义，因此无法给对象分配确定的内存空间，因此<code>只能使用类指针</code>。如果非得互相引用实体，那应该是错误的设计。 </li>
<li>用指针的原因是：假设两个类分别为A和B，在B中用指针调用A，那么在A需要知道B占空间大小的时候，就会去找到B的定义文件，虽然B的定义文件中并没有导入A的头文件，不知道A的占空间大小，但是由于在B中调用A的时候用的指针形式，B只知道指针占4个字节就可以，不需要知道A真正占空间大小，也就是说，A也是知道B的占空间大小的。</li>
</ol>
<h1 id="2-重载、模板"><a href="#2-重载、模板" class="headerlink" title="2.   重载、模板"></a>2.   重载、模板</h1><h2 id="2-1-运算符重载"><a href="#2-1-运算符重载" class="headerlink" title="2.1.  运算符重载"></a>2.1.  运算符重载</h2><h3 id="2-1-1-算术运算符"><a href="#2-1-1-算术运算符" class="headerlink" title="2.1.1. 算术运算符"></a>2.1.1. 算术运算符</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">complex complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> complex &amp;A) <span class="keyword">const</span>{</span><br><span class="line">	complex B;</span><br><span class="line">	B.m_real = <span class="keyword">this</span>-&gt;m_real + A.m_real;</span><br><span class="line">	B.m_imag = <span class="keyword">this</span>-&gt;m_imag + A.m_imag;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//以全局函数的形式重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2){</span><br><span class="line">	Complex c;</span><br><span class="line">	c.m_real = c1.m_real + c2.m_real;</span><br><span class="line">	c.m_imag = c1.m_imag + c2.m_imag;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-1-2"><a href="#2-1-2" class="headerlink" title="2.1.2. []"></a>2.1.2. []</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; Array::<span class="keyword">operator</span>[](<span class="keyword">int</span> i){</span><br><span class="line">	<span class="keyword">return</span> m_p[i];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-1-3-lt-lt-gt-gt"><a href="#2-1-3-lt-lt-gt-gt" class="headerlink" title="2.1.3. <<,>>"></a>2.1.3. &lt;&lt;,&gt;&gt;</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; operator&gt;&gt;(istream &amp;in, complex &amp;A){</span><br><span class="line">	in &gt;&gt; A.m_real &gt;&gt; A.m_imag;</span><br><span class="line">  return in;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;out, complex &amp;A){</span><br><span class="line">	out &lt;&lt; A.m_real &lt;&lt;" + "&lt;&lt; A.m_imag &lt;&lt;" i ";</span><br><span class="line">	return out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-1-4-i和i-的实现"><a href="#2-1-4-i和i-的实现" class="headerlink" title="2.1.4. ++i和i++的实现"></a>2.1.4. ++i和i++的实现</h3><ol>
<li>++i 实现：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;  <span class="keyword">int</span>::<span class="keyword">operator</span>++（）{</span><br><span class="line">	*<span class="keyword">this</span> +=<span class="number">1</span>；</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>i++ 实现：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  <span class="keyword">int</span>::<span class="keyword">operator</span>++（<span class="keyword">int</span>）{</span><br><span class="line">	<span class="keyword">int</span> oldValue = *<span class="keyword">this</span>；</span><br><span class="line">	++（*<span class="keyword">this</span>）；</span><br><span class="line">	<span class="keyword">return</span> oldValue；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-1-5-函数调用运算符"><a href="#2-1-5-函数调用运算符" class="headerlink" title="2.1.5. 函数调用运算符()"></a>2.1.5. 函数调用运算符()</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> {</span></span><br><span class="line">  <span class="keyword">double</span> real, imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Complex</span>(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i){};</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>{ <span class="keyword">return</span> real; } <span class="comment">//重载强制类型转换运算符 double</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1.2</span>, <span class="number">3.4</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; (<span class="keyword">double</span>)c &lt;&lt; endl; <span class="comment">//输出 1.2  !!!!!!!!!!</span></span><br><span class="line">  <span class="keyword">double</span> n = <span class="number">2</span> + c;          <span class="comment">//等价于 double n = 2 + c. operator double()</span></span><br><span class="line">  cout &lt;&lt; n;                 <span class="comment">//输出 3.2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>举个简单的例子，下面这个名为absInt的struct含有一个调用运算符，该运算符负责返回其参数的绝对值：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> {</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span></span>{</span><br><span class="line">    <span class="keyword">return</span> val&lt;<span class="number">0</span>?-val:val;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">	absInt absObj;			<span class="comment">//含有函数调用运算符的对象</span></span><br><span class="line">	<span class="keyword">int</span> ui = <span class="built_in">ansObi</span>(i); <span class="comment">//将i传递给absObj.operator(); </span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="2-1-6-成员访问运算符-gt"><a href="#2-1-6-成员访问运算符-gt" class="headerlink" title="2.1.6. 成员访问运算符* ->"></a>2.1.6. 成员访问运算符* -&gt;</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjContainer</span> {</span></span><br><span class="line">  vector&lt;Obj *&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Obj *obj)</span> </span>{</span><br><span class="line">    a.<span class="built_in">push_back</span>(obj); <span class="comment">// 调用向量的标准方法</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> {</span></span><br><span class="line">  ObjContainer oc;</span><br><span class="line">  Obj *<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> {</span><br><span class="line">    <span class="keyword">if</span> (!oc.a[index]) {</span><br><span class="line">      cout &lt;&lt; <span class="string">"Zero value"</span>;</span><br><span class="line">      <span class="keyword">return</span> (Obj *)<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> oc.a[index];</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>A* ca;      调用ca-&gt;相当于调用ca-&gt;oc.a[index]-&gt;;</p>
<h2 id="2-2-类模板"><a href="#2-2-类模板" class="headerlink" title="2.2.  类模板"></a>2.2.  类模板</h2><p>C++ 中类模板的写法如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型参数表&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类模板名{</span></span><br><span class="line">   成员函数和成员变量</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-C-11中的可变参数模板"><a href="#2-3-C-11中的可变参数模板" class="headerlink" title="2.3.  C++11中的可变参数模板"></a>2.3.  C++11中的可变参数模板</h2><p>C++11的可变参数模板，<code>对参数进行了高度泛化</code>，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上<code>省略号</code>”。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Template&lt;class ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T ... args)</span></span>{</span><br><span class="line">	cout&lt;&lt;”num is”&lt;&lt;<span class="keyword">sizeof</span> ...(args)&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>func();//args不含任何参数</p>
<p>func(1);//args包含一个int类型的实参</p>
<p>func(1,2.0);//args包含一个int一个double类型的实参</p>
<p>其中T叫做模板参数包，args叫做函数参数包</p>
<p>省略号作用如下：</p>
<p>1）声明一个包含0到任意个模板参数的参数包</p>
<p>2）在模板定义得右边，可以将参数包展成一个个独立的参数</p>
<p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最终递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>{</span><br><span class="line">  cout &lt;&lt; <span class="string">"empty"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args... args)</span></span>{</span><br><span class="line">  cout &lt;&lt; head &lt;&lt; <span class="string">","</span>;</span><br><span class="line">  <span class="built_in">print</span>(args...);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参数包Args …在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程</p>
<h1 id="3-类"><a href="#3-类" class="headerlink" title="3.   类"></a>3.   类</h1><h2 id="3-1-空类占多大内存，为什么"><a href="#3-1-空类占多大内存，为什么" class="headerlink" title="3.1.  空类占多大内存，为什么"></a>3.1.  空类占多大内存，为什么</h2><p><code>1字节</code>，</p>
<p><code>类中static数据不占空间。</code></p>
<p><code>虚函数表占4字节，函数不占内存</code>。</p>
<p>编译器往往会给一个<code>空类隐含的加一个字节（char）</code>，这样空类在实例化后在内存得到了<code>独一无二的地址</code>。</p>
<h2 id="3-2-this指针理解"><a href="#3-2-this指针理解" class="headerlink" title="3.2.  this指针理解"></a>3.2.  this指针理解</h2><ol>
<li>定义</li>
</ol>
<ul>
<li>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。<code>this 指针是所有成员函数的隐含参数</code>。因此，在成员函数内部，<code>它可以用来指向调用对象</code>。</li>
</ul>
<ol start="2">
<li><p><code>this只能在成员函数中使用</code></p>
<p>成员函数默认第一个参数为T* const register this。</p>
<p><code>（友元函数，全局函数不是成员函数）</code></p>
</li>
<li><p>this指针不能再静态函数中使用</p>
</li>
</ol>
<ul>
<li>静态函数如同静态变量一样，他不属于具体的哪一个对象，<code>静态函数表示了整个类范围意义上的信息</code>，而<code>this指针却实实在在的对应一个对象</code>，所以this指针不能被静态函数使用。</li>
</ul>
<ol start="4">
<li><code>this指针的创建</code></li>
</ol>
<ul>
<li>this指针在成员函数的开始执行前构造的，在成员的执行结束后清除。</li>
</ul>
<ol start="5">
<li>this指针只有在<code>成员函数</code>中才有定````义````````````````</li>
</ol>
<ul>
<li>创建一个对象后，不能通过对象使用this指针。也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以<code>&amp;this</code>获得)，也可以直接使用的。</li>
<li>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</li>
<li>this 作为隐式形参，<code>本质上是成员函数的局部变量</code>，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。</li>
</ul>
<h2 id="3-3-C-中类成员的访问权限"><a href="#3-3-C-中类成员的访问权限" class="headerlink" title="3.3.  C++中类成员的访问权限"></a>3.3.  C++中类成员的访问权限</h2><ol>
<li><p>public修饰的成员变量</p>
<ul>
<li>在程序的任何地方都可以被访问，就是公共变量的意思，<code>不需要通过成员函数就可以由类的实例直接访问</code></li>
</ul>
</li>
<li><p>private修饰的成员变量</p>
<ul>
<li>只有类内可直接访问，私有的，<code>类的实例要通过成员函数才可以访问</code>，这个可以起到<code>信息隐藏</code></li>
</ul>
</li>
<li><p>protected是受保护变量</p>
<ul>
<li><code>类内和子类可直接访问</code>，也就是说，<code>基类中有protected成员，子类继承于基类，那么也可以访问基类的protected成员，要是基类是private成员，则对于子类也是隐藏的，不可访问</code></li>
</ul>
</li>
</ol>
<h2 id="3-4-C-中struct和class的区别"><a href="#3-4-C-中struct和class的区别" class="headerlink" title="3.4.  C++中struct和class的区别"></a>3.4.  C++中struct和class的区别</h2><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：</p>
<ol>
<li><code>默认的继承访问权</code>。class默认的是private,strcut默认的是public。</li>
<li><code>默认访问权限</code>：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li>
<li>“class”这个关键字还用于<code>定义模板参数</code>，就像“typename”。但关建字“struct”不用于定义模板参数</li>
<li>class和struct在使用大括号<code>{ }</code>上的区别<ul>
<li><strong>关于使用大括号初始化</strong><ol>
<li>class和struct如果定义了构造函数的话，都不能用大括号进行初始化</li>
<li>如果没有定义构造函数，struct可以用大括号初始化。</li>
<li>如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="3-5-C-类内可以定义引用数据成员吗？"><a href="#3-5-C-类内可以定义引用数据成员吗？" class="headerlink" title="3.5.  C++类内可以定义引用数据成员吗？"></a>3.5.  C++类内可以定义引用数据成员吗？</h2><p><code>可以，必须通过成员函数初始化列表初始化。</code> （必须使用初始化列表的情况：const 和引用）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> &amp;b):<span class="built_in">a</span>(b){}</span><br><span class="line">  <span class="keyword">int</span> &amp;a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">  cout &lt;&lt; a.a &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-6-一个空类都有什么默认函数"><a href="#3-6-一个空类都有什么默认函数" class="headerlink" title="3.6.  一个空类都有什么默认函数"></a>3.6.  一个空类都有什么默认函数</h2><ol>
<li>无参的构造函数</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty(){}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>拷贝构造函数</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; copy){}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>赋值运算符</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Empty&amp; copy){}</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>析构函数（非虚）</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Empty</span>(){}</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>寻址函数</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty* <span class="keyword">operator</span>&amp;(){}<span class="comment">//取址运算符</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-7-Struct-和union的区别"><a href="#3-7-Struct-和union的区别" class="headerlink" title="3.7.  Struct 和union的区别"></a>3.7.  Struct 和union的区别</h2><ol>
<li><strong>结构体struct</strong></li>
</ol>
<ul>
<li>各成员<code>各自拥有自己的内存</code>，各自使用互不干涉，同时存在的，<code>遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。</code></li>
</ul>
<ol start="2">
<li><strong>联合体union</strong></li>
</ol>
<ul>
<li>各成员<code>共用一块内存空间</code>，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，<code>联合体比结构体更节约内存</code>。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。<code>不允许对联合体变量名U2直接赋值或其他操作</code>。</li>
</ul>
<h2 id="3-8-C-如何阻止一个类被实例化"><a href="#3-8-C-如何阻止一个类被实例化" class="headerlink" title="3.8.  C++如何阻止一个类被实例化"></a>3.8.  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Stephen-Qin/p/11514588.html">C++如何阻止一个类被实例化</a></h2><ol>
<li>定义一个无用的抽象函数，使得类成为抽象类。</li>
<li>将构造函数定义为private.</li>
<li>使用 构造函数=delete</li>
</ol>
<h2 id="3-9-说一说你理解的内存对齐以及原因"><a href="#3-9-说一说你理解的内存对齐以及原因" class="headerlink" title="3.9 说一说你理解的内存对齐以及原因"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30007037">3.9 说一说你理解的内存对齐以及原因</a></h2><h3 id="为什么要进行内存对齐"><a href="#为什么要进行内存对齐" class="headerlink" title="为什么要进行内存对齐"></a>为什么要进行内存对齐</h3><blockquote>
<p><code>因为大多数处理器有内存存取粒度的限制，比如说32位系统是4字节的存取粒度，只能从地址为4的倍数的内存开始读取数据，所以需要内存对齐，数据在内存的存放没有规则的话，会给数据的读取增添很大的工作量，所以需要按照对齐规则存放数据，进行内存对齐</code></p>
<p>==需要考虑成员变量定义的先后顺序，可以优化数据存储大小==</p>
</blockquote>
<ul>
<li><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为==内存存取粒度.==</p>
</li>
<li><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），==该处理器只能从地址为4的倍数的内存开始读取数据==。</p>
</li>
<li><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/v2-3f40af513a94901b36ceb5387982277e_r.jpg" alt="img"></p>
<ul>
<li>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/v2-361e2d16876ce8383c9e6ea2dca34474_r.jpg" alt="img"></p>
<h3 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h3><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p>
<blockquote>
<p>#pragma pack(n) 设定最大对齐值</p>
</blockquote>
<p>有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p>
<ol>
<li><p>结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p>
</li>
<li><p><strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位系统 4字节内存存取粒度</span></span><br><span class="line"><span class="comment">//32位系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">}x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">}x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">}x3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(x1));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(x2));  <span class="comment">// 输出12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(x3));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/v2-86c644ce29b1e2d3858380aaa631cc1d_r.jpg" alt="img" style="zoom: 80%;">

<p>添加了#pragma pack(n)后规则就变成了下面这样：</p>
<ol>
<li><p>偏移量要是n和当前变量大小中较小值的整数倍</p>
</li>
<li><p>整体大小要是n和最大变量大小中较小值的整数倍</p>
</li>
<li><p>n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p>
</li>
</ol>
<p>例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/v2-672ebe0ccc1430adbda00dfd7abc0375_r.jpg" alt="img" style="zoom:80%;">

<p>如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/v2-1c35bc20c76d85d07855901964488637_r.jpg" alt="img" style="zoom:80%;">

<h1 id="4-指针和引用"><a href="#4-指针和引用" class="headerlink" title="4. 指针和引用"></a>4. 指针和引用</h1><h2 id="4-1-C-x2F-C-中指针和引用的区别？"><a href="#4-1-C-x2F-C-中指针和引用的区别？" class="headerlink" title="4.1.  C/C++ 中指针和引用的区别？"></a>4.1.  C/C++ 中指针和引用的区别？</h2><ol>
<li><p>指针有自己的一块<code>空间</code>，而引用只是一个<code>别名</code>；</p>
</li>
<li><p>使用<code>sizeof看一个指针的大小是4</code>，而<code>引用则是被引用对象的大小</code>==；大小==</p>
</li>
<li><p>指针可以被初始化为<code>NULL</code>，而引用必须被<code>初始化</code>且必须是一个已有<code>对象</code>的引用；==初始化==</p>
</li>
<li><p>作为参数传递时，<code>指针需要被解引用</code>才可以对对象进行操作，而<code>直接对引用的修改都会改变引用所指向的对象</code>；</p>
</li>
<li><p>可以有<code>const指针</code>，但是没有const引用；</p>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；==指向是否可改==</p>
</li>
<li><p>指针可以有<code>多级指针</code>（**p），而引用至于<code>一级</code>； ==多级==</p>
</li>
<li><p>指针和引用使用<code>++</code>运算符的意义不一样； 指针++移动地址，引用++正常++</p>
</li>
<li><p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露？</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33971459">在函数内new一个对象，如果作为引用返回，是不是就可以不用delete了？ - 知乎 (zhihu.com)</a></p>
</li>
</ol>
<h2 id="4-2-野指针是什么？"><a href="#4-2-野指针是什么？" class="headerlink" title="4.2.  野指针是什么？"></a>4.2.  野指针是什么？</h2><p>野指针就是指向      <code>一个已删除的对象</code>或者<code>未申请访问权限内存区域</code>       的指针</p>
<p>指针变量未初始化</p>
<p>任何<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F">指针变量</a>刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。指针释放后之后未置空</p>
<p>有时<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</p>
<p>指针操作超越变量作用域</p>
<p>数组越界</p>
<p>不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</p>
<h2 id="4-3-c-四个智能指针：shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#4-3-c-四个智能指针：shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="4.3.  c++四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>4.3.  c++四个智能指针：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7898.html">shared_ptr</a>,unique_ptr,weak_ptr,auto_ptr</h2><p>C++里面的四个智能指针: auto_ptr, <code>shared_ptr</code>, <code>weak_ptr</code>, <code>unique_ptr</code> 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p><code>为什么要使用智能指针</code>：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：</p>
<blockquote>
<p>申请的空间在函数结束时<code>忘记释放，造成内存泄漏</code>。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个==类==，当超出了类的作用域是，类会自动调用==析构函数==，析构函数会自动释放资源。所以<code>智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</code></p>
</blockquote>
<ol>
<li>auto_ptr（c++98的方案，cpp11已经抛弃）</li>
</ol>
<ul>
<li>采用<code>所有权模式</code>。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">"I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</li>
</ul>
<ol start="2">
<li>unique_ptr（替换auto_ptr）</li>
</ol>
<ul>
<li><p>unique_ptr实现<code>独占式拥有</code>或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
</li>
<li><p>采用<code>所有权</code>模式，还是上面那个例子</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string  (<span class="string">"auto"</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; p4；   </span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
</li>
<li><p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个<code>临时右值</code>，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">"hello world"</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                   <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));  <span class="comment">// #2 allowed</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
</li>
<li><p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数<code>std::move()</code>，让你能够将一个unique_ptr赋给另一个。例如：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1); <span class="comment">//(ps1不在指向原来对象)</span></span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">"alexia"</span>);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/diysoul/p/5930361.html">==shared_ptr==</a></li>
</ol>
<ul>
<li><p>shared_ptr实现<code>共享式拥有</code>概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“<code>最后一个引用被销毁</code>”时候<code>释放</code>。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。==引用计数==</p>
</li>
<li><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
</li>
<li><p>成员函数：</p>
<ol>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;   <span class="comment">//输出10</span></span><br><span class="line">    p1.<span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"p1 不为空"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"p1 为空"</span> &lt;&lt; endl;  <span class="comment">//输出</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;    <span class="comment">//输出10</span></span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">//输出 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ol start="4">
<li>weak_ptr  ( <code>shared_ptr 指针的一种辅助工具</code>)</li>
</ol>
<ul>
<li><p>weak_ptr 是一种<code>不控制对象生命周期</code>的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, <code>它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放</code>。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;B&gt; pb_;</span><br><span class="line">	~<span class="built_in">A</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"A delete\n"</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;A&gt; pa_;</span><br><span class="line">	~<span class="built_in">B</span>(){</span><br><span class="line">    cout&lt;&lt;<span class="string">"B delete\n"</span>;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">  <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">  pb-&gt;pa_ = pa;</span><br><span class="line">  pa-&gt;pb_ = pb;</span><br><span class="line">  cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">  cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>可以看到fun函数中pa ，pb之间<code>互相引用</code>，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（pa_，pb_未释放，因为AB是在堆上申请的内存），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p>
</li>
<li><p>注意的是<code>我们不能通过weak_ptr直接访问对象的方法</code>，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 因为pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr p = pa-&gt;pb_.<span class="built_in">lock</span>();  <span class="comment">//将weak_ptr转换为shared_ptr</span></span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="4-4-智能指针的线程安全问题"><a href="#4-4-智能指针的线程安全问题" class="headerlink" title="4.4.  智能指针的线程安全问题"></a>4.4.  智能指针的线程安全问题</h2><ul>
<li><p>智能指针shared_ptr本身（底层实现原理是引用计数）是线程安全的但对象的读写则不是，因为shared_ptr有两个数据成员，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象。</p>
</li>
<li><p>当智能指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子操作。</p>
</li>
<li><p>如果线程1拷贝对象后线程2将该对象销毁，然后线程1再将引用计数加1，就会产生悬空指针。</p>
<ol>
<li>同一个shared_ptr被多个线程读，是线程安全的；</li>
<li>同一个shared_ptr被多个线程写，不是线程安全的；</li>
<li>共享引用计数的不同的shared_ptr被多个线程写，是线程安全的。</li>
</ol>
</li>
<li><p>线程不安全例子：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">g</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; <span class="comment">// 线程之间共享的 shared_ptr</span></span><br><span class="line">shared_ptr&lt;Foo&gt; x; <span class="comment">// 线程 A 的局部变量</span></span><br><span class="line"><span class="function">shared_ptr&lt;Foo&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; <span class="comment">// 线程 B 的局部变量</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><ol>
<li>线程 A 执行x = g;（即 read g），以下完成了步骤 1，还没来及执行步骤 2。这时切换到了 B 线程。</li>
<li>同时线程 B 执行 g = n; （即 write G），两个步骤一起完成了。</li>
<li>这时 Foo1对象已经销毁，x.ptr 成了空悬指针！</li>
</ol>
</li>
<li><code>我刚读完他 你就把他写没了</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20220226100811237-1324544888.png" alt="img"></p>
<p>weak_ptr不会增加引用计数，不能直接操作对象的内存（需要先调用<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.cppreference.com/w/cpp/memory/weak_ptr/lock">lock</a>接口），需要和shared_ptr配套使用。</p>
<p>同时，通过weak_ptr获得的shared_ptr可以安全使用，因为其<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://en.cppreference.com/w/cpp/memory/weak_ptr/lock">lock</a>接口是原子性的，那么<code>lock返回的是一个新的shared_ptr</code>，不存在同一个shared_ptr的读写操作。</p>
<h2 id="4-5-为什么不能在STL容器中存储auto-ptr"><a href="#4-5-为什么不能在STL容器中存储auto-ptr" class="headerlink" title="4.5.  为什么不能在STL容器中存储auto_ptr"></a>4.5.  为什么不能在STL容器中存储auto_ptr</h2><ul>
<li><p>==一个STL对象是可以“拷贝构造”和“赋值”==，而且当一个源对象复制到目标对象后 ，<code>源对象的状态通常是不会改变</code>的。</p>
</li>
<li><p>但是，这不适用于auto_ptr（智能指针）。因为一个auto_ptr对象拷贝或赋值到另一个对象时会使源对象产生预期变动之外的变化。引发这个问题的原因是<code>auto_ptr指针的唯一性</code>，即一个对象只能有一个auto_ptr指针所指向它。因此，当auto_ptr以传值方式被复制给另外一个对象时，源对象就放弃了对象的拥有权，把它转移到目标对象上。</p>
</li>
</ul>
<h2 id="4-6-智能指针的实现"><a href="#4-6-智能指针的实现" class="headerlink" title="4.6.  智能指针的实现"></a>4.6.  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wxquare/p/4759020.html">智能指针的实现</a></h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24">https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24</a></p>
<ul>
<li><p>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</p>
<ol>
<li>每次<u>创建类的新对象</u>时，初始化指针并将<u>引用计数置为1</u>；</li>
<li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；</li>
<li>对一个对象进行赋值时，赋值操作符<code>减少左操作数所指对象的引用计数</code>（如果引用计数为减至0，则删除对象），并<code>增加右操作数所指对象的引用计数</code>；</li>
<li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象。</li>
</ol>
</li>
<li><p>智能指针就是模拟指针动作的类。</p>
</li>
<li><p>所有的智能指针都会重载 <code>-&gt;</code> 和 <code>*</code> 操作符。</p>
</li>
<li><p>智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *_ptr;</span><br><span class="line">  <span class="keyword">size_t</span> *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SmartPointer</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr) {</span><br><span class="line">    <span class="keyword">if</span> (_ptr) {</span><br><span class="line">      _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);  <span class="comment">//初始化非空 设置count为1</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);	<span class="comment">//初始化为空 count设为0</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer &amp;ptr) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) {</span><br><span class="line">      <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">      <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">      (*<span class="keyword">this</span>-&gt;_count)++;  <span class="comment">//拷贝构造 count++</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SmartPointer &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer &amp;ptr) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr) {</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) {</span><br><span class="line">      (*<span class="keyword">this</span>-&gt;_count)--;   <span class="comment">//本身存在实例化对象，更换指向 因此count--</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;  <span class="comment">//更改指向</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">    (*<span class="keyword">this</span>-&gt;_count)++;  <span class="comment">//count++</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  T &amp;<span class="keyword">operator</span>*() {</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);  <span class="comment">//* 返回指针的解引用 实例化的对象</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  T *<span class="keyword">operator</span>-&gt;() {</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;  <span class="comment">//-&gt;返回的是个指针</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">SmartPointer</span>() {</span><br><span class="line">    (*<span class="keyword">this</span>-&gt;_count)--;   <span class="comment">//对象析构count--</span></span><br><span class="line">    <span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) { <span class="comment">//引用计数为0，析构释放空间</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_count; }  <span class="comment">//返回指向ptr堆空间的智能指针</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  {</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">    sp2 = sp3;</span><br><span class="line">    std::cout &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; sp3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// delete operator</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-7-函数指针"><a href="#4-7-函数指针" class="headerlink" title="4.7.  函数指针"></a>4.7.  <a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-fun-pointer-callback.html">函数指针</a></h2><ol>
<li><p>定义</p>
<ul>
<li><u>函数指针是指向函数的指针变量。</u></li>
<li><code>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数</code>。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</li>
<li>C<u>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</u>。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</li>
</ul>
</li>
<li><p>用途：</p>
</li>
</ol>
<ul>
<li>==调用函数和做函数的参数，比如回调函数。==</li>
</ul>
<ol start="3">
<li><p>示例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * p)</span>  </span>{…}    <span class="comment">// 函数fun</span></span><br><span class="line"><span class="keyword">char</span> * (*pf)(<span class="keyword">char</span> * p);       <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;            <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"><span class="built_in">pf</span>(p);            <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="4-8-函数内可以返回一个局部变量的引用吗？"><a href="#4-8-函数内可以返回一个局部变量的引用吗？" class="headerlink" title="4.8.  函数内可以返回一个局部变量的引用吗？"></a>4.8.  函数内可以返回一个局部变量的引用吗？</h2><p>不可以。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get10</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">}<span class="comment">//错误</span></span><br></pre></td></tr></tbody></table></figure>

<p>解决：</p>
<ol>
<li><p>加static</p>
</li>
<li><p>加传入参数</p>
</li>
<li><p>分配在堆上</p>
</li>
</ol>
<h1 id="5-构造、析构函数"><a href="#5-构造、析构函数" class="headerlink" title="5. 构造、析构函数"></a>5. 构造、析构函数</h1><h2 id="5-1-C-中析构函数的作用"><a href="#5-1-C-中析构函数的作用" class="headerlink" title="5.1.  C++中析构函数的作用"></a>5.1.  C++中析构函数的作用</h2><ul>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</li>
<li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</li>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</li>
<li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</li>
</ul>
<h2 id="5-2-C-中拷贝赋值函数的形参能否进行值传递？"><a href="#5-2-C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="5.2.  C++中拷贝赋值函数的形参能否进行值传递？"></a>5.2.  C++中拷贝赋值函数的形参能否进行值传递？</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(A other) <span class="comment">// 进行值传递而非引用传递（拷贝构造时也有赋值过程）？</span></span><br><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">A b=a;  都是拷贝构造函数来创建对象b</span><br></pre></td></tr></tbody></table></figure>

<p>强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！</p>
<p><code>赋值函数如果为值传递，仅仅是多了一次拷贝构造，并不会无限递归</code></p>
<p>==拷贝构造如果为值传递，才会引起无限递归==</p>
 <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Example</span>(Example&amp; ex)    <span class="comment">//拷贝构造函数（引用传递参数）</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">//aa = ex.aa;       //如果构造函数是成员函数赋值则可以，默认使用参数列表初始化</span></span><br><span class="line">  *<span class="keyword">this</span> = ex;        <span class="comment">//如果是类拷贝则不行</span></span><br><span class="line">  cout &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-3-构造函数可以定义为虚函数吗"><a href="#5-3-构造函数可以定义为虚函数吗" class="headerlink" title="5.3.  构造函数可以定义为虚函数吗"></a>5.3.  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28584889/article/details/88749862">构造函数可以定义为虚函数吗</a></h2><p><strong><code>构造函数不能是虚函数</code></strong></p>
<ol>
<li><p>从vptr角度解释</p>
<ul>
<li>虚函数的调用是通过虚函数表来查找的，而虚函数表由<code>类的实例化对象</code>的vptr指针(vptr可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28584889/article/details/88748923">C++的虚函数表指针vptr</a>)指向，该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，但此时vptr还没有初始化！==（用虚函数构造我 但是使用虚函数需要我）==</li>
</ul>
</li>
<li><p>从多态角度解释</p>
</li>
</ol>
<ul>
<li>虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。</li>
<li>在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。</li>
</ul>
<h2 id="5-4-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#5-4-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="5.4.  为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>5.4.  为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h2><ol>
<li><ul>
<li>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</li>
<li>如果不是虚函数的话，子类的构析函数不会被调用，子类申请的内存不会被释放。</li>
</ul>
</li>
<li><ul>
<li>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会<code>浪费内存</code>。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Father</span>() {</span><br><span class="line">    cout &lt;&lt; <span class="string">"class Father destroyed"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Father {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">Son</span>() {</span><br><span class="line">    cout &lt;&lt; <span class="string">"class Son destroyed"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  Father* p = <span class="keyword">new</span> Son;</span><br><span class="line">  <span class="keyword">delete</span> p;   <span class="comment">//如果不是虚函数 则不调用子类的析构函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>如果父类的析构函数是虚函数，则<code>子类的析构函数一定是虚函数</code>（即使是子类的析构函数不加virtual,这是C++的语法规则），<code>在父类指针或引用指向一个子类时，触发动态绑定（多态）</code>，析构实例化对象时，若是子类则会执行子类的析构函数，同时，编译器会在子类的析构函数中插入父类的析构函数，最终实现了先调用子类析构函数再调用父类析构函数。</p>
</li>
<li><pre><code class="c++">//Rectangle Triangle继承自Shape
//area()为Shape的virtual方法
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
   // 存储矩形的地址
   shape = &amp;rec;
   // 调用矩形的求面积函数 area
   shape-&gt;area(); 
   // 存储三角形的地址
   shape = &amp;tri;
   // 调用三角形的求面积函数 area
   shape-&gt;area(); 
   return 0;
}
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 6.   关键字、函数</span><br><span class="line"></span><br><span class="line">## 6.1.  const 作用和应用场景</span><br><span class="line"></span><br><span class="line">### 6.1.1. [const修饰指针](https://blog.csdn.net/oguro/article/details/52694295)</span><br><span class="line"></span><br><span class="line">**const修饰指针有三种情况：**`离谁近谁不可修改` 说法是==反==过来的？</span><br><span class="line"></span><br><span class="line">1. const修饰指针——指向常量的指针( const int *p = &amp;a )</span><br><span class="line"></span><br><span class="line">   指针的指向可以修改，但是指针指向的值不可以修改.</span><br><span class="line"></span><br><span class="line">2. const修饰常量——指针常量( int * const p = &amp;a )</span><br><span class="line"></span><br><span class="line">   指针的指向不可以修改，但是指针指向的值可以修改.</span><br><span class="line"></span><br><span class="line">3. const既修饰指针，又修饰常量(const int * const p = &amp;a )</span><br><span class="line"></span><br><span class="line">   指针的指向不可以修改，指针指向的值也不可以修改.</span><br><span class="line"></span><br><span class="line">### 6.1.2. [const修饰成员函数](https://blog.csdn.net/lihao21/article/details/8634876)</span><br><span class="line"></span><br><span class="line">- 常函数：成员函数`后加const`后我们称为这个函数为常函数</span><br><span class="line"></span><br><span class="line">  1. `常函数内不可以修改成员属性`</span><br><span class="line"></span><br><span class="line">  ````c++</span><br><span class="line">  class Screen {</span><br><span class="line">  public:</span><br><span class="line">      int ok() const {return _cursor; }  //合法</span><br><span class="line">      int error(intival) const { _cursor = ival; } //非法</span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure>

2. 常函数内修改成员属性的两种方法：
   - 成员属性声明时加关键字mutable后，在常函数中依然可以修改
   - 将成员变量以引用的方式传入函数
   - 值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。例如，

<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_sName;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    m_sName = s.<span class="built_in">c_str</span>();      <span class="comment">// 错误！不能修改m_sName;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        m_sName[i] = s[i];    <span class="comment">// 不好的风格，但不是错误的</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>常对象</p>
<ol>
<li>声明对象前加const称该对象为常对象</li>
<li><code>常对象只能调用常函数</code>，普通对象既可以调用普通成员函数，也可以调用常函数</li>
</ol>
</li>
</ul>
<h3 id="6-1-3-const修饰的函数可以重载么"><a href="#6-1-3-const修饰的函数可以重载么" class="headerlink" title="6.1.3. const修饰的函数可以重载么"></a>6.1.3. const修饰的函数可以重载么</h3><p><strong>const修饰的函数同时也<code>能</code>实现函数的重载。</strong></p>
<ol>
<li>要想调用const修饰的重载函数，需要用const对象去调用。</li>
<li>如果一个函数用const修饰了，但是这个函数没有实现重载，那么非const对象和const对象都能调用这个函数。<ul>
<li>如下代码：若没有fun只有const fun， 则t1也会调用const fun</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span></span><br><span class="line"><span class="class">{</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="keyword">int</span> x;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Test</span> (<span class="keyword">int</span> i):<span class="built_in">x</span>(i) {}  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span>  </span>{  </span><br><span class="line">        cout &lt;&lt; <span class="string">"fun() const called "</span> &lt;&lt; endl;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>  </span>{  </span><br><span class="line">        cout &lt;&lt; <span class="string">"fun() called "</span> &lt;&lt; endl;  </span><br><span class="line">    }  </span><br><span class="line">};  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="function">Test <span class="title">t1</span> <span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">const</span> Test <span class="title">t2</span> <span class="params">(<span class="number">20</span>)</span></span>;  </span><br><span class="line">    t1.<span class="built_in">fun</span>();  <span class="comment">//fun() called</span></span><br><span class="line">    t2.<span class="built_in">fun</span>();  <span class="comment">//fun() const called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-1-4-常量引用"><a href="#6-1-4-常量引用" class="headerlink" title="6.1.4. 常量引用"></a>6.1.4. 常量引用</h3><p>const int &amp; ref = 10// 正确，加上const之后,编译器将代码修改为 int temp = 10; const int &amp; ref = temp;</p>
<h3 id="6-1-5-顶层const和底层const"><a href="#6-1-5-顶层const和底层const" class="headerlink" title="6.1.5. 顶层const和底层const"></a>6.1.5. 顶层const和底层const</h3><ol>
<li>指向<code>常量</code>的指针，<code>底层const</code>。声明时const可以放在类型名前后都可，拿int类型来说，声明时：const int和int const 是等价的，</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num_a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p_a = &amp;num_a; <span class="comment">//底层const</span></span><br><span class="line"><span class="comment">//*p_a = 2; //错误，指向“常量”的指针不能改变所指的对象</span></span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><p>指针常量，顶层const</p>
<blockquote>
<p>记忆 *（指针）const（常量）   ==指针常量==     </p>
<p>记忆  const（常量） int *（指针）  ==常量指针==</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num_b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p_b = &amp;num_b; <span class="comment">//顶层const</span></span><br><span class="line"><span class="comment">//p_b = &amp;num_a; //错误，指针常量不能改变存储的地址值</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>当执行对象的拷贝过程中（赋值操作，函数的值传递）时，如果被拷贝对象拥有底层const资格，则拷贝对象必须拥有相同的底层const资格。或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a = &amp;k;</span><br><span class="line"><span class="keyword">int</span> *b = a;<span class="comment">//可以</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* a = &amp;k;</span><br><span class="line"><span class="keyword">int</span> *b = a;<span class="comment">//不行</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> a = &amp;k;</span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(a);</span><br><span class="line">a = b;<span class="comment">//错误，顶层const不能改变</span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="25、C-的顶层const和底层const"><a href="#25、C-的顶层const和底层const" class="headerlink" title="25、C++的顶层const和底层const"></a><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=25%E3%80%81c%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const">25、C++的顶层const和底层const</a></h4><p><strong>概念区分</strong></p>
<ul>
<li><strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</li>
<li><strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="keyword">int</span>* <span class="keyword">const</span> b1 = &amp;a;        <span class="comment">//顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* b2 = &amp;a;       <span class="comment">//底层const，b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b3 = <span class="number">20</span>;            <span class="comment">//顶层const，b3是常量不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> b4 = &amp;a;  <span class="comment">//前一个const为底层，后一个为顶层，b4不可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b5 = a;           <span class="comment">//用于声明引用变量，都是底层constCopy to clipboardErrorCopied</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>区分作用</strong></p>
<ul>
<li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li>
<li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;<span class="keyword">int</span> <span class="keyword">const</span> a;<span class="keyword">const</span> <span class="keyword">int</span> *a;<span class="keyword">int</span> *<span class="keyword">const</span> a;Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>int const a和const int a均表示定义常量类型a。</li>
<li>const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</li>
<li>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</li>
</ul>
<h2 id="6-2-static关键字的作用"><a href="#6-2-static关键字的作用" class="headerlink" title="6.2.  static关键字的作用"></a>6.2.  static关键字的作用</h2><ol>
<li><p>全局静态变量</p>
<ul>
<li>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</li>
<li>内存中的位置：静态存储区（数据段），在整个程序运行期间一直存在。</li>
<li>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</li>
<li>作用域：全局静态变量在声明他的<code>文件之外</code>是<code>不可见</code>的，准确地说是从定义之处开始，到文件结尾。</li>
</ul>
</li>
<li><p>局部静态变量</p>
<ul>
<li>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</li>
<li>内存中的位置：静态存储区</li>
<li>初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</li>
<li>作用域：作用域仍为<code>局部作用域</code>，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并<code>没有销毁</code>，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数<u>再次被调用</u>，并且<code>值不变</code>；</li>
</ul>
</li>
<li><p>静态函数 （==限定在局部==）</p>
<ul>
<li>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</li>
<li>函数的<code>实现</code>使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</li>
<li>warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</li>
</ul>
</li>
<li><p>类的静态成员</p>
<ul>
<li>在类中，<code>静态成员可以实现多个对象之间的数据共享</code>，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。<u>对多个对象来说，静态数据成员只存储一处，供所有对象共用。不存在对象内存里。</u></li>
</ul>
</li>
<li><p>类的静态函数</p>
<ul>
<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>
<li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>
</ul>
</li>
</ol>
<h2 id="6-3-extern"><a href="#6-3-extern" class="headerlink" title="6.3.  extern"></a>6.3.  extern</h2><ol>
<li><p>extern关键字可以置于变量或者函数前，以<u>标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时<code>在其他模块中寻找其定义</code>。这里起到的是声明作用范围的用处。</u></p>
</li>
<li><p>extern “C”</p>
<ul>
<li>c和c++对同一个函数经过编译后生成的函数名是不同的，由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在c++中调用一个使用c语言编写的模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误。</li>
</ul>
</li>
</ol>
<h2 id="6-4-inline"><a href="#6-4-inline" class="headerlink" title="6.4.  inline"></a>6.4.  inline</h2><ul>
<li><p>inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为<code>内联函数</code>。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline<code>必须与函数定义放在一起</code>才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。</p>
</li>
<li><p><strong>inline和宏的区别</strong></p>
<ol>
<li>内联函数在<code>编译时</code>展开，而宏在预编译时展开</li>
<li>在编译的时候，内联函数直接被<code>嵌入到目标代码</code>中去，而宏只是一个简单的文本替换。</li>
<li>内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</li>
<li>宏不是函数，而inline是<code>函数</code></li>
<li>宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现<code>二义性</code>。而内联函数不会出现二义性。</li>
<li>inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</li>
</ol>
</li>
<li><p>在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a>涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>放在合适的位置）。</p>
</li>
</ul>
<h2 id="6-5-c-中四种cast转换"><a href="#6-5-c-中四种cast转换" class="headerlink" title="6.5.  c++中四种cast转换"></a>6.5.  c++中四种cast转换</h2><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<ol>
<li><p>const_cast</p>
<ul>
<li>用于将const变量转为非const</li>
<li>只能去掉<code>底层</code>const  （<code>靠左</code>的const：const int* p = &amp;a (修饰指针，指向可改，值不可改)）</li>
</ul>
</li>
<li><p>==static_cast==</p>
<ul>
<li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态<code>向上</code>转化，如果向下转能成功但是不安全，结果未知；</li>
<li>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</li>
<li>任何具有明确意义的类型转换，只要不包含底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成douuble类型就能使表达式执行浮点数除法；</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行强制类型转换以便执行浮点数除法</span></span><br><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>当需要把一个<code>较大的算数类型赋值给较小的类型</code>时，static_cast非常有用。此时强制转换类型告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型并且试图赋值给较小的类型时，就会给出警告信息，但是当我们执行了显式的类型转换后，警告信息就会被关闭了。</li>
<li>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以时用static_cast找回存在与void*的指针中的值:</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d; <span class="comment">//正确，任何非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="comment">//正确：将void*转换回初始的指针类型</span></span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(P);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>当我们把指针存放在void*中，并且使用static_cast将其强制转换为原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与其原始的地址相等，因此我们必须确保转换后的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。</li>
</ul>
</li>
<li><p>dynamic_cast</p>
<ul>
<li>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</li>
<li>向上转换：指的是子类向基类的转换</li>
<li>向下转换：指的是基类向子类的转换</li>
<li>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</li>
<li>‘dynamic_cast’只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。检测在运行时进行。（用于将==父类指向子类的指针==转换为==子类指针==， 前提是本身自己是子类）</li>
<li>如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.</li>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span> <span class="function"><span class="keyword">virtual</span> <span class="title">dummy</span><span class="params">()</span> </span>{} };</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base* b2 = <span class="keyword">new</span> Base;</span><br><span class="line"></span><br><span class="line">Derived* d1 = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(b1);     <span class="comment">// succeeds</span></span><br><span class="line">Derived* d2 = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(b2);     <span class="comment">// fails: returns</span></span><br><span class="line"></span><br><span class="line"><span class="string">'NULL'</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果一个引用类型执行了类型转换并且这个转换是不可能的，一个bad_cast的异常类型被抛出： </li>
<li>代码:</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span> <span class="function"><span class="keyword">virtual</span> <span class="title">dummy</span><span class="params">()</span> </span>{} };</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base* b2 = <span class="keyword">new</span> Base;</span><br><span class="line"></span><br><span class="line">Derived d1 = <span class="keyword">dynamic_cast</span>&lt;Derived &amp;*&gt;(b1);     <span class="comment">// succeeds</span></span><br><span class="line">Derived d2 = <span class="keyword">dynamic_cast</span>&lt;Derived &amp;*&gt;(b2);     <span class="comment">// fails: exception</span></span><br><span class="line"></span><br><span class="line">Thrown</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>被转换对象obj的类型T1必须是多态类型，即T1必须公有继承自其它类，或者T1拥有虚函数（继承或自定义）。若T1为非多态类型，使用dynamic_cast会报编译错误</li>
</ul>
</li>
<li><p>reinterpret_cast</p>
<ul>
<li>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
<li>reinterpret_cast通常为运算对象的<code>位模式</code>提供较低层次上的重新解释。举个例子，加入有如下的转换</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。例如：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(pc)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为什么不使用C的强制转换？</p>
<ul>
<li>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li>
</ul>
</li>
</ol>
<h2 id="6-6-volatile关键字的作用"><a href="#6-6-volatile关键字的作用" class="headerlink" title="6.6.  volatile关键字的作用"></a>6.6.  volatile关键字的作用</h2><ul>
<li><p>volatile关键字是<u>防止在共享的空间发生读取的错误。只保证其可见性，不保证原子性；使用volatile指每次从内存中读取数据，而不是从编译器优化后的缓存中读取数据</u>，简单来讲就是防止编译器优化。</p>
</li>
<li><p>在单任务环境中，如果在两次读取变量之间不改变变量的值，编译器就会发生优化，会将RAM中的值赋值到寄存器中；由于访问寄存器的效率要高于RAM，所以在需要读取变量时，直接寄存器中获取变量的值，而不是从RAM中。</p>
</li>
<li><p>在多任务环境中，虽然在两次读取变量之间不改变变量的值，在一些情况下变量的值还是会发生改变，比如在发生中断程序或者有其他的线程。这时候如果编译器优化，依旧从寄存器中获取变量的值，修改的值就得不到及时的响应（在RAM还未将新的值赋值给寄存器，就已经获取到寄存器的值）。</p>
</li>
<li><p>要想<code>防止编译器优化</code>，就需要在声明变量时加volatile关键字，加关键字后，就在RAM中读取变量的值，而不是直接在寄存器中取值。</p>
</li>
</ul>
<h2 id="6-7-override关键字作用："><a href="#6-7-override关键字作用：" class="headerlink" title="6.7.  override关键字作用："></a>6.7.  override关键字作用：</h2><ul>
<li><p>如果派生类在虚函数声明时使用了override描述符，那么该函数==必须重载其基类中的同名函数==，否则代码将无法通过编译</p>
</li>
<li><p>例如如下代码</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This program has a subtle error in the virtual functions.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">const</span></span>{cout &lt;&lt; <span class="string">"This is Base::functionA"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">(<span class="keyword">long</span> arg)</span> <span class="keyword">const</span></span>{ cout &lt;&lt; <span class="string">"This is Derived::functionA"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Base pointer b points to a Derived class object.</span></span><br><span class="line">    shared_ptr&lt;Base&gt;b = make_shared&lt;Derived&gt;();</span><br><span class="line">    <span class="comment">// Call virtual functionA through Base pointer.</span></span><br><span class="line">    b-&gt;<span class="built_in">functionA</span>(<span class="number">99</span>);   <span class="comment">//最终的输出结果为"This is Base::functionA"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在该程序中，Base 类<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a> b 指向 Derived 类对象。因为 functionA 是一个虚函数，所以一般可以认为 b 对 functionA 的调用将选择 Derived 类的版本。</p>
<p>但是，从程序的输出结果来看，实际情况并非如此。其原因是这两个函数有不同的形参类型，所以 Derived 类中的 functionA 不能覆盖 Base 类中的 functionA。基类中的函数釆用的是 int 类型的参数，而派生类中的函数釆用的则是 long 类型的参数，因此，Derived 类中的 functionA 只不过是重载 Base 类中的 functionA 函数。</p>
</blockquote>
</li>
<li><p>要确认派生类中的成员函数覆盖基类中的虚成员函数，可以在派生类的函数原型（如果函数以内联方式写入，则在函数头）后面加上 override 关键字。override 关键字告诉编译器，该函数应覆盖基类中的函数。如果该函数实际上没有覆盖任何函数，则会导致编译器错误。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This program demonstrates the use of the override keyword.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">const</span> </span>{ cout &lt;&lt; <span class="string">"This is Base::functionA"</span> &lt;&lt; endl;}</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">functionA</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>{ cout &lt;&lt; <span class="string">"This is Derived::functionA"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Base pointer b points to a Derived class object.</span></span><br><span class="line">    shared_ptr&lt;Base&gt;b = make_shared&lt;Derived&gt;();</span><br><span class="line">    <span class="comment">// Call virtual functionA through Base pointer.</span></span><br><span class="line">    b-&gt;<span class="built_in">functionA</span>(<span class="number">99</span>);   <span class="comment">//This is Derived::functionA</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="6-8-final关键字作用"><a href="#6-8-final关键字作用" class="headerlink" title="6.8.  final关键字作用"></a>6.8.  final关键字作用</h2><ol>
<li><p><code>禁用继承</code></p>
<ul>
<li>C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</li>
<li>实例如下：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> <span class="keyword">final</span>{</span></span><br><span class="line"> <span class="comment">//......</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>禁用重写</code></p>
<ul>
<li>C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Supe</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SomeMethod</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="6-9-strcpy和strlen"><a href="#6-9-strcpy和strlen" class="headerlink" title="6.9. strcpy和strlen"></a>6.9. strcpy和strlen</h2><h3 id="strlen和sizeof区别？"><a href="#strlen和sizeof区别？" class="headerlink" title="strlen和sizeof区别？"></a><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=16%E3%80%81strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB%EF%BC%9F">strlen和sizeof区别？</a></h3><ul>
<li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li>
<li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li>
<li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>{</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"name"</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(str); <span class="comment">// 取的是指针str的长度，是8  在64位的编译环境下的</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>strcpy是字符串拷贝函数，原型：</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *destinin, <span class="keyword">char</span> *source, <span class="keyword">int</span> maxlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><p>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
<p><code>sizeof计算字符串长度会加1</code>，自动添加’\0’</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{ </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> c[] = <span class="string">"12"</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(c) &lt;&lt; endl;<span class="comment">//输出3</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">strlen</span>(c);       <span class="comment">//输出2</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">char</span> arr[<span class="number">10</span>]={<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>};</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" strlen(arr)=%d   sizeof(arr)=%d\n"</span>,<span class="built_in">strlen</span>(arr),<span class="built_in"><span class="keyword">sizeof</span></span>(arr)); <span class="comment">//输出strlen 3， sizeof 10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-10-memmove-和-memcpy的区别"><a href="#6-10-memmove-和-memcpy的区别" class="headerlink" title="6.10. memmove 和 memcpy的区别"></a>6.10. memmove 和 memcpy的区别</h2><ol>
<li><p>memcpy和memmove都是C语言中的库函数，在头文件string.h中，作用是拷贝一定长度的内存的内容，原型分别如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>; </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，<code>memmove保证拷贝的结果是正确的</code>，memcpy不保证拷贝的结果的正确。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span></span>{</span><br><span class="line">  <span class="built_in">assert</span>(dest != <span class="literal">NULL</span> || src != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span> (dst &lt; src)（memcpy没有<span class="keyword">if</span>判断）{</span><br><span class="line">      <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)dest;</span><br><span class="line">      <span class="keyword">char</span> *q = (<span class="keyword">char</span> *)src;</span><br><span class="line">      <span class="keyword">while</span> (count--){</span><br><span class="line">        *p++ = *q++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)dest + count;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span> *)src + count;</span><br><span class="line">    <span class="keyword">while</span> (count--){</span><br><span class="line">      *--p = *--q;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="7-多态、虚函数"><a href="#7-多态、虚函数" class="headerlink" title="7.   多态、虚函数"></a>7.   多态、虚函数</h1><h2 id="7-1-虚函数和多态"><a href="#7-1-虚函数和多态" class="headerlink" title="7.1.  虚函数和多态"></a>7.1.  虚函数和多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p>
<ul>
<li><p>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。虚函数表存放在代码段的只读数据段。</p>
</li>
<li><p>当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
</li>
<li><p>子类重写父类虚函数后，父类虚函数仍然可以通过子类调用。</p>
</li>
<li><p>不同子类继承同一父类时虚函数表不同。同一子类创建不同对象时虚函数表相同。</p>
</li>
<li><p>继承了多个父类会有多个虚函数表指针，如果父类有2张虚函数表，子类也会继承2张虚函数表。子类自己的虚函数表加在第一张虚函数表之后。</p>
</li>
</ul>
<p>虚函数存储在对象开头，占4字节（32位）</p>
<p>同一个类，创造的不同对象，其虚指针的值是一样的，全都是指向该类的虚函数表。</p>
<h2 id="7-2-虚继承"><a href="#7-2-虚继承" class="headerlink" title="7.2.  虚继承"></a>7.2.  <a target="_blank" rel="noopener" href="https://codeantenna.com/a/xMPwa2Aj7L">虚继承</a></h2><p><code>虚继承</code>主要用于<code>菱形</code>形式的继承形式，是为了在多继承的时候避免引发歧义，避免重复拷贝。重要概念是 <strong>虚基类指针(vbptr)</strong> 和 **虚基类表(vftable)**。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/image-20220316214523810.png" alt="image-20220316214523810" style="zoom:67%;">

<ul>
<li><code>菱形继承</code>带来的问题： 从成员模型可以看出来，菱形继承有<strong>数据冗余</strong>和<strong>数据二义性</strong>的问题。在最下面的一层D类中，对象会有<strong>2份</strong>最上层对象A类里面的成员</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/image-20220316214710539.png" alt="image-20220316214710539" style="zoom:67%;">

<ul>
<li>再来看一个例子，来看菱形继承所带来的问题</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	string No;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Person{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string id;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string course;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">//这样就会有二义性无法明确知道访问的是哪一个</span></span><br><span class="line">	Course c;</span><br><span class="line">	c.name = <span class="string">"tom"</span>;</span><br><span class="line">	<span class="comment">// 这样就可以解决二义性的问题， 但是数据冗余问题无法解决</span></span><br><span class="line">	c.Student::name = <span class="string">"wang"</span>;</span><br><span class="line">	c.Teacher::name = <span class="string">"lili"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>菱形虚拟继承</code></p>
<ul>
<li><strong>菱形虚拟继承的概念</strong>：<br>菱形虚拟继承就是在多个类同时继承一个类的时候加上virtual关键字，使得父类的变量在全局只有一份，多个继承父类的类可以同时找到它并修改它<br>作用就是： A类是父类， B,C类继承父类， D类继承B,C类。 那么A类的成员变量就在B和C类中，但是D类继承B,C类，A类的成员变量就在D类中有两份。菱形虚拟继承的作用是：<strong>使得A类的成员变量在对象中只有一份</strong>。<br><strong>菱形虚拟继承的做法</strong>：<br><strong>在多个类同时需要继承同一个父类的时候，在继承方式前加上virtual关键字</strong>。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span>  <span class="keyword">virtual</span> <span class="keyword">public</span> Person   <span class="comment">//学生类需要继承人这个类     加上virtual关键字，虚拟继承{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	string No;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person    <span class="comment">//老师类也需要继承人这个类     加上virtual关键字，虚拟继承{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string id;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string course;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>{</span><br><span class="line">	Course c;</span><br><span class="line">	c.name = <span class="string">"tom"</span>; <span class="comment">//把name改为tom,所有类里面的name全都该为tom</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>总结：这样子，<strong>就不会产生数据二义性了，和数据冗余了</strong>，因为是继承，所有所有类里面都含有基类变量name。但是菱形虚拟继承做的是在所有类里面的name变量都是同一个。所有你Course类里面的name改变，所有类成员里面的name变量都是”tom”</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20220226100811258-2132271296.png" alt="img"></p>
<ul>
<li>内存顺序：A的虚函数指针，A中Base偏移，A的数据，B的虚函数指针，B中Base偏移，B的数据，Base虚函数指针，Base数据。</li>
</ul>
<h2 id="7-3-静态函数和虚函数的区别"><a href="#7-3-静态函数和虚函数的区别" class="headerlink" title="7.3.  静态函数和虚函数的区别"></a>7.3.  静态函数和虚函数的区别</h2><ul>
<li>静态函数在<code>编译的时候就已经确定运行时机</code>，虚函数在<code>运行的时候动态绑定</code>。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</li>
</ul>
<h2 id="7-4-虚函数表具体是怎样实现运行时多态的"><a href="#7-4-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="7.4.  虚函数表具体是怎样实现运行时多态的?"></a>7.4.  虚函数表具体是怎样实现运行时多态的?</h2><ul>
<li>子类若重写父类虚函数，<code>虚函数表中，该函数的地址会被替换</code>，对于存在虚函数的类的对象，在VS中，<code>对象的对象模型的头部存放指向虚函数表的指针</code>，通过该机制实现多态。</li>
</ul>
<h2 id="7-5-纯虚函数"><a href="#7-5-纯虚函数" class="headerlink" title="7.5.  纯虚函数"></a>7.5.  <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-virtual-functions.html">纯虚函数</a></h2><ul>
<li><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类<code>都要</code>定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译器要求在派生类中<code>必须予以重写</code>以实现多态性。同时含有纯虚拟函数的类称为<code>抽象类</code>，它<code>不能生成对象</code>。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p>
</li>
</ul>
<h2 id="7-6-抽象类"><a href="#7-6-抽象类" class="headerlink" title="7.6.  抽象类"></a>7.6.  抽象类</h2><ol>
<li><p><strong>抽象类的定义</strong>： 称带有纯虚函数的类为抽象类。</p>
</li>
<li><p><strong>抽象类的作用</strong>： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来<code>为派生类提供一个公共的根</code>，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
</li>
<li><p><strong>使用抽象类时注意：</strong></p>
<p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。<code>如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类</code>。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
</li>
</ol>
<h2 id="7-7-重载、覆盖（重写）、隐藏（重定义）"><a href="#7-7-重载、覆盖（重写）、隐藏（重定义）" class="headerlink" title="7.7.  重载、覆盖（重写）、隐藏（重定义）"></a>7.7.  重载、覆盖（重写）、隐藏（重定义）</h2><ol>
<li><p><strong>重载：</strong></p>
<p>两个函数名相同，但是<code>参数列表</code>不同（个数，类型），返回值类型没有要求，在同一作用域中。</p>
</li>
<li><p><strong>重写：</strong></p>
<ul>
<li><code>子类继承了父类</code>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。这样的函数地址是在运行期间绑定。需要函数返回值也相同。</li>
<li>（如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译）</li>
</ul>
</li>
<li><p><strong>隐藏：</strong>（重定义）</p>
<ul>
<li>如果派生类的函数与基类的函数同名，但参数不同，则无论有无virtual关键字，<code>基类的函数都被隐藏</code>。不存在子类和父类的同名函数重载。==（子和父的函数有不同的地方，那么肯定隐藏父的）==</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏。==（子和父的函数完全相同，基类没有virtual，则父中虚函数被隐藏）==</li>
</ul>
</li>
</ol>
<h2 id="7-8-重写override的函数中包含有默认参数的情况，会发生动态绑定吗？"><a href="#7-8-重写override的函数中包含有默认参数的情况，会发生动态绑定吗？" class="headerlink" title="7.8.  重写override的函数中包含有默认参数的情况，会发生动态绑定吗？"></a>7.8.  重写override的函数中包含有默认参数的情况，会发生动态绑定吗？</h2><p>因为默认参数的值要在<code>编译时确定</code>，所以是<code>early binding</code>，不会发生动态绑定。？？</p>
<p>（子类的默认参数值不会用上）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k=<span class="number">1</span>)</span> </span>{}    </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  p-&gt;<span class="built_in">f</span>();<span class="comment">//报错</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果基类也有默认参数，则可以运行子类函数（但是参数为父类默认参数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k=<span class="number">2</span>)</span> </span>{</span><br><span class="line">    cout &lt;&lt; k;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k=<span class="number">1</span>)</span> </span>{   </span><br><span class="line">    cout &lt;&lt; k;</span><br><span class="line">    cout &lt;&lt; <span class="string">"666"</span>;</span><br><span class="line">  } </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  p-&gt;<span class="built_in">f</span>();<span class="comment">//输出2 666</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    cout &lt;&lt; k;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> k=<span class="number">1</span>)</span> </span>{   </span><br><span class="line">    cout &lt;&lt; k &lt;&lt; endl;;</span><br><span class="line">    cout &lt;&lt; <span class="string">"666"</span>;</span><br><span class="line">  } </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  p-&gt;<span class="built_in">f</span>(<span class="number">2</span>);<span class="comment">//输出2 666</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-9-多继承情况下的内存布局？为什么会有自适应偏移？"><a href="#7-9-多继承情况下的内存布局？为什么会有自适应偏移？" class="headerlink" title="7.9.  多继承情况下的内存布局？为什么会有自适应偏移？"></a>7.9.  <a target="_blank" rel="noopener" href="https://m.nowcoder.com/answer/764869?tagId=&amp;pos=1&amp;type=0&amp;onlyWrong=false&amp;source=home">多继承情况下的内存布局？</a>为什么会有自适应偏移？</h2><p>对于多继承情况</p>
<p>考虑示例代码</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> {</span>...};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> {</span>...};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2 {...};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="有如下内存布局"><a href="#有如下内存布局" class="headerlink" title="有如下内存布局"></a>有如下内存布局</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/202203111538412.png" alt="image-20220311153833294"></p>
<p>首先出现的是==派生类Derived类的虚表指针vptr==</p>
<blockquote>
<p>（这里插入一个提醒：</p>
<p>一直以来vptr都被国人翻译为虚函数表指针</p>
<p>但是vtbl英文原文是virtual table并非virtual function table</p>
<p>为什么呢</p>
<p>因为这个表不只是为了虚函数而准备的</p>
<p>一切虚拟化技术都会用这个表 包括 虚继承 RTTI等</p>
<p>所以当类本身与其直接间接基类内都未定义任何虚函数时也是有可能有虚表的</p>
<p>典型就是当前类继承了一个虚基类..提醒结束）</p>
</blockquote>
<p>其次是<u>==第一直接基类的数据成员==</u></p>
<p>然后是==第二直接基类的虚表指针vptr==</p>
<p>再次是==第二直接基类的数据成员==</p>
<p>如果还有后继直接基类 那么依此类推</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li><p>为何偏移0处是Derived类的vptr，而不是Base1的vptr</p>
<blockquote>
<p><code>因为非虚继承第一直接基类Base1与派生类Derived的基地址是一致的</code></p>
<p>==Derived的内存结构正是从Base1开始==</p>
<p>而对于    </p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line">pb1-&gt;<span class="built_in">polymorphicFunction</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>这样的多态引用</p>
<p>事实上我们也是用的Derived的虚表vtbl</p>
<p>因为Derived的vtbl和Base1的vtbl已经==融为一体==了</p>
<p>也就是说从Derived的vtbl中完全可以查到从Base1继承下来的虚函数</p>
<p>以及覆盖Base1的虚函数</p>
</blockquote>
</li>
<li><p>对于Base2来说</p>
<blockquote>
<p>事实上图中所示的Base2::vptr并不是指向Base2类的vtbl</p>
<p>而是指向Derived类的vtbl中的一个thunk地址</p>
<p>这个所谓的thunk地址又指向一段汇编码</p>
<p>这段thunk汇编码负责做两件事：</p>
<ol>
<li><p>跳转到vtbl中正确的虚函数(也就是Derived的虚函数)地址所在的内存单元</p>
</li>
<li><p>修改this指针使其指向Derived对象，并传入上一步检索到的虚函数中</p>
</li>
</ol>
<p><code>通过这个thunk策略</code></p>
<p><code>编译器实现了C++的多态性</code></p>
<p>举个例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pb2;</span><br></pre></td></tr></tbody></table></figure>

<p>此时使用pb2调用虚析构函数时</p>
<p>通过Base2::vptr跳转到了thunk汇编代码</p>
<p>执行thunk后跳转到vtbl中Derived::~Derived()所在的槽位</p>
<p>然后把当前指向Base2子对象部分的的this指针</p>
<p>添加适当偏移使其指向Derived对象的内存首地址</p>
<p>然后传入并调用Derived::~Derived()</p>
<p>从而实现了Base2 *pb2和事实对象类Derived的动态绑定</p>
</blockquote>
</li>
</ul>
<p><u>父类1的虚函数表-父类1成员-父类2的虚函数表-父类2成员。。。</u></p>
<p><u>（派生类自己的虚函数记录在第一张虚函数表末尾，如果父类有2张虚函数表，则子类会继承2张虚函数表）</u></p>
<h3 id="C-虚函数表图解"><a href="#C-虚函数表图解" class="headerlink" title="C++ 虚函数表图解"></a><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15295315/2999213">C++ 虚函数表图解</a></h3><h3 id="虚表布局设计思想："><a href="#虚表布局设计思想：" class="headerlink" title="虚表布局设计思想："></a>虚表布局设计思想：</h3><ol>
<li><p>表结构保护了Base1和Base2这些直接基类的vtbl结构，这样就能保持执行多态操作时的一致性，按照相应基类中虚函数的声明顺序完成固定偏移就能寻址到想要的虚函数</p>
</li>
<li><p>将派生类覆盖了的虚函数叠加到第一直接基类Base1上面，符合Derived和Base1内存空间偏移一致的设计惯例。同时也<code>使得Base1中不需要thunk来完成跳转</code></p>
</li>
<li><p>非第一直接基类的vtbl区域里被覆盖的虚函数都需要<code>thunk来处理</code>跳转以及this指针的重定位</p>
</li>
</ol>
<h3 id="c-多重继承的子类为何要使用多个虚函数表？"><a href="#c-多重继承的子类为何要使用多个虚函数表？" class="headerlink" title="c++多重继承的子类为何要使用多个虚函数表？"></a>c++多重继承的子类为何要使用多个虚函数表？</h3><p>如果基类的虚函数表是<code>分开</code>2个的话，那上面的将父类指针指向子类对象的操作，<code>编译器只需要做一些指针偏移</code>，就可以得到正确的结果。把基类对象在子类对象的内存布局中完全分开可以更高效地实现父子类之间的转换。</p>
<h2 id="7-10-同时定义了两个函数，一个带const，一个不带，会有问题吗？"><a href="#7-10-同时定义了两个函数，一个带const，一个不带，会有问题吗？" class="headerlink" title="7.10. 同时定义了两个函数，一个带const，一个不带，会有问题吗？"></a>7.10. 同时定义了两个函数，一个带const，一个不带，会有问题吗？</h2><p>不会，这==相当于函数的重载==。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span> </span>{}</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>{} </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>（这里的两个函数指的是一个类中两个成员函数，带const，const是放在函数后面的，也就是对this指针做const限定。所以说是重载）</p>
<h2 id="7-11-动态绑定"><a href="#7-11-动态绑定" class="headerlink" title="7.11. 动态绑定"></a>7.11. 动态绑定</h2><h3 id="C-中的静态绑定和动态绑定"><a href="#C-中的静态绑定和动态绑定" class="headerlink" title="C++中的静态绑定和动态绑定"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></h3><ul>
<li><p>找到<code>函数名对应的地址</code>，然后将<code>函数调用处用该地址替换</code>，这称为函数绑定，或符号决议。</p>
</li>
<li><p>一般情况下，在<code>编译期间（包括链接期间）就能完成符号决议</code>，不用等到程序执行时再进行额外的操作，这称为静态绑定。如果编译期间不能完成符号决议，就必须在<code>程序执行期间完成</code>，这称为动态绑定。</p>
</li>
</ul>
<blockquote>
<ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
</blockquote>
<p>从上面的定义也可以看出，<code>非虚函数一般都是静态绑定</code>，而==虚函数都是动态绑定==（如此才可实现多态性）。<br>先看代码和运行结果：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{ std::cout &lt;&lt; <span class="string">"A::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{ std::cout &lt;&lt; <span class="string">"B::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{ std::cout &lt;&lt; <span class="string">"C::func()\n"</span>; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>==动态类型可以更改 静态类型不可修改==</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br></pre></td></tr></tbody></table></figure>

<p> 如果注释掉类C中的func函数定义，其他不变，即</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() 理由同上；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pc在类C中找不到func的定义，因此到其基类中寻找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//A::func() 原因也解释过了；</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果为A中的void func()函数添加virtual特性，其他不变，即</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>{ std::cout &lt;&lt; <span class="string">"A::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="静态绑定和动态绑定的区别："><a href="#静态绑定和动态绑定的区别：" class="headerlink" title="静态绑定和动态绑定的区别："></a>静态绑定和动态绑定的区别：</h3><blockquote>
<ol>
<li>静态绑定发生在编译期，动态绑定发生在运行期；</li>
<li>对象的动态类型可以更改，但是静态类型无法更改；</li>
<li>要想实现动态，必须使用动态绑定；</li>
<li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"E::func()\t"</span>&lt;&lt; i &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> :</span> <span class="keyword">public</span> E{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"F::func()\t"</span> &lt;&lt; i &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">    F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">    E* pe = pf;</span><br><span class="line">    pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">    pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="出现这个现象的原因"><a href="#出现这个现象的原因" class="headerlink" title="出现这个现象的原因"></a>出现这个现象的原因</h4><p>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为<code>缺省参数值都是静态绑定（为了执行效率）</code>，而<code>virtual函数却是动态绑定</code>。</p>
<h1 id="8-函数调用、程序运行、栈"><a href="#8-函数调用、程序运行、栈" class="headerlink" title="8.   函数调用、程序运行、栈"></a>8.   函数调用、程序运行、栈</h1><h2 id="8-1-在main执行之前和之后执行的代码可能是什么？"><a href="#8-1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="8.1.  在main执行之前和之后执行的代码可能是什么？"></a>8.1. <a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=1%E3%80%81-%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"> 在main执行之前和之后执行的代码可能是什么？</a></h2><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li><u>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</u></li>
<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main函数执行之后</strong>：</p>
<ul>
<li><p>全局对象的析构函数会在main函数之后执行；</p>
</li>
<li><p>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</p>
</li>
<li><p><code>__attribute__((destructor))</code></p>
</li>
</ul>
<h3 id="写个函数在main函数执行前先运行"><a href="#写个函数在main函数执行前先运行" class="headerlink" title="写个函数在main函数执行前先运行"></a>写个函数在main函数执行前先运行</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClas</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TestClass</span>();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">TestClass::<span class="built_in">TestClass</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"TestClass"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">TestClass Ts;<span class="comment">//定义个全局变量，让类里面的代码在main之前执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-2-C语言参数压栈顺序？"><a href="#8-2-C语言参数压栈顺序？" class="headerlink" title="8.2.  C语言参数压栈顺序？"></a>8.2.  C语言参数压栈顺序？</h2><p>==从右到左==   <strong>压栈顺序主要考虑出栈读取</strong></p>
<p>printf函数的原型是：printf（const char* format,…）</p>
<p>它是一个不定参函数，那么我们在实际使用中是怎么样知道它的参数个数呢？这就要靠format了，编译器通过format中的%占位符的个数来确定参数的个数。</p>
<p>现在我们假设参数的压栈顺序是从左到右的，这时，函数调用的时候，format最先进栈，之后是各个参数进栈，最后pc进栈，此时，由于format先进栈了，上面压着未知个数的参数，想要知道参数的个数，必须找到format，而要找到format，必须要知道参数的个数，这样就陷入了一个无法求解的死循环了！！</p>
<h2 id="8-3-函数的默认参数为什么必须放在最后"><a href="#8-3-函数的默认参数为什么必须放在最后" class="headerlink" title="8.3.  函数的默认参数为什么必须放在最后"></a>8.3.  函数的默认参数为什么必须放在最后</h2><ol>
<li>结构上：参数从右到左压栈，调用函数时参数从左到右赋值。</li>
<li>应用上：把设定默认值的形参放在最右边可以让函数少传参还能正常执行</li>
</ol>
<h2 id="8-4-函数栈帧内存的分布"><a href="#8-4-函数栈帧内存的分布" class="headerlink" title="8.4.  函数栈帧内存的分布"></a>8.4.  <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017151354">函数栈帧内存的分布</a></h2><p>编程语言离不开函数，函数是对一段代码的封装，往往实现了某个特定的功能，在程序中可以多次调用这个函数。稍有编程经验的同学都知道，函数是由栈实现的，调用对应入栈，退出对应出栈。在写递归函数的时候，如果递归层次太深会出现栈溢出（StackOverFlow）的错误。</p>
<p>“函数栈”包含了对函数调用的基本理解，但是从细节来看，还有很多疑问，例如：</p>
<ul>
<li>函数的栈是如何开辟的？</li>
<li>如何传入参数？</li>
<li>返回值是如何得到的？</li>
</ul>
<p>本文以 C 语言为例，从内存布局、汇编代码的角度来分析函数栈的实现原理。</p>
<h3 id="Linux-进程内存布局"><a href="#Linux-进程内存布局" class="headerlink" title="Linux 进程内存布局"></a>Linux 进程内存布局</h3><p>当程序被执行的时候，Linux 会为其在内存中分配相应的空间以支撑程序的运行，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/bVbj7AB" alt="linux-memory.png"></p>
<p>在虚拟内存中，内存空间被分为多个区域。代码指令保存在文本段，已初始化的全局变量 <code>global</code> 保存在数据段，程序运行中动态申请的内存<code>malloc(10 * char())</code>放在堆中，而函数执行的时候则在栈中开辟空间运行。例如<code>main</code>函数便占有一个函数栈，其中的变量<code>i</code>和<code>ip</code>都保存在<code>main</code>的栈空间中。</p>
<p>函数的栈空间有个名字叫做 <code>栈帧</code>，下面就具体了解一下栈帧。</p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>下图是栈的结构。图中右侧是栈空间，其中有多个栈帧。从上往下由较早的栈帧到较新的栈帧，由于栈是从高地址往低地址生长的，所以最新的栈永远在最下面，即栈顶。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/bVbj7B9" alt="stack-frame.png"></p>
<p>图中有两个画出了具体结构的栈帧，分别是函数 A 和函数 B。函数 A 的栈帧最上面有一块省略号标识的区域，其中保存的是上一个栈帧的寄存器值以及函数 A 自己内部创建的局部变量。下面的参数 n 到参数 1 则是函数 A 要传给函数 B 的调用参数。那么函数 B 如何获取？答案是用寄存器。</p>
<p>CPU 计算时会把很多变量放在寄存器中，根据硬件体系的不同，寄存器数量和作用也不同。<u>一般在 x86 32位中，寄存器 <code>%esp</code> 保存了栈指针的值，也就是栈顶，而 <code>%ebp</code> 作为当前栈帧的帧指针，也就是当前栈帧的底部，所以通过 <code>%esp</code> 和 <code>%ebp</code> 就可以知道当前栈帧的头跟尾。除了这两个寄存器，还有其它一些通用寄存器（<code>%eax</code>、<code>%edx</code>等），用于保存程序执行的临时值。</u></p>
<p>了解了寄存器的基本知识后，下面我们就可以知道函数 B 如何获取到函数 A 传给它的参数了。参数 1 的地址是 <code>%ebp + 8</code>，参数 2 的地址是 <code>%ebp + 12</code>，参数 n 的地址是 <code>%ebp + 4 + 4 * n</code>。相信大家已经看明白，通过帧指针往上找就可以取得这些参数，而这些参数之所以在这里当然是函数 A 预先准备好的，关于这一点下文会有例子。</p>
<p>另外在所有参数的最下面保存着 <code>返回地址</code>，这个是在函数 B 返回之后接下来要执行的指令的地址。</p>
<p>看了函数 A 之后，再看看函数 B。在函数 B 的栈帧最上面是 <code>被保存的 %ebp</code>，这个指的是函数 A 的帧指针，毕竟 <code>%ebp</code> 这个寄存器就一个，所以新的函数入栈的时候要先把老的保存起来，等函数出栈再恢复。在这个老的帧指针下面则是其它需要保存的寄存器变量以及函数 B 自己内部用到的局部变量。再往下是 <code>参数构造区域</code>，也就是函数 B 即将调用另一个函数，在这里先把参数准备好。可以看出，函数 B 与函数 A 的栈帧结构是类似的。</p>
<p>了解了栈帧的理论之后，大家可能会觉得很抽象，下面结合具体实例来看栈帧从产生到消亡的过程。</p>
<h3 id="函数调用实例"><a href="#函数调用实例" class="headerlink" title="函数调用实例"></a>函数调用实例</h3><p>下面图是函数 <code>caller</code> 的具体执行过程，左边是 C 代码，中间是汇编码，右边是对应的栈帧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/bVbj7LZ" alt="caller-frame.png"></p>
<p>我们一行一行的来分析，看中间汇编码，上面三行绿色的：</p>
<figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushl %ebp // 保存旧的 %ebp</span><br><span class="line">movl %esp, %ebp // 将 %ebp 设置为 %esp</span><br><span class="line">subl $24, %esp // 将 %esp 减 <span class="number">24</span> 开辟栈空间</span><br></pre></td></tr></tbody></table></figure>

<p>这三行其实是为栈帧做准备工作。第一行保存旧的 <code>%ebp</code>，此时新的栈空间还没有创建，但保存旧的 <code>%ebp</code> 的这一行空间将作为新栈帧的栈底，也就是帧指针，因此第二行将栈指针 <code>%esp</code>（永远指向栈顶）的值设置到 <code>%ebp</code> 上。 第三行将 <code>%esp</code> 下移 24 个字节，这一行其实就是为函数 <code>caller</code> 开辟栈空间了。从图中可以看出，下面的空间用于保存 <code>caller</code> 中的变量以及传给下个函数的参数。有部分空间未使用，这个是为了地址对齐，不影响我们的分析，可以忽略。</p>
<p>在开辟了栈帧之后，就开始执行 <code>caller</code> 内部的逻辑了，<code>caller</code> 首先创建了两个局部变量（<code>arg1</code>和<code>arg2</code>）。对应的汇编代码为 <code>movl $534, -4(%ebp); movl $1057, -8(%ebp)</code>，其中 <code>-4(%ebp)</code> 表示 <code>%ebp - 4</code> 的位置，也就是图中 <code>arg1</code> 所在的位置， <code>arg2</code> 的位置则是 <code>%ebp - 8</code> 的位置。这两行是把 <code>534</code> 和 <code>1057</code> 保存到传送到这两个位置上。</p>
<p>继续往下是这几行：</p>
<figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leal -<span class="number">8</span>(%ebp), %eax // 把 %ebp - <span class="number">8</span> 这个地址保存到 %eax </span><br><span class="line">movl %eax, <span class="number">4</span>(%esp)  // 把 %eax 的值保存到 %esp + <span class="number">4</span> 这个位置上</span><br><span class="line">leal -<span class="number">4</span>(%ebp), %eax  // 把 %ebp - <span class="number">4</span> 这个地址保存到 %eax </span><br><span class="line">movl %eax, ($esp)  // 把 %eax 的值保存到 %esp 这个位置上</span><br></pre></td></tr></tbody></table></figure>

<p>第一行把 <code>%ebp - 8</code> 这个地址保存到 <code>%eax</code> 中，而 <code>%ebp - 8</code> 是 <code>arg2</code> 的地址，下一行把这个地址放到 <code>%esp + 4</code> 这个位置上，也就是图中 <code>&amp;arg2</code> 的那个区域块。其实这一行是在为函数 <code>swap_add</code> 准备参数 <code>&amp;arg2</code>，而下面两行则是准备参数 <code>&amp;arg1</code>。</p>
<p>再下面一行是 <code>call swap_add</code>。这一行就是调用函数 <code>swap_add</code> 了，不过在这之前还需要把返回地址压到栈上，这里的返回地址是函数 <code>swap_add</code> 返回后要接着执行的代码的地址，也就是 <code>int diff = arg1 - arg2</code> 地址。</p>
<p>在调用 <code>swap_add</code> 后用到了其返回值 <code>sum</code> 继续进行计算，我们还不知道返回值是怎么拿到的。在这之前，我们先进入 <code>swap_add</code> 函数，下面是对应的代码执行图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/bVbj7TT" alt="swap_add-frame.png"></p>
<p><code>swap_add</code> 对应的汇编代码的前三行与 <code>caller</code> 类似，同样是保存旧的帧指针，但是因为 <code>swap_add</code> 不需要保存额外的变量，只需要多用一个寄存器 <code>%ebx</code>，所以这里保存了这个寄存器的旧值，但是没有将 <code>%esp</code> 直接下移一段长度的操作。</p>
<p>接下来绿色的两行就是关键了：</p>
<figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="number">8</span>(%ebp), %edx // 从 %ebp + <span class="number">8</span> 取值保存到 %edx</span><br><span class="line">movl <span class="number">12</span>(%ebp), %ecx // 从 %ebp + <span class="number">12</span> 取值保存到 %ecx</span><br></pre></td></tr></tbody></table></figure>

<p>这两行分别是从 <code>caller</code> 中保存参数 <code>&amp;arg1</code> 和 <code>&amp;arg2</code> 的地方取得地址值，并根据地址取得 <code>arg1</code>和<code>arg2</code> 的实际数值。</p>
<p>接下来的 4 行是交换操作，这里就不具体看每一行的逻辑了。</p>
<p>再下面一行 <code>addl %ebx, %eax</code> 是将返回值保存到寄存器 <code>%eax</code> 中，这里非常关键，<strong>函数 <code>swap_add</code> 的返回值保存在 <code>%eax</code> 中</strong>，一会儿 <code>caller</code> 就是从这个寄存器获取的。</p>
<p><code>swap_add</code> 的最后几行是出栈操作，将 <code>%ebx</code> 和 <code>%ebp</code> 分别恢复为 <code>caller</code> 中的值。最后执行 <code>ret</code> 返回到 <code>caller</code> 中。</p>
<p>下面我们继续回到 <code>caller</code> 中，刚才执行到 <code>call swap_add</code>，下面几行是执行 <code>int diff = arg1 - arg2</code>，结果保存在 <code>%edx</code> 中。</p>
<p>最后一行是计算 <code>sum * diff</code>，对应的汇编代码为 <code>imull %edx, %eax</code>。这里是把 <code>%edx</code> 和 <code>%eax</code> 的值相乘并且把结果保存到 <code>%eax</code> 中。在上面的分析中，我们知道 <code>%eax</code> 保存着 <code>swap_add</code> 的返回值，这里还是从 <code>%eax</code> 中取出返回值进行计算，并且把结果继续保存到 <code>%eax</code> 中，而这个值又是 <code>caller</code> 的返回值，这样调用 <code>caller</code> 的函数也可以从这个寄存器中获取返回值了。</p>
<p><code>caller</code> 函数的最后一行汇编代码是 <code>ret</code>，这会销毁 <code>caller</code> 的栈帧并且恢复相应寄存器的旧值。到此，<code>caller</code> 和 <code>swap_add</code> 这个函数的调用过程就全部分析完了。</p>
<p>寄存器ebp和esp来保存栈底地址和栈顶地址</p>
<p>eip专门记录下一条指令的寄存器</p>
<p>每当执行一条指令，eip寄存器加上相应指令的长度，这样每一条指令执行完成后，eip都执向下一条指令的地址。只要能够保存函数调用前，下一句代码的地址，这样在函数执行完成后将这个地址赋值给eip寄存器，就能够回到调用者的位置，这是函数实现的基本依据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg" alt="IMG_256"></p>
<p>\1. 首先从右至左将被调用函数的参数压入栈中</p>
<p>\2. 然后调用call指令保存eip寄存器的值，然后跳转到函数代码</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image039.gif" alt="IMG_256"></p>
<p>\3. 将上一个函数的栈底地址ebp的值压入栈中</p>
<p>\4. 将此时esp的值保存到ebp中，作为该函数的函数栈的栈底地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image041.gif" alt="IMG_256"></p>
<p>\5. 根据函数中局部变量的个数抬高esp的值并初始化这段栈空间</p>
<p>\6. 将其余寄存器的值压栈</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image043.gif" alt="IMG_256"></p>
<p>\7. 执行函数代码</p>
<p>\8. 通过eax或者内存拷贝的方式保存返回值</p>
<p>\9. 将上面保存的寄存器的值出栈</p>
<p>\10. 执行esp = ebp，时esp指向函数栈的栈底</p>
<p>\11. pop ebp 还原之前保存的值，使ebp指向调用者的函数栈栈底</p>
<p>\12. ret 返回或者ret n(n为整数)指令返回到调用者的下一句代码</p>
<h2 id="8-5-C语言是怎么进行函数调用的？"><a href="#8-5-C语言是怎么进行函数调用的？" class="headerlink" title="8.5.  C语言是怎么进行函数调用的？"></a>8.5.  C语言是怎么进行函数调用的？</h2><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。</p>
<ol>
<li><p>将被调用函数的参数按照<code>从右到左的顺序压入栈</code>中,==再把返回地址压栈==</p>
</li>
<li><p>调用call指令保存eip寄存器的值，然后跳转到函数代码</p>
</li>
<li><p>然后把当前函数的esp指针压栈。</p>
</li>
<li><p>将调用者的 %ebp 压入栈</p>
</li>
<li><p>将 %esp 的值赋给 %ebp。</p>
</li>
<li><p>根据函数中局部变量的个数抬高esp的值并初始化这段栈空间</p>
</li>
<li><p>将其余寄存器的值压栈</p>
</li>
</ol>
<h2 id="8-6-C-如何处理返回值？"><a href="#8-6-C-如何处理返回值？" class="headerlink" title="8.6.  C++如何处理返回值？"></a>8.6.  C++如何处理返回值？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37836661/article/details/106490987">写的很好的一个博客</a></p>
<p>执行某个函数时，如果有参数，则在<strong>栈上</strong>为形式参数分配空间（如果是引用类型的参数则类外），继续进入到函数体内部，如果遇到变量，则按情况为变量在不同的存储区域分配空间（如果是static类型的变量，则是在进行编译的过程中已经就分配了空间），函数内的语句执行完后，如果函数没有返回值，则直接返回调用该函数的地方（即执行远点），如果存在返回值，则<strong>先将返回值进行拷贝传回</strong>，再返回执行远点，函数全部执行完毕后，进行退栈操作，将刚才函数内部在栈上申请的内存空间释放掉。</p>
<p><u>函数的返回值用于<strong>初始化在调用函数时创建的临时对象</strong>(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。</u></p>
<blockquote>
<ul>
<li>char（8bit）：寄存器a1</li>
<li>short（16bit）：寄存器ax</li>
<li>int（32bit）：寄存器eax     如果是64位，那么就是存放在eax和edx中了，高位在edx，低位在eax。</li>
<li>double（64bit）：协处理器堆栈</li>
<li>指针、引用：寄存器eax</li>
<li>类的对象且体积超过64bit：主调函数会在函数栈上创建临时对象存放</li>
</ul>
</blockquote>
<h2 id="8-7-C-函数栈空间的最大值"><a href="#8-7-C-函数栈空间的最大值" class="headerlink" title="8.7.  C++函数栈空间的最大值"></a>8.7.  C++函数栈空间的最大值</h2><p>默认是1M，不过可以调整</p>
<h2 id="8-8-C-中的RTTI机制-简书"><a href="#8-8-C-中的RTTI机制-简书" class="headerlink" title="8.8.  C++中的RTTI机制 - 简书"></a>8.8.  <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3b4a80adffa7">C++中的RTTI机制 - 简书</a></h2><p>RTTI(Run Time Type Identification)即==通过运行时类型识别==，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</p>
<p>RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。</p>
<blockquote>
<p>typeid操作符，==返回指针和引用所指的实际类型==；</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is class A."</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is class B."</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>{</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is struct C."</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     <span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">unsigned</span> ui = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line">     <span class="keyword">wchar_t</span> wch = <span class="string">L'b'</span>;</span><br><span class="line">     <span class="keyword">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line">     <span class="keyword">double</span> d = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(s).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// short</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(ui).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// unsigned int</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(i).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// int</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(ch).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// char</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(wch).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// wchar_t</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(f).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// float</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(d).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// double</span></span><br><span class="line">    </span><br><span class="line">     A *pA1 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">     A a2;</span><br><span class="line"></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(pA1).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// class A *</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(a2).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// class A</span></span><br><span class="line"></span><br><span class="line">     B *pB1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(pB1).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// class B *</span></span><br><span class="line"></span><br><span class="line">     C *pC1 = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">     C c2;</span><br><span class="line"></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(pC1).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// struct C *</span></span><br><span class="line">     cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(c2).<span class="built_in">name</span>()&lt;&lt;endl; <span class="comment">// struct C</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>dynamic_cast操作符，==将基类类型的指针或引用安全地转换为其派生类类型的指针或引用==。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is class A."</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is class B."</span>&lt;&lt;endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>{ cout&lt;&lt;<span class="string">"This is C."</span>&lt;&lt;endl; }</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Printt</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"This is Cc."</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">     A *pA = <span class="keyword">new</span> C;</span><br><span class="line">     <span class="comment">//C *pC = pA; // Wrong 编译器会提示错误</span></span><br><span class="line">     C *pC = <span class="keyword">dynamic_cast</span>&lt;C *&gt;(pA);</span><br><span class="line">     <span class="keyword">if</span> (pC != <span class="literal">NULL</span>)</span><br><span class="line">     {</span><br><span class="line">          pC-&gt;<span class="built_in">Print</span>();  <span class="comment">// This is C.</span></span><br><span class="line">          pC-&gt;<span class="built_in">Printt</span>(); <span class="comment">// Tiis is Cc.</span></span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">delete</span> pA;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。</p>
<p>在执行dynamic_cast时，两个type_info会被交给runtime library函数，比较之后告诉我们是否吻合。如果吻合，返回转换后的指针；否则返回nullptr。</p>
<p>在 type_info 类中，拷贝构造函数和赋值运算符重载都被删除（C++11），同时也没有默认的构造函数（一个类只有一个type信息）。==typeid使用友元返回type_info引用。==</p>
<p>程序中创建type_info对象的唯一方法是使用typeid操作符（由此可见，如果把typeid看作函数的话，其应该是type_info的友元）</p>
<p>如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。</p>
<h2 id="8-9-在什么情况下你应该使用dynamic-cast替代虚函数"><a href="#8-9-在什么情况下你应该使用dynamic-cast替代虚函数" class="headerlink" title="8.9.  在什么情况下你应该使用dynamic_cast替代虚函数?"></a>8.9.  在什么情况下你应该使用dynamic_cast替代虚函数?</h2><p>如果我们需要在派生类中增加新的成员函数f，但又无法取得基类的源代码，因而无法在基类中增加相应的虚函数，这时，可以在派生类中增加非虚成员函数。但这样一来，就无法用基类指针调用函数f。如果在程序中需要通过基类指针(如使用该继承层次的某个类中所包含的指向基类对象的指针数据成员p)来调用f，则必须使用dynamic_cast将p转换为指向派生类的指针，才能调用f。也就是说，如果无法为基类增加虚函数，就可以使用dynamic_cast 代替虚函数。</p>
<blockquote>
<p>==由于种种原因（父类不可修改或不可获得）需要使用父类指针调用子类中的非虚函数时==</p>
</blockquote>
<h2 id="8-10-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#8-10-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="8.10. include头文件的顺序以及双引号””和尖括号<>的区别？"></a>8.10. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h2><ul>
<li><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p>
</li>
<li><p>双引号和尖括号的区别：编译器预处理阶段<code>查找头文件的路径</code>不一样。==双引号先对当前文件目录进行查找==</p>
<ol>
<li><p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p><code>当前头文件目录</code>-&gt;编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）-&gt;系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
<li><p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）-&gt;<code>系统变量</code>CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p>
</li>
</ol>
</li>
</ul>
<h2 id="8-11-源码到可执行文件的过程"><a href="#8-11-源码到可执行文件的过程" class="headerlink" title="8.11. 源码到可执行文件的过程"></a>8.11. 源码到可执行文件的过程</h2><ul>
<li><p>预编译(.i)</p>
<p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<ol>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</li>
<li>删除所有的注释，“//”和“/**/”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号。</li>
</ol>
</li>
<li><p>编译(.s)</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ol>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</li>
</ol>
</li>
<li><p>汇编(.o)</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
</li>
<li><p>链接(.exe .out)</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ol>
<li><p>==静态链接==：</p>
<p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中<code>复制这些函数和数据</code>并把它们和应用程序的其它模块<code>组合</code>起来创建最终的可执行文件。</p>
<blockquote>
<p><code>空间浪费</code>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p><code>更新困难</code>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p><code>运行速度快</code>：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
</blockquote>
</li>
<li><p>==动态链接==：</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在<u>程序运行时才将它们链接在一起形成一个完整的程序</u>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<blockquote>
<p><code>共享库</code>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p><code>更新方便</code>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p><code>性能损耗</code>：<u>因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</u></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="9-内存"><a href="#9-内存" class="headerlink" title="9.   内存"></a>9.   内存</h1><h2 id="9-1-new-x2F-delete与malloc-x2F-free的区别是什么"><a href="#9-1-new-x2F-delete与malloc-x2F-free的区别是什么" class="headerlink" title="9.1.  new/delete与malloc/free的区别是什么"></a>9.1.  new/delete与malloc/free的区别是什么</h2><ol>
<li><p>new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数 </p>
<blockquote>
<p>语言不同</p>
</blockquote>
</li>
<li><p>malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理</p>
<blockquote>
<p>new/delete 还可以进行构造和析构</p>
</blockquote>
</li>
<li><p>new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现；</p>
<blockquote>
<p>实现层次的上下关系</p>
</blockquote>
</li>
<li><p>malloc开辟空间类型大小需手动计算，new是由编译器自己计算；</p>
<blockquote>
<p>是否需要手动计算 空间大小</p>
</blockquote>
</li>
<li><p>malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针；</p>
<blockquote>
<p>指针返回类型不同</p>
</blockquote>
</li>
<li><p>malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；</p>
<blockquote>
<p>是否需要手动检查开辟是否成功</p>
</blockquote>
</li>
<li><p>无论释放几个空间大小，free只传递指针，多个对象时delete需加[]</p>
<blockquote>
<p>对于内置类型若new[]但用delete释放时，没有影响，但若是自定义类型如类时，若释放使用 delete时，这时则会只调用一次析构函数，只析构了一个对象，剩下的对象都没有被清理。</p>
</blockquote>
</li>
<li><p>因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；</p>
<blockquote>
<p>是否可以被重载</p>
</blockquote>
</li>
<li><p>对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；</p>
<blockquote>
<p>malloc分配的空间可以再次调整 relloc</p>
</blockquote>
</li>
<li><p><code>对于new/delete若内存分配失败，用户可以指定处理函数或重新制定分配器（new_handler(可以在此处进行扩展)），malloc/free用户是不可以处理的。</code></p>
</li>
</ol>
<h2 id="new和delete是如何实现的？"><a href="#new和delete是如何实现的？" class="headerlink" title="new和delete是如何实现的？"></a><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=9%E3%80%81new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F">new和delete是如何实现的？</a></h2><ul>
<li>new的实现过程是：首先调用名为<strong>operator new</strong>的标准库函数，<code>分配</code>足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个<code>构造</code>函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的<code>指针</code></li>
<li>delete的实现过程：对<code>指针指向</code>的对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li>
</ul>
<h2 id="9-2-free是怎么知道它要free的空间有多大"><a href="#9-2-free是怎么知道它要free的空间有多大" class="headerlink" title="9.2.  free是怎么知道它要free的空间有多大"></a>9.2.  free是怎么知道它要free的空间有多大</h2><p>malloc返回的内存地址<u>前面有一段空间存储了该块内存的长度</u>，一般这段空间是16个字节，<u>在free时，解析传入内存地址的前一段内存空间，就可以得到具体的长度。</u></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/202203111827845.jpeg" alt="img"></p>
<h2 id="9-3-allocator"><a href="#9-3-allocator" class="headerlink" title="9.3.  allocator"></a>9.3.  allocator</h2><p>标准库 allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>
<h2 id="9-4-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#9-4-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="9.4.  malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>9.4.  malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>更详细：<a target="_blank" rel="noopener" href="https://blog.csdn.net/z_ryan/article/details/79950737">https://blog.csdn.net/z_ryan/article/details/79950737</a></p>
<p><strong>内存池</strong></p>
<p>为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；</p>
<p>当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p><strong>Brk,mmap****函数</strong></p>
<p>linux系统向用户提供申请的内存有brk(sbrk)和mmap函数。下面我们先来了解一下这几个函数。</p>
<p>brk() 和 sbrk()</p>
<p>#include &lt;unistd.h&gt;</p>
<p>int brk( const void *addr )</p>
<p>void* sbrk ( intptr_t incr );</p>
<p>两者的作用是扩展heap的上界brk</p>
<p>Brk（）的参数设置为新的brk上界地址，成功返回1，失败返回0；</p>
<p>Sbrk（）的参数为申请内存的大小，返回heap新的上界brk的地址</p>
<p>mmap()</p>
<p>#include &lt;sys/mman.h&gt;</p>
<p>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>int munmap(void *addr, size_t length);</p>
<p>Mmap的第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。</p>
<p>Malloc使用的是mmap的第二种用法（匿名映射）。</p>
<p>Munmap函数用于释放内存。</p>
<p><strong>申请内存</strong></p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。</p>
<p>当申请内存小于128K时，会使用系统函数brk在堆区中分配；</p>
<p>当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<p>栈、映射区内存至顶向下扩展，堆至低向上扩展。</p>
<p><strong>释放内存</strong></p>
<p>当用户使用free函数释放掉的内存，ptmalloc并不会马上交还给操作系统，而是被ptmalloc本身的空闲链表bins管理起来了，这样当下次进程需要malloc一块内存的时候，ptmalloc就会从空闲的bins上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>当释放mmaped chunk上的内存的时候会直接交还给操作系统。</p>
<p><strong>chunk</strong> <strong>内存块的基本组织单元</strong></p>
<p>在 ptmalloc 的实现源码中定义结构体 malloc_chunk 来描述这些块。malloc_chunk 定义如下：</p>
<p>1.struct malloc_chunk { </p>
<p>\2. INTERNAL_SIZE_T   prev_size;  /* Size of previous chunk (if free). */ </p>
<p>\3. INTERNAL_SIZE_T   size;     /* Size in bytes, including overhead. */ </p>
<p>\4. </p>
<p>\5. struct malloc_chunk* fd;      /* double links – used only if free. */ </p>
<p>\6. struct malloc_chunk* bk; </p>
<p>\7. </p>
<p>\8. /* Only used for large blocks: pointer to next larger size. */ </p>
<p>\9. struct malloc_chunk* fd_nextsize;   /* double links – used only if free. */ </p>
<p>\10. struct malloc_chunk* bk_nextsize; </p>
<p>11.}; </p>
<p><strong>主分配区和非主分配区</strong></p>
<p>Allocate的内存分配器中，为了解决多线程锁争夺问题，分为主分配区main_area和非主分配区no_main_area。</p>
<p>　1. 主分配区和非主分配区形成一个环形链表进行管理。</p>
<p>　2. 每一个分配区利用互斥锁使线程对于该分配区的访问互斥。</p>
<p>　3. 每个进程只有一个主分配区，也可以允许有多个非主分配区。</p>
<p>　4. ptmalloc根据系统对分配区的争用动态增加分配区的大小，分配区的数量一旦增加，则不会减少。</p>
<p>　5. 主分配区可以使用brk和mmap来分配，而非主分配区只能使用mmap来映射内存块</p>
<p>　6. 申请小内存时会产生很多内存碎片，ptmalloc在整理时也需要对分配区做加锁操作。</p>
<p>当一个线程需要使用malloc分配内存的时候，会先查看该线程的私有变量中是否已经存在一个分配区。若是存在。会尝试对其进行加锁操作。若是加锁成功，就在使用该分配区分配内存，若是失败，就会遍历循环链表中获取一个未加锁的分配区。若是整个链表中都没有未加锁的分配区，则malloc会开辟一个新的分配区，将其加入全局的循环链表并加锁，然后使用该分配区进行内存分配。当释放这块内存时，同样会先获取待释放内存块所在的分配区的锁。若是有其他线程正在使用该分配区，则必须等待其他线程释放该分配区互斥锁之后才能进行释放内存的操作。</p>
<h2 id="9-5-C-的内存管理是怎样的？"><a href="#9-5-C-的内存管理是怎样的？" class="headerlink" title="9.5.  C++的内存管理是怎样的？"></a>9.5.  C++的内存管理是怎样的？</h2><p>从低地址到高地址，可分为下面几段：</p>
<p>预留内存地址（操作系统维护的内存地址，不可访问）</p>
<p>程序代码区（只读，存代码和一些其他的东西）；</p>
<p>data段（存初始化的全局变量和static变量）； </p>
<p>bss段（存未初始化的全局变量和static变量）； </p>
<p>堆（由低地址向高地址增长，一般new和malloc分配，由程序员分配释放）；</p>
<p>共享库文件（调用的库文件，位于堆和栈之间）从上向下生长； </p>
<p>栈（由高地址向低地址增长，和堆的增长方式相对，对不同的OS来说，栈的初始大小有规定，可以修改，目前默认一般为2M，由编译器自动分配释放）</p>
<p><strong>再上面存的都是操作系统和内核调用的一些内存地址</strong>。</p>
<p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p>
<p>代码段:包括只读存储区（.rodata段）和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。虚函数表存在只读数据段。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image059.jpg" alt="IMG_256"></p>
<h2 id="9-6-栈和堆比较"><a href="#9-6-栈和堆比较" class="headerlink" title="9.6.  栈和堆比较"></a>9.6.  栈和堆比较</h2><h4 id="1-堆和栈的区别"><a href="#1-堆和栈的区别" class="headerlink" title="1. 堆和栈的区别"></a><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB">1. 堆和栈的区别</a></h4><ul>
<li>申请方式不同。<ul>
<li>栈由系统自动分配。</li>
<li>堆是自己申请和释放的。</li>
</ul>
</li>
<li>申请大小限制不同。<ul>
<li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li>
<li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
</ul>
</li>
<li>申请效率不同。<ul>
<li>栈由系统分配，速度快，不会有碎片。</li>
<li>堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
</li>
</ul>
<p>==栈空间默认是4M, 堆区一般是 1G - 4G==</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">堆</th>
<th align="left">栈</th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理方式</strong></td>
<td align="left">堆中资源由程序员控制（容易产生memory leak）</td>
<td align="left">栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr>
<td><strong>内存管理机制</strong></td>
<td align="left">系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td>
<td align="left">只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td>
</tr>
<tr>
<td><strong>空间大小</strong></td>
<td align="left">堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td>
<td align="left">栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）</td>
</tr>
<tr>
<td><strong>碎片问题</strong></td>
<td align="left">对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td>
<td align="left">对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td>
</tr>
<tr>
<td><strong>生长方向</strong></td>
<td align="left">堆向上，向高地址方向增长。</td>
<td align="left">栈向下，向低地址方向增长。</td>
</tr>
<tr>
<td><strong>分配方式</strong></td>
<td align="left">堆都是动态分配（没有静态分配的堆）</td>
<td align="left">栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr>
<td><strong>分配效率</strong></td>
<td align="left">堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td>
<td align="left">栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody></table>
<p><strong>形象的比喻</strong></p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h4 id="2-你觉得堆快一点还是栈快一点？"><a href="#2-你觉得堆快一点还是栈快一点？" class="headerlink" title="2. 你觉得堆快一点还是栈快一点？"></a><a target="_blank" rel="noopener" href="https://interviewguide.cn/#/Doc/Knowledge/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95?id=6%E3%80%81%E4%BD%A0%E8%A7%89%E5%BE%97%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F">2. 你觉得堆快一点还是栈快一点？</a></h4><p>毫无疑问是==栈快==一点。</p>
<p>因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p>
<p>而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要<code>一定的算法寻找合适大小的内存</code>。<u>并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</u></p>
<h2 id="9-7-为什么堆栈增长方向不一样"><a href="#9-7-为什么堆栈增长方向不一样" class="headerlink" title="9.7.  为什么堆栈增长方向不一样"></a>9.7.  为什么堆栈增长方向不一样</h2><p>为了最大程度利用地址空间。</p>
<h2 id="9-8-什么时候会发生段错误"><a href="#9-8-什么时候会发生段错误" class="headerlink" title="9.8.  什么时候会发生段错误"></a>9.8.  什么时候会发生段错误</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35703848/article/details/90670581">https://blog.csdn.net/qq_35703848/article/details/90670581</a></p>
<p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<ol>
<li>使用未经初始化及或已经释放的指针地址，使用野指针:</li>
</ol>
<p>strcpy(s,”abcd”);</p>
<ol start="2">
<li><p>试图修改字符串常量的内容（写入只读的内存地址）</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"samson"</span>;</span><br><span class="line">*str = <span class="string">"cool"</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数组越界</p>
</li>
<li><p>堆栈溢出</p>
</li>
<li><p>错误的访问类型引起</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="string">"hello world"</span>;</span><br><span class="line">    c[<span class="number">1</span>] = <span class="string">'H'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在.rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。</li>
</ul>
</li>
<li><p>访问了不属于进程地址空间的内存</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{ </span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">0xC0000fff</span>; </span><br><span class="line">    *p = <span class="number">10</span>; </span><br><span class="line">}　</span><br></pre></td></tr></tbody></table></figure>

<p>还有一种可能，往受到系统保护的内存地址写数据，最常见的就是给一个指针以0地址；</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i=<span class="number">0</span>; </span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%d"</span>, i);  <span class="comment">/* should have used &amp;i */</span> </span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%d\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>访问了不存在的内存<br> 最常见的情况不外乎解引用空指针了，如：</p>
</li>
</ol>
  <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = null;</span><br><span class="line">*p = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在。</li>
</ul>
<ol start="4">
<li><p>内存越界，数组越界，变量类型不一致等</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{ </span><br><span class="line">	<span class="keyword">char</span> test[<span class="number">1</span>]; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c"</span>, test[<span class="number">10</span>]); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}　</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>这就是明显的数组越界了，或者这个地址根本不存在。</li>
</ul>
</li>
<li><p>试图把一个整数按照字符串的方式输出</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>{ </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}　</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="9-9-内存溢出原因"><a href="#9-9-内存溢出原因" class="headerlink" title="9.9.  内存溢出原因"></a>9.9.  内存溢出原因</h2><p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<p>内存溢出原因：</p>
<ol>
<li><p>内存中<code>加载的数据量过于庞大</code>，如一次从数据库取出过多数据  (new读取几个g的文件)</p>
</li>
<li><p>==递归==调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p>
</li>
<li><p><code>集合类中有对对象的引用，使用完后未清空，使得不能回收</code></p>
</li>
<li><p>代码中存在==死循环或循环==产生过多重复的对象实体</p>
</li>
</ol>
<h2 id="9-10-什么是memory-leak，也就是内存泄漏"><a href="#9-10-什么是memory-leak，也就是内存泄漏" class="headerlink" title="9.10. 什么是memory leak，也就是内存泄漏"></a>9.10. 什么是memory leak，也就是内存泄漏</h2><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，<code>由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费</code>。</p>
<h3 id="内存泄漏的分类："><a href="#内存泄漏的分类：" class="headerlink" title="内存泄漏的分类："></a>内存泄漏的分类：</h3><ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h2 id="9-11-如何判断内存泄漏？"><a href="#9-11-如何判断内存泄漏？" class="headerlink" title="9.11. 如何判断内存泄漏？"></a>9.11. 如何判断内存泄漏？</h2><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是<code>缺少了对应的free/delete</code>。</p>
<p><strong>Linux:</strong></p>
<p>我们一方面可以使用linux环境下的内存泄漏检查工具==Valgrind==,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<p>Valgrind：</p>
<p>编译：g++ -g -o test test.cpp</p>
<p>使用：valgrind –tool=memcheck ./test</p>
<p>可以检测如下问题：</p>
<p>使用未初始化的内存（全局/静态变量初始化为0，局部变量/动态申请初始化为随机值）；</p>
<p>内存读写越界；</p>
<p>内存覆盖（strcpy/strcat/memcpy）；</p>
<p>动态内存管理（申请释放方式不同，忘记释放等）；</p>
<p>内存泄露（动态内存用完后没有释放，又无法被其他程序使用）。</p>
<p><strong>Windows(vs)</strong></p>
<p>#define CRTDBG_MAP_ALLOC //放在程序最前</p>
<p>#include <iostream></iostream></p>
<p>#include &lt;stdlib.h&gt;  </p>
<p>#include &lt;crtdbg.h&gt; </p>
<p>using namespace std;</p>
<p>int main()</p>
<p>{</p>
<p>​    int *a = new int [10];</p>
<p>​    int *p = new int[1000];</p>
<p>​    _CrtDumpMemoryLeaks(); //放在程序最后</p>
<p>​    system(“pause”);</p>
<p>​    return 0;</p>
<p>}</p>
<h2 id="9-12-C-如何处理内存泄漏？"><a href="#9-12-C-如何处理内存泄漏？" class="headerlink" title="9.12. C++如何处理内存泄漏？"></a>9.12. C++如何处理内存泄漏？</h2><p>Linux使用varglind检测</p>
<p>Windows使用CRT</p>
<h2 id="9-13-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#9-13-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="9.13. C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>9.13. C++里是怎么定义常量的？常量存放在内存的哪个位置？</h2><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区(代码段)。</p>
<h2 id="9-14-const-char-arr-x3D-“123”-char-brr-x3D-“123”-const-char-crr-x3D-“123”-char-drr-x3D-“123”的区别是什么"><a href="#9-14-const-char-arr-x3D-“123”-char-brr-x3D-“123”-const-char-crr-x3D-“123”-char-drr-x3D-“123”的区别是什么" class="headerlink" title="9.14. const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”的区别是什么;"></a>9.14. const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”的区别是什么;</h2><p>const char * arr = “123”;</p>
<p>//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</p>
<p>char * brr = “123”;（vs下不加const报错）</p>
<p>//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</p>
<p>const char crr[] = “123”;</p>
<p>//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</p>
<p>char drr[] = “123”;</p>
<p>//字符串123保存在栈区，可以通过drr去修改</p>
<h2 id="9-15-c-中的RAII机制"><a href="#9-15-c-中的RAII机制" class="headerlink" title="9.15. c++中的RAII机制"></a>9.15. c++中的RAII机制</h2><p>RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</p>
<p>由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。<strong>如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。</strong></p>
<p><strong>例子：智能指针，****lock_guard()</strong></p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qianxunslimg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/16/c-ba-gu/">http://example.com/2022/03/16/c-ba-gu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">qianxunslimgのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/airpay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/airpay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianxunslimg</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/qianxunslimg"><i class="fab fa-github"></i><span>My Gitee</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">编程菜鸟,多多指教~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1.   语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-C-%E5%92%8CC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.  C++和C的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2.  面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">1.3.  面向对象的六大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-C-%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">1.4.  C++中，为什么可以函数重载，实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-C-11%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5.  C++11有哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-NULL%E5%92%8Cnullptr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">1.6.  NULL和nullptr的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.7.</span> <span class="toc-text">1.7.  使用初始化列表的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-auto-%E5%92%8C-decltype%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.8.</span> <span class="toc-text">1.8.  auto 和 decltype区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-C-11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.9.</span> <span class="toc-text">1.9.  C++11右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-1-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.9.1. 移动构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-2-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.9.2.</span> <span class="toc-text">1.9.2. 完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-push-back-%E5%92%8Cemplace-back-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">1.10. push_back()和emplace_back()区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-C-11-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">1.11. C++11 Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">1.12. 头文件循环引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E3%80%81%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.</span> <span class="toc-text">2.   重载、模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.  运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. []</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-lt-lt-gt-gt"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3. &lt;&lt;,&gt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-i%E5%92%8Ci-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4. ++i和i++的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5. 函数调用运算符()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6-gt"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6. 成员访问运算符* -&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.  类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-C-11%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.  C++11中的可变参数模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">3.   类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%A9%BA%E7%B1%BB%E5%8D%A0%E5%A4%9A%E5%A4%A7%E5%86%85%E5%AD%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.  空类占多大内存，为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-this%E6%8C%87%E9%92%88%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.  this指针理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.  C++中类成员的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.  C++中struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-C-%E7%B1%BB%E5%86%85%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">3.5.  C++类内可以定义引用数据成员吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">3.6.  一个空类都有什么默认函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Struct-%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">3.7.  Struct 和union的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-C-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">3.8.</span> <span class="toc-text">3.8.  C++如何阻止一个类被实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 说一说你理解的内存对齐以及原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">3.9.1.</span> <span class="toc-text">为什么要进行内存对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-number">3.9.2.</span> <span class="toc-text">内存对齐规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">4. 指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-C-x2F-C-%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.  C&#x2F;C++ 中指针和引用的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2.  野指针是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-c-%E5%9B%9B%E4%B8%AA%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9Ashared-ptr-unique-ptr-weak-ptr-auto-ptr"><span class="toc-number">4.3.</span> <span class="toc-text">4.3.  c++四个智能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">4.4.  智能指针的线程安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9C%A8STL%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AD%98%E5%82%A8auto-ptr"><span class="toc-number">4.5.</span> <span class="toc-text">4.5.  为什么不能在STL容器中存储auto_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.</span> <span class="toc-text">4.6.  智能指针的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.7.</span> <span class="toc-text">4.7.  函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E5%87%BD%E6%95%B0%E5%86%85%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">4.8.  函数内可以返回一个局部变量的引用吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">5. 构造、析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-C-%E4%B8%AD%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.  C++中析构函数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-C-%E4%B8%AD%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E8%83%BD%E5%90%A6%E8%BF%9B%E8%A1%8C%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2.  C++中拷贝赋值函数的形参能否进行值传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97"><span class="toc-number">5.3.</span> <span class="toc-text">5.3.  构造函数可以定义为虚函数吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88C-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">5.4.  为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-const%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD%E4%B9%88"><span class="toc-number">5.4.1.</span> <span class="toc-text">6.1.3. const修饰的函数可以重载么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">5.4.2.</span> <span class="toc-text">6.1.4. 常量引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">5.4.3.</span> <span class="toc-text">6.1.5. 顶层const和底层const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81C-%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">25、C++的顶层const和底层const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">6.2.  static关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-extern"><span class="toc-number">5.6.</span> <span class="toc-text">6.3.  extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-inline"><span class="toc-number">5.7.</span> <span class="toc-text">6.4.  inline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-c-%E4%B8%AD%E5%9B%9B%E7%A7%8Dcast%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.8.</span> <span class="toc-text">6.5.  c++中四种cast转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">6.6.  volatile关键字的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-override%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">5.10.</span> <span class="toc-text">6.7.  override关键字作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="toc-number">5.11.</span> <span class="toc-text">6.8.  final关键字作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-strcpy%E5%92%8Cstrlen"><span class="toc-number">5.12.</span> <span class="toc-text">6.9. strcpy和strlen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.12.1.</span> <span class="toc-text">strlen和sizeof区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-memmove-%E5%92%8C-memcpy%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.13.</span> <span class="toc-text">6.10. memmove 和 memcpy的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%A4%9A%E6%80%81%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">7.   多态、虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">6.1.</span> <span class="toc-text">7.1.  虚函数和多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">6.2.</span> <span class="toc-text">7.2.  虚继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">7.3.  静态函数和虚函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84"><span class="toc-number">6.4.</span> <span class="toc-text">7.4.  虚函数表具体是怎样实现运行时多态的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">7.5.  纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">7.6.  抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89%E3%80%81%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">7.7.  重载、覆盖（重写）、隐藏（重定义）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E9%87%8D%E5%86%99override%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%AD%E5%8C%85%E5%90%AB%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%90%97%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">7.8.  重写override的函数中包含有默认参数的情况，会发生动态绑定吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%87%AA%E9%80%82%E5%BA%94%E5%81%8F%E7%A7%BB%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">7.9.  多继承情况下的内存布局？为什么会有自适应偏移？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%A6%82%E4%B8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.9.1.</span> <span class="toc-text">有如下内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">6.9.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.9.3.</span> <span class="toc-text">C++ 虚函数表图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8%E5%B8%83%E5%B1%80%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">6.9.4.</span> <span class="toc-text">虚表布局设计思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AD%90%E7%B1%BB%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%9F"><span class="toc-number">6.9.5.</span> <span class="toc-text">c++多重继承的子类为何要使用多个虚函数表？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%B8%A6const%EF%BC%8C%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%B8%A6%EF%BC%8C%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">7.10. 同时定义了两个函数，一个带const，一个不带，会有问题吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">6.11.</span> <span class="toc-text">7.11. 动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">6.11.1.</span> <span class="toc-text">C++中的静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">6.11.2.</span> <span class="toc-text">静态绑定和动态绑定的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E8%BF%99%E4%B8%AA%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.11.2.1.</span> <span class="toc-text">出现这个现象的原因</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E3%80%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E3%80%81%E6%A0%88"><span class="toc-number">7.</span> <span class="toc-text">8.   函数调用、程序运行、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">8.1.  在main执行之前和之后执行的代码可能是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%A8main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%85%88%E8%BF%90%E8%A1%8C"><span class="toc-number">7.1.1.</span> <span class="toc-text">写个函数在main函数执行前先运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-C%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">8.2.  C语言参数压栈顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%94%BE%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">7.3.</span> <span class="toc-text">8.3.  函数的默认参数为什么必须放在最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-number">7.4.</span> <span class="toc-text">8.4.  函数栈帧内存的分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">7.4.1.</span> <span class="toc-text">Linux 进程内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7"><span class="toc-number">7.4.2.</span> <span class="toc-text">栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.4.3.</span> <span class="toc-text">函数调用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-C%E8%AF%AD%E8%A8%80%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">8.5.  C语言是怎么进行函数调用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">8.6.  C++如何处理返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-C-%E5%87%BD%E6%95%B0%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.7.</span> <span class="toc-text">8.7.  C++函数栈空间的最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-C-%E4%B8%AD%E7%9A%84RTTI%E6%9C%BA%E5%88%B6-%E7%AE%80%E4%B9%A6"><span class="toc-number">7.8.</span> <span class="toc-text">8.8.  C++中的RTTI机制 - 简书</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8dynamic-cast%E6%9B%BF%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">7.9.</span> <span class="toc-text">8.9.  在什么情况下你应该使用dynamic_cast替代虚函数?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-include%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%8F%8C%E5%BC%95%E5%8F%B7%E2%80%9D%E2%80%9D%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.10.</span> <span class="toc-text">8.10. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.11.</span> <span class="toc-text">8.11. 源码到可执行文件的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%86%85%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">9.   内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-new-x2F-delete%E4%B8%8Emalloc-x2F-free%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.1.</span> <span class="toc-text">9.1.  new&#x2F;delete与malloc&#x2F;free的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">new和delete是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-free%E6%98%AF%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E5%AE%83%E8%A6%81free%E7%9A%84%E7%A9%BA%E9%97%B4%E6%9C%89%E5%A4%9A%E5%A4%A7"><span class="toc-number">8.3.</span> <span class="toc-text">9.2.  free是怎么知道它要free的空间有多大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-allocator"><span class="toc-number">8.4.</span> <span class="toc-text">9.3.  allocator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-malloc%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%A6%E5%A4%96brk%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Cmmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">9.4.  malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">9.5.  C++的内存管理是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E6%A0%88%E5%92%8C%E5%A0%86%E6%AF%94%E8%BE%83"><span class="toc-number">8.7.</span> <span class="toc-text">9.6.  栈和堆比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.0.1.</span> <span class="toc-text">1. 堆和栈的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%A0%E8%A7%89%E5%BE%97%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F"><span class="toc-number">8.7.0.2.</span> <span class="toc-text">2. 你觉得堆快一点还是栈快一点？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%86%E6%A0%88%E5%A2%9E%E9%95%BF%E6%96%B9%E5%90%91%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">8.8.</span> <span class="toc-text">9.7.  为什么堆栈增长方向不一样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AE%B5%E9%94%99%E8%AF%AF"><span class="toc-number">8.9.</span> <span class="toc-text">9.8.  什么时候会发生段错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.10.</span> <span class="toc-text">9.9.  内存溢出原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-%E4%BB%80%E4%B9%88%E6%98%AFmemory-leak%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">8.11.</span> <span class="toc-text">9.10. 什么是memory leak，也就是内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">8.11.1.</span> <span class="toc-text">内存泄漏的分类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">9.11. 如何判断内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-12-C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">8.13.</span> <span class="toc-text">9.12. C++如何处理内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-13-C-%E9%87%8C%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">9.13. C++里是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14-const-char-arr-x3D-%E2%80%9C123%E2%80%9D-char-brr-x3D-%E2%80%9C123%E2%80%9D-const-char-crr-x3D-%E2%80%9C123%E2%80%9D-char-drr-x3D-%E2%80%9C123%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.15.</span> <span class="toc-text">9.14. const char * arr &#x3D; “123”; char * brr &#x3D; “123”; const char crr[] &#x3D; “123”; char drr[] &#x3D; “123”的区别是什么;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-15-c-%E4%B8%AD%E7%9A%84RAII%E6%9C%BA%E5%88%B6"><span class="toc-number">8.16.</span> <span class="toc-text">9.15. c++中的RAII机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/18/dp/" title="dp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dp"/></a><div class="content"><a class="title" href="/2022/03/18/dp/" title="dp">dp</a><time datetime="2022-03-18T13:51:49.000Z" title="发表于 2022-03-18 21:51:49">2022-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/zhi-zhen-shu-zu-fu-zhi-yue-jie-yin-fa-de-bug/" title="指针数组赋值越界引发的bug"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="指针数组赋值越界引发的bug"/></a><div class="content"><a class="title" href="/2022/03/16/zhi-zhen-shu-zu-fu-zhi-yue-jie-yin-fa-de-bug/" title="指针数组赋值越界引发的bug">指针数组赋值越界引发的bug</a><time datetime="2022-03-16T11:28:00.000Z" title="发表于 2022-03-16 19:28:00">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/er-fen-cha-zhao-suan-fa/" title="二分查找"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二分查找"/></a><div class="content"><a class="title" href="/2022/03/15/er-fen-cha-zhao-suan-fa/" title="二分查找">二分查找</a><time datetime="2022-03-15T12:17:49.000Z" title="发表于 2022-03-15 20:17:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/pai-xu-suan-fa/" title="排序算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法"/></a><div class="content"><a class="title" href="/2022/03/15/pai-xu-suan-fa/" title="排序算法">排序算法</a><time datetime="2022-03-15T12:16:49.000Z" title="发表于 2022-03-15 20:16:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/xiao-suan-fa/" title="前缀和/差分"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前缀和/差分"/></a><div class="content"><a class="title" href="/2022/03/15/xiao-suan-fa/" title="前缀和/差分">前缀和/差分</a><time datetime="2022-03-15T12:13:49.000Z" title="发表于 2022-03-15 20:13:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/tu-lun/" title="图论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图论"/></a><div class="content"><a class="title" href="/2022/03/15/tu-lun/" title="图论">图论</a><time datetime="2022-03-15T12:12:49.000Z" title="发表于 2022-03-15 20:12:49">2022-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By qianxunslimg</div><div class="footer_custom_text">只愿得一人心 白首不分离</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/SerokSSR/cdn/meting.min.js"></script></div></body></html>