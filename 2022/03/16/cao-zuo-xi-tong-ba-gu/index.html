<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统面试 | qianxunslimgのblog</title><meta name="robots" content="noindex"><meta name="keywords" content="面试"><meta name="author" content="qianxunslimg"><meta name="copyright" content="qianxunslimg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 操作系统有哪些模块 处理器管理   处理器管理最基本的功能是处理中断事件，配置了操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是处理器调度，针对不同情况采取不同的调度策略。   存储器管理   存储器管理主要是指针对内存储器的管理。主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。   设备管理   设备管理是指负责管理各类外围">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统面试">
<meta property="og:url" content="http://example.com/2022/03/16/cao-zuo-xi-tong-ba-gu/index.html">
<meta property="og:site_name" content="qianxunslimgのblog">
<meta property="og:description" content="1. 操作系统有哪些模块 处理器管理   处理器管理最基本的功能是处理中断事件，配置了操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是处理器调度，针对不同情况采取不同的调度策略。   存储器管理   存储器管理主要是指针对内存储器的管理。主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。   设备管理   设备管理是指负责管理各类外围">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/3.jpg">
<meta property="article:published_time" content="2022-03-15T18:31:49.000Z">
<meta property="article:modified_time" content="2022-03-16T01:48:16.620Z">
<meta property="article:author" content="qianxunslimg">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/3.jpg"><link rel="shortcut icon" href="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png"><link rel="canonical" href="http://example.com/2022/03/16/cao-zuo-xi-tong-ba-gu/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-16 09:48:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><style type="text/css">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="qianxunslimgのblog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">qianxunslimgのblog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统面试<a class="post-edit-link" href="null_posts/操作系统八股.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-15T18:31:49.000Z" title="发表于 2022-03-16 02:31:49">2022-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-16T01:48:16.620Z" title="更新于 2022-03-16 09:48:16">2022-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>126分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-操作系统有哪些模块"><a href="#1-操作系统有哪些模块" class="headerlink" title="1. 操作系统有哪些模块"></a>1. 操作系统有哪些模块</h1><ol>
<li><code>处理器</code>管理</li>
</ol>
<ul>
<li>处理器管理最基本的功能是<code>处理中断事件</code>，配置了操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是处理器<code>调度</code>，针对不同情况采取不同的调度策略。</li>
</ul>
<ol start="2">
<li><code>存储器</code>管理</li>
</ol>
<ul>
<li>存储器管理主要是指针对内存储器的管理。主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。</li>
</ul>
<ol start="3">
<li><code>设备</code>管理</li>
</ol>
<ul>
<li>设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用。</li>
</ul>
<ol start="4">
<li><p><code>文件</code>管理</p>
<ul>
<li>文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的存储、检索和修改等操作以及文件的保护功能。</li>
</ul>
</li>
<li><p><code>作业</code>管理</p>
<ul>
<li>每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。</li>
</ul>
</li>
</ol>
<h1 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h1><h2 id="2-1-进程与线程的概念，以及为什么要有进程线程"><a href="#2-1-进程与线程的概念，以及为什么要有进程线程" class="headerlink" title="2.1.  进程与线程的概念，以及为什么要有进程线程"></a>2.1.  进程与线程的概念，以及为什么要有进程线程</h2><p>基本概念：</p>
<ul>
<li><p><u><code>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发</code>；</u></p>
</li>
<li><ol>
<li>线程是进程的子任务，是==CPU调度和分派的基本单位==，用于保证程序的实时性，实现进程内部的并发；</li>
<li>线程是操作系统可识别的==最小执行和调度单位==。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是==共享==同一<code>地址空间</code>（也就是同样的动态内存，映射文件，目标代码等等），打开的<code>文件队列</code>和其他<code>内核资源</code>。</li>
</ol>
</li>
<li><p>线程产生的原因：</p>
<ol>
<li><p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p>
<ul>
<li>进程在同一时间只能干一件事（<code>一次一件事</code>）；</li>
<li>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（<code>阻塞挂起整个</code>）。</li>
</ul>
</li>
<li><p>（<code>为了减小并发的时空开销</code>）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p>
<ul>
<li><p>（相同的地址空间，所以<code>节省资源</code>）从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。 </p>
</li>
<li><p>（相同的地址空间，所以<code>切换快</code>）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</p>
</li>
<li><p>相同的地址空间，所以<code>通信快捷方便</code>）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
</li>
<li><p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="2-2-线程与进程的区别"><a href="#2-2-线程与进程的区别" class="headerlink" title="2.2.  线程与进程的区别"></a>2.2.  线程与进程的区别</h2><ol>
<li><p>（<code>从属关系</code>）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程<code>依赖</code>于进程而存在。</p>
</li>
<li><p>（<code>资源区别</code>）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。</p>
</li>
<li><p>（<code>单位</code>）进程是资源分配的最小单位，线程是CPU调度的最小单位；</p>
</li>
<li><p><code>系统开销</code>： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。</p>
<p>类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p>
</li>
<li><p><code>通信</code>：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</p>
</li>
<li><p>（<code>调试难度可靠性</code>）进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</p>
</li>
<li><p>（``相互影响`）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p>
</li>
</ol>
<h2 id="2-3-协程"><a href="#2-3-协程" class="headerlink" title="2.3.  协程"></a>2.3.  协程</h2><ol>
<li><p>概念：</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">print <span class="string">'1'</span></span></span><br><span class="line"><span class="function">print <span class="string">'2'</span></span></span><br><span class="line"><span class="function">print <span class="string">'3'</span></span></span><br><span class="line"><span class="function">def B() :</span></span><br><span class="line"><span class="function">print <span class="string">'x'</span></span></span><br><span class="line"><span class="function">print <span class="string">'y'</span></span></span><br><span class="line"><span class="function">print <span class="string">'z'</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
</li>
<li><p>协程和线程区别</p>
<p>那和多线程比，协程最大的优势就是协程<code>极高的执行效率</code>。因为子程序切换不是线程切换，而是由程序自身控制（用户态），因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，协程常使用异步IO。</p>
</li>
</ol>
<h2 id="2-4-有了进程，为什么还要有线程？"><a href="#2-4-有了进程，为什么还要有线程？" class="headerlink" title="2.4.  有了进程，为什么还要有线程？"></a>2.4.  有了进程，为什么还要有线程？</h2><p>线程产生的原因：</p>
<ol>
<li><p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p>
<ul>
<li>进程在同一时间只能干一件事（<code>一次一件事</code>）；</li>
<li>进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（<code>阻塞挂起整个</code>）。</li>
</ul>
</li>
<li><p>（<code>为了减小并发的时空开销</code>）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：</p>
<ul>
<li><p>（相同的地址空间，所以<code>节省资源</code>）从资源上来讲，线程是一种非常”节俭”的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。 </p>
</li>
<li><p>（相同的地址空间，所以<code>切换快</code>）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。</p>
</li>
<li><p>相同的地址空间，所以<code>通信快捷方便</code>）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</p>
</li>
<li><p>除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-5-说一下多线程和多进程的不同"><a href="#2-5-说一下多线程和多进程的不同" class="headerlink" title="2.5.  说一下多线程和多进程的不同"></a>2.5.  说一下多线程和多进程的不同</h2><p>进程是资源分配的最小单位，而线程是CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单（？？？），适用于多核、多机分布。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th align="center">多进程</th>
<th align="center">多线程</th>
<th align="center">总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td align="center">数据是分开的:共享复杂，需要用IPC;同步简单</td>
<td align="center">多线程共享进程数据：共享简单；同步复杂</td>
<td align="center">各有优势</td>
</tr>
<tr>
<td>内存、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CPU&amp;spm=1001.2101.3001.7020">CPU</a></td>
<td align="center">占用内存多，切换复杂，CPU利用率低</td>
<td align="center">占用内存少，切换简单，CPU利用率高</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td align="center">创建销毁、切换复杂，速度慢</td>
<td align="center">创建销毁、切换简单，速度快</td>
<td align="center">线程占优</td>
</tr>
<tr>
<td>编程调试</td>
<td align="center">编程简单，调试简单</td>
<td align="center">编程复杂，调试复杂</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td align="center">进程间不会相互影响</td>
<td align="center">一个线程挂掉将导致整个进程挂掉</td>
<td align="center">进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td align="center">适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td>
<td align="center">适应于多核分布</td>
<td align="center">进程占优</td>
</tr>
</tbody></table>
<h2 id="2-6-多进程和多线程的使用场景"><a href="#2-6-多进程和多线程的使用场景" class="headerlink" title="2.6.  多进程和多线程的使用场景"></a>2.6.  多进程和多线程的使用场景</h2><p>多进程模型的优势是CPU</p>
<ol>
<li><p>多线程模型主要优势为线程间切换代价较小，因此适用于==I/O密集型==（<code>读写文件</code>）的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。</p>
</li>
<li><p>多进程模型，适用于==CPU密集型==（<code>大量计算</code>）。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。</p>
</li>
</ol>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/7027610930431131685">一分钟明白IO密集型与CPU密集型的区别 - 掘金 (juejin.cn)</a></strong></p>
<ul>
<li>CPU密集型也叫<code>计算密集型</code>，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作CPU读写IO(硬盘/内存)时，IO可以在很短的时间内完成，而CPU还有许多运算要处理，因此，CPU负载很高。</li>
<li>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等IO (硬盘/内存) 的<code>读写</code>操作，因此，CPU负载并不高。</li>
<li>一个计算为主的应用程序（CPU密集型程序），多线程或多进程跑的时候，可以充分利用起所有的 CPU 核心数，比如说16核的CPU ，开16个线程的时候，可以同时跑16个线程的运算任务，此时是最大效率。但是如果线程数/进程数远远超出 CPU 核心数量，反而会使得任务效率下降，因为<strong>频繁的切换线程或进程</strong>也是要消耗时间的。因此对于 CPU 密集型的任务来说，线程数/进程数等于 CPU 数是最好的了。</li>
<li>如果是一个磁盘或网络为主的应用程序（IO密集型程序），一个线程处在 IO 等待的时候，另一个线程还可以在 CPU 里面跑，有时候 CPU 闲着没事干，所有的线程都在等着 IO，这时候他们就是同时的了，而单线程的话，此时还是在一个一个等待的。我们都知道IO的速度比起 CPU 来是很慢的。此时线程数可以是CPU核心数的数倍（视情况而定）</li>
</ul>
<h2 id="2-7-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"><a href="#2-7-线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的" class="headerlink" title="2.7.  线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的"></a>2.7.  线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h2><p>线程在切换的过程中需要保存<code>当前线程Id</code>、<code>线程状态</code>、<code>堆栈</code>、<code>寄存器状态</code>等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：</p>
<ul>
<li>SP:<strong>堆栈指针</strong>，指向当前栈的栈顶地址 （<code>存地址</code>）</li>
<li>PC:<strong>程序计数器，存储下一条将要执行的指令</strong>（<code>存下一条指令</code>）</li>
<li>EAX:累加寄存器，用于加法乘法的缺省寄存器 <code>？</code></li>
</ul>
<h2 id="2-8-进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#2-8-进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="2.8.  进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>2.8.  进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h2><ol>
<li><p>进程的五种基本状态：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220301002354909-1638079864.png" alt="img" style="zoom: 50%;">

<ul>
<li><p>创建状态：进程正在被创建</p>
</li>
<li><p>就绪状态：进程被加入到就绪队列中等待CPU调度运行</p>
</li>
<li><p>执行状态：进程正在被运行</p>
</li>
<li><p>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。</p>
</li>
<li><p>终止状态：进程运行完毕</p>
<p>（2-4为基本状态）</p>
</li>
</ul>
</li>
<li><p>交换技术</p>
<ul>
<li><p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理就会空闲，I/0速度比处理速度慢得多，可能<code>出现全部进程阻塞等待I/O</code>。</p>
</li>
<li><p>针对以上问题，提出了两种解决方法：</p>
<p>1）<code>交换技术</code>：<u>换出一部分进程到外存，腾出内存空间。</u></p>
<ul>
<li><p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。</p>
</li>
<li><p>从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
</li>
</ul>
<p>2）<code>虚拟存储技术</code>：每个进程只能装入一部分程序和数据。</p>
</li>
</ul>
</li>
<li><p>活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<p>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</p>
<p>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</p>
<p>3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。</p>
<p>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。</p>
<p>从而出现了：</p>
<p>活动就绪 ——  静止就绪    （内存不够，调到外存）</p>
<p>活动阻塞 ——  静止阻塞    （内存不够，调到外存）</p>
<p>执行   ——  静止就绪     （时间片用完）</p>
</li>
</ol>
<h2 id="2-9-进程调度算法"><a href="#2-9-进程调度算法" class="headerlink" title="2.9.  进程调度算法"></a>2.9.  进程调度算法</h2><h3 id="2-9-1-先来先去服务"><a href="#2-9-1-先来先去服务" class="headerlink" title="2.9.1. 先来先去服务"></a>2.9.1. 先来先去服务</h3><p>先来先去服务调度算法是一种最简单的调度算法，也称为<code>先进先出</code>或<code>严格排队</code>方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，<u>选择在就绪队列中存在时间最长的进程运行</u>。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。</p>
<h3 id="2-9-2-最短进程优先"><a href="#2-9-2-最短进程优先" class="headerlink" title="2.9.2. 最短进程优先"></a>2.9.2. 最短进程优先</h3><p>最短进程优先是一个非抢占策略，他的原则是<code>下一次选择预计处理时间最短的进程</code>，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是<u>他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。</u></p>
<h3 id="2-9-3-最短剩余时间优先"><a href="#2-9-3-最短剩余时间优先" class="headerlink" title="2.9.3. 最短剩余时间优先"></a>2.9.3. 最短剩余时间优先</h3><p>（==估计时间最短就不排队了 直接抢==）最短剩余时间是针对最短进程优先<code>增加了抢占机制</code>的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。</p>
<h3 id="2-9-4-x3D-x3D-时间片-x3D-x3D-轮转法"><a href="#2-9-4-x3D-x3D-时间片-x3D-x3D-轮转法" class="headerlink" title="2.9.4. ==时间片==轮转法"></a>2.9.4. ==时间片==轮转法</h3><p>（<code>被抢占之前起码运行一段时间</code>）轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于==先来先去==服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。</p>
<h3 id="2-9-5-优先权调度算法的类型"><a href="#2-9-5-优先权调度算法的类型" class="headerlink" title="2.9.5. 优先权调度算法的类型"></a>2.9.5. 优先权调度算法的类型</h3><p>此算法常被用于批处理系统中，作为作业调度算法，也作为多种<a target="_blank" rel="noopener" href="http://www.wypblog.com/archives/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><strong>操作系统</strong></a>中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p>
<ol>
<li>非抢占式优先权算法</li>
</ol>
<p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该<code>进程便一直执行下去，直至完成</code>；或因发生某事件使<code>该进程放弃处理机</code>时（==完成或自己放弃==），系统方可再将处理机重新分配给另一优先权<code>最高</code>的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p>
<ol start="2">
<li>抢占式优先权调度算法</li>
</ol>
<p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就<code>立即停止</code>当前进程(原优先权最高的进程)的执行，<code>重新将处理机分配</code>给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>
<h3 id="2-9-6-最高响应比优先"><a href="#2-9-6-最高响应比优先" class="headerlink" title="2.9.6. 最高响应比优先"></a>2.9.6. 最高响应比优先</h3><p>（照顾长时间进程）根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）</p>
<p>如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。</p>
<p>和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。</p>
<h3 id="2-9-7-x3D-x3D-多级反馈队列调度算法-x3D-x3D"><a href="#2-9-7-x3D-x3D-多级反馈队列调度算法-x3D-x3D" class="headerlink" title="2.9.7. ==多级反馈队列调度算法=="></a>2.9.7. ==多级反馈队列调度算法==</h3><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则<code>不必事先知道各种进程所需的执行时间</code>，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种<code>较好</code>的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p>
<p><code>优先级越高 越靠前 时间越短 没完成扔到第二队列最后 时间边长 等待</code></p>
<p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p>
<p>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p>
<p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p>
<h2 id="2-10-常用线程模型"><a href="#2-10-常用线程模型" class="headerlink" title="2.10. 常用线程模型"></a>2.10. 常用线程模型</h2><ol>
<li><p>Future模型  （==QFuture 和 run==）</p>
<ul>
<li>该模型通常在使用的时候需要结合Callable接口配合使用。</li>
<li>Future是<code>把结果放在将来获取</code>，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。</li>
<li>使用Future模式便可以<code>省去全局变量</code>的使用，直接从线程中获取子线程处理结果</li>
</ul>
</li>
<li><p>fork&amp;join模型  （==Qt::Concurrent map那一堆==）</p>
<ul>
<li><p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。</p>
</li>
<li><p>这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic2.zhimg.com/v2-884ed47503dcaa900d72066f3eb8c10d_r.jpg" alt="img" style="zoom: 67%;"></li>
</ul>
</li>
<li><p>生产者消费者模型   （新建线程任务放在==队列==就不管了）</p>
<ul>
<li>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。<code>开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。</code>这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。</li>
</ul>
</li>
<li><p>master-worker模型</p>
<ul>
<li>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</li>
</ul>
</li>
</ol>
<h2 id="2-11-reactor模型组成"><a href="#2-11-reactor模型组成" class="headerlink" title="2.11. reactor模型组成"></a>2.11. <a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd58a63">reactor模型组成</a></h2><h3 id="线程模型1：传统阻塞-I-x2F-O-服务模型"><a href="#线程模型1：传统阻塞-I-x2F-O-服务模型" class="headerlink" title="线程模型1：传统阻塞 I/O 服务模型"></a>线程模型1：传统阻塞 I/O 服务模型</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://filescdn.proginn.com/7c7de7fd1ea9c9a3403ccebfa2740ff4/7f1dd376f2ab0eaf7415844713efac4f.webp" alt="img" style="zoom: 80%;">

<p>特点：</p>
<ul>
<li>1）采用阻塞式 I/O 模型获取输入数据；</li>
<li>2）每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。</li>
</ul>
<p>存在问题：</p>
<ul>
<li>1）当并发数较大时，需要创建大量线程来处理连接，<code>系统资源占用较大</code>；</li>
<li>2）连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成<code>线程资源浪费</code>。</li>
</ul>
<h3 id="线程模型2：Reactor-模式"><a href="#线程模型2：Reactor-模式" class="headerlink" title="线程模型2：Reactor 模式"></a>线程模型2：Reactor 模式</h3><p>针对传统阻塞 I/O 服务模型的 2 个缺点，比较常见的有如下解决方案： </p>
<ul>
<li>1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；</li>
<li>2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ul>
<p><code>I/O 复用结合线程池</code>，这就是 Reactor 模式基本设计思想，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://filescdn.proginn.com/91365ea7446633c6dcc8d9aeef035f79/bd40e7f36c71aaa1710e68303122a899.webp" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_2.jpeg">     </p>
<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的<code>事件驱动处理模式</code>。 </p>
<p>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 <code>Dispatcher</code> 模式。</p>
<p>即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<p>Reactor 模式中有 2 个关键组成：</p>
<ul>
<li><p>1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；    ==接线员==</p>
</li>
<li><p>2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。    ==事件处理程序==</p>
</li>
</ul>
<p>reactor模型要求<code>主线程只负责监听文件描述上是否有事件发生</code>，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220301002354841-2074717704.png" alt="img"></p>
<ol>
<li><p>Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。</p>
</li>
<li><p>Synchronous Event Demultiplexer（<code>同步事件复用器</code>）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。</p>
<blockquote>
<p>Select 是I/O 复用模型的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</p>
</blockquote>
</li>
<li><p>Initiation Dispatcher：用于<code>管理Event Handler</code>，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。</p>
</li>
<li><p>Event Handler：定义<code>事件处理方法</code>：handle_event()，以供InitiationDispatcher回调使用。</p>
</li>
<li><p>Concrete Event Handler：事件EventHandler接口，实现<code>特定事件处理逻辑</code>。</p>
</li>
</ol>
<h2 id="2-12-僵尸进程和孤儿进程"><a href="#2-12-僵尸进程和孤儿进程" class="headerlink" title="2.12. 僵尸进程和孤儿进程"></a>2.12. 僵尸进程和孤儿进程</h2><ul>
<li><p>正常进程</p>
<ol>
<li><p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。<code>子进程的结束和父进程的运行是一个异步过程</code>，即<code>父进程永远无法预测子进程到底什么时候结束</code>。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
</li>
<li><p>unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：</p>
<blockquote>
<p>1<code>进程号</code>the process ID</p>
<p>2<code>退出状态</code>the termination status of the process</p>
<p>3<code>运行时间</code>the amount of CPU time taken by the process等</p>
</blockquote>
</li>
</ol>
</li>
<li><p>==孤儿==进程</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。<code>孤儿进程将被init进程(进程号为1)所收养</code>，并由init进程对它们完成状态收集工作。</p>
</li>
<li><p>==僵尸==进程</p>
<ol>
<li>一个进程使用fork创建子进程，<u>如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程</u>。</li>
<li>僵尸进程是一个进程==必然==会经过的过程：这是每个子进程在结束时都要经过的阶段。</li>
<li>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</li>
<li>如果父进程在子进程结束之前退出，则子进程将由<code>init</code>接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</li>
</ol>
<ul>
<li><p>危害：</p>
<p><u>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</u></p>
</li>
<li><p>外部消灭：</p>
<p>通过kill发送sig_term或者sig_kill信号消灭产生僵尸进程的父进程，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源 （==杀死僵尸的爹，让它变成孤儿==）</p>
</li>
<li><p>内部解决：</p>
<ol>
<li><p>子进程退出时向父进程发送sig_child信号，父进程处理sig_child信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<p>（==告诉你一声我要结束了，来处理我==）</p>
</li>
<li><p>fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 </p>
<p>（==创建时fork两次，然后退出第一个子进程，孙子就变成了孤儿==）</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-13-怎样确定当前线程是繁忙还是阻塞？"><a href="#2-13-怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="2.13. 怎样确定当前线程是繁忙还是阻塞？"></a>2.13. 怎样确定当前线程是繁忙还是阻塞？</h2><p>==使用ps命令查看==</p>
<p>  <code>ps</code>命令是Process Status的缩写，用来列出系统中当前运行的进程。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。ps命令所列出的进行是当前进程的快照，也就是并不是动态的，而是执行该命令时那一时刻进行的状态。而经常和ps一起结合使用的杀死进程的是<code>kill</code>命令。<br>  在我们的学习中我们知道，Linux的进程状态一般分为几种：</p>
<pre><code>&gt;`R`(TASK_RUNNING，可执行状态)，这个进程是可运行的——要么它正在运行，要么在运行队列中等待运行；
&gt;
&gt;`S`(TASK_INTERRUPTIBLE，中断状态)，这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量等）而被挂起，然后当这些事件发生或完成后，对应的等待队列中的一个或多个进程将被唤醒。
&gt;
&gt;`D`(TASK_UNINTERRUPTIBLE，不可中断状态)，在进程接收到信号时，不会被唤醒变成可运行的。除了这一点，该状态和TASK_INTERRUPTIBLE其他部分完全一样，这个状态通常用于进程必须不间断等待或者事件发生的频率很快，并且无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。
&gt;
&gt;`T`(TASK_STOPPED或TASK_TRACED，暂停状态或跟踪状态)，该状态表示该进程已经停止执行，并且不具有再次执行的条件。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。而当进程正在被跟踪时，它处于TASK_TRACED状态。
&gt;
&gt;`Z`(TASK_DEAD或EXIT_ZOMBIE，退出状态)，进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在，这也就是所谓的"僵尸"进程。
&gt;
&gt;`X`(TASK_DEAD - EXIT_DEAD，退出状态)，进程即将被销毁。EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。
</code></pre>
<h2 id="2-14-就绪状态的进程在等待什么？"><a href="#2-14-就绪状态的进程在等待什么？" class="headerlink" title="2.14. 就绪状态的进程在等待什么？"></a>2.14. 就绪状态的进程在等待什么？</h2><p>==被调度使用cpu的运行权==</p>
<h2 id="2-15-fork-wait-exec函数"><a href="#2-15-fork-wait-exec函数" class="headerlink" title="2.15. fork,wait,exec函数"></a>2.15. fork,wait,exec函数</h2><p>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1</p>
<h2 id="2-16-fork和vfork的区别"><a href="#2-16-fork和vfork的区别" class="headerlink" title="2.16. fork和vfork的区别"></a>2.16. fork和vfork的区别</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    fpid=fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) {  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d/n"</span>,<span class="built_in">getpid</span>());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是爹的儿子/n"</span>);<span class="comment">//对某些人来说中文看着更直白。  </span></span><br><span class="line">        count++;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">else</span> {  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d/n"</span>,<span class="built_in">getpid</span>());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是孩子他爹/n"</span>);  </span><br><span class="line">        count++;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>成功调用fork()会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork()返回子进程的pid。如果出现错误，fork( )返回一个负值。</li>
<li><code>最常见的fork()用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像</code>。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“<code>派生加执行</code>”的方式是很常见的。</li>
<li>==写时拷贝==：当任意一个进程试图修改共享空间中的数据，操作系统就会将需要修改的数据所在的页直接拷一份出来。 </li>
<li>内核只为新生成的子进程创建虚拟空间结构，它们复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应的段的行为发生时，再为子进程相应的段分配物理空间。</li>
</ul>
<h3 id="fork失败的主要原因："><a href="#fork失败的主要原因：" class="headerlink" title="fork失败的主要原因："></a>fork失败的主要原因：</h3><ol>
<li>当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN  ==（进程数上限）==</li>
<li>系统内存不足，这时errno的值被设置为ENOMEM  ==（内存不足）==</li>
</ol>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><ul>
<li>在实现写时复制之前，Unix的设计者们就一直很关注<code>在fork后立刻执行exec所造成的地址空间的浪费</code>。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程<code>直到子进程终止或者运行了一个新的可执行文件的映像</code>。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。</li>
<li>==意思是 vfork的唯一好处就是避免了父进程映像的拷贝，要想使用仍然需要调用exec();==</li>
</ul>
<h3 id="fork和vfork的区别："><a href="#fork和vfork的区别：" class="headerlink" title="fork和vfork的区别："></a>fork和vfork的区别：</h3><ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
</li>
<li><p>当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
<h2 id="2-17-手写一下fork调用示例"><a href="#2-17-手写一下fork调用示例" class="headerlink" title="2.17. 手写一下fork调用示例"></a>2.17. 手写一下fork调用示例</h2><ol>
<li><p>概念：</p>
<p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
</li>
<li><p>fork实例</p>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// printf("pid : %d\n", pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am parent process, pid : %d, ppid : %d\n"</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent num : %d\n"</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent num += 10 : %d\n"</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process, pid : %d, ppid : %d\n"</span>, <span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child num : %d\n"</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child num += 100 : %d\n"</span>, num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环    //无pid判断 父子进程都执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i : %d , pid : %d\n"</span>, i , <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h2 id="视频学习资料"><a href="#视频学习资料" class="headerlink" title="视频学习资料"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/study/live/504/2/7?autoplay=1">视频学习资料</a></h2><h2 id="GDB多线程调试"><a href="#GDB多线程调试" class="headerlink" title="GDB多线程调试"></a>GDB多线程调试</h2><ul>
<li><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
</li>
<li><p>设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]</p>
</li>
<li><p>设置调试模式：set detach-on-fork [on | off]   默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。</p>
</li>
<li><p>查看调试的进程：info inferiors</p>
</li>
<li><p>切换当前调试的进程：inferior id</p>
</li>
<li><p>使进程脱离 GDB 调试：detach inferiors id</p>
</li>
</ul>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><h3 id="exec-函数族介绍"><a href="#exec-函数族介绍" class="headerlink" title="exec 函数族介绍"></a>exec 函数族介绍</h3><ul>
<li><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
</li>
<li><p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c  -&gt; hello.out</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// execl.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am parent process, pid : %d\n"</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// execl("hello","hello",NULL);  //执行hello.out程序， 输出hello, world</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">"/bin/ps"</span>, <span class="string">"ps"</span>, <span class="string">"aux"</span>, <span class="literal">NULL</span>);  <span class="comment">//执行操作系统的 ps命令</span></span><br><span class="line">      	<span class="built_in">execlp</span>(<span class="string">"ps"</span>, <span class="string">"ps"</span>, <span class="string">"aux"</span>, <span class="literal">NULL</span>); <span class="comment">//execlp可以从环境变量中查找 不需要指定路径</span></span><br><span class="line">        <span class="comment">// perror("execl");  //execl路径错误会输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process, pid : %d\n"</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i = %d, pid = %d\n"</span>, i, <span class="built_in">getpid</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="1-进程退出"><a href="#1-进程退出" class="headerlink" title="1. 进程退出"></a>1. 进程退出</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220303183615766-727338168.png" alt="img"></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line">    <span class="comment">// exit(0);   // 打印 hello world 最后刷新io缓冲输出的world</span></span><br><span class="line">    _exit(<span class="number">0</span>);    <span class="comment">//打印hello  因为printf的\n有刷新缓冲区的作用 输出hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-孤儿进程"><a href="#2-孤儿进程" class="headerlink" title="2. 孤儿进程"></a>2. 孤儿进程</h3><ul>
<li>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。</li>
<li>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</li>
<li>因此<code>孤儿进程并不会有什么危害</code>。</li>
</ul>
<h3 id="3-僵尸进程"><a href="#3-僵尸进程" class="headerlink" title="3. 僵尸进程"></a>3. 僵尸进程</h3><ul>
<li>每个进程结束之后, 都会释放自己地址空间中的用户区数据，==内核区的 PCB 没有办法自己释放掉，需要父进程去释放==。</li>
<li>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</li>
<li>==僵尸进程不能被 kill -9 杀死==，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</li>
</ul>
<h3 id="4-进程回收"><a href="#4-进程回收" class="headerlink" title="4. 进程回收"></a>4. 进程回收</h3><ul>
<li><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。</p>
</li>
<li><p>父进程可以通过调用<code>wait</code>或<code>waitpid</code>得到它的退出状态同时彻底清除掉这个进程。</p>
</li>
<li><p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</p>
</li>
<li><p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 ==（一次一个）==</p>
</li>
<li><p>==主进程wait阻塞等待子进程被kill掉 清楚pcb 主进程继续==</p>
<blockquote>
<p><code>线程中也存在子线程资源的回收</code>:</p>
<p>join函数（类似多进程中的wait和waitpid），不同于多进程，任何线程都可以对其他线程的资源进行回收</p>
</blockquote>
</li>
</ul>
<h1 id="3-线程同步，进程通信"><a href="#3-线程同步，进程通信" class="headerlink" title="3. 线程同步，进程通信"></a>3. 线程同步，进程通信</h1><h2 id="3-1-多线程，线程同步的几种方式"><a href="#3-1-多线程，线程同步的几种方式" class="headerlink" title="3.1.  多线程，线程同步的几种方式"></a>3.1.  多线程，线程同步的几种方式</h2><p>临界区（线程通信方式）：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</p>
<p>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p>
<p>信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</p>
<p>条件变量（事件）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p>
<ol>
<li><p><em><strong>==互斥锁==</strong></em> </p>
<p>互斥锁是最常见的线程同步方式，它是一种特殊的变量，它有 <em><strong>lock</strong></em> 和 <em><strong>unlock</strong></em> 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取在使用同一个资源前加锁，使用后解锁，即可实现线程同步，需要注意的是，如果加锁后不解锁，会造成死锁</p>
<ul>
<li><p><strong>优点：</strong></p>
<p>使用简单；</p>
</li>
<li><p><strong>缺点：</strong></p>
<ol>
<li>重复锁定和解锁，<code>每次都会检查共享数据结构，浪费时间和资源</code>；   ==（频繁检查共享数据（锁），浪费时间和资源）==</li>
<li>繁忙查询的效率非常低；   ==（效率低）==</li>
</ol>
</li>
</ul>
</li>
<li><p>==条件变量==</p>
<p>条件变量的方法是，当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁，实现高效。</p>
<p>条件变量允许线程阻塞并等待另一个线程发送信号，<code>一般和互斥锁一起使用</code>。</p>
<p><u>条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。</u>    ==（一些锁 用条件变量替换）==</p>
</li>
<li><p>==信号量==</p>
<p><strong>信号量</strong> 和互斥锁的区别在于：互斥锁只允许一个线程进入临界区，信号量允许多个线程同时进入临界区</p>
<p>可以这样理解，互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步</p>
<ul>
<li><p>为什么要使用信号量？？?</p>
<p>为了防止多个进程在访问共享资源为引发的问题。信号量可以协调进程对共享资源的访问，也就是用来<code>保护临界资源</code>的。任一时刻只能有一个执行线程进入临界区。  ==（生产消费）==</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220301220958085-739618204.png" alt="img" style="zoom:67%;"></li>
</ol>
<h2 id="3-2-线程间的同步方式，最好说出具体的系统调用"><a href="#3-2-线程间的同步方式，最好说出具体的系统调用" class="headerlink" title="3.2.  线程间的同步方式，最好说出具体的系统调用"></a>3.2.  线程间的同步方式，最好说出具体的系统调用</h2><p>==信号量==</p>
<p>信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：</p>
<p>P(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。 ==消费==线程 </p>
<blockquote>
<p>假设sv = 1, sv大于0表示有苹果 可以吃  –， 然后sv = 0还想吃 则挂起</p>
</blockquote>
<p>V(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。 ==生产==线程</p>
<p>其系统调用为：</p>
<p>sem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</p>
<p>sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</p>
<p>==互斥量==</p>
<p>互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：</p>
<p>pthread_mutex_init:初始化互斥锁</p>
<p>pthread_mutex_destroy：销毁互斥锁</p>
<p>pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。</p>
<p>pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。</p>
<p>==条件变量==</p>
<p>条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：</p>
<p>pthread_cond_init:初始化条件变量</p>
<p>pthread_cond_destroy：销毁条件变量</p>
<p>pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</p>
<p>pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。</p>
<h2 id="3-3-互斥锁和条件变量的区别"><a href="#3-3-互斥锁和条件变量的区别" class="headerlink" title="3.3.  互斥锁和条件变量的区别"></a>3.3.  互斥锁和条件变量的区别</h2><ul>
<li><p>条件变量：可以自己决定什么时候唤醒别的线程，达到唤醒条件之后再==唤醒==某个线程。选择唤醒单个线程   </p>
<p>==（主要是唤醒特定线程）==</p>
</li>
<li><p>互斥锁强调的是资源的访问互斥：解锁时自动唤醒阻塞线程</p>
</li>
</ul>
<h3 id="1-互斥锁（mutual-exclusive-lock-variable-x2F-mutex-）"><a href="#1-互斥锁（mutual-exclusive-lock-variable-x2F-mutex-）" class="headerlink" title="1. 互斥锁（mutual exclusive lock variable / mutex ）"></a>1. 互斥锁（mutual exclusive lock variable / mutex ）</h3><ul>
<li>互斥量(mutex)从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥锁加锁的线程将会阻塞直到当前线程释放该互斥锁。<strong>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。</strong></li>
</ul>
<h3 id="2-条件变量"><a href="#2-条件变量" class="headerlink" title="2. 条件变量"></a>2. 条件变量</h3><ul>
<li>条件变量(cond)是在多线程程序中用来实现”等待–》唤醒”逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。</li>
</ul>
<h3 id="3-那为什么有互斥锁，还需要条件变量"><a href="#3-那为什么有互斥锁，还需要条件变量" class="headerlink" title="3. 那为什么有互斥锁，还需要条件变量"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/01ad36b91d39">3. 那为什么有互斥锁，还需要条件变量</a></h3><ul>
<li><p>因为：<strong>互斥锁和条件变量所解决的，是不同的问题，不同的场景。</strong></p>
</li>
<li><p>互斥锁解决的是在 shared memory space 模型下，多个线程对同一个全局变量的访问的竞争问题。由于写操作的非原子性（从内存中读进寄存器，修改，如果其他线程完成了对这个变量的修改，则旧的修改就被覆盖，等等问题），必须保证同一时间只有一个线程在进行写操作。这就涉及到了互斥锁，将临界区的<strong>操作</strong>锁起来，保证只有一个线程在进行操作。多个线程在等待同一把锁的时候，按照 FIFO 组织队列，当锁被释放时，队头线程获得锁（由操作系统管理，具体不表）。<strong>没有获得锁的线程继续被 block，换言之，它们是因为没有获得锁而被 block</strong>。</p>
</li>
<li><p>假如我们没有“条件变量”这个概念，如果一个线程要等待某个“自定义的条件”满足而继续执行，而这个条件只能由另一个线程来满足，比如 T1不断给一个全局变量 x +1， T2检测到x 大于100时，将x 置0，如果我们没有条件变量，则只通过互斥锁则可以有如下实现:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Assume we have global variables:</span></span><br><span class="line"><span class="comment"> * int iCount == 0;</span></span><br><span class="line"><span class="comment"> * pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//thread 1:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    iCount++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread 2:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(iCount &gt;= <span class="number">100</span>){</span><br><span class="line">        iCount = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>这种实现下，就算 lock 空闲，thread2需要不断重复&lt;加锁，判断，解锁&gt;这个流程，会给系统带来不必要的开销。有没有一种办法让 thread2先被 block，等条件满足的时候再唤醒 thread2？这样 thread2 就不用不断进行重复的加解锁操作了？这就要用到条件变量了：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread1 :</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    iCount++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(iCount &gt;= <span class="number">100</span>){</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread2:    啥玩意 没看懂</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(iCount &lt; <span class="number">100</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"iCount &gt;= 100\r\n"</span>);</span><br><span class="line">    iCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>需要注意的是，条件变量需要配合互斥锁来使用：<br>为什么要与pthread_mutex 一起使用呢？ 这是为了应对 线程1在调用pthread_cond_wait()但线程1还没有进入wait cond的状态的时候，此时线程2调用了 cond_singal 的情况。 如果不用mutex锁的话，这个cond_singal就丢失了。加了锁的情况是，线程2必须等到 mutex 被释放（也就是 pthread_cod_wait() 释放锁并进入wait_cond状态 ，此时线程2上锁） 的时候才能调用cond_singal.</p>
</li>
<li><p>简而言之就是，在thread 1 call pthread_cond_wait() 的时刻到 thread 1真正进入 wait 状态时，是存在着时间差的。如果在这段时间差内 thread2 调用了 pthread_cond_signal() 那这个 signal 信号就丢失了。给 wait 加锁可以防止同时有另一个线程在 signal。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-进程间通信方式"><a href="#3-4-进程间通信方式" class="headerlink" title="3.4.  进程间通信方式"></a>3.4.  进程间通信方式</h2><p><strong>进程间通信的方式：</strong></p>
<p>进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。</p>
<ol>
<li><p>管道：</p>
<ul>
<li>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</li>
</ul>
<p>1.1 普通管道PIPE：</p>
<ol>
<li>它是<code>半双工</code>的（即数据只能在一个方向上流动），具有<code>固定的读端和写端</code>    ==（指定方向的queue）==</li>
<li>它只能用于具<code>有亲缘关系的进程之间</code>的通信（也是父子进程或者兄弟进程之间） ==（父亲或兄弟）==</li>
<li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。   ==（特殊的，存在于内存中的文件）==</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>]; <span class="comment">// 定义文件描述符   0为读 1为写</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1024</span>] = <span class="string">"hello\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(fd) &lt; <span class="number">0</span>) <span class="comment">// 创建管道，成功返回0，失败返回-1</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    pid = fork(); <span class="comment">// 创建一个子进程</span></span><br><span class="line">    <span class="comment">// 功能：父写子读</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">// 父进程</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">// 父进程关闭读端</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str)); <span class="comment">// 向管道里写数据</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 回收子进程</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 子进程</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]); <span class="comment">// 子进程关闭写端</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)); <span class="comment">// 从管道里读数据</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len); <span class="comment">// 把读到的数据写到标准输出</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 创建子进程失败</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>1.2 命名管道FIFO： ==（仍然为 单向 半双工）==</p>
<ol>
<li>FIFO可以在无关的进程之间交换数据   ==（任意进程间）==</li>
<li>FIFO有路径名与之相关联，它以一种特殊设备文件形式==存在于文件系统==中。</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">int</span> ret;      </span><br><span class="line">    ret = <span class="built_in">mkfifo</span>(<span class="string">"my_fifo"</span>, <span class="number">0666</span>); <span class="comment">// 创建命名管道  ret!=0创建成功</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"my_fifo"</span>, O_WRONLY); <span class="comment">// 写  &gt;0 open success</span></span><br><span class="line">    <span class="keyword">char</span> send[<span class="number">100</span>] = <span class="string">"Hello World"</span>;  </span><br><span class="line">    <span class="built_in">write</span>(fd, send, <span class="built_in">strlen</span>(send));  <span class="comment">// 写数据  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"write to my_fifo buf=%s\n"</span>,send);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 阻塞，保证读写进程保持着通信过程</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//read</span></span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">int</span> ret;      </span><br><span class="line">    ret = <span class="built_in">mkfifo</span>(<span class="string">"my_fifo"</span>, <span class="number">0666</span>); <span class="comment">// 创建命名管道  </span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"my_fifo"</span>, O_RDONLY); <span class="comment">// 等着只写  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {  </span><br><span class="line">        <span class="keyword">char</span> recv[<span class="number">100</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="built_in">read</span>(fd, recv, <span class="built_in"><span class="keyword">sizeof</span></span>(recv)); <span class="comment">// 读数据  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read from my_fifo buf=[%s]\n"</span>, recv);  </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);  </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>系统IPC：</p>
<p>2.1 消息队列</p>
<ul>
<li><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
<p>特点：</p>
<ol>
<li>消息队列是面向记录的，其中的消息具有特定的<code>格式</code>以及特定的<code>优先级</code>。</li>
<li>消息队列独立于发送与接收进程。进程<code>终止</code>时，消息队列及其内容并<code>不会被删除</code>。</li>
<li>消息队列可以实现消息的<code>随机查询</code>,<u>消息不一定要以先进先出的次序读取,也可以按消息的类型读取</u>。</li>
</ol>
</li>
</ul>
<p>2.2 信号量semaphore     ==(控制而非通信)==</p>
<ul>
<li><p>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个<code>计数器</code>，可以用来<code>控制多个进程对共享资源的访问</code>。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>特点：</p>
<ol>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ol>
</li>
</ul>
<p>2.3 信号signal</p>
<ul>
<li>信号是一种比较复杂的通信方式，用于<code>通知接收进程某个事件已经发生</code>。</li>
</ul>
<p> 2.4 共享内存（Shared Memory）  （<code>不是</code>内存映射）</p>
<ul>
<li><p>它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
<p>特点：</p>
<ol>
<li>共享内存是最快的一种IPC，因为进程是直接对内存进行存取</li>
<li>因为多个进程可以同时操作，所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ol>
</li>
</ul>
</li>
<li><p>套接字SOCKET：</p>
<ul>
<li>socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于==不同主机之间的进程==通信。</li>
</ul>
</li>
</ol>
<h1 id="4-多线程、线程同步、通信实现"><a href="#4-多线程、线程同步、通信实现" class="headerlink" title="4.    多线程、线程同步、通信实现"></a>4.    多线程、线程同步、通信实现</h1><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</li>
<li>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。</li>
<li>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</li>
</ol>
<h2 id="4-1-多线程"><a href="#4-1-多线程" class="headerlink" title="4.1.  多线程"></a>4.1.  多线程</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> &amp;a)</span> </span>{</span><br><span class="line">  cout &lt;&lt; <span class="string">"我是子线程,传入参数为"</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">"子线程中显示子线程id为"</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main {</span><br><span class="line">  <span class="function">thread <span class="title">th2</span><span class="params">(proc,td::ref(a))</span> <span class="comment">//第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。</span></span></span><br><span class="line"><span class="function">  th2.<span class="title">join</span><span class="params">()</span></span>; <span class="comment">//此时主线程被阻塞直至子线程执行结束。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h3><p>线程中也存在子线程资源的回收:</p>
<p><code>join函数</code>（类似多进程中的wait和waitpid），不同于多进程，任何线程都可以对其他线程的资源进行回收</p>
<h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><p>int pthread_detach(pthread_t thread);</p>
<ul>
<li>功能：分离一个线程。被分离的线程在终止的时候，会<code>自动释放资源</code>返回给系统。<br>    1.不能多次分离，会产生不可预料的行为。<br>    2.不能去连接一个已经分离的线程，会报错。<br>  - 参数：需要分离的线程的ID<br>  - 返回值：<br>      成功：0<br>      失败：返回错误号</li>
</ul>
<h2 id="4-2-互斥锁-x2F-互斥量"><a href="#4-2-互斥锁-x2F-互斥量" class="headerlink" title="4.2.  互斥锁/互斥量"></a>4.2.  互斥锁/互斥量</h2><ol>
<li><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</p>
</li>
<li><p>互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</p>
</li>
<li><p>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问</p>
</li>
<li><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域</p>
</li>
<li><p>同一资源时将采用如下协议：</p>
<blockquote>
<p>⚫ 针对共享资源锁定互斥量</p>
<p>⚫ 访问共享资源</p>
<p>⚫ 对互斥量解锁</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">mutex mut;</span><br><span class="line">mut.<span class="built_in">lock</span>();</span><br><span class="line">val++;</span><br><span class="line">mut.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">// lock_guard自动解锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">  <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>; <span class="comment">//自动锁定</span></span><br><span class="line">  cout &lt;&lt; <span class="string">"proc2函数正在改写a"</span> &lt;&lt; endl;</span><br><span class="line">} <span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unique_lock自动解锁，且可在中途解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">  <span class="function">unique_lock&lt;mutex&gt; <span class="title">g1</span><span class="params">(m, defer_lock)</span></span>; <span class="comment">//始化了一个没有加锁的mutex</span></span><br><span class="line">  g1.<span class="built_in">lock</span>(); <span class="comment">//手动加锁，注意，不是m.lock();注意，不是m.lock(),m已经被g1接管了;</span></span><br><span class="line">  cout &lt;&lt; <span class="string">"proc1函数正在改写a"</span> &lt;&lt; endl;</span><br><span class="line">  g1.<span class="built_in">unlock</span>(); <span class="comment">//临时解锁</span></span><br><span class="line">  cout &lt;&lt; <span class="string">"xxxxx"</span> &lt;&lt; endl;</span><br><span class="line">  g1.<span class="built_in">lock</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">"xxxxxx"</span> &lt;&lt; endl;</span><br><span class="line">} <span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>{</span><br><span class="line">  <span class="function">unique_lock&lt;mutex&gt; <span class="title">g2</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      m,</span></span></span><br><span class="line"><span class="params"><span class="function">      try_to_lock)</span></span>; <span class="comment">//尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作。</span></span><br><span class="line">  <span class="keyword">if</span> (g2.owns_lock) { <span class="comment">//锁成功</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"proc2函数正在改写a"</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"原始a为"</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"现在a为"</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">  } <span class="keyword">else</span> { <span class="comment">//锁失败则执行这段语句</span></span><br><span class="line">    cout &lt;&lt; <span class="string">""</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">} <span class="comment">//自动解锁</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-3-条件变量"><a href="#4-3-条件变量" class="headerlink" title="4.3.  条件变量"></a>4.3.  条件变量</h2><p>条件变量一般和互斥锁搭配使用，互斥锁用于上锁，条件变量用于在多线程环境中等待特定事件发生。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">k = <span class="number">1</span>; </span><br><span class="line">cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知其他所有在等待唤醒队列中的线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>](){ <span class="keyword">return</span> k == <span class="number">1</span>; }); </span><br><span class="line"><span class="comment">// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span>;</span><br><span class="line">cv.<span class="built_in">notify_one</span>();  <span class="comment">// 随机通知一个（unspecified）在等待唤醒队列中的线程</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="4-4-信号量"><a href="#4-4-信号量" class="headerlink" title="4.4.  信号量"></a>4.4.  信号量</h2><p>信号量是用来实现对共享资源的同步访问的机制，其使用方法和条件变量类似，都是通过<code>主动等待和主动唤醒</code>来实现的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;sem_1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>{</span><br><span class="line">  <span class="built_in">printFirst</span>();</span><br><span class="line">  <span class="built_in">sem_post</span>(&amp;sem_1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>{</span><br><span class="line">  <span class="built_in">sem_wait</span>(&amp;sem_1);</span><br><span class="line">  <span class="built_in">printSecond</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-5-异步操作"><a href="#4-5-异步操作" class="headerlink" title="4.5.  异步操作"></a>4.5.  异步操作</h2><p>刚实例化的future是没有储存值的，但在调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line">future&lt;<span class="keyword">double</span>&gt; fu = <span class="built_in">async</span>(t1, a, b);<span class="comment">//创建异步线程，并将线程的执行结果用fu占位；</span></span><br><span class="line">cout &lt;&lt; <span class="string">"正在进行计算"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"计算结果马上就准备好，请您耐心等待"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"计算结果："</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">//阻塞主线程，直至异步线程return</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-6-原子操作"><a href="#4-6-原子操作" class="headerlink" title="4.6.  原子操作"></a>4.6.  原子操作</h2><p>每次操作这个对象时，就不用lock与unlock，这个对象自身就具有原子性（==相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了==</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-7-生产者消费者模型"><a href="#4-7-生产者消费者模型" class="headerlink" title="4.7. 生产者消费者模型"></a>4.7. 生产者消费者模型</h2><p>店家生产包子 放到桌子上 客人吃包子</p>
<p>三个对象：生产者 消费者 容器 </p>
<p>生产者和消费者需要交流：有包子了通知客人吃，客人吃完了通知店家做</p>
<h3 id="简单实现："><a href="#简单实现：" class="headerlink" title="简单实现："></a>简单实现：</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    条件变量的类型 pthread_cond_t</span></span><br><span class="line"><span class="comment">    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">    int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</span></span><br><span class="line"><span class="comment">        - 等待，调用了该函数，线程会阻塞。</span></span><br><span class="line"><span class="comment">    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</span></span><br><span class="line"><span class="comment">        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span></span><br><span class="line"><span class="comment">    int pthread_cond_signal(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="comment">    int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒所有的等待的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add node, num : %d, tid : %ld\n"</span>, newNode-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只要生产了一个，就通知消费者消费</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"del node, num : %d, tid : %ld\n"</span>, tmp-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 没有数据，需要等待</span></span><br><span class="line">            <span class="comment">// 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="comment">//没有条件变量 会一致解锁 浪费资源</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ptids[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ctids[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="5-IO操作-x2F-线程池"><a href="#5-IO操作-x2F-线程池" class="headerlink" title="5. IO操作/线程池"></a>5. IO操作/线程池</h1><h2 id="5-1-介绍一下5种IO模型"><a href="#5-1-介绍一下5种IO模型" class="headerlink" title="5.1.  介绍一下5种IO模型"></a>5.1.  <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/486b0965c296">介绍一下5种IO模型</a></h2><ol>
<li>阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作  ==（等待 的准备好了才能继续）==</li>
<li>非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就==可以做其他事==。</li>
<li>信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。 ==（不是我去循环检查你好没好，而是你好了告诉我）==</li>
<li>IO复用/多路转接IO:linux用==select/poll==函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数 ==（批处理）==</li>
<li>异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。   ==（告知你我要什么，你自己给我送过来 然后再通知我）==</li>
</ol>
<h2 id="5-3-死循环-来连接时新建线程的方法效率有点低，怎么改进？"><a href="#5-3-死循环-来连接时新建线程的方法效率有点低，怎么改进？" class="headerlink" title="5.3.  死循环+来连接时新建线程的方法效率有点低，怎么改进？"></a>5.3.  死循环+来连接时新建线程的方法效率有点低，怎么改进？</h2><p>提前创建好一个线程池，用<code>生产者消费者模型</code>，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h2 id="5-4-线程池"><a href="#5-4-线程池" class="headerlink" title="5.4.  线程池"></a>5.4.  线程池</h2><ul>
<li><code>因为创建线程关闭线程花销是比较大的，大过了线程空转的花销</code>,创建和销毁线程开销大，可能需要上千个时钟周期，避免cpu花费不必要的时间在这上面。</li>
</ul>
<h3 id="5-4-1-原理"><a href="#5-4-1-原理" class="headerlink" title="5.4.1. 原理"></a>5.4.1. 原理</h3><p><strong>为了减少创建与销毁线程所带来的时间消耗与资源消耗，因此采用线程池的策略：</strong></p>
<ol>
<li><p>程序启动后，预先创建一定数量的线程放入空闲队列中，这些线程都是处于阻塞状态，基本不消耗CPU，只占用较小的内存空间。</p>
</li>
<li><p>接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。</p>
</li>
<li><p>任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。</p>
</li>
</ol>
<p><strong>线程池所解决的问题：</strong></p>
<ol>
<li>需要频繁创建与销毁大量线程的情况下，由于线程预先就创建好了，接到任务就能马上从线程池中调用线程来处理任务，<code>减少了创建与销毁线程带来的时间开销和CPU资源占用</code>。</li>
<li>需要并发的任务很多时候，无法为每个任务指定一个线程（<code>线程不够分</code>），使用线程池可以将提交的任务挂在任务队列上，等到池中有空闲线程时就可以为该任务指定线程。</li>
</ol>
<h3 id="5-4-2-x3D-x3D-怎么实现线程池-x3D-x3D"><a href="#5-4-2-x3D-x3D-怎么实现线程池-x3D-x3D" class="headerlink" title="5.4.2. ==怎么实现线程池=="></a>5.4.2. ==怎么实现线程池==</h3><ol>
<li><u>设置一个生产者消费者队列</u>，作为临界资源</li>
<li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li>
<li>当任务队列为空的时候，所有线程阻塞</li>
<li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li>
</ol>
<h3 id="5-4-3-线程池参数设置"><a href="#5-4-3-线程池参数设置" class="headerlink" title="5.4.3. 线程池参数设置"></a>5.4.3. 线程池参数设置</h3><p>线程池的线程数量设置<code>过多</code>会导致线程<code>竞争激烈</code></p>
<p>如果线程数量设置<code>过少</code>的话，还会导致系统<code>无法充分利</code>用计算机<code>资源</code></p>
<ul>
<li><p>CPU 密集型任务</p>
<p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <code>N（CPU 核心数）+1</code>，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
</li>
<li><p>I/O 密集型任务</p>
<p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <code>2N</code>。</p>
</li>
</ul>
<h2 id="5-5-select，epoll的区别，原理，性能，限制都说一说"><a href="#5-5-select，epoll的区别，原理，性能，限制都说一说" class="headerlink" title="5.5.  select，epoll的区别，原理，性能，限制都说一说"></a>5.5.  <a target="_blank" rel="noopener" href="https://www.zhihu.com/collection/786678607">select，epoll的区别，原理，性能，限制都说一说</a></h2><h3 id="5-5-1-IO多路复用"><a href="#5-5-1-IO多路复用" class="headerlink" title="5.5.1. IO多路复用"></a>5.5.1. IO多路复用</h3><p>IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。</p>
<p>这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。</p>
<p>IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><u>当用户进程调用了select，那么<code>整个进程会被block</code>，而同时，kernel会“<code>监视</code>”所有select负责的socket，当任何一个socket中的<code>数据准备好了</code>，select就会<code>返回</code>。这个时候用户进程再调用<code>read操作</code>，<code>将数据从kernel拷贝到用户进程</code>。</u></p>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="select-poll-epoll大体介绍及对比"><a href="#select-poll-epoll大体介绍及对比" class="headerlink" title="select poll epoll大体介绍及对比"></a>select poll epoll大体介绍及对比</h3><p><strong>(1)、select==&gt;时间复杂度O(n)</strong></p>
<ul>
<li><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>==（知道有io事件了 再遍历所有）==</p>
</li>
</ul>
<p><strong>(2)、poll==&gt;时间复杂度O(n)</strong></p>
<ul>
<li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.  ==(链表存储 没有大小限制)==</li>
</ul>
<p><strong>(3)、epoll==&gt;时间复杂度O(1)</strong></p>
<ul>
<li><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（==每个事件关联上fd==）</strong>的，此时我们对这些流的操作都是有意义的。==<strong>（复杂度降低到了O(1)）</strong>==、</p>
</li>
<li><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上<code>都是同步I/O</code>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
</li>
<li><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
</li>
</ul>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select本质上是通过设置或者检查存放fd标志位的数据结构(<code>检查描述符集</code>)来进行下一步处理。这样所带来的缺点是：</p>
<ol>
<li><p>单个进程可监视的fd数量被限制，即能监听端口的大小有限。默认是1024  ==（数量受限）==</p>
<p>一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p>
</li>
<li><p>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低： ==（效率低）==</p>
<p>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能<code>给套接字注册某个回调函数</code>，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
</li>
<li><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大  ==（维护的数据结构开销大）==</p>
<p><strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
</li>
<li><p>每次调用select 都要重新初始化fd集合</p>
</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p><strong>它没有最大连接数的限制</strong>，原因是它是基于链表来存储的，但是同样有一个缺点：   ==(链表存储 数量不限)==</p>
<ol>
<li><p>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。 （大量数据复制）</p>
</li>
<li><p>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a><strong>epoll:</strong></h3><ul>
<li>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。</li>
<li>LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作  ==（没读完数据可以重复提醒）==</li>
<li>在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。==（====我只说一次）==</li>
<li>所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。</li>
<li>还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的<code>回调机制</code>来激活该fd，epoll_wait便可以收到通知。</li>
</ul>
<h3 id="epoll为什么要有EPOLLET触发模式？"><a href="#epoll为什么要有EPOLLET触发模式？" class="headerlink" title="epoll为什么要有EPOLLET触发模式？"></a><strong>epoll为什么要有EPOLLET触发模式？</strong></h3><ul>
<li>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！==<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</strong>==</li>
</ul>
<h3 id="epoll的优点："><a href="#epoll的优点：" class="headerlink" title="epoll的优点："></a><strong>epoll的优点：</strong></h3><ol>
<li><p><strong>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</strong>；==（数量大）==</p>
</li>
<li><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 ==（效率高）==</p>
</li>
<li><p>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap<code>减少复制开销</code>。  ==（开销小）==</p>
</li>
</ol>
<h3 id="select、poll、epoll-区别总结"><a href="#select、poll、epoll-区别总结" class="headerlink" title="select、poll、epoll 区别总结"></a><strong>select、poll、epoll 区别总结</strong></h3><p><strong>1、支持一个进程所能打开的最大连接数</strong></p>
<blockquote>
<p>select    单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p>
<p>poll    poll本质上和select没有区别，但是它<code>没有</code>最大连接数的<code>限制</code>，原因是它是基于链表来存储的</p>
<p>epoll    虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接  ==(1G10W)==</p>
</blockquote>
<p><strong>2、FD剧增后带来的IO效率问题</strong></p>
<blockquote>
<p>select    因为每次调用时都会对连接进行<code>线性遍历</code>，所以随着FD的增加会造成遍历速度慢的“<code>线性下降性能问题</code>”。</p>
<p>poll    同上</p>
<p>epoll    因为epoll内核中实现是根据每个fd上的<code>callback函数</code>来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p>
</blockquote>
<p><strong>3、 消息传递方式</strong></p>
<blockquote>
<p>select     内核需要将消息传递到用户空间，都需要<code>内核拷贝</code>动作</p>
<p>poll    同上</p>
<p>epoll    epoll通过内核和用户空间<code>共享一块内存</code>来实现的。</p>
</blockquote>
<p>==<strong>总结：</strong>==</p>
<blockquote>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</strong></p>
<p><strong>1、表面上看epoll的性能最好，但是在<code>连接数少并且连接都十分活跃</code>的情况下，<code>select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</strong></p>
<p><strong>2、select低效是因为每次它都需要轮询。但<code>低效也是相对</code>的，视情况而定，也可通过良好的<code>设计</code>改善</strong></p>
</blockquote>
<h2 id="epoll水平触发与边沿触发"><a href="#epoll水平触发与边沿触发" class="headerlink" title="epoll水平触发与边沿触发"></a>epoll水平触发与边沿触发</h2><ol>
<li><p>LT模式</p>
<ul>
<li><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
</li>
<li><p>比如说我们采用epoll水平触发模式监听一个文件描述符的可读，当这个文件可读就绪时，epoll会触发一个通知，然后我们执行一次读取操作，但这次操作我们并没有把该文件描述符的数据全部读取完。当下一次调用epoll监听该文件描述符时，epoll还会再次触发通知，直到该事件被处理完。这就意味着，当epoll触发通知后，我们可以不立即处理该事件，当下次调用epoll监听时，然后会再次向应用程序通告此事件，此时我们再处理也不晚。</p>
</li>
</ul>
</li>
<li><p>ET模式</p>
<ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li>
<li>当文件描述符收到I/O事件通知时，通常我们并不知道要处理多少I/O（例如有多少字节可读）。如果程序采用循环来对文件描述符执行尽可能多的I/O，而文件描述符又被设置为可阻塞的，那么最终当没有更多的I/O可执行时，I/O系统调用就会阻塞。</li>
</ul>
</li>
<li><p>LT模式与ET模式的区别如下：</p>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</li>
</ol>
<h1 id="6-锁"><a href="#6-锁" class="headerlink" title="6. 锁"></a>6. 锁</h1><h2 id="6-1-Linux的4种锁机制："><a href="#6-1-Linux的4种锁机制：" class="headerlink" title="6.1.  Linux的4种锁机制："></a>6.1.  Linux的4种锁机制：</h2><h3 id="四种锁介绍"><a href="#四种锁介绍" class="headerlink" title="四种锁介绍"></a>四种锁介绍</h3><ol>
<li><p>==互斥锁：mutex==，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
</li>
<li><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许<code>多个线程同时获得读操作</code>。但是同一时刻只能有<code>一个线程可以获得写锁</code>。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。   ==(多个读 一个写)==</p>
</li>
<li><p>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在<code>原地自旋</code>，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，==在加锁时间短暂的环境下会极大的提高效率==。但如果加锁时间过长，则会非常浪费CPU资源。</p>
</li>
<li><p>RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。==在有大量读操作，少量写操作的情况下效率非常高。==</p>
</li>
</ol>
<h3 id="互斥锁和读写锁的区别："><a href="#互斥锁和读写锁的区别：" class="headerlink" title="互斥锁和读写锁的区别："></a>互斥锁和读写锁的区别：</h3><ol>
<li><p>读写锁<code>区分读者和写者</code>，而互斥锁不区分</p>
</li>
<li><p>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许<code>多个读者</code>同时读对象。</p>
</li>
</ol>
<h2 id="6-2-乐观锁和悲观锁"><a href="#6-2-乐观锁和悲观锁" class="headerlink" title="6.2.  乐观锁和悲观锁"></a>6.2.  乐观锁和悲观锁</h2><p>前面提到的==互斥锁、自旋锁、读写锁==，都是属于悲观锁。</p>
<ul>
<li><p>悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>
</li>
<li><p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
</li>
</ul>
<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>
<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现乐观锁全程并没有加锁，所以它也叫无锁编程。</p>
<h2 id="6-3-递归锁和非递归锁"><a href="#6-3-递归锁和非递归锁" class="headerlink" title="6.3.  递归锁和非递归锁"></a>6.3.  递归锁和非递归锁</h2><p> Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。<br>     二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。   ==(递归锁指不能连续上锁 连续解锁)==<br>     Windows下的Mutex和Critical Section是可递归的。Linux下的pthread_mutex_t锁默认是非递归的。可以显示的设置PTHREAD_MUTEX_RECURSIVE属性，将pthread_mutex_t设为递归锁。</p>
<h2 id="6-4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"><a href="#6-4-两个进程访问临界区资源，会不会出现都获得自旋锁的情况？" class="headerlink" title="6.4.  两个进程访问临界区资源，会不会出现都获得自旋锁的情况？"></a>6.4.  两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h2><p><code>单核cpu，并且开了抢占可以造成这种情况。</code></p>
<h2 id="6-5-互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#6-5-互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="6.5.  互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>6.5.  互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h2><p>互斥锁和读写锁区别：</p>
<p>互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<ol>
<li><p>读写锁区分读者和写者，而互斥锁不区分</p>
</li>
<li><p>互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</p>
</li>
</ol>
<h2 id="6-6-死锁发生的条件以及如何解决死锁"><a href="#6-6-死锁发生的条件以及如何解决死锁" class="headerlink" title="6.6.  死锁发生的条件以及如何解决死锁"></a>6.6.  死锁发生的条件以及如何解决死锁</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。</p>
<h3 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h3><p><code>互斥条件</code>：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</p>
<p><code>请求和保持条件</code>：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</p>
<p><code>不可抢占条件</code>：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p>
<p><code>循环等待条件</code>：进程发生死锁后，必然存在一个进程-资源之间的环形链</p>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>即破坏上述四个条件之一，主要方法如下：</p>
<ol>
<li><p>资源一次性分配，从而剥夺请求和保持条件</p>
</li>
<li><p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</p>
</li>
<li><p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件</p>
</li>
</ol>
<h3 id="处理死锁的基本发法"><a href="#处理死锁的基本发法" class="headerlink" title="处理死锁的基本发法:"></a>处理死锁的基本发法:</h3><ol>
<li><p>预防死锁:属于事前预防的策略，通过设置某些限制条件，去破坏产生死锁的四个必要条件或其中的几个条件。预防死锁比较容易实现，所以被泛使用，但是由于施加的限制条件过于严格可能会导致系统资源利用率和系统吞吐量降低。</p>
</li>
<li><p>避免死锁:属于事前预防的策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的产生。但实现有一定的难度。目前较完善的系统中常用此法来避免死锁。</p>
</li>
<li><p>检测死锁:这种方法不需要事前采取任何限制措施，也不用检查是否进入不安全状态，而是允许系统在运行的过程中发生死锁。但是通过系统所设置的检测机构.及时的检测出死锁的发生，并精确的测出与死锁有关的进程和资源，然后，采取适当的措施，从系统中将已发生的死锁清楚掉。</p>
</li>
<li><p>解除死锁:这是与检测死锁相配套的一套措施。当检测到系统已经产生死锁时，须将进程从死锁中解放出来。通常用到的实施方法是撤销或挂起些进程，以便收回一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源和吞吐量，但在现实上难度也最大。</p>
</li>
</ol>
<h3 id="预防死锁和避免死锁的区别"><a href="#预防死锁和避免死锁的区别" class="headerlink" title="预防死锁和避免死锁的区别:"></a>预防死锁和避免死锁的区别:</h3><ul>
<li><p>预防死锁和避免死锁实质上都是通过施加某种相知条件的方法，来预防发生死锁。两者的主要区别:为了预防死锁所施加的限制条件较为严格，这往往会影响到进程的并发执行，而避免死锁所施加的限制条件则较为宽松，有利于进程的并发执行。 </p>
<p>==（预防比较严格 避免比较宽松）==</p>
</li>
</ul>
<h2 id="6-7-银行家算法（避免死锁）"><a href="#6-7-银行家算法（避免死锁）" class="headerlink" title="6.7.  银行家算法（避免死锁）"></a>6.7.  <code>银行家算法</code>（避免死锁）</h2><ul>
<li><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中<code>允许进程动态地申请资源</code>，但系统在进行资源分配之前，应<code>先计算此次分配资源的安全性</code>，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。要解释银行家算法，必须先解释操作系统安全状态和不安全状态。</p>
</li>
<li><p>安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220303234601290-1516095814.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220303234601275-2072986485.png" alt="img"></p>
<h2 id="6-8-单核机器上写多线程程序，是否需要考虑加锁，为什么？"><a href="#6-8-单核机器上写多线程程序，是否需要考虑加锁，为什么？" class="headerlink" title="6.8.  单核机器上写多线程程序，是否需要考虑加锁，为什么？"></a>6.8.  单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2><ul>
<li>在单核机器上写多线程程序，<code>仍然需要</code>线程锁。因为线程锁通常用来实现线程的<code>同步和通信</code>。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。<u>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</u></li>
</ul>
<h1 id="7-并行并发"><a href="#7-并行并发" class="headerlink" title="7. 并行并发"></a>7. 并行并发</h1><h2 id="7-1-并发-concurrency-和并行-parallelism"><a href="#7-1-并发-concurrency-和并行-parallelism" class="headerlink" title="7.1.  并发(concurrency)和并行(parallelism)"></a>7.1.  并发(concurrency)和并行(parallelism)</h2><ul>
<li><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p>
<p><code>（其实是交替运行）</code></p>
</li>
<li><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p>
<p><code>（真正的同时运行）</code></p>
</li>
</ul>
<h2 id="7-2-如何采用单线程的方式处理高并发"><a href="#7-2-如何采用单线程的方式处理高并发" class="headerlink" title="7.2.  如何采用单线程的方式处理高并发"></a>7.2.  如何采用单线程的方式处理高并发</h2><p>（这里指主线程为单线程）</p>
<p>在单线程模型中，可以采用<code>I/O复用</code>来提高单线程处理多个请求的能力</p>
<p>采用事件驱动模型<code>（epoll?）</code>，基于异步回调来处理事件，当遇到非常耗时的IO操作时，采用非阻塞的方式，继续执行后面的代码，并且进入事件循环，当IO操作完成时，程序会被通知IO操作已经完成。</p>
<h1 id="8-内存"><a href="#8-内存" class="headerlink" title="8.    内存"></a>8.    内存</h1><h2 id="8-1-Linux虚拟地址空间"><a href="#8-1-Linux虚拟地址空间" class="headerlink" title="8.1.  Linux虚拟地址空间"></a>8.1.  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96098896">Linux虚拟地址空间</a></h2><p><code>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏</code>，<u>采用了虚拟内存</u>。</p>
<blockquote>
<p>直接使用物理内存会产生一些问题</p>
<ol>
<li>内存空间利用率的问题 （内存碎片化）</li>
<li>读写内存的安全性问题（访问权限问题）</li>
<li>进程间的安全问题</li>
<li>内存读写的效率问题</li>
</ol>
</blockquote>
<p>虚拟内存技术使得不同进程在运行过程中，<u>它所看到的是自己独自占有了当前系统的4G内存</u>。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间<code>映射并存储</code>到物理内存上。 <u>事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）</u>，等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，<code>要动态分配内存</code>，比如malloc时，也<code>只是分配了虚拟内存</code>，即为这块虚拟内存对应的页表项做相应设置，<code>当进程真正访问到此数据时，才引发缺页异常</code>。</p>
<p>请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p>
<p><strong>虚拟内存的好处：</strong></p>
<ol>
<li><p><code>扩大</code>地址空间；</p>
</li>
<li><p>内存<code>保护</code>：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</p>
</li>
<li><p><code>公平</code>内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</p>
</li>
<li><p>当进程<code>通信</code>时，可采用虚存共享的方式实现。</p>
</li>
<li><p>当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，<code>节省内存</code></p>
</li>
<li><p>虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。<u>在内存中可以保留多个进程</u>，系统<code>并发度提高</code></p>
</li>
<li><p>在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</p>
</li>
</ol>
<p><strong>虚拟内存的代价：</strong></p>
<ol>
<li><p>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的<code>内存</code></p>
</li>
<li><p>虚拟地址到物理地址的转换，增加了指令的<code>执行时间</code>。</p>
</li>
<li><p>页面的换入换出需要<code>磁盘I/O</code>，这是很<code>耗时</code>的</p>
</li>
<li><p><u>如果一页中只有一部分数据，会浪费内存。</u></p>
</li>
</ol>
<h2 id="8-2-操作系统中的程序的内存结构"><a href="#8-2-操作系统中的程序的内存结构" class="headerlink" title="8.2.  操作系统中的程序的内存结构"></a>8.2.  操作系统中的程序的内存结构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<p><strong>一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段（包括文本区和只读数据区）、数据区和未初始化数据区三部分。</strong></p>
<ul>
<li><p><code>代码段</code>：存放程序执行代码的一块内存区域。<u>这部分区域的大小在程序运行前就已经确定</u>，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量</p>
</li>
<li><p>数据段：存放程序中已初始化的<code>全局变量</code>的一块内存区域。<u>数据段也属于静态内存分配</u></p>
</li>
</ul>
<p>text段和data段在编译时已经分配了空间，而<code>BSS段并不占用可执行文件的大小</code>，它是由<code>链接器来获取内存</code>的。</p>
<p>bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有<code>正文段</code>和<code>初始化数据段</code>。  </p>
<p>数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。</p>
<p><u>可执行程序在运行时又多出两个区域</u>：==栈区==和==堆区==。</p>
<p>==栈区==：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块<code>连续</code>的内存区域，最大容量是由系统<code>预先定义</code>好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p>
<p>==堆区==：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。<code>堆是从低地址位向高地址位增长，采用链式存储结构</code>。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的<code>效率</code>比栈要<code>低</code>的多。</p>
<h2 id="8-3-为什么堆栈生长方向不一样"><a href="#8-3-为什么堆栈生长方向不一样" class="headerlink" title="8.3.  为什么堆栈生长方向不一样"></a>8.3.  <a target="_blank" rel="noopener" href="https://blog.csdn.net/unix21/article/details/8531875">为什么堆栈生长方向不一样</a></h2><p><strong>历史原因</strong></p>
<ul>
<li>在没有内存管理单元MMU的时代，<code>为了最大的利用内存空间</code>，堆和栈被设计为从<code>两端相向生长</code>。那么哪一个向上，哪一个向下呢？<br>人们对数据访问是习惯于向上的，比如你在堆中new一个数组，是习惯于把低元素放到低地址，把高位放到高地址，所以<code>堆向上生长比较符合习惯</code>。而<code>栈则对方向不敏感</code>，一般对栈的操作只有PUSH和pop，无所谓向上向下，所以就把堆放在了低端，把栈放在了高端。MMU出来后就无所谓了，只不过也没必要改了。</li>
</ul>
<h2 id="8-4-A-a-x3D-new-A-a-gt-i-x3D-10-在内核中的内存分配上发生了什么？"><a href="#8-4-A-a-x3D-new-A-a-gt-i-x3D-10-在内核中的内存分配上发生了什么？" class="headerlink" title="8.4.  A* a = new A; a->i = 10;在内核中的内存分配上发生了什么？"></a>8.4.  A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么？</h2><p>A* a = new A; a-&gt;i = 10：</p>
<p>1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序<code>栈区</code>开辟4/8字节的空间（0x000m），分配给指针a。==（栈区指针8字节）==</p>
<p>2）new A：<code>通过new动态的在堆区申请类A大小的空间</code>（0x000n）。 ==（new在堆上分配A空间）==</p>
<p>3）a = new A：将指针a的<u>内存区域填入栈中类A申请到的地址的地址</u>。即*（0x000m）=0x000n。 ==（指针指向A地址）==</p>
<p>4）==a-&gt;i==：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。  ==（栈-&gt;堆-&gt;偏移-&gt;赋值）==</p>
<h2 id="8-5-静态变量什么时候初始化"><a href="#8-5-静态变量什么时候初始化" class="headerlink" title="8.5.  静态变量什么时候初始化"></a>8.5.  静态变量什么时候初始化</h2><p>静态变量存储在虚拟地址空间的数据段和bss段，<code>C语言</code>中其在代码执行之前初始化，属于<code>编译期初始化</code>。</p>
<p>而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定</p>
<p><strong>全局或静态对象是有首次用到时才会进行构造，即：</strong></p>
<p>==全局变量,总是在main函数运行之前初始化==</p>
<p>==局部静态对象当且仅当对象首次用到时进行构造==</p>
<h2 id="8-6-一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"><a href="#8-6-一个类，里面有static，virtual，之类的，来说一说这个类的内存分布" class="headerlink" title="8.6.  一个类，里面有static，virtual，之类的，来说一说这个类的内存分布"></a>8.6.  一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h2><p><strong>static修饰符</strong></p>
<ol>
<li>static修饰成员变量</li>
</ol>
<ul>
<li><p><u>对于非静态数据成员，每个类对象都有自己的拷贝</u>。而<u>静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝</u>，<code>为该类型的所有对象所共享(包括其派生类)</code>。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</p>
</li>
<li><p>因为静态数据成员在==全局数据区==分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</p>
</li>
</ul>
<ol start="2">
<li>static修饰成员函数</li>
</ol>
<ul>
<li>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此==它不具有this指针==。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</li>
</ul>
<ol start="3">
<li>Static修饰的成员函数，在==代码区==分配内存。</li>
</ol>
<p><strong>C++继承和虚函数</strong></p>
<ul>
<li><p>C++多态分为静态多态和动态多态。</p>
<blockquote>
<p>静态多态是通过<u>重载</u>和<u>模板</u>技术实现，在==编译==的时候确定。</p>
<p>动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
</blockquote>
</li>
<li><p>动态多态实现有几个条件：</p>
<blockquote>
<p> 虚函数；</p>
<p> 一个基类的指针或引用指向派生类的对象；</p>
</blockquote>
</li>
<li><p>基类指针在调用成员函数(虚函数)时，就会去<u>查找该对象的虚函数表</u>。虚函数表的地址在每个对象的首地址。<u>查找该虚函数表中该函数的指针进行调用</u>。</p>
</li>
<li><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。</p>
</li>
<li><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，<u>如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</u></p>
</li>
</ul>
<p><strong>virtual修饰符</strong></p>
<ul>
<li><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。</p>
</li>
<li><p>如果该类是virutal继承而来的子类，则该类的<code>虚函数表指针</code>==和该类其他成员一起存储==。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</p>
</li>
<li><p>如果类中成员是virtual属性，会隐藏父类对应的属性。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220305213755495-1587408473.png" alt="img" style="zoom:50%;">

<h2 id="8-7-内存溢出和内存泄漏"><a href="#8-7-内存溢出和内存泄漏" class="headerlink" title="8.7.  内存溢出和内存泄漏"></a>8.7.  内存溢出和内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>指程序申请内存时，没有足够的内存供申请者使用。内存溢出<code>就是你要的内存空间超过了系统实际分配给你的空间</code>，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<p>内存溢出原因：</p>
<ol>
<li><p>内存中加载的==数据量过于庞大==，如一次从数据库取出过多数据</p>
</li>
<li><p>递归调用层次太多。==递归==函数在运行时会执行==压栈==操作，当压栈次数太多时，也会导致堆栈溢出。</p>
</li>
<li><p>集合类中有对对象的引用，使用完后==未清空==，使得不能回收</p>
</li>
<li><p>代码中存在死循环或==循环==产生过多重复的对象实体</p>
</li>
<li><p>==指针或数组越界==。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p>
</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>内存泄漏是指由于疏忽或错误造成了<code>程序未能释放掉不再使用的内存</code>的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。  ==（堆上内存没有被释放）==</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。  ==（分配的资源未释放）==</p>
</li>
<li><p>==没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。==  </p>
<blockquote>
<p>（在公有继承中,基类对派生类及其对象的操作,只能影响到那些从基类继承下来的成员.如果想要用基类对非继承成员进行操作,则要把基类的这个函数定义为虚函数.）</p>
</blockquote>
</li>
</ol>
<h2 id="8-8-为什么要有page-cache，操作系统怎么设计的page-cache"><a href="#8-8-为什么要有page-cache，操作系统怎么设计的page-cache" class="headerlink" title="8.8.  为什么要有page cache，操作系统怎么设计的page cache"></a>8.8.  为什么要有page cache，操作系统怎么设计的page cache</h2><p><strong>Page cache（页面缓存）</strong></p>
<blockquote>
<p>Page cache 也叫页缓冲或文件缓冲，是由好几个磁盘块构成，大小通常为4k，在64位系统上为8k，构成的几个磁盘块在物理磁盘上不一定连续，文件的组织单位为一页， 也就是一个page cache大小，文件读取是由外存上不连续的几个磁盘块，到buffer cache，然后组成page cache，然后供给应用程序。</p>
<p>Page cache在linux读写文件时，它用于<code>缓存文件的逻辑内容</code>，从而<code>加快对磁盘上映像和数据的访问</code>。具体说是加速对文件内容的访问，buffer cache缓存文件的具体内容——物理磁盘上的磁盘块，这是加速对磁盘的访问。</p>
</blockquote>
<ul>
<li><p>CPU如果要访问外部磁盘上的文件，需要首先将这些文件的内容拷贝到内存中，<strong>由于硬件的限制，从磁盘到内存的数据传输速度是很慢的</strong>，<u>如果现在物理内存有空余，干嘛不用这些空闲内存来缓存一些磁盘的文件内容呢</u>，这部分用作缓存磁盘文件的内存就叫做page cache。</p>
</li>
<li><p>page cache中有一部分磁盘文件的缓存，<code>因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</code>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree（基数树），另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项</p>
</li>
<li><p>radix tree（基数树）其实就差不多是传统的二叉树，只是在寻找方式上，利用比如一个unsigned int的类型的每一个比特位作为树节点的判断。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220304010427367-928071720.png" alt="img"></p>
<h2 id="8-9-？逻辑地址、虚拟地址、物理地址"><a href="#8-9-？逻辑地址、虚拟地址、物理地址" class="headerlink" title="8.9.  ？逻辑地址、虚拟地址、物理地址"></a>8.9.  ？逻辑地址、虚拟地址、物理地址</h2><ul>
<li><p>物理地址：加载到内存地址寄存器中的地址，==内存单元的真正地址==。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。</p>
</li>
<li><p>逻辑地址：由程序产生的与段相关的==偏移地址部分==，<code>编程中使用的地址</code>（在非虚拟内存的情况下给一个进程分配一段内存空间）。</p>
</li>
<li><p>虚拟内存：虚拟<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98">内存</a>是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/7210959">计算机系统</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5633616">内存管理</a>的一种技术。它使得==<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445">应用程序</a>认为==它拥有==连续的可用的==<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>（一个连续完整的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/1423980">地址空间</a>），而==实际==上，它通常是被分隔成==多个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/2502263">物理内存</a>碎片==，还有==部分暂时存储在外部<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8/2386684">磁盘存储器</a>==上，在需要时进行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/1586256">数据交换</a>。</p>
<blockquote>
<p>虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 虚拟内存的实际容量 = min（内存和外存容量之和，CPU寻址范围）</p>
<p>如：某计算机地址结构为32位，按字节编址，内存大小位512MB，外存大小为2GB，则虚拟内存的最大容量为4GB.(2的32次方B)</p>
<p>32位CPU一般有32根地址总线，那么就一共可以寻232个地址=也就是4x1024x1024x1024=4G个地址，1个地址对应1字节的存储单位，对应到内存上就是4GB（4GByte）</p>
</blockquote>
</li>
</ul>
<h2 id="8-10-虚拟内存和物理内存怎么对应"><a href="#8-10-虚拟内存和物理内存怎么对应" class="headerlink" title="8.10. 虚拟内存和物理内存怎么对应"></a>8.10.<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96098896"> 虚拟内存</a>和物理内存怎么对应</h2><h3 id="8-10-1-页式管理"><a href="#8-10-1-页式管理" class="headerlink" title="8.10.1.   页式管理"></a>8.10.1.   页式管理</h3><p>通过页号在页表中查询对应的内存块号，得到内存块起始地址，再加上偏移地址得到物理地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220304010542498-1068777910.png" alt="img"></p>
<h3 id="8-10-2-段页式挂管理"><a href="#8-10-2-段页式挂管理" class="headerlink" title="8.10.2.   段页式挂管理"></a>8.10.2.   段页式挂管理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="IMG_256"></p>
<h3 id="8-10-3-快表的使用-x2F-高速缓存（cache）"><a href="#8-10-3-快表的使用-x2F-高速缓存（cache）" class="headerlink" title="8.10.3.   快表的使用/高速缓存（cache）"></a>8.10.3.   快表的使用/高速缓存（cache）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg" alt="img"></p>
<h3 id="8-10-4-请求分页式管理（虚拟内存）"><a href="#8-10-4-请求分页式管理（虚拟内存）" class="headerlink" title="8.10.4.   请求分页式管理（虚拟内存）"></a>8.10.4.   请求分页式管理（虚拟内存）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg" alt="IMG_256"></p>
<h2 id="8-11-OS缺页置换算法"><a href="#8-11-OS缺页置换算法" class="headerlink" title="8.11. OS缺页置换算法"></a>8.11. OS缺页置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p>
<ol>
<li><p><code>先进先出(FIFO)算法</code>：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。  ==（那最早调入的替换掉）==</p>
</li>
<li><p><code>最近最少使用（LRU）算法</code>: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。  ==（替换最长时间没有使用的页面）==</p>
</li>
<li><p>最佳置换算法（OPT）算法：最佳置换算法是由 <strong>Belady</strong> 于1966年提出的一种理论上的算法。<code>每次选择以后永不使用的</code>， 或许是在最长(未来)时间内不再被访问的页面的页面被淘汰。显然OPT算法是<code>最优</code>的，但是在实际操作往往无法预知未来，所以OPT只存在理论而<code>不能真的实现</code>，通常用于衡量其他置换算法的优劣。</p>
</li>
<li><p>时钟置换（Clock/NRU）算法：也称为NRU算法（最近未使用算法）是LRU和FIFO的折中算法。</p>
</li>
</ol>
<p>当前最常采用的就是LRU算法。</p>
<h2 id="8-12-CPU内存的寻址能力？"><a href="#8-12-CPU内存的寻址能力？" class="headerlink" title="8.12. CPU内存的寻址能力？"></a>8.12. CPU内存的寻址能力？</h2><p>（CPU寻址范围是2的N次方字节，即2^N(B)。）</p>
<h2 id="8-13-CPU寻址了解吗-为什么需要虚拟地址空间"><a href="#8-13-CPU寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="8.13.  CPU寻址了解吗?为什么需要虚拟地址空间?"></a>8.13.  CPU寻址了解吗?为什么需要虚拟地址空间?</h2><p>现代处理器使用的是- -种称为虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址</p>
<p>转换的硬件是CPU中含有一个被称为内存管理单元(Memory Management Unit, MMU) 的硬件。</p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>没有虚拟地址空间的时候， 程序都是直接访问和操作的都是物理内存 。</p>
<p>如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。</p>
<blockquote>
<p>直接使用物理内存会产生一些问题</p>
<ol>
<li>内存空间利用率的问题 （内存碎片化）</li>
<li>读写内存的安全性问题（访问权限问题）</li>
<li>进程间的安全问题</li>
<li>内存读写的效率问题</li>
</ol>
</blockquote>
<p> <code>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏</code>，<u>采用了虚拟内存</u>。</p>
<p><strong>通过虚拟地址访问内存有以下优势：</strong></p>
<ul>
<li><p>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</p>
</li>
<li><p>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页(通常大小为4 KB) 保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</p>
</li>
<li><p>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</p>
</li>
</ul>
<h1 id="9-用户态和内核态"><a href="#9-用户态和内核态" class="headerlink" title="9.    用户态和内核态"></a>9.    用户态和内核态</h1><h2 id="9-1-用户态和内核态区别"><a href="#9-1-用户态和内核态区别" class="headerlink" title="9.1.  用户态和内核态区别"></a>9.1.  用户态和内核态区别</h2><p>内核态：<code>cpu可以访问内存的所有数据</code>，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：<code>只能受限的访问内存</code>，且<code>不允许访问外围设备</code>，<code>占用cpu的能力被剥夺</code>，cpu资源可以被其他程序获取。</p>
<p>内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。</p>
<blockquote>
<p>用户态拥有最低的特权级，内核态拥有较高的特权级。</p>
<p>运行在用户态的程序不能直接访问操作系统内核数据结构和程序。</p>
</blockquote>
<h4 id="内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。"><a href="#内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。" class="headerlink" title="内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。"></a>内核态和用户态之间的转换方式主要包括：<code>系统调用</code>，<code>异常和中断</code>。</h4><ul>
<li><p>系统调用</p>
<blockquote>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</blockquote>
</li>
<li><p>中断</p>
<blockquote>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
</li>
<li><p>异常</p>
<blockquote>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。</p>
</li>
<li><p>系统调用<code>实质</code>就是<u>通</u><u>过指令产生中断</u>，称为<u>软中断</u>。</p>
</li>
<li><p>进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，<u>此时进程陷入内核态</u>，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中，然后设置堆栈指针寄存器的地址为内核栈地址，这样就完成了用户栈向内核栈的切换。</p>
</li>
<li><p>当进程从内核态切换到用户态时，最后把保存在内核栈中的用户栈地址恢复到CPU栈指针寄存器即可，这样就完成了内核栈向用户栈的切换。</p>
</li>
</ol>
<h2 id="9-2-操作系统为什么要分内核态和用户态"><a href="#9-2-操作系统为什么要分内核态和用户态" class="headerlink" title="9.2.  操作系统为什么要分内核态和用户态"></a>9.2.  操作系统为什么要分内核态和用户态</h2><p>为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。</p>
<p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。</p>
<blockquote>
<p>假设没有这种内核态和用户态之分，程序随随便就能访问<u>硬件资源</u>，比如<u>分配内存</u>，程序能随便读写所有的内存空间，如果程序员不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。<br>用户程序是不可信的，不管程序员有意还是无意，都容易将系统==干到崩溃==。</p>
</blockquote>
<h2 id="9-3-？用户态到内核态的转化原理"><a href="#9-3-？用户态到内核态的转化原理" class="headerlink" title="9.3. ？用户态到内核态的转化原理"></a>9.3. ？用户态到内核态的转化原理</h2><h3 id="用户态到内核态的转化原理"><a href="#用户态到内核态的转化原理" class="headerlink" title="用户态到内核态的转化原理"></a>用户态到内核态的转化原理</h3><h4 id="1-用户态切换到内核态的3种方式"><a href="#1-用户态切换到内核态的3种方式" class="headerlink" title="1. 用户态切换到内核态的3种方式"></a>1. 用户态切换到内核态的3种方式</h4><ul>
<li><p>系统调用</p>
<blockquote>
<p>这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。</p>
</blockquote>
</li>
<li><p>异常</p>
<blockquote>
<p>当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。</p>
</blockquote>
</li>
<li><p>外围设备的中断</p>
<blockquote>
<p>当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
</li>
</ul>
<h4 id="2-切换操作"><a href="#2-切换操作" class="headerlink" title="2. 切换操作"></a>2. 切换操作</h4><p>线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换。（<strong>“用户态与内核态的切换”具体带来什么成本？？？</strong>）</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的<code>切换操作上来说，涉及的关键步骤是完全一样的</code>，没有任何区别，都相当于执行了一个中断响应的过程，因为<u>系统调用实际上最终是<code>中断机制</code>实现的</u>，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<ul>
<li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li>
<li>使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li>
<li>将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li>
</ul>
<h4 id="3-在Linux中，上下文切换，进程切换和线程切换之间有什么区别？"><a href="#3-在Linux中，上下文切换，进程切换和线程切换之间有什么区别？" class="headerlink" title="3. 在Linux中，上下文切换，进程切换和线程切换之间有什么区别？"></a>3. 在Linux中，上下文切换，进程切换和线程切换之间有什么区别？</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/13d5819d62ff237b70f77c9bf5228143d64099db/img/image-20220315112359560.png" alt="img/image-20220315112359560.png  0 → 100644"></p>
<p>上下文切换涉及存储进程或线程的上下文或状态，以便可以在需要时重新加载它，并可以执行</p>
<p>从先前的相同点恢复。这是多任务操作系统的功能，并且允许单个CPU由多个进程共享。</p>
<p>进程切换或进程调度是通过保存当前正在执行的进程的所有状态（包括其寄存器状态，关联的内核状态及其所有虚拟内存配置）来将一个进程更改为另一个进程。</p>
<p>线程切换是指在进程中从一个线程切换到另一个线程。</p>
<p>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<p>因此，在进程之间进行切换的成本比在线程之间进行切换的成本高得多。</p>
<blockquote>
<p>举一个不太恰当的例子，线程切换就好比你从主卧走到次卧，反正主卧和次卧都在同一个房子中(虚拟地址空间)，因此你无需换鞋子、换衣服等等。但是进程切换就不一样了，进程切换就好比从你家到别人家，这是两个不同的房子(不同的虚拟地址空间)，出发时要换好衣服、鞋子等等，到别人家后还要再换鞋子等等。</p>
<p>因此我们可以形象的认为线程是处在同一个屋檐下的，这里的屋檐就是虚拟地址空间，因此线程间切换无需虚拟地址空间的切换；而进程则不同，两个不同进程位于不同的屋檐下，即进程位于不同的虚拟地址空间，因此进程切换涉及到虚拟地址空间的切换，这也是为什么进程切换要比线程切换慢的原因。</p>
</blockquote>
<h4 id="4-为什么虚拟地址切换很慢"><a href="#4-为什么虚拟地址切换很慢" class="headerlink" title="4. 为什么虚拟地址切换很慢"></a>4. 为什么虚拟地址切换很慢</h4><p>现在我们已经知道了进程都有自己的虚拟地址空间，把==虚拟地址转换为物理地址需要查找页表==，<code>页表查找是一个很慢的过程</code>，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是==TLB==，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，==页表切换后TLB就失效==了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而==线程切换则不会导致TLB失效==，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<h2 id="9-4-系统调用是什么，你用过哪些系统调用"><a href="#9-4-系统调用是什么，你用过哪些系统调用" class="headerlink" title="9.4.  系统调用是什么，你用过哪些系统调用"></a>9.4.  系统调用是什么，你用过哪些系统调用</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/202203112205908.jpeg" alt="img" style="zoom:50%;">

<ol>
<li><p>概念：</p>
<ul>
<li><p>在计算机中，系统调用（英语：system call），又称为<u>系统呼叫</u>，指<u>运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务</u>。系统调用<code>提供了用户程序与操作系统之间的接口</code>（即==系统调用是用户程序和内核交互的接口==）。</p>
</li>
<li><p>操作系统中的状态分为管态（<code>核心态</code>）和目态（<code>用户态</code>）。</p>
<blockquote>
<p><u>大多数系统<code>交互式</code>操作需求在<code>内核</code>态执行</u>。如设备IO操作或者进程间通信。</p>
<p>特权指令：一类==只能在核心态==下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说<u>主要是和<code>硬件</code>相关的一些指令</u>。</p>
<p>用户程序只在用户态下运行，<u>有时需要访问系统核心功能，这时通过<code>系统调用接口</code>使用系统调用</u>。</p>
</blockquote>
</li>
<li><p>应用程序<u>有时会需要一些危险的、权限很高的指令</u>，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，<u>所有的资源都由操作系统控制，进程只能向操作系统请求这些资源</u>。<code>操作系统是这些资源的唯一入口，这个入口就是系统调用</code>。</p>
</li>
</ul>
</li>
<li><p>系统调用举例：</p>
<p><u>对文件进行写操作</u>，程序向打开的文件写入字符串“hello world”，<u>open和write都是系统调用</u>。还有写数据write，创建进程<u>fork，vfork</u>等都是系统调用。<strong>用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。</strong></p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2></li>
</ol>
<ul>
<li><p><code>调用库函数是为了使用系统调用</code>。linux几乎库函数和系统调用一一对应。windows则不然。</p>
</li>
<li><p>从宏观上说，<code>系统调用时内核层，C标准库在应用层</code>。</p>
</li>
<li><p>从细节上来说，<code>库函数的实现方式，一般都是对系统调用的再次封装</code>，在linux中，C标准基本是对系统调用的包装</p>
<blockquote>
<p>例如我们常见的printf，putc，fwrite等等，其实去看源码可以发现内部都有使用系统调用write函数，相似的例子还有很多，例如文件描述符filefd，与FILE的关系，FILE是一个struct，内部其实封装了filefd，同时包括一个buffer用于缓冲…</p>
</blockquote>
</li>
</ul>
<h2 id="9-5-请介绍一下操作系统中的中断"><a href="#9-5-请介绍一下操作系统中的中断" class="headerlink" title="9.5.  请介绍一下操作系统中的中断"></a>9.5.  请介绍一下操作系统中的中断</h2><p>中断是指CPU对系统发生的某个事件做出的一种反应，<code>CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。</code></p>
<h3 id="中断一般三类。"><a href="#中断一般三类。" class="headerlink" title="中断一般三类。"></a>中断一般三类。</h3><blockquote>
<ol>
<li><p>一种是由==CPU外部==引起的，如I/O中断、时钟中断，</p>
</li>
<li><p>一种是来自==CPU内部事件==或==程序执行中引起的中断==，例如程序非法操作，地址越界、浮点溢出，</p>
</li>
<li><p>最后一种是在程序中使用了==系统调用==引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。</p>
</li>
</ol>
</blockquote>
<h2 id="9-6-操作系统中的缺页中断"><a href="#9-6-操作系统中的缺页中断" class="headerlink" title="9.6.  操作系统中的缺页中断"></a>9.6.  操作系统中的缺页中断</h2><p>malloc()和mmap()等内存分配函数，<u>在分配时只是建立了进程虚拟地址空间</u>，<u>并没有分配虚拟内存对应的物理内存</u>。<u>当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</u>。  </p>
<blockquote>
<p>（分配了虚拟的地址空间 但没有分配映射到物理内存，访问时会缺页异常）</p>
</blockquote>
<p><strong>缺页中断：</strong>在请求分页系统中，可以<u>通过查询页表中的<code>状态位</code>来确定所要访问的<code>页面是否存在于内存</code>中</u>。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<blockquote>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
</blockquote>
<p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p>
<blockquote>
<p>1、<u>在指令执行期间产生和处理缺页中断信号</u></p>
<p>2、<u>一条指令在执行期间，可能产生多次缺页中断</u></p>
<p>3、<u>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</u>。</p>
</blockquote>
<h1 id="10-其他"><a href="#10-其他" class="headerlink" title="10.  其他"></a>10.  其他</h1><h2 id="10-1-windows消息机制知道吗，请说一说"><a href="#10-1-windows消息机制知道吗，请说一说" class="headerlink" title="10.1. windows消息机制知道吗，请说一说"></a>10.1. windows消息机制知道吗，请说一说</h2><p>当用户有操作(鼠标，键盘等)时，系统会将这些事件转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h4 id="一、那么消息究竟是What-嘞？"><a href="#一、那么消息究竟是What-嘞？" class="headerlink" title="一、那么消息究竟是What 嘞？"></a>一、那么消息究竟是What 嘞？</h4><p>消息系统对于一个win32程序来说十分重要，它是一个程序运行的动力源泉。一个消息，是系统定义的一个32位的值，他唯一的定义了一个事件，向 Windows发出一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序的消息队列（下面会讲到）中，然后应用程序再从消息队列中取出消息并进行相应的响应。在这个处理的过程中，操作系统也会给应用程序“发送消息”，而所谓的发送消息——–实际上就是操作系统调用程序中的一个专门负责处理消息的函数，这个函数称为窗口过程。</p>
<p>​    <strong>消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息</strong>。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做MSG，MSG含有来自windows应用程序消息队列的消息信息，在Windows中MSG结构体定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMsg</span>{</span></span><br><span class="line">  HWND  hwnd;       <span class="comment">//接受该消息的窗口句柄</span></span><br><span class="line">  UINT  message;     <span class="comment">//消息常量标识符，也就是我们通常所说的消息号</span></span><br><span class="line">  WPARAM wParam;   <span class="comment">//32位消息的特定附加信息，确切含义依赖于消息值</span></span><br><span class="line">  LPARAM lParam;     <span class="comment">//32位消息的特定附加信息，确切含义依赖于消息值</span></span><br><span class="line">  DWORD  time;       <span class="comment">//消息创建时的时间</span></span><br><span class="line">  POINT  pt;          <span class="comment">//消息创建时的鼠标/光标在屏幕坐标系中的位置</span></span><br><span class="line">}MSG;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二、What-is消息队列？"><a href="#二、What-is消息队列？" class="headerlink" title="二、What  is消息队列？"></a><strong>二、What  is消息队列？</strong></h4><p>在Windows编程中，每一个Windows应用程序开始执行后，<u>系统都会为该程序创建一个消息队列</u>，这个消息队列<u>用来存放该应用程序所创建的窗口的信息</u>。例如，当我们按下鼠标右键的时候，这时会产生一个WM_RBUTTONDOWN消息，系统会自动将这个消息放进当前窗口所属的应用程序的消息队列中，等待应用程序的结束。Windows将产生的消息以此放进消息队列中，<u>应用程序则通过一个消息循环不断的从该消息队列中读取消息，并做出响应</u>（后面会详细讲述消息处理过程。。。。）</p>
<h4 id="三、消息中的家庭成员？"><a href="#三、消息中的家庭成员？" class="headerlink" title="三、消息中的家庭成员？"></a><strong>三、消息中的家庭成员？</strong></h4><p>​    通过前面所罗列的MSG结构体，我们是不是会对消息结构里边含有的东东有了一个比较清楚的认识呢？如果还没有，没关系！！呵呵，那么我再次对那些咋一看就会泪奔的变量做出详细的解释：</p>
<p>​    hwnd - - - 一个32位的窗口句柄（我的PC是32 位的^_^），它表示的是消息所属的窗口。我们通常开发的程序都是窗口应用程序，一般一个消息都是和某个窗口相关联的。比如我们在某个活动窗口按下鼠标右键，此时产生的消息就是发送给该活动窗口的。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。</p>
<p>（补充一下：“句柄”—在Windows程序中，有各种各样的资源，系统在创建这些资源的时候，都会为他们分配内存，并返回标识这些资源的标识号，这个标识号就是句柄）</p>
<p>​    message- - - -一个消息的标识符，用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。在Windows中消息是由一个数值表示的，不同的消息对应不同的数值。但由于当这些消息种类多到足以挑战我们的IQ，所以聪明的程序开发者便想到将这些数值定义为WM_XXX宏的形式。例如，鼠标左键按下的消息–WM_LBUTTONDOWN，键盘按下消息–WM_KEYDOWN，字符消息–WM_CHAR，等等。。。。消息标识符以常量命名的方式指出消息的含义。当窗口过程接收到消息之后，他就会使用消息标识符来决定如何处理消息。例如、WM_PAINT告诉窗口过程窗体客户区被改变了需要重绘。符号常量指定系统消息属于的类别，其前缀指明了处理解释消息的窗体的类型。</p>
<p>​    wParam和lParam- - - 用于指定消息的附加信息。例如，当我们收到一个键盘按下消息的时候，message成员变量的值就是WM_KEYDOWN，但是用户到底按下的是哪一个按键，我们就得拜托这二位，由他们来告知我们具体的信息。</p>
<p>time和pt- - -这俩兄弟分别被用来表示消息投递到消息队列中的时间和鼠标当前的位置，一般情况下不怎么使用（但不代表没用）</p>
<h4 id="四、see-see-消息标识符"><a href="#四、see-see-消息标识符" class="headerlink" title="四、see see 消息标识符"></a><strong>四、see see 消息标识符</strong></h4><p>系统保留消息标识符的值在0x0000在0x03ff(WM_USER-1)范围。这些值被系统定义消息使用。应用程序不能使用这些值给自己的消息。应用程序消息从WM_USER（0X0400）到0X7FFF，或0XC000到0XFFFF；WM_USER到 0X7FFF范围的消息由应用程序自己使用；0XC000到0XFFFF范围的消息用来和其他应用程序通信，在此只是罗列一些具有标志性的消息值：</p>
<blockquote>
<p>WM_NULL—0x0000  空消息    0x0001—-0x0087  主要是窗口消息。</p>
<p>0x00A0—-0x00A9  非客户区消息    0x0100—-0x0108  键盘消息</p>
<p>0x0111—-0x0126  菜单消息    0x0132—-0x0138  颜色控制消息</p>
<p>0x0200—-0x020A  鼠标消息    0x0211—-0x0213  菜单循环消息</p>
<p>0x0220—-0x0230  多文档消息    0x03E0—-0x03E8  DDE消息</p>
<p>0x0400       WM_USER    0x8000       WM_APP</p>
<p>0x0400—-0x7FFF  应用程序自定义私有消息</p>
</blockquote>
<h4 id="五、原来消息也有分类啊"><a href="#五、原来消息也有分类啊" class="headerlink" title="五、原来消息也有分类啊"></a><strong>五、原来消息也有分类啊</strong></h4><p>windows中的消息虽然很多，但是种类并不繁杂，大体上有3种： <code>窗口</code>消息、 <code>命令</code>消息、 <code>控件通知</code>消息。</p>
<blockquote>
<ol>
<li><p>窗口消息- - - -大概是系统中最为常见的消息，它是指由操作系统和控制其他窗口的窗口所使用的消息。例如CreateWindow、DestroyWindow和MoveWindow等都会激发窗口消息，还有我们在上面谈到的单击鼠标所产生的消息也是一种窗口消息。</p>
</li>
<li><p>命令消息- - - - 这是一种特殊的窗口消息，他用来处理从一个窗口发送到另一个窗口的用户请求，例如按下一个按钮，他就会向主窗口发送一个命令消息。</p>
</li>
<li><p>控件通知消息- - - 其实它是这样滴，当一个窗口内的子控件发生了一些事情，而这些是需要通知父窗口的，此刻它就上场啦。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑框，以及Windows公共控件如树状视图、列表视图等。</p>
</li>
</ol>
</blockquote>
<p>例如，单击或双击一个控件、在控件中选择部分文本、操作控件的滚动条都会产生通知消息——-她类似于命令消息，那么控件通知消息就会从控件窗口发送到它的主窗口。但是这种消息的存在并不是为了处理用户命令，而是为了让主窗口能够改变控件，例如加载、显示数据。</p>
<p>再例如，按下一个按钮，他向父窗口发送的消息也可以看作是一个控件通知消息；单击鼠标所产生的消息可以由主窗口直接处理，然后交给控件窗口处理。其中窗口消息及控件通知消息主要由窗口类即直接或间接由CWND类派生类处理。相对窗口消息及控件通知消息而言，命令消息的处理对象范围就广得多，它不仅可以由窗口类处理，还可以由文挡类，文档模板类及应用类所处理。</p>
<h4 id="六、队列消息和非队列消息"><a href="#六、队列消息和非队列消息" class="headerlink" title="六、队列消息和非队列消息"></a><strong>六、队列消息和非队列消息</strong></h4><ol>
<li><p>队列消息送到系统消息队列，然后到线程消息队列；</p>
</li>
<li><p>非队列消息直接送给目的窗口过程。</p>
</li>
</ol>
<h2 id="10-2-微内核与宏内核"><a href="#10-2-微内核与宏内核" class="headerlink" title="10.2. 微内核与宏内核"></a>10.2. 微内核与宏内核</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg" alt="IMG_256"></p>
<p>微内核相当于一个信息交换中心，自身可以实现的功能较少，他的主要职责是传递一个请求，一个A模块对其他模块功能的请求；而宏内核相当于一个是一个中央集权控制中心，把内存管理，文件管理等功能全部管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image032.jpg" alt="IMG_256"></p>
<p><strong>微内核定义：</strong></p>
<p>内核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。</p>
<p>在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。</p>
<p><strong>宏内核定义：</strong></p>
<p>宏内核同样管理着用户程序和硬件之间的系统资源，但是和微内核不一样的是，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。</p>
<p>在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。</p>
<h2 id="10-3-什么是大端小端以及如何判断大端小端"><a href="#10-3-什么是大端小端以及如何判断大端小端" class="headerlink" title="10.3. 什么是大端小端以及如何判断大端小端"></a>10.3. 什么是大端小端以及如何判断大端小端</h2><p>大端：将表示一个对象的字节在内存中按照从最高有效字节到最低有效字节的顺序存储，即最高有效字节在内存地址最前面的方式，称为大端法</p>
<p>小端：将表示一个对象的字节在内存中按照从最低有效字节到最高有效字节的顺序存储，即最低有效字节在内存地址最前面的方式，称为小端法</p>
<p>我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif" alt="IMG_256"></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0x01234567</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2x "</span>, ((<span class="keyword">char</span> *)&amp;x)[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">char</span> *)&amp;x)[<span class="number">0</span>] == <span class="number">0x67</span>){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"little endian!\n"</span>);</span><br><span class="line">  }</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (((<span class="keyword">char</span> *)&amp;x)[<span class="number">0</span>] == <span class="number">0x01</span>){</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"big endian\n"</span>);</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="10-4-说操作系统中的结构体对齐，字节对齐"><a href="#10-4-说操作系统中的结构体对齐，字节对齐" class="headerlink" title="10.4. 说操作系统中的结构体对齐，字节对齐"></a>10.4. 说操作系统中的结构体对齐，字节对齐</h2><p>1、原因：</p>
<p>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<p>2、规则</p>
<p>1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</p>
<p>3、定义结构体对齐</p>
<p>可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</p>
<p>（32位机4字节是一个自然对其）</p>
<p>4、举例</p>
<p>#pragma pack(2)</p>
<p>struct AA {</p>
<p>int a;    //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</p>
<p>char b;  //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</p>
<p>short c;   //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</p>
<p>char d;  //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节</p>
<p>};</p>
<p>总共10字节，（如果b和d在一起则只占8字节）</p>
<p>#pragma pack()</p>
<p>\1. 什么是字节对齐？</p>
<p>在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。</p>
<p>为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”. 比如4字节的int型,其起始地址应该位于4字节的边界上,即起始地址能够被4整除.</p>
<p>\2. 字节对齐有什么作用？</p>
<p>字节对齐的作用不仅是便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。</p>
<p>对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。</p>
<h2 id="10-5-系统将数据从磁盘读到内存的过程"><a href="#10-5-系统将数据从磁盘读到内存的过程" class="headerlink" title="10.5. 系统将数据从磁盘读到内存的过程"></a>10.5. 系统将数据从磁盘读到内存的过程</h2><p>在开始DMA传输时，主机向内存写入DA命令块，向DMA控制器写入该命令块的地址，启动I/O设备。然后，CPU继续其他工作，DMA控制器则继续下去直接操作内存总线，将地址放到总线上开始传输。当整个传输完成后，DMA控制器中断CPU。因此正确的执行顺序应该是</p>
<ol>
<li><p>初始化DMA控制器并启动磁盘</p>
</li>
<li><p>从磁盘传输一块数据到内存缓冲区</p>
</li>
<li><p>DMA控制器发出中断请求</p>
</li>
<li><p>执行“DMA结束”中断服务程序</p>
</li>
</ol>
<h2 id="10-6-Linux-内核和-Windows-内核有什么区别-http-learn-lianglianglee-com-专栏-重学操作系统-完-13-操作系统内核：Linux-内核和-Windows-内核有什么区别？-md"><a href="#10-6-Linux-内核和-Windows-内核有什么区别-http-learn-lianglianglee-com-专栏-重学操作系统-完-13-操作系统内核：Linux-内核和-Windows-内核有什么区别？-md" class="headerlink" title="10.6. [Linux 内核和 Windows 内核有什么区别](http://learn.lianglianglee.com/专栏/重学操作系统-完/13  操作系统内核：Linux 内核和 Windows 内核有什么区别？.md)"></a>10.6. [Linux 内核和 Windows 内核有什么区别](<a target="_blank" rel="noopener" href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/13">http://learn.lianglianglee.com/专栏/重学操作系统-完/13</a>  操作系统内核：Linux 内核和 Windows 内核有什么区别？.md)</h2><p>Windows 有两个内核，最新的是 <code>NT 内核</code>，目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，<code>没有太大的结构化差异</code>。</p>
<p>从整体设计上来看，Linux 是==宏内核==，NT 内核属于==混合型内核==。和微内核不同，宏内核和混合类型内核从实现上来看是一个完整的程序。只不过混合类型内核内部也抽象出了微内核的概念，从内核内部看混合型内核的架构更像微内核。</p>
<p>另外 NT 内核和 Linux 内核还存在着许多其他的差异，比如：</p>
<ul>
<li>Linux 内核是一个==开源==的内核；</li>
<li>它们支持的==可执行文件格式==不同；</li>
<li>它们用到的==虚拟化技术==不同。</li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">qianxunslimg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/16/cao-zuo-xi-tong-ba-gu/">http://example.com/2022/03/16/cao-zuo-xi-tong-ba-gu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">qianxunslimgのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/airpay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://qianxunslimg.github.io/2021/12/03/wo-de-tu-chuang/airpay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://portrait.gitee.com/uploads/avatars/user/2717/8153406_qianxunslimg_1618191223.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianxunslimg</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/qianxunslimg"><i class="fab fa-github"></i><span>My Gitee</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">编程菜鸟,多多指教~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">1. 操作系统有哪些模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2. 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.  进程与线程的概念，以及为什么要有进程线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2.2.  线程与进程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3.  协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4.  有了进程，为什么还要有线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">2.5.</span> <span class="toc-text">2.5.  说一下多线程和多进程的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.6.</span> <span class="toc-text">2.6.  多进程和多线程的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%98%E5%93%AA%E4%BA%9B%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%8CSP%E3%80%81PC%E3%80%81EAX%E8%BF%99%E4%BA%9B%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AF%E5%B9%B2%E5%98%9B%E7%94%A8%E7%9A%84"><span class="toc-number">2.7.</span> <span class="toc-text">2.7.  线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%EF%BC%8C%E5%8A%A8%E6%80%81%E5%B0%B1%E7%BB%AA%EF%BC%8C%E9%9D%99%E6%80%81%E5%B0%B1%E7%BB%AA%EF%BC%8C%E5%8A%A8%E6%80%81%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%99%E6%80%81%E9%98%BB%E5%A1%9E"><span class="toc-number">2.8.</span> <span class="toc-text">2.8.  进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">2.9.  进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-%E5%85%88%E6%9D%A5%E5%85%88%E5%8E%BB%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.9.1.</span> <span class="toc-text">2.9.1. 先来先去服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88"><span class="toc-number">2.9.2.</span> <span class="toc-text">2.9.2. 最短进程优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-3-%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">2.9.3.</span> <span class="toc-text">2.9.3. 最短剩余时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-4-x3D-x3D-%E6%97%B6%E9%97%B4%E7%89%87-x3D-x3D-%E8%BD%AE%E8%BD%AC%E6%B3%95"><span class="toc-number">2.9.4.</span> <span class="toc-text">2.9.4. &#x3D;&#x3D;时间片&#x3D;&#x3D;轮转法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-5-%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.9.5.</span> <span class="toc-text">2.9.5. 优先权调度算法的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-6-%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-number">2.9.6.</span> <span class="toc-text">2.9.6. 最高响应比优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-7-x3D-x3D-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-x3D-x3D"><span class="toc-number">2.9.7.</span> <span class="toc-text">2.9.7. &#x3D;&#x3D;多级反馈队列调度算法&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.10.</span> <span class="toc-text">2.10. 常用线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-reactor%E6%A8%A1%E5%9E%8B%E7%BB%84%E6%88%90"><span class="toc-number">2.11.</span> <span class="toc-text">2.11. reactor模型组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B1%EF%BC%9A%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-x2F-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.11.1.</span> <span class="toc-text">线程模型1：传统阻塞 I&#x2F;O 服务模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B2%EF%BC%9AReactor-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.11.2.</span> <span class="toc-text">线程模型2：Reactor 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.12.</span> <span class="toc-text">2.12. 僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-%E6%80%8E%E6%A0%B7%E7%A1%AE%E5%AE%9A%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E7%B9%81%E5%BF%99%E8%BF%98%E6%98%AF%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">2.13. 怎样确定当前线程是繁忙还是阻塞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%9C%A8%E7%AD%89%E5%BE%85%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">2.14. 就绪状态的进程在等待什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-fork-wait-exec%E5%87%BD%E6%95%B0"><span class="toc-number">2.15.</span> <span class="toc-text">2.15. fork,wait,exec函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-fork%E5%92%8Cvfork%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">2.16. fork和vfork的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">2.16.1.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.16.2.</span> <span class="toc-text">fork失败的主要原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfork"><span class="toc-number">2.16.3.</span> <span class="toc-text">vfork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E5%92%8Cvfork%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.16.4.</span> <span class="toc-text">fork和vfork的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%8Bfork%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.17.</span> <span class="toc-text">2.17. 手写一下fork调用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="toc-number">2.18.</span> <span class="toc-text">视频学习资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-number">2.19.</span> <span class="toc-text">GDB多线程调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">2.20.</span> <span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E5%87%BD%E6%95%B0%E6%97%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.20.1.</span> <span class="toc-text">exec 函数族介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.21.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-number">2.21.1.</span> <span class="toc-text">1. 进程退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.21.2.</span> <span class="toc-text">2. 孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.21.3.</span> <span class="toc-text">3. 僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">2.21.4.</span> <span class="toc-text">4. 进程回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.</span> <span class="toc-text">3. 线程同步，进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.  多线程，线程同步的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%9C%80%E5%A5%BD%E8%AF%B4%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.  线程间的同步方式，最好说出具体的系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.  互斥锁和条件变量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88mutual-exclusive-lock-variable-x2F-mutex-%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 互斥锁（mutual exclusive lock variable &#x2F; mutex ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. 条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">3. 那为什么有互斥锁，还需要条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.4.  进程间通信方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">4.    多线程、线程同步、通信实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.1.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.1.  多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">线程分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BA%92%E6%96%A5%E9%94%81-x2F-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.2.  互斥锁&#x2F;互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4.3.  条件变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.4.  信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.</span> <span class="toc-text">4.5.  异步操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">4.7.</span> <span class="toc-text">4.6.  原子操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.8.</span> <span class="toc-text">4.7. 生产者消费者模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">4.8.1.</span> <span class="toc-text">简单实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-IO%E6%93%8D%E4%BD%9C-x2F-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">5. IO操作&#x2F;线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.  介绍一下5种IO模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%AD%BB%E5%BE%AA%E7%8E%AF-%E6%9D%A5%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87%E6%9C%89%E7%82%B9%E4%BD%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">5.3.  死循环+来连接时新建线程的方法效率有点低，怎么改进？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.3.</span> <span class="toc-text">5.4.  线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.4.1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-x3D-x3D-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0-x3D-x3D"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.4.2. &#x3D;&#x3D;怎么实现线程池&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.4.3. 线程池参数设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-select%EF%BC%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%A7%E8%83%BD%EF%BC%8C%E9%99%90%E5%88%B6%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="toc-number">5.4.</span> <span class="toc-text">5.5.  select，epoll的区别，原理，性能，限制都说一说</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.5.1. IO多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-poll-epoll%E5%A4%A7%E4%BD%93%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.2.</span> <span class="toc-text">select poll epoll大体介绍及对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">5.4.3.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">5.4.4.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">5.4.5.</span> <span class="toc-text">epoll:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89EPOLLET%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">5.4.6.</span> <span class="toc-text">epoll为什么要有EPOLLET触发模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">5.4.7.</span> <span class="toc-text">epoll的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E3%80%81poll%E3%80%81epoll-%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.8.</span> <span class="toc-text">select、poll、epoll 区别总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91"><span class="toc-number">5.5.</span> <span class="toc-text">epoll水平触发与边沿触发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">6. 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Linux%E7%9A%844%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">6.1.  Linux的4种锁机制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E9%94%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.1.</span> <span class="toc-text">四种锁介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">互斥锁和读写锁的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">6.2.  乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%80%92%E5%BD%92%E9%94%81%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-number">6.3.</span> <span class="toc-text">6.3.  递归锁和非递归锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%B5%84%E6%BA%90%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%83%BD%E8%8E%B7%E5%BE%97%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">6.4.  两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88mutex%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.</span> <span class="toc-text">6.5.  互斥锁（mutex）机制，以及互斥锁和读写锁的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="toc-number">6.6.</span> <span class="toc-text">6.6.  死锁发生的条件以及如何解决死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.6.1.</span> <span class="toc-text">死锁发生的四个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">解决死锁的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%91%E6%B3%95"><span class="toc-number">6.6.3.</span> <span class="toc-text">处理死锁的基本发法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.4.</span> <span class="toc-text">预防死锁和避免死锁的区别:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">6.7.  银行家算法（避免死锁）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E5%8D%95%E6%A0%B8%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">6.8.  单核机器上写多线程程序，是否需要考虑加锁，为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">7.</span> <span class="toc-text">7. 并行并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E5%B9%B6%E5%8F%91-concurrency-%E5%92%8C%E5%B9%B6%E8%A1%8C-parallelism"><span class="toc-number">7.1.</span> <span class="toc-text">7.1.  并发(concurrency)和并行(parallelism)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%A6%82%E4%BD%95%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">7.2.</span> <span class="toc-text">7.2.  如何采用单线程的方式处理高并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">8.    内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Linux%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">8.1.</span> <span class="toc-text">8.1.  Linux虚拟地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">8.2.  操作系统中的程序的内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%86%E6%A0%88%E7%94%9F%E9%95%BF%E6%96%B9%E5%90%91%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">8.3.</span> <span class="toc-text">8.3.  为什么堆栈生长方向不一样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-A-a-x3D-new-A-a-gt-i-x3D-10-%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8A%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">8.4.  A* a &#x3D; new A; a-&gt;i &#x3D; 10;在内核中的内存分配上发生了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.5.</span> <span class="toc-text">8.5.  静态变量什么时候初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89static%EF%BC%8Cvirtual%EF%BC%8C%E4%B9%8B%E7%B1%BB%E7%9A%84%EF%BC%8C%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">8.6.</span> <span class="toc-text">8.6.  一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">8.7.</span> <span class="toc-text">8.7.  内存溢出和内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">8.7.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">8.7.2.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89page-cache%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84page-cache"><span class="toc-number">8.8.</span> <span class="toc-text">8.8.  为什么要有page cache，操作系统怎么设计的page cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%EF%BC%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E3%80%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">8.9.</span> <span class="toc-text">8.9.  ？逻辑地址、虚拟地址、物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%80%8E%E4%B9%88%E5%AF%B9%E5%BA%94"><span class="toc-number">8.10.</span> <span class="toc-text">8.10. 虚拟内存和物理内存怎么对应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-1-%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">8.10.1.</span> <span class="toc-text">8.10.1.   页式管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-2-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E6%8C%82%E7%AE%A1%E7%90%86"><span class="toc-number">8.10.2.</span> <span class="toc-text">8.10.2.   段页式挂管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-3-%E5%BF%AB%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8-x2F-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%EF%BC%88cache%EF%BC%89"><span class="toc-number">8.10.3.</span> <span class="toc-text">8.10.3.   快表的使用&#x2F;高速缓存（cache）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-4-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%EF%BC%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%89"><span class="toc-number">8.10.4.</span> <span class="toc-text">8.10.4.   请求分页式管理（虚拟内存）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-OS%E7%BC%BA%E9%A1%B5%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.11.</span> <span class="toc-text">8.11. OS缺页置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12-CPU%E5%86%85%E5%AD%98%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">8.12. CPU内存的寻址能力？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13-CPU%E5%AF%BB%E5%9D%80%E4%BA%86%E8%A7%A3%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">8.13.</span> <span class="toc-text">8.13.  CPU寻址了解吗?为什么需要虚拟地址空间?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">9.    用户态和内核态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">9.1.  用户态和内核态区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E3%80%82"><span class="toc-number">9.1.0.1.</span> <span class="toc-text">内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">9.2.</span> <span class="toc-text">9.2.  操作系统为什么要分内核态和用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%EF%BC%9F%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E8%BD%AC%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. ？用户态到内核态的转化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E8%BD%AC%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.1.</span> <span class="toc-text">用户态到内核态的转化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">1. 用户态切换到内核态的3种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%87%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.1.2.</span> <span class="toc-text">2. 切换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8Linux%E4%B8%AD%EF%BC%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.3.1.3.</span> <span class="toc-text">3. 在Linux中，上下文切换，进程切换和线程切换之间有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%87%E6%8D%A2%E5%BE%88%E6%85%A2"><span class="toc-number">9.3.1.4.</span> <span class="toc-text">4. 为什么虚拟地址切换很慢</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">9.4.</span> <span class="toc-text">9.4.  系统调用是什么，你用过哪些系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">9.6.</span> <span class="toc-text">9.5.  请介绍一下操作系统中的中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%80%E8%88%AC%E4%B8%89%E7%B1%BB%E3%80%82"><span class="toc-number">9.6.1.</span> <span class="toc-text">中断一般三类。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">9.7.</span> <span class="toc-text">9.6.  操作系统中的缺页中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%85%B6%E4%BB%96"><span class="toc-number">10.</span> <span class="toc-text">10.  其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-windows%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%8C%E8%AF%B7%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. windows消息机制知道吗，请说一说</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%82%A3%E4%B9%88%E6%B6%88%E6%81%AF%E7%A9%B6%E7%AB%9F%E6%98%AFWhat-%E5%98%9E%EF%BC%9F"><span class="toc-number">10.1.0.1.</span> <span class="toc-text">一、那么消息究竟是What 嘞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81What-is%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">10.1.0.2.</span> <span class="toc-text">二、What  is消息队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%AD%E7%9A%84%E5%AE%B6%E5%BA%AD%E6%88%90%E5%91%98%EF%BC%9F"><span class="toc-number">10.1.0.3.</span> <span class="toc-text">三、消息中的家庭成员？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81see-see-%E6%B6%88%E6%81%AF%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">10.1.0.4.</span> <span class="toc-text">四、see see 消息标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8E%9F%E6%9D%A5%E6%B6%88%E6%81%AF%E4%B9%9F%E6%9C%89%E5%88%86%E7%B1%BB%E5%95%8A"><span class="toc-number">10.1.0.5.</span> <span class="toc-text">五、原来消息也有分类啊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF%E5%92%8C%E9%9D%9E%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF"><span class="toc-number">10.1.0.6.</span> <span class="toc-text">六、队列消息和非队列消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%BE%AE%E5%86%85%E6%A0%B8%E4%B8%8E%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 微内核与宏内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. 什么是大端小端以及如何判断大端小端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E8%AF%B4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%EF%BC%8C%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-number">10.4.</span> <span class="toc-text">10.4. 说操作系统中的结构体对齐，字节对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E7%B3%BB%E7%BB%9F%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E7%A3%81%E7%9B%98%E8%AF%BB%E5%88%B0%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">10.5.</span> <span class="toc-text">10.5. 系统将数据从磁盘读到内存的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-Linux-%E5%86%85%E6%A0%B8%E5%92%8C-Windows-%E5%86%85%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-http-learn-lianglianglee-com-%E4%B8%93%E6%A0%8F-%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C-13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%EF%BC%9ALinux-%E5%86%85%E6%A0%B8%E5%92%8C-Windows-%E5%86%85%E6%A0%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-md"><span class="toc-number">10.6.</span> <span class="toc-text">10.6. [Linux 内核和 Windows 内核有什么区别](http:&#x2F;&#x2F;learn.lianglianglee.com&#x2F;专栏&#x2F;重学操作系统-完&#x2F;13  操作系统内核：Linux 内核和 Windows 内核有什么区别？.md)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/zhi-zhen-shu-zu-fu-zhi-yue-jie-yin-fa-de-bug/" title="指针数组赋值越界引发的bug"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="指针数组赋值越界引发的bug"/></a><div class="content"><a class="title" href="/2022/03/16/zhi-zhen-shu-zu-fu-zhi-yue-jie-yin-fa-de-bug/" title="指针数组赋值越界引发的bug">指针数组赋值越界引发的bug</a><time datetime="2022-03-16T11:28:00.000Z" title="发表于 2022-03-16 19:28:00">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/er-fen-cha-zhao-suan-fa/" title="二分查找"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二分查找"/></a><div class="content"><a class="title" href="/2022/03/15/er-fen-cha-zhao-suan-fa/" title="二分查找">二分查找</a><time datetime="2022-03-15T12:17:49.000Z" title="发表于 2022-03-15 20:17:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/pai-xu-suan-fa/" title="排序算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法"/></a><div class="content"><a class="title" href="/2022/03/15/pai-xu-suan-fa/" title="排序算法">排序算法</a><time datetime="2022-03-15T12:16:49.000Z" title="发表于 2022-03-15 20:16:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/dp/" title="dp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dp"/></a><div class="content"><a class="title" href="/2022/03/15/dp/" title="dp">dp</a><time datetime="2022-03-15T12:15:49.000Z" title="发表于 2022-03-15 20:15:49">2022-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/15/xiao-suan-fa/" title="前缀和/差分"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前缀和/差分"/></a><div class="content"><a class="title" href="/2022/03/15/xiao-suan-fa/" title="前缀和/差分">前缀和/差分</a><time datetime="2022-03-15T12:13:49.000Z" title="发表于 2022-03-15 20:13:49">2022-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By qianxunslimg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">只愿得一人心 白首不分离</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="xxx" data-server="xxx" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/SerokSSR/cdn/meting.min.js"></script><script async data-pjax src="/%5Bobject%20Object%5D"></script></div></body></html>