[{"title":"个人成果展示","url":"/2022/05/23/cheng-guo-zhan-shi/","content":"\n# 商业软件\n\n## ****处理系统\n\n### 界面展示\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523190127830.png\" alt=\"image-20220523190127830\" style=\"zoom:50%;\" />\n\n### 处理流程\n\n****处理系统主要是对采集到的原始信号进行分析，通过一系列算法运算，分析得到地下信息\n\n#### 1.原始信号的导入\n\n信号的原始信号是规范格式的二进制文件，seg2或者sac，首先读取文件头信息到结构体，例如几道信号，信号的起始时间，检波器的坐标和分量信息等，然后读取数据段内存\n\n#### 2.信号预处理\n\n采集到的原始信号经常是存在坏点的，需要对信号进行坏点筛除和有效信号的提取，用到了sta/lta算法，和阈值百分比的方法去筛选坏点，一般的算法运算都需要转到频域，因此还需要一个按频点分窗fft的过程\n\n#### 3.算法实现\n\n这主要设计一些地址算法的实现过程了，hv是水平垂直的功率谱比。 fk是频率波数域求解相速度， si的计算相干系数拟合到贝塞尔曲线去求解相速度。\n\n用到了多线程 qt::concurrent实现单个台站的线程， qt::concurrent::map实现单台站多频点的多线程实现\n\n#### 4.结果的导出与展示\n\n做一个结果的导出工作，然后基于qcustomplot对计算结果 做一个图像化的快速显示\n\n\n\n## 地质剖面绘制软件\n\n### 界面展示\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523190444488.png\" alt=\"image-20220523190444488\" style=\"zoom:50%;\" />\n\n### 处理流程\n\n主要是多台阵的计算结果（频散曲线，hv谱比或功率谱），使用opencv进行二维拉伸成图\n\n#### 1.地质算法结果文件的导入\n\n读取csv，主要是csv记录的位置信息（相互距离），测点高程，根据csv记录的路径将结果文件（自定义保存的结果格式 文本）导入到成图系统，存储所有数据\n\n#### 2.预处理\n\n多个成图过程需要预处理：例如 结果坏点检测与剔除，频散曲线根据半波长计算深度，需要进行深度的插值depth = a*fre^b^ ，剪切波速转换等\n\n#### 3.剖面图实现\n\n1. 多测点垂直方向的数据插值\n2. 按距离对数据矩阵进行比例缩放 使用opencv进行resize和honcat\n3. 色系填充：将结果整合到对应色系，使用opencv进行显示 （已有的色系包括： hsv jet gray 以及自定义色带）\n4. 轮廓线绘制：opencv进行drawContours检测，依次进行所有轮廓的绘制\n\n#### 4.结果导出\n\n因为是工程探测，因此导出格式为bmp，保存比例信息\n\n\n\n# QT小练习\n\n## QDIR\n\n### 介绍\n\n一个文件搬运软件，查找目标路径下 所有文件名中包含目标字段的文件 对齐进行copy to 或者delete操作\n\n![image-20220407205913909](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220407205913909.png)\n\n### 使用说明\n\n1. 选择要查找的文件路径\n2. 填写 目标字段\n3. 点击查找\n4. 选择要复制到的目标文件夹 或者删除\n\n### 参与贡献\n\n1. qianxunslimg\n2. 无条件为小刘老师提供定制化服务\n3. 看心情为福州刘教授提供定制化服务\n\n\n\n##  llmHomeWork\n\n### 介绍\n\n学校网站信息不全，为了小刘老师更方便的书写假期作业批改记录，写了这个小软件\n\n### 使用说明\n\n1. 在作业详情页ctrl+A全选页面，再ctrl+C复制所有信息，如图\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/clip_image002.jpg)\n\n2. 新建一个txt，ctrl+V粘贴所有信息，保存并关闭，如图\n\n3. 用软件打开保存的txt即可，如图\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220407211419171.png)\n\n### 参与贡献\n\n1. qianxunslimg\n2. 为小刘老师提供定制化服务\n\n\n\n## LED点阵控制\n\n### 介绍\n\n学长毕业 学弟帮忙 一个串口控制led点阵的小程序\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523193404814.png\" alt=\"image-20220523193404814\" style=\"zoom:67%;\" />\n\n简单的通过串口发送点触位置，下位机控制灯亮灯灭\n\n1. 单点模式：点触时 此点亮 之前灭\n2. 常亮模式：点触接连亮灯\n\n\n\n##  DrinkMoreWater\n\n### 介绍\n\n喝水太少，用来提醒自己和小刘老师按时喝水的小软件\n\n![image-20220407204200017](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220407204200017.png)\n\n![image-20220407204253224](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220407204253224.png)\n\n### 软件架构\n\n1. 基于qt框架\n2. window默认通知\n\n\n\n## myWeatherReport\n\n### 介绍\n\n天气预报练手小项目，主要练习 api的请求（和风天气） 解析 和 样式表\n\n![image-20220407213239133](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220407213239133.png)\n\n### 软件架构\n\n- 基于qt框架\n- 基于QNetworkAccessManager进行api的请求和数据接收\n- 数据解析与显示\n\n\n\n# 机械设计展示\n\n## ****主控机箱\n\n### 1.0版本\n\n#### 使用型材在sku机箱内部进行架构\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523195518716.png\" alt=\"image-20220523195518716\" style=\"zoom: 50%;\" />\n\n### 2.0版本\n\n#### 人工建模注塑，提高空间利用率，减轻机箱重量\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523200240399.png\" alt=\"image-20220523200240399\" style=\"zoom:50%;\" />\n\n#### 面板改进设计\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523195338692.png\" alt=\"image-20220523195338692\" style=\"zoom: 33%;\" />\n\n## 叶片尺寸检测系统\n\n\n\n![image-20220523201623899](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523201623899.png)\n\n## 视觉挠度测量\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523214144909.png\" alt=\"image-20220523214144909\" style=\"zoom:50%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220523214358988.png\" alt=\"image-20220523214358988\" style=\"zoom:50%;\" />","tags":["开发随笔"]},{"title":"记忆化搜索","url":"/2022/05/22/ji-yi-hua-sou-suo/","content":"\n# 记忆化搜索\n\n记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。\n\n因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。\n\n### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=509)[思路](https://leetcode.cn/problems/fibonacci-number/#)\n\n难度简单462收藏分享切换为英文接收动态反馈\n\n**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n```\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n```\n\n给定 `n` ，请计算 `F(n)` 。\n\n \n\n**示例 1：**\n\n```\n输入：n = 2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n```\n\n**示例 2：**\n\n```\n输入：n = 3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n```\n\n#### `记忆化搜索`\n\n是因为函数压栈 所以用时高吗\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> memo;\n    int fib(int n) {\n      if(memo.count(n)) return memo[n];\n      if(n<=1) return n;\n      return fib(n-1) + fib(n-2);\n    }\n};\n```\n\n#### 动态规划 略\n\n### [397. 整数替换](https://leetcode.cn/problems/integer-replacement/)\n\n难度中等235收藏分享切换为英文接收动态反馈\n\n给定一个正整数 `n` ，你可以做如下操作：\n\n1. 如果 `n` 是偶数，则用 `n / 2`替换 `n` 。\n2. 如果 `n` 是奇数，则可以用 `n + 1`或`n - 1`替换 `n` 。\n\n返回 `n` 变为 `1` 所需的 *最小替换次数* 。\n\n \n\n**示例 1：**\n\n```\n输入：n = 8\n输出：3\n解释：8 -> 4 -> 2 -> 1\n```\n\n**示例 2：**\n\n```\n输入：n = 7\n输出：4\n解释：7 -> 8 -> 4 -> 2 -> 1\n或 7 -> 6 -> 3 -> 2 -> 1\n```\n\n#### 最优 贪心\n\n局部最优的情况肯定是 不能被2整除的情况下下向4靠拢 比如 9 - 8 - 4 - 2 - 1    9 - 10 - 5 - 6 - 3 - 4 - 2 - 1\n\n```c++\nclass Solution {\npublic:\n  int integerReplacement(int n) {\n    long nn = n;\n    int res = 0;\n    while (nn != 1) {\n      if (nn == 3) {\n        res += 2;\n        break;\n      }\n      if (nn % 2) {\n        if (!((nn + 1) % 4)) {\n          nn = nn + 1;\n        } else {\n          nn = nn - 1;\n        }\n      } else {\n        nn /= 2;\n      }\n      res++;\n    }\n    return res;\n  }\n};\n```\n\n#### 记忆化搜索\n\n递归思想 恶心的是 有个INT_MAX会导致溢出\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> memo;\n    int integerReplacement(int n) {\n      if(n == INT_MAX) return 32;  //溢出的特殊情况直接返回\n      if(memo.count(n))\n        return memo[n];\n      if(n == 1) return 0;\n      if(n%2){\n        return 1 + min(integerReplacement(n+1), integerReplacement(n-1));\n      }else\n        return 1 + integerReplacement(n/2);\n    }\n};\n```\n\n#### 官方\n\n```c++\nclass Solution {\npublic:\n    int integerReplacement(int n) {\n        if (n == 1) {\n            return 0;\n        }\n        if (n % 2 == 0) {\n            return 1 + integerReplacement(n / 2);\n        }\n        return 2 + min(integerReplacement(n / 2), integerReplacement(n / 2 + 1));\n    }\n};\n```\n\n### [464. 我能赢吗](https://leetcode.cn/problems/can-i-win/)\n\n难度中等424收藏分享切换为英文接收动态反馈\n\n在 \"100 game\" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过** 100 的玩家，即为胜者。\n\n如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？\n\n例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。\n\n给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家是否能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。\n\n \n\n**示例 1：**\n\n```\n输入：maxChoosableInteger = 10, desiredTotal = 11\n输出：false\n解释：\n无论第一个玩家选择哪个整数，他都会失败。\n第一个玩家可以选择从 1 到 10 的整数。\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\n第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n```\n\n\n\n[【负雪明烛】图解算法：递归，步步优化，弄清每个细节 - 我能赢吗 - 力扣（LeetCode）](https://leetcode.cn/problems/can-i-win/solution/by-fuxuemingzhu-g16c/)\n\n#### 详细但超时的解法 有基本的思路\n\n```c++\nclass Solution {\npublic:\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        // 候选集，「公共整数池」\n        unordered_set<int> choosable;\n        for (int i = 1; i <= maxChoosableInteger; ++i) {\n            choosable.insert(i);\n        }\n        // 判断当前做选择的玩家（先手），是否一定赢\n        return dfs(choosable, 0, maxChoosableInteger, desiredTotal);\n    }\n    \n    // 当前做选择的玩家是否一定赢\n    bool dfs(unordered_set<int>& choosable, int sum, int maxChoosableInteger, int desiredTotal) {\n        // 遍历可选择的公共整数\n        for (int x : choosable) {\n            // 如果选择了 x 以后，大于等于了 desiredTotal，当前玩家赢\n            if (sum + x >= desiredTotal) {\n                return true;\n            }\n            // 改变「公共整数池」\n            // 为了避免影响当前的 choosable，因此复制了一份并擦出掉 x，传给对手\n            unordered_set<int> choosable_copy = choosable;\n            choosable_copy.erase(x);\n            // 当前玩家选择了 x 以后，判断对方玩家一定输吗？\n            if (!dfs(choosable_copy, sum + x, maxChoosableInteger, desiredTotal)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n};\n```\n\n#### 官方题解\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, bool> memo;\n\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {\n            return false;\n        }\n        return dfs(maxChoosableInteger, 0, desiredTotal, 0);\n    }\n\n    bool dfs(int maxChoosableInteger, int usedNumbers, int desiredTotal, int currentTotal) {\n        if (!memo.count(usedNumbers)) {\n            bool res = false;\n            for (int i = 0; i < maxChoosableInteger; i++) {\n                if (((usedNumbers >> i) & 1) == 0) {\n                    if (i + 1 + currentTotal >= desiredTotal) {\n                        res = true;\n                        break;\n                    }\n                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {\n                        res = true;\n                        break;\n                    }\n                }\n            }\n            memo[usedNumbers] = res;\n        }\n        return memo[usedNumbers];\n    }\n};\n```\n\n### [139. 单词拆分](https://leetcode.cn/problems/word-break/)\n\n[思路](https://leetcode.cn/problems/word-break/#)\n\n难度中等1619收藏分享切换为英文接收动态反馈\n\n给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。\n\n**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n \n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n     注意，你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n","tags":["算法总结"]},{"title":"手撕代码","url":"/2022/05/18/shou-si-dai-ma/","content":"\n### 字符串拷贝\n\n#### str`cpy`\n\n从src逐字节拷贝到dest，直到遇到'\\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,`安全版本是strncpy函数`。\n\n```c++\nchar* strcpy(char* destination, const char* source){\n    if (destination == NULL)\n        return NULL;\n    char *ptr = destination;\n    while (*source != '\\0'){\n        *destination = *source;\n        destination++;\n        source++;\n    }\n    *destination = '\\0';\n    return ptr;\n}\n```\n\n#### str`ncpy`\n\n```c++\nchar *mystrncpy(char *dest, const char *src, size_t count) {\n  char *tmp = dest;\n  while (count--) {\n    if ((*tmp = *src) != 0)\n      src++;\n    tmp++;\n  }\n  return dest;\n}\n```\n\n```c++\n  char str[16] = {\"hello,world!\\n\"};\n  strncpy(str, \"ipc\", strlen(\"ipc\"));  //ipclo,world!\n  printf(\"%s\\n\", str);\n  strncpy(str, \"ipc\\n\", strlen(\"ipc\")); ////ipclo,world!\n  printf(\"%s\\n\", str);\n  strncpy(str, \"ipc\", strlen(\"ipc\") + 1); //ipc  此时ipc<给定大小 str补%0\n  printf(\"%s\\n\", str);\n```\n\n### String实现\n\n```c++\nclass String {\npublic:\n  String(const char *str = NULL);         // 普通构造函数\n  String(const String &other);            // 拷贝构造函数\n  ~String(void);                          // 析构函数\n  String &operator=(const String &other); // 赋值函数\nprivate:\n  char *m_data; // 用于保存字符串\n};\n//普通构造函数\nString::String(const char *str) {\n  if (str == NULL) {\n    m_data = new char[1];\n    *m_data = '\\0';\n  } else {\n    int length = strlen(str);\n    m_data = new char[length + 1];\n    strcpy(m_data, str);\n  }\n}\n// String的析构函数\nString::~String(void) { delete[] m_data; }\n//拷贝构造函数\nString::String(const String &other){ // 得分点：输入参数为const型\n  int length = strlen(other.m_data);\n  m_data = new char[length + 1];\n  strcpy(m_data, other.m_data);\n}\n//赋值函数\nString &String::operator=(const String &other){ // 得分点：输入参数为const型\n  if (this == &other) {\n    return *this;\n  }\n  delete[] m_data;\n  m_data = new char[strlen(other.m_data) + 1];\n  strcpy(m_data, other.m_data);\n  return *this;\n}\n```\n\n### 智能指针\n\n```c++\n#include <iostream>\n#include <memory>\n\ntemplate <typename T> \n\nclass SmartPointer {\nprivate:\n  T *_ptr;\n  size_t *_count;\n\npublic:\n  SmartPointer(T *ptr = nullptr) : _ptr(ptr) {\n    if (_ptr) {\n      _count = new size_t(1);  //初始化非空 设置count为1\n    } else {\n      _count = new size_t(0);\t//初始化为空 count设为0\n    }\n  }\n\n  SmartPointer(const SmartPointer &ptr) {\n    if (this != &ptr) {\n      this->_ptr = ptr._ptr;\n      this->_count = ptr._count;\n      (*this->_count)++;  //拷贝构造 count++\n    }\n  }\n\n  SmartPointer &operator=(const SmartPointer &ptr) {\n    if (this->_ptr == ptr._ptr) { //元素相等 直接返回\n      return *this;\n    }\n    if (this->_ptr) { //本身非空 自己原来的计数-1\n      (*this->_count)--;   //本身存在实例化对象，更换指向 因此count--\n      if (*this->_count == 0) { //计数为0 释放所有\n        delete this->_ptr;\n        delete this->_count;\n      }\n    }\n    this->_ptr = ptr._ptr;  //更改指向\n    this->_count = ptr._count;\n    (*this->_count)++;  //count++\n    return *this;\n  }\n\n  T &operator*() {\n    assert(this->_ptr == nullptr);\n    return *(this->_ptr);  //* 返回指针的解引用 实例化的对象\n  }\n\n  T *operator->() {\n    assert(this->_ptr == nullptr);\n    return this->_ptr;  //->返回的是个指针\n  }\n\n  ~SmartPointer() {   //RAII机制, 对象离开作用域即调用析构函数\n    (*this->_count)--;   //对象析构count--\n    if (*this->_count == 0) { //引用计数为0，析构释放空间\n      delete this->_ptr;\n      delete this->_count;\n    }\n  }\n\n  size_t use_count() { return *this->_count; }  //返回指向ptr堆空间的智能指针\n};\n\nint main() {\n    SmartPointer<int> sp(new int(10));\n    SmartPointer<int> sp2(sp);\n    SmartPointer<int> sp3(new int(20));\n    sp2 = sp3;\n    std::cout << sp.use_count() << std::endl;\n    std::cout << sp3.use_count() << std::endl;\n \t\t// delete operator\n}\n```\n\n### 排序算法\n\n| **排序方法**         | **平均时间** | **最好时间** | **最坏时间** |\n| -------------------- | ------------ | ------------ | ------------ |\n| 桶排序(不稳定)       | O(n)         | O(n)         | O(n)         |\n| 基数排序(稳定)       | O(n)         | O(n)         | O(n)         |\n| 归并排序(==稳定==)   | `O(nlogn)`   | `O(nlogn)`   | `O(nlogn)`   |\n| 快速排序(==不稳定==) | `O(nlogn)`   | `O(nlogn)`   | `O(n^2^)`    |\n| 堆排序(不稳定)       | O(nlogn)     | O(nlogn)     | O(nlogn)     |\n| 希尔排序(不稳定)     | O(n^1.25^)   |              |              |\n| 冒泡排序(稳定)       | O(n^2^)      | O(n)         | O(n^2^)      |\n| 选择排序(不稳定)     | O(n^2^)      | O(n^2^)      | O(n^2^)      |\n| 直接插入排序(稳定)   | O(n^2^)      | O(n)         | O(n^2^)      |\n\n#### 快速排序\n\n```c++\n//分割函数\nint paritition(vector<int>& A, int low, int high){\n    int pivotValue = A[low];\n    while(low<high){\n        while(low<high && A[high] >= pivotValue)\n            --high;  //从右向左查找到第一个小于pivot的坐标\n        A[low] = A[high];\n        while(low<high && A[low] <= pivotValue)\n            ++low;   //从左向右查找到第一个大于pivot的坐标\n        A[high] = A[low];\n    }\n    A[low] = pivotValue; //拿走的值返还 放到排序的位置\n    return low;   //返回的是一个位置\n    \n}\n\n//快排母函数\nvoid quickSort(vector<int>& A, int low, int high){\n    if(low<high){\n        int pivotIndex = paritition(A, low, high);\n        quickSort(A, low, pivotIndex-1);\n        quickSort(A, pivotIndex+1, high);\n    }\n}\n\n// 洗牌算法，将输入的数组随机打乱 避免极端情况\nvoid shuffle(vector<int>& nums){\n    srand(time(0)); //随机数种子是必须有的? 因为一次shuffle函数调用 多次rand\n    for(int i = 0; i<nums.size(); i++){\n        int r = i + rand()%(nums.size() - i)\n        swap(nums[i], nums[r]);\n    }\n}\n```\n\n从大到小排序修改\n\n```c++\n    //分割函数\n    int Paritition(vector<int>& A, int low, int high){\n        int pivotValue = A[low];\n        while(low<high){\n            while(low<high && A[high] <= pivotValue) //<=\n                --high;\n            A[low] = A[high];\n            while(low<high && A[low] >= pivotValue)  //>=\n                ++low;\n            A[high] = A[low];\n        }\n        A[low] = pivotValue;  //拿走的值返还 放到排序的位置\n        return low;  //返回的是一个位置\n    }\n```\n\n#### 归并排序\n\n```c++\nvoid merge(vector<int> &nums, int left, int mid, int right) {\n  // preconditions:\n  // nums[left, mid] is sorted\n  // nums[mid + 1, right] is sorted\n  // Copy nums[left ... mid] to LeftSubNums\n  // Copy nums[mid+1 ... end] to RightSubNums\n  vector<int> LeftSubNums(nums.begin() + left, nums.begin() + mid + 1);\n  vector<int> RightSubNums(nums.begin() + mid + 1, nums.begin() + right + 1);\n  int leftIndex = 0, rightIndex = 0;\n  LeftSubNums.insert(LeftSubNums.end(), INT_MAX);\n  RightSubNums.insert(RightSubNums.end(), INT_MAX);\n  // Pick min of LeftSubnums[idxLeft] and RightSubnums[idxRight], and put into nums[i]\n  for (int i = left; i <= right; i++) {\n    if (LeftSubNums[leftIndex] < RightSubNums[rightIndex]) \n      nums[i] = LeftSubNums[leftIndex++];\n    else \n      nums[i] = RightSubNums[rightIndex++];\n  }\n}\n\nvoid mergeSort(vector<int> &nums, int left, int right) {\n  if (left >= right)\n    return;\n  int mid = left + (right - left) / 2;\n  mergeSort(nums, left, mid);\n  mergeSort(nums, mid + 1, right);\n  merge(nums, left, mid, right);\n}\n```\n\n#### 选择排序\n\n```c++\ntemplate <typename T>\n\nvoid selection_sort(std::vector<T> &arr) {\n  for (int i = 0; i < arr.size() - 1; i++) {\n    int minIndex = i;\n    for (int j = i + 1; j < arr.size(); j++)\n      if (arr[j] < arr[minIndex])\n        minIndex = j; //找到其他元素中的最小值对应的index\n    std::swap(arr[i], arr[minIndex]); //交换\n  }\n}\n```\n\n#### 插入排序\n\n```c++\nvoid insertion_sort(int arr[],int len){\n  for(int i=1;i<len;i++){\n    int key=arr[i];  //拿出来比较的元素\n    int j=i-1;\n    while((j>=0) && (key<arr[j])){\n      arr[j+1]=arr[j];\n      j--;\n    }\n    arr[j+1]=key;\n  }\n}\n```\n","tags":["面试"]},{"title":"移位获取INT_MIN和INT_MAX","url":"/2022/05/09/yi-wei-huo-qu-int-min-he-int-max/","content":"\n```c++\nint main() {\n  \n  int minn = 1 << 31;           // INT_MIN 0x80000000\n  int maxx = long(1 << 31) - 1; // INT_MAX 0x7fffffff\n  int a = INT_MAX;\n  int b = INT_MIN;\n\n  return 0;\n}\n```\n\n![image-20220509110112005](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220509110112005.png)\n\n","tags":["开发随笔"]},{"title":"人名算法","url":"/2022/05/04/ren-ming-suan-fa/","content":"\n## 约瑟夫环\n\n### [1823. 找出游戏的获胜者](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/)\n\n难度中等129收藏分享切换为英文接收动态反馈\n\n共有 `n` 名小伙伴一起做游戏。小伙伴们围成一圈，按 **顺时针顺序** 从 `1` 到 `n` 编号。确切地说，从第 `i` 名小伙伴顺时针移动一位会到达第 `(i+1)` 名小伙伴的位置，其中 `1 <= i < n` ，从第 `n` 名小伙伴顺时针移动一位会回到第 `1` 名小伙伴的位置。\n\n游戏遵循如下规则：\n\n1. 从第 `1` 名小伙伴所在位置 **开始** 。\n2. 沿着顺时针方向数 `k` 名小伙伴，计数时需要 **包含** 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。\n3. 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。\n4. 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 **顺时针下一位** 小伙伴 **开始**，回到步骤 `2` 继续执行。\n5. 否则，圈子中最后一名小伙伴赢得游戏。\n\n给你参与游戏的小伙伴总数 `n` ，和一个整数 `k` ，返回游戏的获胜者。\n\n \n\n**示例 1：**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220505002315098.png\" alt=\"image-20220505002315098\" style=\"zoom:67%;\" />\n\n```\n输入：n = 5, k = 2\n输出：3\n解释：游戏运行步骤如下：\n1) 从小伙伴 1 开始。\n2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。\n3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。\n4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。\n5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。\n6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。\n7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。\n8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。\n9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。\n```\n\n**示例 2：**\n\n```\n输入：n = 6, k = 5\n输出：1\n解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。\n```\n\n#### 笨比解法 模拟\n\n```c++\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n      vector<int> all;\n      for(int i = 1; i<=n; i++){\n        all.push_back(i);\n      }\n      int index = 0;\n      while(all.size() > 1){\n        index = (index + k - 1)%n;\n        all.erase(all.begin() + index);\n        n--;\n      }\n      return all.front();\n    }\n};\n```\n\n#### 数学解法\n\n```dart\n下表 0 1 2 3 4   数到3删除\n最后只剩下一个元素，假设这个最后存活的元素为 num, 这个元素最终的的下标一定是0 （因为最后只剩这一个元素），\n所以如果我们可以推出上一轮次中这个num的下标，然后根据上一轮num的下标推断出上上一轮num的下标，\n直到推断出元素个数为n的那一轮num的下标，那我们就可以根据这个下标获取到最终的元素了。推断过程如下：\n\n首先最后一轮中num的下标一定是0， 这个是已知的。\n那上一轮应该是有两个元素，此轮次中 num 的下标为 (0 + m)%n = (0+3)%2 = 1; 说明这一轮删除之前num的下标为1；\n再上一轮应该有3个元素，此轮次中 num 的下标为 (1+3)%3 = 1；说明这一轮某元素被删除之前num的下标为1；\n再上一轮应该有4个元素，此轮次中 num 的下标为 (1+3)%4 = 0；说明这一轮某元素被删除之前num的下标为0；\n再上一轮应该有5个元素，此轮次中 num 的下标为 (0+3)%5 = 3；说明这一轮某元素被删除之前num的下标为3；\n....\n\n因为我们要删除的序列为0-n-1, 所以求得下标其实就是求得了最终的结果。比如当n 为5的时候，num的初始下标为3，\n 所以num就是3，也就是说从0-n-1的序列中， 经过n-1轮的淘汰，3这个元素最终存活下来了，也是最终的结果。\n\n总结一下推导公式：(此轮过后的num下标 + m) % 上轮元素个数 = 上轮num的下标\n```\n\n注意 这道题因为编号是从1开始的 index 0对应的人是1 所以最后的下标要+1\n\n```c++\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n      int pos = 0; // 最终活下来那个人的初始位置\n      for(int i = 2; i <= n; i++) //上次剩两个人 最后剩n个人\n          pos = (pos + k) % i;  // 每次循环右移\n      return pos + 1;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"数据结构","url":"/2022/05/02/shu-ju-jie-gou/","content":"\n## RB-Tree\n\n### 概念明确\n\n#### 二叉搜索树（二叉查找树） BST\n\n二叉查找树是一种特殊的**二叉树**，因此其也有递归定义：\n\n- 二叉搜索树是一颗空树\n- 二叉搜索树由根结点、左子树、右子树组成，其中左子树、右子树都是二叉查找树，且左子树上**所有结点的数据域均小于或等于根结点的数据域**，右子树上**所有结点的数据域均大于根结点的数据域**。\n\n#### 平衡二叉树(AVL)\n\n本质：仍是一棵`二叉搜索树`，只不过增加了平衡的要求\n\n特点：使树的高度在每次插入元素后仍能保持O(logn)级别\n\n平衡：对于树中任意结点，其**左子树与右子树的高度之差的绝对值**不大于1\n\n平衡因子：**结点的左子树与右子树的高度之差**\n\n### 红黑树 RB-Tree\n\n红黑树是一种含有红黑结点并能`自平衡的二叉查找树`。\n\n- 性质1：每个节点要么是黑色，要么是红色。\n- 性质2：根节点是黑色。\n- 性质3：每个叶子节点（NIL）是黑色。\n- 性质4：每个红色结点的两个子结点一定都是黑色。\n- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**\n- 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点\n\n**黑是真正的节点，而红只不过是用来表示两个键是属于一个3-节点。**\n\n红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。\n\n- **左旋**：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。（`右子节点的左岔连自己 右子节点当爹`）\n\n  ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-a95db442f1b47f8a.png)\n\n- **右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。（`左子节点的右岔连自己 左子节点当爹`）\n\n  ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-0676a8e2a12e2a0b.png)\n\n- **变色**：结点的颜色由红变黑或由黑变红。\n\n红黑树的维护可以简要地概括为三句话：\n\n1. 如果右子节点是红色的，而左子节点是黑色的，进行左旋转。\n2. 如果左子节点是红色的，且它的左子节点也是红色的，进行右旋转。\n3. 如果左右子节点均为红色,进行颜色转换\n\n#### 红黑树查找\n\n因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：\n\n1. 从根结点开始查找，把根结点设置为当前结点；\n2. 若当前结点为空，返回null；\n3. 若当前结点不为空，用当前结点的key跟查找key作比较；\n4. 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；\n5. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；\n6. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2392382-07b47eb3722981e6.png)\n\n\n\n\n\n\n\n\n\n## b树和b+树\n\n### B树(B-tree)\n\n注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;\n\n#### 概念\n\nB树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），`数据库索引技术`里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;\n\n#### 规则\n\n（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；\n\n（2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；\n\n（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);\n\n（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;\n\n最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C>B>A）\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-2c2264cc1c6c603dfeca4f84a2575901_r.jpg)\n\n#### B树的查询流程\n\n如上图我要从上图中找到E字母，查找流程如下\n\n（1）获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；\n\n（2）拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；\n\n（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；\n\n#### B树的插入节点流程\n\n定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28、53 这些数字构建出一个5阶树出来;\n\n遵循规则：\n\n（1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）；\n\n（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;\n\n先插入 3、8、31、11\n\n\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-66a9896538aac51fa9e5e3675ac22fe7_r.jpg)\n\n再插入23、29\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-29884e575bff8a49898eae6ab0e5a1aa_r.jpg)\n\n再插入50、28、53\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-611a75c925af37f8e6f18dfc0f8a0760_r.jpg)\n\n\n\n#### B树节点的删除\n\n##### **规则：**\n\n（1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于 ceil(m/2)-1（所以这里关键字数<2就要进行节点合并）；\n\n（2）满足节点本身比左边节点大，比右边节点小的排序规则;\n\n（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-a8712ab2bded1411726efea37ae20223_r.jpg)\n\n##### **特点：**\n\nB树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;\n\n### B+树\n\n#### 概念\n\n`B+树是B树的一个升级版`，相对于B树来说B+树`更充分的利用了节点的空间`，`让查询速度更加稳定`，`其速度完全接近于二分法查找`。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别\n\n#### 规则\n\n（1）B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加；\n\n（2）B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；\n\n（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。\n\n（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-5f069fd820637db1b877fdd6799a2b67_r.jpg)\n\n\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-9644d1a1f83d3e45da779f2e63c35d55_r.jpg)\n\n#### 特点\n\n1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；\n\n2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;\n\n3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。\n\n4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。\n\n**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。","tags":["面试"]},{"title":"自我介绍","url":"/2022/05/02/zi-wo-jie-shao/","content":"\n你好，我叫岳子冲，是武汉理工大学的2023届毕业生，主修是仪器，我们实验室分工比较明确，我在实验室主要负责一个微动地质勘测仪器的客户端分析软件的开发，手里现在比较大的有两个软件，一个是qt框架的信号处理软件，主要就是一些采集到的信号导入到软件，然后进行一些地质算法的计算，专业人士看一下计算结果就可以进行地质分析；还有一个mfc框架的成图软件，这个软件属于是比较原始，主要就是绘制几个等值线剖面图，用的是opencv实现的，属于是自己造了个轮子。手里主要就是这两个软件，毕业论文的研究方向也是地质算法的研究和改进，在第一个软件上做测试，对一些算法做一些探测深度和精度上的优化\n\n","tags":["面试"]},{"title":"随机算法","url":"/2022/04/25/sui-ji-suan-fa/","content":"\n\n\n### [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=382)[思路](https://leetcode-cn.com/problems/linked-list-random-node/#)\n\n难度中等270\n\n给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。\n\n实现 `Solution` 类：\n\n- `Solution(ListNode head)` 使用整数数组初始化对象。\n- `int getRandom()` 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。\n\n \n\n**示例：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/getrand-linked-list.jpg)\n\n```\n输入\n[\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\n[[[1, 2, 3]], [], [], [], [], []]\n输出\n[null, 1, 3, 2, 2, 3]\n```\n\n#### [蓄水池抽样算法](https://leetcode-cn.com/problems/linked-list-random-node/solution/xu-shui-chi-chou-yang-suan-fa-by-jackwener/)\n\n当内存无法加载全部数据时，如何从包含`未知大小的数据流`中`随机选取k个数据`，并且要保证每个数据被抽取到的概率相等。\n\n当 k = 1 时，即此题的情况\n也就是说，我们每次只能读一个数据。\n\n假设数据流含有N个数，我们知道如果要保证所有的数被抽到的概率相等，那么每个数抽到的概率应该为 1/N\n\n那如何保证呢？\n\n先说方案：\n\n每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数。\n\n举例说明： 1 - 10\n\n遇到1，概率为1，保留第一个数。\n遇到2，概率为1/2，这个时候，1和2各1/2的概率被保留\n遇到3，3被保留的概率为1/3，(之前剩下的数假设1被保留)，2/3的概率 1 被保留，(此时1被保留的总概率为 2/3 * 1/2 = 1/3)\n遇到4，4被保留的概率为1/4，(之前剩下的数假设1被保留)，3/4的概率 1 被保留，(此时1被保留的总概率为 3/4 * 2/3 * 1/2 = 1/4)\n以此类推，每个数被保留的概率都是1/N。\n\n证明使用数学归纳法即可\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220425010136581.png\" alt=\"image-20220425010136581\" style=\"zoom: 33%;\" />\n\n#### 代码\n\n```c++\nclass Solution {\n    ListNode* head;\npublic:\n    Solution(ListNode* head) {\n        this->head = head;\n    }\n    \n    /** Returns a random node's value. */\n    int getRandom() {\n        ListNode* phead = this->head;\n        int val = phead->val;\n        int count = 1;\n        while (phead){\n            if (rand() % count++ == 0)\n                val = phead->val;\n            phead = phead->next;\n        }\n        return val;\n    }\n};\n```\n\n### [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=398)[思路](https://leetcode-cn.com/problems/random-pick-index/#)\n\n难度中等146英文版讨论区\n\n给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。\n\n**注意：**\n数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。\n\n**示例:**\n\n```\nint[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。\nsolution.pick(3);\n\n// pick(1) 应该返回 0。因为只有nums[0]等于1。\nsolution.pick(1);\n```\n\n#### 代码\n\n```c++\nclass Solution {\n    vector<int> &nums;\npublic:\n    Solution(vector<int> &nums) : nums(nums) {}\n\n    int pick(int target) {\n        int ans;\n        for (int i = 0, cnt = 0; i < nums.size(); ++i) {\n            if (nums[i] == target) {\n                ++cnt; // 第 cnt 次遇到 target\n                if (rand() % cnt == 0) {\n                    ans = i;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)\n\n难度中等273\n\n给你一个整数数组 `nums` ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 **等可能** 的。\n\n实现 `Solution` class:\n\n- `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象\n- `int[] reset()` 重设数组到它的初始状态并返回\n- `int[] shuffle()` 返回数组随机打乱后的结果\n\n \n\n**示例 1：**\n\n```\n输入\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\n输出\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n```\n\n#### `Fisher–Yates shuffle 洗牌算法`\n\n##### 现代方法\n\nFisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。\n\n现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。**这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后**。这样就将时间复杂度从 O(n^2) 减小到了 **O(n)**。算法的伪代码如下：\n\n```\n-- To shuffle an array a of n elements (indices 0..n-1):\nfor i from n−1 downto 1 do\n     j ← random integer such that 0 ≤ j ≤ i\n     exchange a[j] and a[i]\n```\n\n##### 例子\n\n###### 迭代步骤演示\n\n根据每次迭代次数可以用下面的表格，描述这个算法的执行过程\n\n| 随机数取值范围 | 随机数 |        原始数据 | 结果          |\n| :------------- | :----- | --------------: | :------------ |\n|                |        | 1 2 3 4 5 6 7 8 |               |\n| 1-8            | 6      |   1 2 3 4 5 7 8 | 6             |\n| 1-7            | 2      |     1 7 3 4 5 8 | 2 6           |\n| 1–6            | 6      |       1 7 3 4 5 | 8 2 6         |\n| 1–5            | 1      |         5 7 3 4 | 1 8 2 6       |\n| 1–4            | 3      |           5 7 4 | 3 1 8 2 6     |\n| 1–3            | 3      |             5 7 | 4 3 1 8 2 6   |\n| 1–2            | 1      |               7 | 5 4 3 1 8 2 6 |\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n\t\tvector<int> nums;\n\t\tvector<int> origin;\n  \n    Solution(vector<int>& nums) {\n        this->nums = nums;\n        this->origin.resize(nums.size());\n        copy(nums.begin(), nums.end(), origin.begin());\n    }\n    \n    vector<int> reset() {\n        copy(origin.begin(), origin.end(), nums.begin());\n        return nums;\n    }\n    \n    vector<int> shuffle() {\n        for(int i = 0; i<nums.size(); i++){\n            int j =i+ rand()%(nums.size()-i);\n            swap(nums[i], nums[j]);\n        }\n        return nums;\n    }\n};\n```\n\n### [剑指 Offer II 071. 按权重生成随机数](https://leetcode-cn.com/problems/cuyjEf/)\n\n难度中等19英文版讨论区\n\n给定一个正整数数组 `w` ，其中 `w[i]` 代表下标 `i` 的权重（下标从 `0` 开始），请写一个函数 `pickIndex` ，它可以随机地获取下标 `i`，选取下标 `i` 的概率与 `w[i]` 成正比。\n\n\n\n例如，对于 `w = [1, 3]`，挑选下标 `0` 的概率为 `1 / (1 + 3) = 0.25` （即，25%），而选取下标 `1` 的概率为 `3 / (1 + 3) = 0.75`（即，75%）。\n\n也就是说，选取下标 `i` 的概率为 `w[i] / sum(w)` 。\n\n \n\n**示例 1：**\n\n```\n输入：\ninputs = [\"Solution\",\"pickIndex\"]\ninputs = [[[1]],[]]\n输出：\n[null,0]\n解释：\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。\n```\n\n**示例 2：**\n\n```\n输入：\ninputs = [\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\ninputs = [[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n```\n\n#### 解法1\n\n前缀和 + 二分 主要注意二分查找的值的选择\n\n```cpp\nclass Solution {\n    vector<int> preSum;\npublic:\n    Solution(vector<int>& w) {\n      preSum.resize(w.size());\n      int pre = 0;\n      for(int i = 0; i<preSum.size(); i++){\n        preSum[i] = pre + w[i];\n        pre = preSum[i];\n      }\n    }\n    \n    int pickIndex() {\n      //假设1 1 1 presum: 1 2 3 \n      //取随机数的size应该就是 3 但是查找随机数应该在随机数+1\n      //从最后一个看 rand最大为2 永远取不到最后一个 且多取到1次0\n      int val = rand()%(preSum.back());\n      int pos = lower_bound(preSum.begin(), preSum.end(), val + 1) - preSum.begin();\n      return pos;\n    }\n};\n```\n\n#### 解法2\n\n蓄水池抽样 超时了 想起来更简单 但是每次都是On 总体时间超时了 试了下随机中断他，通过不了 可能中断思路不对吧\n\n```c++\nclass Solution {\n    vector<int> nums;\npublic:\n    Solution(vector<int>& w) : nums(w){}\n    \n    int pickIndex() {\n      int ans;\n      int preSum = 0;\n      for(int i = 0; i<nums.size(); i++){\n        preSum += nums[i];\n        ans = rand()%preSum < nums[i]?i:ans;\n      }\n      return ans;\n    }\n};\n```","tags":["算法总结"]},{"title":"博客园代码拷贝问题","url":"/2022/04/22/bo-ke-yuan-kao-bei-dai-ma-de-yi-ge-keng/","content":"\n\n\n博客园拷贝代码 到 vs2015运行 竟然还能出现格式问题。。。\n\n#### 问题如下\n\n这样，博客园的复制 将代码拷贝到本地运行，按理说官方的推荐复制方式 应该没什么问题吧\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422103829763.png\" alt=\"image-20220422103829763\" style=\"zoom:50%;\" />\n\n然而拷贝过来 vs的贴心提示 ： 你该输入`;`的\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422103929682.png\" alt=\"image-20220422103929682\" style=\"zoom: 67%;\" />\n\n好家伙 直接好家伙， 用sublime打开看看吧\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422104117209.png\" alt=\"image-20220422104117209\" style=\"zoom:67%;\" />\n\n删除之后 解决问题 vs是隐藏的空格 因此 只能在文本编辑器中删除\n\n#### 总结\n\n博客园原创多，资料好\n\n但是 服务器崩 资源停用 md不友好也就算了 竟然还有这种乱七八糟的问题 ","tags":["开发随笔"]},{"title":"设计模式","url":"/2022/04/22/she-ji-mo-shi/","content":"\n# 面试问题\n\n\n\n# 常用设计模式\n\n[C++ 常用设计模式 - 小肚哥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chengjundu/p/8473564.html)\n\n## 1. 工厂模式\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接new完成一个实例对象的创建。\n\n### 1.1、简单工厂模式\n\n#### 应用举例\n\n**客户Jungle需要时可以向工厂提供产品参数，工厂根据产品参数生产对应产品，客户Jungle并不需要关心产品的生产过程细节**。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20191017205259541.png)\n\n**简单工厂模式：**\n\n**定义一个简单工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类**\n\n#### 实现流程\n\n由上述例子，可以很容易总结出简单工厂的实现流程：\n\n设计一个抽象产品类，它包含一些公共方法的实现；\n从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码；\n设计一个工厂类，工厂类中提供一个生产各种产品的工厂方法，该方法根据传入参数（产品名称）创建不同的具体产品类对象；\n客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。\n\n\n\n主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。\n\n`缺点`：工厂类集中了所有产品类的创建逻辑，如果产品量较大，会使得工厂类变的非常臃肿\n\n#### 大体上有3个角色\n\n- **工厂（Factory）**：根据客户提供的具体产品类的参数，创建具体产品实例；\n- **抽象产品（AbstractProduct）**：具体产品类的基类，包含创建产品的公共方法；\n- **具体产品（ConcreteProduct）**：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。\n\n![image-20220422105125245](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422105125245.png)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//设计模式\n//定义产品类型信息\ntypedef enum { Tank_Type_56, Tank_Type_96, Tank_Type_Num } Tank_Type;\n\n//抽象产品类\nclass Tank {\npublic:\n  virtual const string &type() = 0;\n};\n\n//具体的产品类\nclass Tank56 : public Tank {\npublic:\n  Tank56() : Tank(), m_strType(\"Tank56\") {}\n  // 在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。\n  const string &type() override {\n    cout << m_strType.data() << endl;\n    return m_strType;\n  }\n\nprivate:\n  string m_strType;\n};\n\n//具体的产品类\nclass Tank96 : public Tank {\npublic:\n  Tank96() : Tank(), m_strType(\"Tank96\") {}\n  const string &type() override {\n    cout << m_strType.data() << endl;\n    return m_strType;\n  }\n\nprivate:\n  string m_strType;\n};\n\n//工厂类\nclass TankFactory {   //产品量较大，会使得工厂类变的非常臃肿\npublic:\n  //根据产品信息创建具体的产品类实例，返回一个抽象产品类\n  Tank *createTank(Tank_Type type) {\n    switch (type) {\n    case Tank_Type_56:\n      return new Tank56();\n    case Tank_Type_96:\n      return new Tank96();\n    default:\n      return nullptr;\n    }\n  }\n};\n\nint main() {\n  TankFactory *factory = new TankFactory();\n  Tank *tank56 = factory->createTank(Tank_Type_56);\n  tank56->type();    // output: Tank56\n  Tank *tank96 = factory->createTank(Tank_Type_96);\n  tank96->type();\t\t// output: Tank96\n\n  delete tank96;\n  tank96 = nullptr;\n  delete tank56;\n  tank56 = nullptr;\n  delete factory;\n  factory = nullptr;\n\n  return 0;\n}\n```\n\n### 1.2、工厂方法模式\n\n定义一个创建对象的接口，其子类去具体现实这个接口以完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。\n\n缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量\n\n![image-20220422105539020](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422105539020.png)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\n//产品抽象类\nclass Tank {\npublic:\n  virtual const string &type() = 0;\n};\n\n//具体的产品类\nclass Tank56 : public Tank {\npublic:\n  Tank56() : Tank(), m_strType(\"Tank56\") {}\n\n  const string &type() override {\n    cout << m_strType.data() << endl;\n    return m_strType;\n  }\n\nprivate:\n  string m_strType;\n};\n\n//具体的产品类\nclass Tank96 : public Tank {\npublic:\n  Tank96() : Tank(), m_strType(\"Tank96\") {}\n  const string &type() override {\n    cout << m_strType.data() << endl;\n    return m_strType;\n  }\n\nprivate:\n  string m_strType;\n};\n\n//抽象工厂类，提供一个创建接口\nclass TankFactory {\npublic:\n  //提供创建产品实例的接口，返回抽象产品类\n  virtual Tank *createTank() = 0;\n};\n\n//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例\nclass Tank56Factory : public TankFactory {\npublic:\n  Tank *createTank() override { return new Tank56(); }\n};\n\n//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例\nclass Tank96Factory : public TankFactory {\npublic:\n  Tank *createTank() override { return new Tank96(); }\n};\n\nint main() {\n  TankFactory *factory56 = new Tank56Factory();\n  Tank *tank56 = factory56->createTank();\n  tank56->type();\n\n  TankFactory *factory96 = new Tank96Factory();\n  Tank *tank96 = factory96->createTank();\n  tank96->type();\n\n  delete tank96;\n  tank96 = nullptr;\n  delete factory96;\n  factory96 = nullptr;\n\n  delete tank56;\n  tank56 = nullptr;\n  delete factory56;\n  factory56 = nullptr;\n\n  return 0;\n}\n```\n\n### 1.3、`抽象工厂模式`\n\n抽象工厂模式提供创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n当存在多个产品系列，而客户端只使用一个系列的产品时，可以考虑使用抽象工厂模式。\n\n缺点：当增加一个新系列的产品时，不仅需要现实具体的产品类，还需要增加一个新的创建接口，扩展相对困难。\n\n\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422105924780.png\" alt=\"image-20220422105924780\" style=\"zoom:150%;\" />\n\n```c++\n//抽象上衣类\nclass Coat {\npublic:\n  virtual const string &color() = 0;\n};\n\n//黑色上衣类\nclass BlackCoat : public Coat {\npublic:\n  BlackCoat() : Coat(), m_strColor(\"Black Coat\") {}\n  const string &color() override {\n    cout << m_strColor.data() << endl;\n    return m_strColor;\n  }\n\nprivate:\n  string m_strColor;\n};\n\n//白色上衣类\nclass WhiteCoat : public Coat {\npublic:\n  WhiteCoat() : Coat(), m_strColor(\"White Coat\") {}\n  const string &color() override {\n    cout << m_strColor.data() << endl;\n    return m_strColor;\n  }\n\nprivate:\n  string m_strColor;\n};\n\n//抽象裤子类\nclass Pants {\npublic:\n  virtual const string &color() = 0;\n};\n\n//黑色裤子类\nclass BlackPants : public Pants {\npublic:\n  BlackPants() : Pants(), m_strColor(\"Black Pants\") {}\n  const string &color() override {\n    cout << m_strColor.data() << endl;\n    return m_strColor;\n  }\n\nprivate:\n  string m_strColor;\n};\n\n//白色裤子类\nclass WhitePants : public Pants {\npublic:\n  WhitePants() : Pants(), m_strColor(\"White Pants\") {}\n  const string &color() override {\n    cout << m_strColor.data() << endl;\n    return m_strColor;\n  }\n\nprivate:\n  string m_strColor;\n};\n\n//抽象工厂类，提供衣服创建接口\nclass Factory {\npublic:\n  //上衣创建接口，返回抽象上衣类\n  virtual Coat *createCoat() = 0;\n  //裤子创建接口，返回抽象裤子类\n  virtual Pants *createPants() = 0;\n};\n\n//创建白色衣服的工厂类，具体实现创建白色上衣和白色裤子的接口\nclass WhiteFactory : public Factory {\npublic:\n  Coat *createCoat() override { return new WhiteCoat(); }\n  Pants *createPants() override { return new WhitePants(); }\n};\n//创建黑色衣服的工厂类，具体实现创建黑色上衣和白色裤子的接口\nclass BlackFactory : public Factory {\n  Coat *createCoat() override { return new BlackCoat(); }\n  Pants *createPants() override { return new BlackPants(); }\n};\n```\n\n## 2. 策略模式\n\n策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色环境角色表现出不同的行为。\n\n相比于使用大量的if...else，使用策略模式可以降低复杂度，使得代码更容易维护。\n\n缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。\n\n[环境角色] 持有一个策略类的引用，最终给客户端调用。\n\n`在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦`\n\n#### 传统的策略模式利用多态实现\n\n#### 除了多态 `还可以利用函数指针实现` 略\n\n![image-20220422111042179](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422111042179.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass TaxStrategy\n{\npublic:\n    virtual double Calculate()=0;\n    virtual ~TaxStrategy(){}\n};\n\nclass CNTax : public TaxStrategy\n{\npublic:\n    virtual double Calculate()\n\t{\n       printf(\"CNTax Calculate\\n\");\n\t   return 0;\n    }\n};\n\nclass USTax : public TaxStrategy\n{\npublic:\n    virtual double Calculate()\n\t{\n       printf(\"USTax Calculate\\n\");\n\t   return 0;\n    }\n};\n\nclass DETax : public TaxStrategy{\npublic:\n    virtual double Calculate()\n\t{\n       printf(\"DETax Calculate\\n\");\n\t   return 0;\n    }\n};\n\nclass SalesOrder{\nprivate:\n    TaxStrategy* strategy;\n\npublic:\n    /*SalesOrder(StrategyFactory* strategyFactory)\n\t{//使用工厂方法\n        this->strategy = strategyFactory->NewStrategy();\n    }*/\n\tSalesOrder(TaxStrategy* strategy)\n\t{\n\t\tthis->strategy = strategy;\n\t}\n    ~SalesOrder(){\n    }\n\n    double CalculateTax()\n\t{\n        //...\n        double val = strategy->Calculate();//多态调用\n        //...\n\t\treturn val;\n    }\n    \n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\t//TaxStrategy* strategy = new DETax();\n\tTaxStrategy* strategy = new CNTax();\n\tSalesOrder order(strategy);\n\torder.CalculateTax();\n\tdelete strategy;\n\treturn 0;\n}\n```\n\n## 3. [观察者模式](https://zhuanlan.zhihu.com/p/119308881)\n\n### 观察者模式的核心思想是 **1对多**\n\n以自己为例，我下班的时候会告诉孩子和他妈，我开车要往回走了\n\n- 孩子妈收到消息后开始做饭\n- 孩子收到消息后，就赶紧收起手机，怕挨揍\n\n传统写法：\n\n```c++\n#include <iostream>\nclass Son{\npublic:\n    void DoSomething(){\n        std::cout<<\"爸爸回来了，赶紧去写作业\"<<std::endl;\n    }\n};\n\nclass Wife{\npublic:\n    void DoSomething(){\n        std::cout<<\"老公回来了，去做饭\"<<std::endl;\n    }\n};\n\nclass Me{\npublic:\n    void Gohome(){\n        wife.DoSomething();\n        son.DoSomething();\n    }\nprivate:\n    Wife wife;\n    Son son;\n};\n\nint main(){\n    Me me;\n    me.Gohome();\n    return 0;\n}\n```\n\n这样写的不足如下：\n\n1. 如果关心我的人变多了，比如我又加了我老妈、老爸 ，这时候我们`不得不去修改Me的类`\n\n```c++\nclass Me{\npublic:\n    void Gohome(){\n        wife.DoSomething();\n        son.DoSomething();\n        mom.DoSomething();\n        ba.DoSomething();\n    }\nprivate:\n    Wife wife;\n    Son son;\n    Mother mom;\n    Father ba;\n};\n```\n\n2. 人数少的时候，还可以应付，假如关心我的人有1000人，那这时候我们该怎么办\n3. 本身这样写就不科学 大家都是独立的人 不应该相互包含\n\n#### 1. 开始重构，简单观察者模式，面向抽象编程\n\n1. 观察者接口\n\n```c++\nclass ObserverInterface{\npublic:\n    virtual void dosomething()=0;\n    virtual ~ObserverInterface(){}\n};\n```\n\n2. 被观察者接口\n\n```c++\nclass SubjectInterface{\npublic:\n    virtual void Add(ObserverInterface* obr)=0;\n    virtual void Remove(ObserverInterface* obr)=0;\n    virtual void Notify()=0;\n\n    virtual ~SubjectInterface(){}\n};\n```\n\n3. 我自己\n\n```c++\nclass Me:public SubjectInterface{\npublic:\n    void Add(ObserverInterface* obr) override{\n        observers.push_back(obr);\n    }\n\n    void Remove(ObserverInterface* obr) override{\n        auto pos=std::find(observers.begin(),observers.end(),obr);\n        if(pos!=observers.end()){\n            observers.erase(pos);\n        }\n    }\n\n    void Notify() override{\n        for(const auto& obs:observers){\n            obs->dosomething();\n        }\n    }\n\nprivate:\n    std::vector<ObserverInterface*> observers;\n};\n```\n\n4. 孩子妈\n\n```c++\nclass Wife:public ObserverInterface{\npublic:\n    void dosomething() override{\n        std::cout<<\"老公快回来了，开始做饭\"<<std::endl;\n    }\n};\n```\n\n5. 孩子\n\n```c++\nclass Son:public  ObserverInterface{\npublic:\n    void dosomething() override {\n        std::cout<<\"爸爸快回来了，不能玩游戏了\"<<std::endl;\n    }\n};\n```\n\n6. main函数\n\n```c++\nint main(){\n    Me me;\n    ObserverInterface* wife=new Wife;\n    ObserverInterface* son=new Son;\n    me.Add(wife);\n    me.Add(son);\n\n    //下班了 发消息\n    me.Notify();\n\n    delete wife;\n    delete son;\n}\n```\n\n这样的好处是：\n\n- 再增加新的观察者，我们就不用修改Me的类了，只需要添加到vector中就可以\n\n不足是：\n\n- `需要自己做内存管理`去 delete <u>`感觉也不是什么不足吧`</u>\n\n#### 2. 优化，使用智能指针shared_ptr代替*\n\n```c++\n//\n// Created by 刘春雷 on 2020/3/28.\n//\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n\nclass ObserverInterface{\npublic:\n    virtual void dosomething()=0;\n\n    //virtual ~ObserverInterface(){}\n};\n\nusing pObserverInterface=std::shared_ptr<ObserverInterface>;\nclass SubjectInterface{\npublic:\n    virtual void Add(pObserverInterface obr)=0;\n    virtual void Remove(pObserverInterface obr)=0;\n    virtual void Notify()=0;\n\n    //virtual ~SubjectInterface(){}\n};\n\n\nclass Me:public SubjectInterface{\npublic:\n    void Add(pObserverInterface obr) override{\n        observers.push_back(obr);\n    }\n\n    void Remove(pObserverInterface obr) override{\n        auto pos=std::find(observers.begin(),observers.end(),obr);\n        if(pos!=observers.end()){\n            observers.erase(pos);\n        }\n    }\n\n    void Notify() override{\n        for(const auto& obs:observers){\n            obs->dosomething();\n        }\n    }\n\nprivate:\n    std::vector<pObserverInterface> observers;\n};\n\n\nclass Wife:public ObserverInterface{\npublic:\n    void dosomething() override{\n        std::cout<<\"老公快回来了，开始做饭\"<<std::endl;\n    }\n\n};\n\nclass Son:public  ObserverInterface{\npublic:\n    void dosomething() override {\n        std::cout<<\"爸爸快回来了，不能玩游戏了\"<<std::endl;\n    }\n};\n\n\nint main(){\n    Me me;\n    auto wife=std::make_shared<Wife>();\n    auto son=std::make_shared<Son>();\n    me.Add(wife);\n    me.Add(son);\n\n    //下班了 发消息\n    me.Notify();\n\n}\n```\n\n#### 3. 使用智能指针 unique_ptr\n\nunique_ptr有两个比较注意的地方\n\n- 所有权的转移\n- 基类析构函数要virtual（跟shared_ptr不一样）\n\n```c++\n//\n// Created by 刘春雷 on 2020/3/28.\n//\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n\nclass ObserverInterface{\npublic:\n    virtual void dosomething()=0;\n    virtual ~ObserverInterface(){}\n};\n\nusing pObserverInterface=std::unique_ptr<ObserverInterface>;\nclass SubjectInterface{\npublic:\n    virtual void Add( pObserverInterface obr)=0;\n    virtual void Remove(pObserverInterface obr)=0;\n    virtual void Notify()=0;\n\n    virtual ~SubjectInterface(){}\n};\n\n\nclass Me:public SubjectInterface{\npublic:\n    void Add(pObserverInterface obr) override{\n        observers.push_back(std::move(obr));\n    }\n\n    void Remove(pObserverInterface obr) override{\n        //TODO\n    }\n\n    void Notify() override{\n        for(const auto& obs:observers){\n            obs->dosomething();\n        }\n    }\n\nprivate:\n    std::vector<pObserverInterface> observers;\n};\n\n\nclass Wife:public ObserverInterface{\npublic:\n    void dosomething() override{\n        std::cout<<\"老公快回来了，开始做饭\"<<std::endl;\n    }\n\n    Wife(){\n        std::cout<<\"wife is created\"<<std::endl;\n    }\n    ~Wife(){\n        std::cout<<\"wife is destroyed\"<<std::endl;\n    }\n};\n\nclass Son:public  ObserverInterface{\npublic:\n    void dosomething() override {\n        std::cout<<\"爸爸快回来了，不能玩游戏了\"<<std::endl;\n    }\n    Son(){\n        std::cout<<\"son is created\"<<std::endl;\n    }\n    ~Son(){\n        std::cout<<\"son is destroyed\"<<std::endl;\n    }\n};\n\n\nint main(){\n    Me me;\n    pObserverInterface wife=std::make_unique<Wife>();\n    pObserverInterface son=std::make_unique<Son>();\n    me.Add(std::move(wife));\n    \n    me.Add(std::move(son));\n    //下班了 发消息\n    me.Notify();\n}\n```\n\n输出结果：\n\n```text\nwife is created\nson is created\n老公快回来了，开始做饭\n爸爸快回来了，不能玩游戏了\n调用son析构函数\n调用wife析构函数\n```\n\n如果把基类析构函数的virtual去掉，输出结果，基类的析构函数没有调用\n\n```text\nwife is created\nson is created\n老公快回来了，开始做饭\n爸爸快回来了，不能玩游戏了\n```","tags":["面试"]},{"title":"顶堆","url":"/2022/04/20/ding-dui/","content":"\n## 顶堆基础知识\n\n### 1. 底层原理\n\n### 2. 应用\n\nc++中的顶堆是 priority_queue，应用中有以下几个注意的点\n\n1. 默认是大顶堆\n\n   ```c++\n   priority_queue<int> que;\n   que.push(1);\n   que.push(3);\n   que.push(2);  // top : 3 2 1\n   ```\n\n2. 可以使用stl提供的 greater< T > 实现小顶堆\n\n   `priority_queue<int, vector<int>, greater<int>> que;`\n\n   对上面的参数做几个说明：\n\n   1. 第一个int 是顶堆中的数据类型\n   2. vector是顶堆使用的容器\n   3. greater< T >标配是指定的\n\n3. 自定义数据类型 和 比较规则 例如存储pair 按 和 从小到大排序\n\n   ```c++\n   auto cmp = [](const pair<int, int> a, const pair<int, int> b)->bool{\n     return a.first + a.second > b.first + b.second;\n   };\n   priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n   ```\n\n   注意：\n\n   1. 比较规则上，顶堆是和vector（或者其他？）完全相反的 `> 表示小顶堆`    `< 表示大顶堆`\n\n   2. 不使用lamda的话 需要加取址运算符 `&`\n\n      ```c++\n      static bool cmp(const pair<int, int> a, const pair<int, int> b){\n        return a.first + a.second > b.first + b.second;\n      };\n      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> que(cmp);\n      ```\n\n   3. 结构体内部重载 < 注意函数后的const该加加\n\n      > 重载小于号猜测 顶堆默认调的是 less  如果重载大于号 则需要明确greater\n\n      结构体重载（） 仿函数\n      \n      lamda decltype 注意 用到decltype 后面顶堆名就也要加（cmp函数名）\n\n## 题目\n\n\n\n### [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode-cn.com/problems/jBjn9C/)\n\n难度简单23收藏分享切换为英文接收动态反馈英文版讨论区\n\n设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。\n\n请实现 `KthLargest` 类：\n\n- `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。\n- `int add(int val)` 将 `val` 插入数据流 `nums` 后，返回当前数据流中第 `k` 大的元素。\n\n \n\n**示例：**\n\n```\n输入：\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n输出：\n[null, 4, 5, 5, 8, 8]\n\n解释：\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n```\n\n#### 思路\n\n维护一个大小为k的小顶堆，每次直接压入，超过k就pop 这样top()永远是第k大的\n\n#### 代码\n\n```c++\nclass KthLargest {\n    priority_queue<int, vector<int>, greater<int>> que;\n    int k;\npublic:\n    KthLargest(int k, vector<int>& nums) {\n      this->k = k;\n      for(int i = 0; i<nums.size(); i++){\n        if(que.size() >= k){\n          que.push(nums[i]);\n          que.pop();\n        }else{\n          que.push(nums[i]);\n        }\n      }\n    }\n    \n    int add(int val) {\n      if(que.size() == k){\n        que.push(val);\n        que.pop();\n      }else{\n        que.push(val);\n      }\n      return que.size() >= k?que.top():0;\n    }\n};\n```\n\n### [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)\n\n难度中等390\n\n给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。\n\n定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。\n\n请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。\n\n \n\n**示例 1:**\n\n```\n输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n输出: [1,2],[1,4],[1,6]\n解释: 返回序列中的前 3 对数：\n     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n```\n\n**示例 2:**\n\n```\n输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n输出: [1,1],[1,1]\n解释: 返回序列中的前 2 对数：\n     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n```\n\n**示例 3:**\n\n```\n输入: nums1 = [1,2], nums2 = [3], k = 3 \n输出: [1,3],[2,3]\n解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]\n```\n\n#### 解法1\n\n1. 将所有组合 都压入顶堆 取前k个\n2. 组合最后每个k个 小优化到 时间复杂度 k^2logk；\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n      vector<vector<int>> ans;\n      auto cmp = [](const pair<int,int>& a, const pair<int,int>& b)->bool{\n        return a.first + a.second < b.first + b.second;\n      };\n      priority_queue<pair<int, int>,vector<pair<int,int>>, decltype(cmp)> que(cmp);\n      auto sumPair = [](const pair<int, int> &a)->int{\n        return a.first + a.second;\n      };\n      //注意这里可以小优化一下 k个数 则单个不可能超过k\n      for(int i = 0; i<nums1.size() && i<k; i++) {\n        int num1 = nums1[i];\n        for(int j = 0; j<nums2.size() && j<k; j++){\n          int num2 = nums2[j];\n          if(que.size() >= k){\n            if(sumPair(que.top()) > (num1 + num2)){\n              que.pop();\n              que.push(pair<int, int>(num1, num2));\n            }\n          }else que.push(pair<int, int>(num1, num2));\n        }\n      }\n      int i = que.size() - 1;\n      ans.resize(que.size());\n      while(!que.empty()){\n        ans[i--] = vector<int>{que.top().first, que.top().second};\n        que.pop();\n      }\n      return ans;\n    }\n};\n```\n\n#### 解法2 正解\n\n多路归并\n\n同样是用顶堆 但是先压入较少的一组， 然后循环压入第二个数组 每次将堆顶压入ans 然后pop\n\n注意一下lamda捕获的妙用，`只需要传入index 然后按照nums内的关系排序` \n\n时间复杂度 klogk 空间复杂度 k\n\n```c++\nclass Solution {\npublic:\n    bool swaped;\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n      vector<vector<int>> ans;\n      swaped = 0;\n      int n = nums1.size(), m = nums2.size();\n      if(n > m){ //保证nums1 较少 n\n        swap(nums1, nums2);\n        swap(m, n);\n        swaped = 1;\n      }\n      //定义比较规则  lamda捕获 用的太妙了\n      auto cmp = [&](const auto& a, const auto& b)->bool{\n        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n      };\n      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n      for(int i = 0; i<min(n, k); i++)\n        que.push(pair<int, int>(i, 0));\n      while(ans.size() < k && !que.empty()){\n        pair<int, int> temp = que.top();\n        que.pop();\n        //注意 反转的换 需要在ans 反转回来\n        swaped ? ans.push_back({nums2[temp.second], nums1[temp.first]}) : ans.push_back({nums1[temp.first], nums2[temp.second]});\n        if(temp.second + 1 < m)\n          que.push(pair<int, int>(temp.first, temp.second + 1));\n      }\n      return ans;\n    }\n};\n```\n\n### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)\n\n难度困难309\n\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n- void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n- double findMedian() - 返回目前所有元素的中位数。\n\n**示例 1：**\n\n```\n输入：\n[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]\n```\n\n#### 方法\n\n使用两个顶堆 对半分的维护整个数组\n\n例如：1 2 3 4 5\n\n假设维护大顶堆个数多1\n\n小： . \t\t2\t\t3 \t\t 3 4 \t\t4 5\n\n大： 1\t\t1\t\t2 1\t\t2 1\t\t3 2 1\n\n```c++\nclass MedianFinder {\npublic:\n    /** initialize your data structure here. */\n    priority_queue<int> bigQue;\n    priority_queue<int, vector<int>, greater<int>> smallQue;\n    MedianFinder() {\n    }\n    \n    //两个顶堆哪个个数多都没关系 只需要保证size差最大为1\n    void addNum(int num) {\n      if(smallQue.size() == bigQue.size()){\n        smallQue.push(num);\n        int tmp = smallQue.top();\n        smallQue.pop();\n        bigQue.push(tmp); \n      }else{\n        bigQue.push(num);\n        int tmp = bigQue.top();\n        bigQue.pop();\n        smallQue.push(tmp);     \n      }\n    }\n    \n    double findMedian() {\n      if(smallQue.size() == bigQue.size())\n        return (1.0 * (smallQue.top() + bigQue.top())/2);\n      else return smallQue.top();\n    }\n};\n```\n\n### [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n难度中等802\n\n给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。\n请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。\n\n你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。\n\n \n\n**示例 1：**\n\n```\n输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n输出：13\n解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13\n```\n\n#### 解法1 归并\n\n```c++\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n        int n = matrix.size();\n\n        // // 定义pq方法一：用自定义的比较\n        // auto comp = [](Element e1, Element e2) { return e1.val > e2.val; };\n        // priority_queue<Element, vector<Element>, decltype(comp)> pq (comp);    // 用优先队列表示最小堆\n\n        // 定义pq方法二：在 Element 中重载 operator>，然后用内置的std::greater\n        priority_queue<Element, vector<Element>> pq;\n\n        // 初始化：将 matrix 的第一列加入 pq 作为初始的「最小人候选值」列表\n        for (int r = 0; r < n; r++) {\n            Element e (matrix[r][0], r, 0);\n            pq.push(e);\n        }\n\n        // 弹出前 k-1 小的值\n        for (int i = 0; i < k-1; i++) {\n            Element top = pq.top();\n            pq.pop();\n            if (top.y != n - 1) {   // 当前 (top.x, top.y) 的右边还有数字，将它右边的数 push 到优先队列中\n                Element e (matrix[top.x][top.y + 1], top.x, top.y + 1);\n                pq.push(e);\n            }\n        }\n\n        return pq.top().val;\n    }\n\nprivate:\n    struct Element {\n        int val;\n        int x;\n        int y;\n\n        Element(int val, int x, int y) : val(val), x(x), y(y) {}\n\n        // 方法二定义pq 需要重载 operator>\n        bool operator< (const Element &other) const {\n            return this->val > other.val;\n        }\n    };\n};\n```\n\n##### 利用lamda捕获的简单归并写法\n\n```c++\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n      int n = matrix.size();\n      auto cmp = [&](pair<int, int>& a, pair<int, int>& b){\n        return matrix[a.first][a.second] > matrix[b.first][b.second];\n      };\n      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n      for(int i = 0; i < n; i++){\n        que.push(pair<int, int>(i, 0));\n      }\n      // 弹出前 k-1 小的值\n      for(int i = 0; i<k-1; i++){\n        pair<int, int> top = que.top();\n        que.pop(); //每次把最小的拿出来\n        int x = top.first, y = top.second;\n        if(y != n-1){\n          que.push(pair<int, int>(x, y+1));\n        }\n      }\n      return matrix[que.top().first][que.top().second];\n    }\n};\n```\n\n#### 解法2 二分 最优\n\n时间复杂度：O(nlog(r−l))，二分查找进行次数为O(log(r−l))，每次操作时间复杂度为 O(n)。\n\n空间复杂度：O(1)。\n\n```c++\n  bool check(vector<vector<int>> &matrix, int mid, int k, int n) {\n    int i = n - 1;\n    int j = 0;\n    int num = 0;\n    //每次对于「猜测」的答案 mid，计算矩阵中有多少数不大于 mid\n    //如果数量不少于 k，那么说明最终答案 x 不大于 mid；\n    //如果数量少于 k，那么说明最终答案 x 大于 mid。\n    while (i >= 0 && j < n) {\n      if (matrix[i][j] <= mid) {\n        num += i + 1;\n        j++;\n      } else {\n        i--;\n      }\n    }\n    return num >= k;\n  }\n\n  int kthSmallest2(vector<vector<int>> &matrix, int k) {\n    int n = matrix.size();\n    int left = matrix[0][0];\n    int right = matrix[n - 1][n - 1];\n    while (left < right) {\n      int mid = left + ((right - left) >> 1);\n      if (check(matrix, mid, k, n)) { //<=mid的个数>=k 找左边界\n        right = mid;                  //向左上角收缩\n      } else {\n        left = mid + 1; //向右下角扩大\n      }\n    }\n    return left;\n  }\n```","tags":["算法总结"]},{"title":"多路归并","url":"/2022/04/20/duo-lu-gui-bing/","content":"\n## 多路归并\n\n- [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n- [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)\n- [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/comments/)\n- [632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)\n- [719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)\n- [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)\n- [1439. 有序矩阵中的第 k 个最小数组和](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)\n- [1508. 子数组和排序后的区间和](https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/)\n- [1675. 数组的最小偏移量](https://leetcode-cn.com/problems/minimize-deviation-in-array/)\n\n\n\n### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n\n难度中等890收藏分享切换为英文接收动态反馈\n\n给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。\n\n**丑数** 就是只包含质因数 `2`、`3` 和/或 `5` 的正整数。\n\n \n\n**示例 1：**\n\n```\n输入：n = 10\n输出：12\n解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。\n```\n\n**示例 2：**\n\n```\n输入：n = 1\n输出：1\n解释：1 通常被视为丑数。\n```\n\n#### 解法1\n\n使用小顶堆记录每个丑数 使用set进行去重\n\n去重的原因 1 2 3 4 5    2 * 5    5 * 2  不去重的话  会记录两遍\n\n```c++\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> factors = {2, 3, 5};\n        unordered_set<long> sett;\n        priority_queue<long, vector<long>, greater<long>> que;\n        sett.insert(1L);\n        que.push(1L);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            long curr = que.top();\n            que.pop();\n            ans = (int)curr;\n            for (int factor : factors) {\n                long next = curr * factor;\n                if (!sett.count(next)) {\n                    sett.insert(next);\n                    que.push(next);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n相同的思路 可以直接用set\n\n```c++\nclass Solution {\npublic:\n\tint nthUglyNumber(int n) {\n        set<long> sett;  // set 是有序的，且不重复\n        long ans = 1;\n        for (int i = 1; i < n; i++) {\n            sett.insert(ans * 2);\n            sett.insert(ans * 3);\n            sett.insert(ans * 5);\n            ans = *sett.begin();\n            sett.erase(ans);\n        }\n        return (int)ans;\n    }\t\n};\n```\n\n#### 解答2\n\n多路归并\n\n「往后产生的丑数」都是基于「已有丑数」而来（使用「已有丑数」乘上「质因数」2、3、5）。\n\n```c++\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n      vector<int> dp(n+1);\n      dp[1] = 1;\n      //三个数记录*2 *3 *5 在dp内的下标\n      int p2 = 1, p3 = 1, p5 = 1;\n      for(int i = 2; i<=n; i++){\n        dp[i] = min(min(dp[p2]*2, dp[p3]*3), dp[p5]*5);\n        if(dp[i] == dp[p2]*2)\n          p2++;\n        if(dp[i] == dp[p3]*3)\n          p3++;\n        if(dp[i] == dp[p5]*5)\n          p5++;\n      }\n      return dp[n];\n  }\n};\n```\n\n### [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)\n\n难度中等390\n\n给定两个以 **升序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。\n\n定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。\n\n请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。\n\n \n\n**示例 1:**\n\n```\n输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n输出: [1,2],[1,4],[1,6]\n解释: 返回序列中的前 3 对数：\n     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n```\n\n**示例 2:**\n\n```\n输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n输出: [1,1],[1,1]\n解释: 返回序列中的前 2 对数：\n     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n```\n\n#### 解法1\n\n1. 将所有组合 都压入顶堆 取前k个\n2. 组合最后每个k个 小优化到 时间复杂度 `k^2logk`；\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n      vector<vector<int>> ans;\n      auto cmp = [](const pair<int,int>& a, const pair<int,int>& b)->bool{\n        return a.first + a.second < b.first + b.second;\n      };\n      priority_queue<pair<int, int>,vector<pair<int,int>>, decltype(cmp)> que(cmp);\n      auto sumPair = [](const pair<int, int> &a)->int{\n        return a.first + a.second;\n      };\n      //注意这里可以小优化一下 k个数 则单个不可能超过k\n      for(int i = 0; i<nums1.size() && i<k; i++) {\n        int num1 = nums1[i];\n        for(int j = 0; j<nums2.size() && j<k; j++){\n          int num2 = nums2[j];\n          if(que.size() >= k){\n            if(sumPair(que.top()) > (num1 + num2)){\n              que.pop();\n              que.push(pair<int, int>(num1, num2));\n            }\n          }else que.push(pair<int, int>(num1, num2));\n        }\n      }\n      int i = que.size() - 1;\n      ans.resize(que.size());\n      while(!que.empty()){\n        ans[i--] = vector<int>{que.top().first, que.top().second};\n        que.pop();\n      }\n      return ans;\n    }\n};\n```\n\n#### 解法2 正解\n\n多路归并\n\n同样是用顶堆 但是先压入较少的一组， 然后循环压入第二个数组 每次将堆顶压入ans 然后pop\n\n注意一下lamda捕获的妙用，`只需要传入index 然后按照nums内的关系排序` \n\n时间复杂度 klogk 空间复杂度 k\n\n```c++\nclass Solution {\npublic:\n    bool swaped;\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n      vector<vector<int>> ans;\n      swaped = 0;\n      int n = nums1.size(), m = nums2.size();\n      if(n > m){ //保证nums1 较少 n\n        swap(nums1, nums2);\n        swap(m, n);\n        swaped = 1;\n      }\n      //定义比较规则  lamda捕获 用的太妙了\n      auto cmp = [&](const auto& a, const auto& b)->bool{\n        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n      };\n      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n      for(int i = 0; i<min(n, k); i++)\n        que.push(pair<int, int>(i, 0));\n      while(ans.size() < k && !que.empty()){\n        pair<int, int> temp = que.top();\n        que.pop();\n        //注意 反转的换 需要在ans 反转回来\n        swaped ? ans.push_back({nums2[temp.second], nums1[temp.first]}) : ans.push_back({nums1[temp.first], nums2[temp.second]});\n        if(temp.second + 1 < m)\n          que.push(pair<int, int>(temp.first, temp.second + 1));\n      }\n      return ans;\n    }\n};\n```\n\n### [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)\n\n难度困难213英文版讨论区\n\n给你一个按递增顺序排序的数组 `arr` 和一个整数 `k` 。数组 `arr` 由 `1` 和若干 **素数** 组成，且其中所有整数互不相同。\n\n对于每对满足 `0 <= i < j < arr.length` 的 `i` 和 `j` ，可以得到分数 `arr[i] / arr[j]` 。\n\n那么第 `k` 个最小的分数是多少呢? 以长度为 `2` 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。\n\n**示例 1：**\n\n```\n输入：arr = [1,2,3,5], k = 3\n输出：[2,5]\n解释：已构造好的分数,排序后如下所示: \n1/5, 1/3, 2/5, 1/2, 3/5, 2/3\n很明显第三个最小的分数是 2/5\n```\n\n**示例 2：**\n\n```\n输入：arr = [1,7], k = 1\n输出：[1,7]\n```\n\n#### 解法\n\n1. 什么pair On^2 加sort的垃圾解法就不说了，On^2^logn\n\n2. 用归并，类似上一题\n\n   1 2 3 4 5 \n\n   1 2 3 4 5\n\n   压入 1/2 1/3 1/4 1/5 然后 1/5出  2/5入 然后 1/4出 2/4入....\n\n```c++\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\n      vector<int> ans;\n      auto cmp = [&](const pair<int, int> a, const pair<int ,int> b){\n        return (double)nums[a.first] / nums[a.second] >  (double)nums[b.first] / nums[b.second];\n      };\n      priority_queue<pair<int, int> ,vector<pair<int, int>>, decltype(cmp)> que(cmp);\n      for(int i = 1; i<nums.size(); i++){\n        que.push(pair<int, int>(0, i));\n      }\n      // 为社么是 k-1 因为pop调k-1g个最下 就是第k个最小了\n      // 相同的怎么办 1怎么办  \n      // 1太大 不可能到1 看题目\n      for (int i = 0; i < k - 1; i++) {\n          auto p = que.top();\n          que.pop();\n          que.push(pair<int, int>(p.first + 1, p.second));\n      }\n\n      ans.push_back(nums[que.top().first]);\n      ans.push_back(nums[que.top().second]);\n\n      return ans;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"bat实现hexo一键部署","url":"/2022/04/19/bat-shi-xian-hexo-yi-jian-bu-shu/","content":"\n#### 起因\n\n个人有每天凌晨更新所有博客的习惯，流程繁琐如下\n\n1. 从多个文件夹中拷贝所有markdown到指定的文件夹\n2. 该目录下运行cmd\n3. 执行hexo g生成html 然后漫长的等待 执行完成后 hexo d部署到远端 然后又是漫长的等待\n\n不堪折磨，粗略学了下脚本语言，简单实现了博客一键更新部署的功能\n\n#### 实现\n\n```bash\n@echo off\n%color 4A%\necho 自动远端部署开始。。。\n%注意有中文路径 则必须使用ANSI编码 && 表示前面执行成功 后面再执行%\ncopy C:\\Users\\qianxunslimg\\Desktop\\myMD\\算法\\*.md D:\\MyBlog\\source\\_posts\ncopy C:\\Users\\qianxunslimg\\Desktop\\myMD\\面试\\*.md D:\\MyBlog\\source\\_posts\ncopy C:\\Users\\qianxunslimg\\Desktop\\myMD\\开发随笔\\*.md D:\\MyBlog\\source\\_posts\necho 拷贝工作完成。。。\"\ncd d: \ncd D:\\MyBlog\nhexo g && hexo d && echo 自动部署完成。。。 && color 20 && pause > nul\n```\n\n","tags":["开发随笔"]},{"title":"哈希 自定义key","url":"/2022/04/18/ha-xi-zi-ding-yi-key/","content":"\n\n\n哈希 自定义key\n\n\n\n1. 自定义等于判断函数\n\n   1. 结构体中重载==\n   2. 仿函数 struct内重载()\n\n2. 自定义哈希函数\n\n   根据向量的每一个维度的不同，通过一定的计算，得到一个值，注意类型要用`size_t`来返回\n\n```c++\nstruct Point {\n  int x;\n  int y;\n  Point() : x(0), y(0){};\n  Point(int _x, int _y) : x(_x), y(_y){};\n  //1. 重载==\n  bool operator==(const Point &other) const {\n    return this->x == other.x && this->y == other.y;\n  }\n};\n\n//2. 仿函数重载()\nstruct MyEqualFunc {\n  bool operator()(const Point &v1, const Point &v2) const {\n    return (v1.x == v2.x && v1.y == v2.y);\n  }\n};\n\nstruct MyHashFunc {\n  size_t operator()(const Point &p) const { return hash<int>()(p.x & p.y); }\n};\n\n\nint main() {\n  //1.\n  unordered_set<Point, MyHashFunc, MyEqualFunc> set1;\n  //2. \n  unordered_set<Point, MyHashFunc> set2;\n  \n  set1.insert(Point(0, 1));\n  set1.insert(Point(0, 1));\n  set1.insert(Point(0, 1));\n  set1.insert(Point(2, 1));\n  set1.insert(Point(0, 1));\n  set1.insert(Point(1, 1));\n  set1.insert(Point(1, 2));\n\n  return 0;\n```\n\n\n\n","tags":["开发随笔"]},{"title":"bfs","url":"/2022/04/18/bfs/","content":"\n## bfs\n\n### 介绍\n\n之前做题一直用的都是dfs，bfs只在层序遍历时用到过 感觉需要整理下bfs\n\n#### dfs是深度优先，一直往深层遍历 思路和回溯有很大的相似\n\n#### bfs是广度优先，在一个节点先遍历周围，遍历完自己这层后，在子节点重复这个步骤\n\n二叉树已经很熟悉了，就是前中后三种遍历和层序遍历的区别\n\n二维矩阵 或者说 图 的bfs从岛屿问题感受下\n\n### [引入 200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=200)[思路](https://leetcode-cn.com/problems/number-of-islands/#)\n\n难度中等1672\n\n给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n\n岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n\n此外，你可以假设该网格的四条边均被水包围。\n\n \n\n**示例 1：**\n\n```\n输入：grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n输出：1\n```\n\ndfs很熟悉了 类似的岛屿问题之前我都是用dfs做的 直接给出代码\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n      int land_num = 0;\n      for(int i = 0; i<grid.size(); i++){\n        for(int j = 0; j<grid[0].size(); j++){\n          if(grid[i][j] == '1'){\n            dfs(grid, i, j);\n            land_num++;\n          }\n        }\n      }\n      return land_num;\n    }\n\n    void dfs(vector<vector<char>>& grid, int i, int j){\n      if(i<0||i>=grid.size()||j<0||j>=grid[0].size()||grid[i][j]!='1') return;\n      grid[i][j] = '2';\n      dfs(grid, i+1,j);\n      dfs(grid, i,j+1);\n      dfs(grid, i-1,j);\n      dfs(grid, i,j-1);\n    }\n};\n```\n\n#### 下面看一下bfs的写法\n\n- 主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。\n- bfs 方法：\n  - 借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：\n    - 若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；\n    - 若不是则跳过此节点；\n  - 循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿\n\n```c++\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n      int land_num = 0;\n      for(int i = 0; i<grid.size(); i++){\n        for(int j = 0; j<grid[0].size(); j++){\n          if(grid[i][j] == '1'){\n            bfs(grid, i, j);\n            land_num++;\n          }\n        }\n      }\n      return land_num;\n    }\n\n    void bfs(vector<vector<char>>& grid, int i, int j){\n      queue<pair<int, int>> que;\n      que.push(pair<int, int>(i, j));\n      while(!que.empty()){\n        pair<int, int> node = que.front();\n        que.pop();\n        i = node.first;\n        j = node.second;\n        if(i<0||i>=grid.size()||j<0||j>=grid[0].size()||grid[i][j]!='1')\n          continue;\n        grid[i][j] = '0';\n        que.push(pair<int, int>(i + 1, j));\n        que.push(pair<int, int>(i - 1, j));\n        que.push(pair<int, int>(i, j + 1));\n        que.push(pair<int, int>(i, j - 1));\n      }\n    }\n};\n```\n\n### 总结\n\n#### 从上题可以看出， bfs是接住了一个<u>队列 和 while循环</u> 类似二叉树的程序遍历 对四周所以接触的节点进行一层一层的遍历\n\n#### 最短路径属于dp问题 可以考虑使用bfs\n\n### [对称飞行器](https://www.nowcoder.com/questionTerminal/ef231526f822489d879949226b4bed65?answerType=1&f=discussion)\n\n![image-20220418163802022](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418163802022.png)\n\n链接：https://www.nowcoder.com/questionTerminal/ef231526f822489d879949226b4bed65?answerType=1&f=discussion\n来源：牛客网\n\n\n\n##### **输入描述:**\n\n```\n第一行两个空格分隔的正整数 n,m\\mathit n,mn,m ，分别代表迷宫的行数和列数。\n接下来 n\\mathit nn 行 每行一个长度为 m\\mathit mm 的字符串来描述这个迷宫。\n其中\n. 代表通路。\n 代表障碍。\nS 代表起点。\nE 代表终点。\n保证只有一个 S 和 一个 E 。\n```\n\n##### **输出描述:**\n\n```\n仅一行一个整数表示从起点最小花费多少时间单位到达终点。\n如果无法到达终点，输出 -1\n```\n\n#### 示例1\n\n##### 输入\n\n```\n4 4\n#S..\nE#..\n#...\n....\n```\n\n##### 输出\n\n```\n4\n```\n\n##### 说明\n\n```\n一种可行的路径是用对称飞行器到达 (4,3) 再向上走一步，再向右走一步，然后使用一次对称飞行器到达终点。\n```\n\n#### 思路\n\n1. 最短路径属于dp问题 优先考虑使用bfs dfs复杂会更高 代码也复杂\n2. \n\n#### 代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct NodeAli4 {\n  int x;\n  int y;\n  int lastFly;\n  int nowStep;\n};\n\nint dirX[4] = {0, 0, 1, -1};\nint dirY[4] = {1, -1, 0, 0};\n\nbool checkAli4(NodeAli4 &node, int n, int m, vector<string> &all,\n               vector<vector<int>> &visited) {\n  return node.x >= 0 && node.x < n && node.y >= 0 && node.y < m &&\n         visited[node.x][node.y] == 0 && all[node.x][node.y] != '#';\n}\n\nint bfsAli4(NodeAli4 &node, vector<string> &all, vector<vector<int>> &visited,\n            int n, int m) {\n  queue<NodeAli4> que;\n  que.push(node);\n  while (!que.empty()) {\n    NodeAli4 tempNode = que.front();\n    que.pop();\n    int x = tempNode.x;\n    int y = tempNode.y;\n    if (all[x][y] == 'E')\n      return tempNode.nowStep;\n    //相当于五叉树的层序\n    for (int i = 0; i < 5; i++) {\n      NodeAli4 nextNode;\n      if (i == 4) {\n        if (tempNode.lastFly > 0) {\n          nextNode.x = n - 1 - x;\n          nextNode.y = m - 1 - y;\n          nextNode.lastFly = tempNode.lastFly - 1;\n          nextNode.nowStep = tempNode.nowStep + 1;\n        }\n      } else {\n        nextNode.x = x + dirX[i];\n        nextNode.y = y + dirY[i];\n        nextNode.lastFly = tempNode.lastFly;\n        nextNode.nowStep = tempNode.nowStep + 1;\n      }\n\n      if (checkAli4(nextNode, n, m, all, visited)) {\n        que.push(nextNode);\n        visited[nextNode.x][nextNode.y] = 1;\n      }\n    }\n  }\n  return -1;\n}\n\nvoid ali4() {\n  int n, m;\n  cin >> n >> m;\n  string temp;\n  vector<string> all(n);\n  vector<vector<int>> visited(n, vector<int>(m));\n  for (int i = 0; i < n; i++) {\n    cin >> all[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (all[i][j] == 'S') {\n        visited[i][j] = 1;\n        NodeAli4 node = {i, j, 5, 0};\n        cout << bfsAli4(node, all, visited, n, m);\n        return;\n      }\n    }\n  }\n}\n\nint main() {\n  ali4();\n  return 0;\n}\n```\n\n### [剑指 Offer II 107. 矩阵中的距离](https://leetcode.cn/problems/2bCMpM/)\n\n难度中等22收藏分享切换为英文接收动态反馈\n\n给定一个由 `0` 和 `1` 组成的矩阵 `mat` ，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。\n\n两个相邻元素间的距离为 `1` 。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626667201-NCWmuP-image.png)\n\n```\n输入：mat = [[0,0,0],[0,1,0],[0,0,0]]\n输出：[[0,0,0],[0,1,0],[0,0,0]]\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626667205-xFxIeK-image.png)\n\n```\n输入：mat = [[0,0,0],[0,1,0],[1,1,1]]\n输出：[[0,0,0],[0,1,0],[1,2,1]]\n```\n\n\n\n#### 解法 bfs\n\n将所有0的位置压入队列，然后进行bfs\n\n按下图走，四周有1是 1变0 坐标入队列 ans位置 = ans pre位置++\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220509155601268.png\" alt=\"image-20220509155601268\" style=\"zoom:50%;\" />\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<vector<int>> ans(n, vector<int>(m, 0));\n        queue<pair<int, int>> que;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!mat[i][j]) {\n                    que.push({i, j});\n                }\n            }\n        }\n        while (!que.empty()) {\n            auto f = que.front();\n            que.pop();\n            for (auto& d: dirs) {\n                int x = f.first + d[0], y = f.second + d[1];\n                //周围为1的方向时\n                if (x >= 0 && x < n && y >= 0 && y < m && mat[x][y]) {\n                    ans[x][y] = ans[f.first][f.second] + 1;\n                    mat[x][y] = 0;\n                    que.push({x, y});\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n#### 解法 按1暴力bfs\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> dir{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n      vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size()));\n      vector<vector<bool>> used;\n      for(int i = 0; i<mat.size(); i++){\n        for(int j = 0; j<mat[0].size(); j++){\n          if(mat[i][j] == 1){\n            int depth = 0;\n            used.clear(); //注意 重置内部元素的话 必须先clear\n            // size相等的话 并不会执行resize内部的构造\n            used.resize(mat.size(), vector<bool>(mat[0].size(), 0));\n            bfs(mat, i, j, depth, used);\n            ans[i][j] = depth;\n          }\n        }\n      }\n      return ans;\n    }\n\n    void bfs(vector<vector<int>>& mat, int x, int y, int& depth, vector<vector<bool>>& used){\n      queue<pair<int, int>> que;\n      que.push(pair<int, int>(x, y));\n      used[x][y] = 1;\n      while(!que.empty()){\n        int n = que.size();\n        depth++;\n        while(n--){\n            pair<int, int> node = que.front();\n            que.pop();\n            int i = node.first;\n            int j = node.second;\n            for(int ii = 0; ii<4; ii++){\n                int newI = i + dir[ii][0];\n                int newJ = j + dir[ii][1];\n                if(newI<0||newI>=mat.size()||newJ<0||newJ>=mat[0].size() || used[newI][newJ])\n                    continue;\n                if(mat[newI][newJ] == 0)        \n                    return;\n                que.push(pair<int, int>(newI, newJ));\n                used[newI][newJ] = 1;\n            }\n        }\n      }\n    }\n};\n```\n\n\n\n### [剑指 Offer II 109. 开密码锁](https://leetcode.cn/problems/zlDJc7/)\n\n难度中等15收藏分享切换为英文接收动态反馈\n\n一个密码锁由 4 个环形拨轮组成，每个拨轮都有 10 个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。\n\n锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。\n\n列表 `deadends` 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n\n字符串 `target` 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 `-1` 。\n\n \n\n**示例 1:**\n\n```\n输入：deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n输出：6\n解释：\n可能的移动序列为 \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\"。\n注意 \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" 这样的序列是不能解锁的，因为当拨动到 \"0102\" 时这个锁就会被锁定。\n```\n\n**示例 2:**\n\n```\n输入: deadends = [\"8888\"], target = \"0009\"\n输出：1\n解释：\n把最后一位反向旋转一次即可 \"0000\" -> \"0009\"。\n```\n\n**示例 3:**\n\n```\n输入: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n输出：-1\n解释：\n无法旋转到目标数字且不被锁定。\n```\n\n#### 解法 bfs求最优路径\n\n枚举每次旋转的所有可能情况\n\n符合要求的压入栈中\n\n一轮一轮的波 先把所有位置都播一边 次数 = 0， 压所有情况入队列\n\n然后 拨动所有次数 = 1的 压所有情况到队列之后\n\n依次 直到最后\n\n```c++\nclass Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n      unordered_set<string> sett(deadends.begin(), deadends.end());\n      if(target == \"0000\" ) return 0;\n      if(sett.count(target) || sett.count(\"0000\")) return -1;\n\n      auto num_prev = [](char x)->char{\n        return (x == '0' ? '9' : x-1);\n      };\n      auto num_next = [](char x)->char{\n        return (x == '9' ? '0' : x+1);\n      };\n\n      //枚举status通过一次旋转得到的数字\n      auto get = [&](string& status)->vector<string>{\n        vector<string> res;\n        for(int i = 0; i<4; i++){\n          char num = status[i];\n          status[i] = num_prev(num);\n          res.push_back(status);\n          status[i] = num_next(num);\n          res.push_back(status);\n          status[i] = num;\n        }\n        return res;\n      };\n\n      queue<pair<string, int>> que;\n      que.push(pair<string, int>(\"0000\", 0));\n      unordered_set<string> seen = {\"0000\"};\n      while(!que.empty()){\n        auto [status, step] = que.front();\n        que.pop();\n        for(auto& next_status : get(status)){\n          if(!seen.count(next_status) && !sett.count(next_status)){\n            if(next_status == target) return step+1;\n            que.push(pair<string, int>(next_status, step+1));\n            seen.insert(next_status);\n          }\n        }\n      }\n      return -1;\n    }\n};\n```\n\n起始可以写成常规的bfs 记录好每层的节点数\n\n```c++\n      queue<string> que;\n      que.push(\"0000\");\n      unordered_set<string> seen = {\"0000\"};\n      int ans = 0;\n      while(!que.empty()){\n        ans++;\n        int n = que.size();\n        while(n--){\n          string status= que.front();\n          que.pop();\n          for(auto& next_status : get(status)){\n            if(!seen.count(next_status) && !sett.count(next_status)){\n              if(next_status == target) return ans;\n              que.push(next_status);\n              seen.insert(next_status);\n            }\n          }\n        }\n      }\n      return -1;\n```\n\n### [剑指 Offer II 108. 单词演变](https://leetcode.cn/problems/om3reC/)\n\n难度困难11\n\n在字典（单词列表） `wordList` 中，从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列：\n\n- 序列中第一个单词是 `beginWord` 。\n- 序列中最后一个单词是 `endWord` 。\n- 每次转换只能改变一个字母。\n- 转换过程中的中间单词必须是字典 `wordList` 中的单词。\n\n给定两个长度相同但内容不同的单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，找到从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目** 。如果不存在这样的转换序列，返回 0。\n\n \n\n**示例 1：**\n\n```\n输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n输出：5\n解释：一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。\n```\n\n#### bfs 密码锁\n\n```c++\nclass Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n      //return 0;\n\n      unordered_set<string> sett(wordList.begin(), wordList.end());\n      auto get = [&](string str)->vector<string>{\n        vector<string> res;\n        for(int i = 0; i<str.size(); i++){\n          string temp = str;\n          for(int j = 0; j<26; j++){\n            char ch = 'a' + j;\n            temp[i] = ch;\n            if(temp != str && sett.count(temp))\n              res.push_back(temp);\n          }\n        }\n        return res;\n      };\n      if(!sett.count(endWord)) return 0;\n      unordered_set<string> seen;\n      queue<string> que;\n      que.push(beginWord);\n      seen.insert(beginWord);\n      int ans = 1;  //转换序列的长度 所以初值是1\n      while(!que.empty()){\n        int n = que.size();\n        ans++;\n        while(n--){\n          string str = que.front();\n          que.pop();\n          for(string s: get(str)){\n            // cout<<s<<\" \";\n            if(seen.count(s))\n              continue;\n            if(s == endWord) return ans;\n            que.push(s);\n            seen.insert(s);\n          }\n        }\n      }\n      return 0;\n    }\n};\n```\n\n### [863. `二叉树中所有距离为 K 的结点`](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)\n\n[思路](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/#)\n\n难度中等536\n\n给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `k` 。\n\n返回到目标结点 `target` 距离为 `k` 的所有结点的值的列表。 答案可以以 **任何顺序** 返回。\n\n**示例 1：**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/sketch0.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\n输出：[7,4,1]\n解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n```\n\n#### 思考\n\n构建parent 是怎么跨过根节点的？\n\n> 起始仔细想想并不需要通过根节点的parent跨过，而是通过左右子树节点跨过，在根节点上 就是一个二叉树而非三叉\n\n#### 解法\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, TreeNode*> parent;\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\n        if(root == nullptr) return vector<int>{};\n        dfs(root, nullptr);\n        vector<int> ans;\n        queue<TreeNode*> que;\n        unordered_set<TreeNode*> visited;\n        visited.insert(target);\n        que.push(target);\n        int diss = 0;\n        while(!que.empty()){\n          int n = que.size(); \n          while(n--){\n            TreeNode* node = que.front();\n            que.pop();\n            if(diss == k){\n              ans.push_back(node->val);\n              continue;\n            }\n            TreeNode* par = parent[node->val];\n            if(par && !visited.count(par)){\n              que.push(par);\n              visited.insert(par);\n            }\n            if(node->left && !visited.count(node->left)) {\n              que.push(node->left);\n              visited.insert(node->left);\n            }\n            if(node->right && !visited.count(node->right)) {\n              que.push(node->right);\n              visited.insert(node->right);\n            }\n          }\n          diss++;\n        }\n        return ans;\n    }\n    void dfs(TreeNode* node, TreeNode* parentNode){\n      if(node == nullptr) return;\n      parent[node->val] = parentNode;\n      dfs(node->left, node);\n      dfs(node->right, node);\n    }\n};\n```\n\n## 记忆化dfs\n\n### [剑指 Offer II 112. 最长递增路径](https://leetcode.cn/problems/fpTFWP/)\n\n难度困难17\n\n给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。\n\n对于每个单元格，你可以往上，下，左，右四个方向移动。 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/grid1.jpg)\n\n```\n输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]\n输出：4 \n解释：最长递增路径为 [1, 2, 6, 9]。\n```\n\n解法 记忆化dfs\n\n1. 普通dfs过于暴力 无法通过\n2. 学习以下带返回值的dfs写法吧\n3. 记忆化dfs就是在dfs开始的时候 先查找是否存在 不存在再继续搜索 最后返回时对记忆化赋值\n\n```c++\nclass Solution {\npublic:\n    const int dxy[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        int m=matrix.size();\n        int n=matrix[0].size();\n        int maxstep=0;\n        vector<vector<int>> length(m,vector<int>(n));\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                int step=dfs(matrix,i,j,length);\n                maxstep=max(step,maxstep);\n            }\n        }\n        return maxstep;\n    }\n    int dfs(vector<vector<int>>& matrix,int i,int j,vector<vector<int>>& length){\n        if(length[i][j]!=0){\n            return length[i][j];\n        }\n        int step=1;\n        for(int k=0;k<4;k++){\n            int dx=i+dxy[k][0];\n            int dy=j+dxy[k][1];\n            if(dx>=0&&dx<matrix.size()&&dy>=0&&dy<matrix[0].size()){\n                if(matrix[dx][dy]>matrix[i][j]){\n                    int path=dfs(matrix,dx,dy,length);\n                    step=max(step,path+1);\n                }\n            }\n        }\n        length[i][j]=step;\n        return step;;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"面经题目们","url":"/2022/04/18/mian-jing-ti-mu-men/","content":"\n2022.5.10 联发科北京嵌入式软件\n\n1. 链表和数组 什么时候用链表\n2. 有没有手写过一些数据结构和操作 说一下怎么实现\n3. 程序装载到内存的内存分布 \n4. linux内存空间 怎样寻址 一级页表 二级页表页表的大小分别是怎么算的\n5. 进程和线程\n6. 说一下inline内联 以及是怎么实现运行速度的优化的\n7. union了解吗\n8. 你的软件结构是什么 哪几个部分\n\n2022.5.19 青岛鼎信\n\n1. 指针和引用的区别，对cpu来说两个是一样的吗\n2. 什么是内存泄漏 内存泄漏怎么检测\n3. 智能指针了解吗 相互引用怎么办 为什么weakptr可以解\n4. 线程的锁有哪几种\n5. TCP和UDP的区别\n6. vector和list的区别\n7. select和epoll的区别 为什么select有一个参数1024，为什么是1024\n8. 程序在内存中的分布\n9. c++的动态多态是什么 怎么实现的 设计一个多态\n10. c++的静态多态是什么 返回值类型不同呢\n11. 从项目中学到了什么\n12. Qt::concurrent是线程安全的吗\n\n# 基础知识\n\n## 分析下面代码可能会有什么风险？ \n\n```c++\nvoid test1() { \n    char string[10]; \n    char* str1 = \"01234567891\"; \n    strcpy( string, str1 ); \n} \n```\n\n1. 严格区分的话，string是`保留字`，而不是关键字，理论上可以作变量名或数组名，且`能`编译通过，但<u>一个好的编程习惯是不建议这样做的</u> \n\n2. “01234567891”是“const char *”类型，不可赋值给“char *”类型，故应改为const char * str = \"01234567891\" \n\n   > <u>但是在使用过程中是没有问题 不会报错的啊 这样写 其实就是const char*</u>\n\n3. \"01234567891\"大小为12个字节（加上结束符），但string数组只有10个字节空间，在调用strcpy函数时发生越界，有安全隐患\n\n#### 知识点\n\n```c++\n//考虑内存᯿叠的字符串拷⻉函数 优化的点\nchar *strcpy(char *dest, char *src) {\n  char *ret = dest;\n  assert(dest != NULL);\n  assert(src != NULL);\n  memmove(dest, src, strlen(src) + 1);\n  return ret;\n}\n```\n\n## 分析下面代码有什么问题？\n\n```c++\nvoid test2() { \n    char string[10], str1[10]; \n    int i; \n    for(i=0; i<10; i++) { \n        str1  = 'a'; \n    } \n    strcpy( string, str1 ); \n} \n```\n\n1. 首先，代码根本不能通过编译。因为数组名str1为 `char *const类型的右值类型`，根本不能赋值。\n\n2. 再者，即使想对数组的第一个元素赋值，也要使用 *str1 = 'a'; \n\n3. 其次，对字符数组赋值后，使用库函数`strcpy`进行拷贝操作，strcpy会从源地址一直往后拷贝，直到遇到`'\\0'`为止。所以拷贝的长度是不定的。`如果一直没有遇到'\\0'导致越界访问非法内存，程序就崩了`。\n\n完美修改方案为：\n\n```c++\nvoid test2(){\n\tchar string[10], str1[10];\n\tint i;\n\tfor(i=0; i<9; i++){\n\t\tstr1[i]  = 'a';\n\t}\n\tstr1[9] = '\\0';\n\tstrcpy( string, str1 );\n}\n```\n\n#### 知识点\n\n```c++\n//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。\nchar *strcat(char *dest, const char *src) {\n\t// 1. 将⽬的字符串的起始位置先保存，最后要返回它\n\t// 2. 先找到dest的结束位置,再把src拷⻉到dest中，记得在最后要加上'\\0'\n\tchar *ret = dest;\n\tassert(dest != NULL);\n\tassert(src != NULL);\n\twhile (*dest != '\\0')\n\t\tdest++;\n\twhile (*src != '\\0')\n\t\t*(dest++) = *(src++);\n\t*dest = '\\0';\n\treturn ret;\n}\n```\n\n## 指出下面代码有什么问题？\n\n```c++\nvoid test3(char* str1) { \n    if(str1 == NULL){\n        return;\n    }\n\n    char string[10]; \n    if( strlen( str1 ) <= 10 ) { \n        strcpy( string, str1 ); \n    } \n} \n```\n\n`if(strlen(str1) <= 10)`应改为`if(strlen(str1) < 10)`，因为strlen的结果未统计’\\0’所占用的1个字节。 \n\n## 写出完整版的strcpy函数\n\n```c++\nchar *strcpy(char *dst, const char *src){\n    assert((dst != NULL) && (src !=NULL));//加断言，指针为空时报错\n    const char *address = dst; //保存dst地址，因为下面*dst++会进行指针的移动\n    while((*dst++ = *src++) != '\\0');//字符拷贝\n    return address;//返回输出地址，以便生成链式表达式\n}\n\n//把 src 所指向的字符串复制到 dest，注意：dest定义的空间应该⽐src⼤。\nchar *strcpy(char *dest, const char *src) {\n\tchar *ret = dest;\n\tassert(dest != NULL); //优化点1：检查输⼊参数\n\tassert(src != NULL);\n\twhile (*src != '\\0')\n\t\t*(dest++) = *(src++);\n\t*dest = '\\0'; //优化点2：⼿动地将最后的'\\0'补上\n\treturn ret;\n}\n```\n\n## 检查下面代码有什么问题？\n\n```c++\nvoid GetMemory( char *p ) { \n    p = (char *) malloc( 100 ); \n} \n\nvoid Test( void )  { \n    char *str = NULL; \n    GetMemory( str );  \n    strcpy( str, \"hello world\" ); \n    printf( str ); \n} \n```\n\n1. 只是传值而没有传地址\n\n   ```c++\n   //传值调用\n   void GetMemory( char **p ){\n       *p = (char *) malloc( 100 );\n   }\n   \n   GetMemory( &str );\n   ```\n\n   或者传引用进去\n\n   ```c++\n   //引用调用\n   void GetMemory_1(char *&p){\n       p = (char *) malloc (100);\n   }\n   \n   GetMemory_1( str );\n   ```\n\n2. 没有释放malloc的内存 应该`free(str); str = NULL;`\n\n3. printf这里应该改为 cout<<str<<endl;  （`然而运行起来并没有什么问题）`\n\n   > printf(\"%c\\n\",*str);//输出首字符\n   >\n   > printf(\"%s\\n\",str);//输出整串字符\n   >\n   > printf(\"%p\\n\",str);//输出[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)首字符地址\n   >\n   > printf(\"%p\\n\",&str);//输出指针str的地址\n\n### `下面代码会出现什么问题？`\n\n```c++\nchar *GetMemory( void ) {  \n    char p[] = \"hello world\";  \n    return p;  \n} \n\nvoid Test( void ) {  \n    char *str = NULL;  \n    str = GetMemory();  \n    printf( str );  \n} \n```\n\n1. p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。 \n\n   > char p[]=\"hello world\";相当于char p[12]，strcpy(p,\" hello world\" ).\n   >\n   > p是一个数组名，属于局部变量，存储在栈中， \" hello world\" 存储在文字存储区，数组p中存储的是 \" hello world\" 的一个副本，当函数结束，p被回收，副本也消失了(确切的说`p指向的栈存储区被取消标记，可能随时被系统修改`)，而函数返回的p指向的内容也变得不确定，文字存储区的 \" hello world\" 未改变。\n   >\n   > 可以这样修改: \n   >\n   > 1. ? <u>char* p= \" hello world\" ; return p; 这里p直接指向文字存储区的 \" hello world\" ，函数按值返回p存储的地址，所以有效。</u>\n   > 2. static char p[]= \" hello world\" ; return p; static指出数组p为静态数组，函数结束也不会释放，所以有效.\n\n2. 函数可以返回普通局部变量，但是不能返回局部变量的指针（确切说是 栈内存的地址），如果想返回指针，可以通过传参的方式，让这个参数做输出型参数。 int a = 1; return a; 是可以的\n\n   > 一般来说，函数是可以返回局部变量的，但不能返回局部变量的地址，包括指向局部变量的指针也是不能返回的。如果真要返回，必需定义为static，存放在静态数据区，这样是可以返回的。当定义 int a=1,return a;时，此时返回的值，会有一个临时变量产生，类似调用拷贝构造函数，把a的值传递到临时变量，同时a的内存被释放。\n   > 接下来我们考虑下面情况： const *char p=\"hello world\"; return p; 此时是可以的，因为这是一个字符串常量，存储在文字常量区，也可以叫只读数据段，在只读数据段存储的数据的生命期一直到main退出的。\n\n## 下面代码会出现什么问题？\n\n```c++\nvoid GetMemory( char **p, int num ) { \n    *p = (char *) malloc( num ); \n} \n\nvoid Test( void ) { \n    char *str = NULL; \n    GetMemory( &str, 100 ); \n    strcpy( str, \"hello\" );  \n    printf( str );  \n} \n```\n\n\n\n1. 传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句, 后未判断内存是否申请成功，应加上：以及未考虑nums<=0的情况\n\n```c++\nvoid GetMemory(char **p, int num){\n    if(num<=0)\n        printf(\"申请的内存空间要大于零!\\n\");\n    *p = (char*)malloc(num);\n    if(*p==NULL)\n        printf(\"申请内存失败!\\n\");\n}\n```\n\n2. 未释放堆内存 动态分配的内存在程序结束之前没有释放，应该调用free, 把malloc生成的内存释放掉 str = NULL;\n\n3. printf(str) 改为 printf(\"%s\",str),否则可使用格式化 字符串攻击\n\n## 下面代码会出现什么问题？\n\n```c++\nvoid Test( void ) { \n    char *str = (char *) malloc( 100 ); \n    strcpy( str, \"hello\" ); \n    free( str );  \n    ... //省略的其它语句 \n} \n```\n\n1. 在执行 `char *str = (char *) malloc(100);` 后未进行内存是否申请成功的判断；\n\n2. 另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上： str = NULL;  试题6的Test函数中也未对malloc的内存进行释放。 \n\n## 看看下面的一段程序有什么错误?\n\n```c++\nswap( int* p1,int* p2 ) { \n    int *p; \n    *p = *p1; \n    *p1 = *p2; \n    *p2 = *p; \n} \n```\n\n1. 需要一个返回值void \n\n2. 在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：\n\n   ```c++\n   void swap( int* p1,int* p2 ) { \n       int p; \n       p = *p1; \n       *p1 = *p2; \n       *p2 = p; \n   } \n   //或者\n   void swap( int* p1,int* p2 ) { \n       int *p = new int(0); \n       *p = *p1; \n       *p1 = *p2; \n       *p2 = p;\n       delete p;\n   } \n   ```\n\n## 分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）\n\n```c++\nif(!a)\nif(0 == a) //避免少些等号 出错\nconst float eps = 0.00001;\nif((x>=-eps) && (x<=eps))\nif(a == nullptr)\n```\n\n### `以下为Windows NT下的32位C++程序，请计算sizeof的值`\n\n```c++\nvoid Func ( char str[100] ) { \n    sizeof( str ) = ? \n} \nvoid *p = malloc( 100 ); \nsizeof ( p ) = ? \n```\n\nsizeof( str ) = 4 \nsizeof ( p ) = 4 \n`【剖析】` \nFunc ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。 \n数组名的本质如下： \n\n1. 数组名指代一种数据结构，这种数据结构就是数组； \n   例如： \n\n```c++\nchar str[10]; \ncout ＜＜ sizeof(str) ＜＜ endl; \n```\n\n​\t\t`输出结果为10，str指代数据结构char[10]。` \n\n2. 数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改； \n   char str[10];  \n   str++; //编译出错，提示str不是左值 \n\n3. 数组名作为函数形参时，沦为普通指针。 \n\nWindows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。 \n\n> 在编译时是将char str[100]按指针变量处理的，相当于将函数f的首部写成f(int *str);\n>\n> 说明：C语言调用函数时采用“值传递”方式，当用变量名作为函数参数时传递的是变量的值，当                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n>\n> 用数组名作为函数参数时，由于数组名代表的是数组首元素地址，因此传递的是地址，所以要求形参为指针变量。\n>\n> 所以说：\n>\n> `void fun(int num[]) 和 void fun(int* num) 使用上是完全一样的`\n\n## 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？ least = MIN(*p++, b); \n\n解答： \n\n```c++\n#define MIN(A,B) ((A) <= (B) ? (A) : (B))  \n```\n\nMIN(*p++, b)会产生宏的副作用 \n剖析： \n这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。 \n程序员对宏定义的使用要非常小心，特别要注意两个问题： \n\n1. ==<u>谨慎地将宏定义中的“`参数`”和`整个宏`用用括弧括起来</u>==。所以，严格地讲，下述解答： \n\n   ```c++\n   #define MIN(A,B) (A) <= (B) ? (A) : (B) \n   #define MIN(A,B) (A <= B ? A : B ) \n   ```\n\n   <u>都应判0分；</u> \n\n2. 防止宏的副作用。 \n   宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是： \n\n   ```c++\n   ((*p++) <= (b) ? (*p++) : (b))  \n   ```\n\n   这个表达式会产生副作用，指针p会作`2次++`自增操作。 \n\n   除此之外，另一个应该判0分的解答是： \n\n   ```c++\n   #define MIN(A,B) ((A) <= (B) ? (A) : (B)); \n   ```\n\n   这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清，只能被无情地判0分并被面试官淘汰。\n\n## 为什么标准头文件都有类似以下的结构？\n\n```c++\n#ifndef __INCvxWorksh \n#define __INCvxWorksh  \n#ifdef __cplusplus \nextern \"C\" { \n#endif  \n/*...*/  \n#ifdef __cplusplus \n} \n#endif  \n#endif /* __INCvxWorksh */ \n```\n\n1. 头文件中的编译宏\n\n   ```c++\n   #ifndef　__INCvxWorksh \n   #define　__INCvxWorksh \n   #endif  \n   ```\n\n   的作用是`防止被重复引用`。\n\n2. 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为：\n   `void foo(int x, int y);`\n   该函数被C编译器编译后在symbol库中的名字为 `_foo`，而C++编译器则会产生像 `_foo _int _int`之类的名字。 _foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，<u>C++就是靠这种机制来实现函数重载的</u>。\n   为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern \"C\"来解决名字匹配问题，函数声明前加上extern \"C\"后，则编译器就会按照C语言的方式将该函数编译为 _foo，这样c++中调用c的函数了。\n\n## 编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefg” \n\n函数头是这样的：\n//pStr是指向以'\\0'结尾的字符串的指针\n//steps是要求移动的n\n\n```c++\nvoid LoopMove ( char * pStr, int steps ) { \n //请填充... \n} \n```\n\n![image-20220415001515908](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415001515908.png)\n\n原型声明：  \n\n​    void *memcpy(void *dest, const void *src, size_t n);  \n\n  功能：\n\n  从源`src`所指的内存地址的起始位置开始拷贝`n个字节`到目标`dest`所指的内存地址的起始位置中\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415001914920.png\" alt=\"image-20220415001914920\" style=\"zoom:67%;\" />\n\n`可以用strcpy()和strncpy()代替`\n\n## 已知WAV文件格式如下表，打开一个WAV文件，以适当的数据结构组织WAV文件头并解析WAV格式的各项信息。 \n\n  WAVE文件格式说明表   \n\n![image-20220415002538169](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415002538169.png)\n\n```c++\ntypedef struct tagWaveFormat {  \n    char cRiffFlag[4];  \n    UIN32 nFileLen;  \n    char cWaveFlag[4];  \n    char cFmtFlag[4];  \n    char cTransition[4];  \n    UIN16 nFormatTag ;  \n    UIN16 nChannels;  \n    UIN16 nSamplesPerSec;  \n    UIN32 nAvgBytesperSec; \n    UIN16 nBlockAlign;  \n    UIN16 nBitNumPerSample; \n    char cDataFlag[4];  \n    UIN16 nAudioLength;  \n} WAVEFORMAT; \n```\n\n> 假设WAV文件内容读出后存放在指针buffer开始的内存单元内，则分析文件格式的代码很简单，为：    \n>\n> WAVEFORMAT waveFormat;    \n>\n> memcpy( &waveFormat, buffer,sizeof( WAVEFORMAT ) );   \n>\n> 直接通过访问waveFormat的成员，就可以获得特定WAV文件的各项格式信息。\n\n【质疑】 结构体应该考虑到对齐。第9个字段之前实际上会有两个字节填充。 实际的存储空间比读取到的内容大\n\n## 编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：\n\n```c++\nclass String {  \npublic:  \n    String(const char *str = NULL); // 普通构造函数  \n    String(const String &other); // 拷贝构造函数  \n    ~ String(void); // 析构函数  \n    String & operator =(const String &other); // 赋值函数  \nprivate:  \n    char *m_data; // 用于保存字符串  \n}; \n```\n\n```c++\n//普通构造函数 \nString::String(const char *str){\n\tif (str == NULL){\n\t\tm_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\\0'的空 \n\t\t\t\t\t\t\t  //加分点：对m_data加NULL 判断 \n\t\t*m_data = '\\0';\n\t}\n\telse{\n\t\tint length = strlen(str);\n\t\tm_data = new char[length + 1];\n\t\tstrcpy(m_data, str);\n\t}\n}\n// String的析构函数 \nString::~String(void){\n\tdelete[] m_data; // 或delete m_data; \n}\n//拷贝构造函数 \nString::String(const String &other){ 　　　// 得分点：输入参数为const型 \n\tint length = strlen(other.m_data);\n\tm_data = new char[length + 1];\n\tstrcpy(m_data, other.m_data);\n}\n//赋值函数 \nString & String::operator =(const String &other){ // 得分点：输入参数为const型 \n\tif (this == &other) 　　//得分点：检查自赋值 \n\t\treturn *this;\n\tdelete[] m_data; 　　　　//得分点：释放原有的内存资源 \n\tint length = strlen(other.m_data);\n\tm_data = new char[length + 1];\n\tstrcpy(m_data, other.m_data);\n\treturn *this; 　　　　　　　　//得分点：返回本对象的引用 \n}\n\n```\n\n> C 库函数 **size_t strlen(const char \\*str)** 计算字符串 **str** 的长度，直到空结束字符，但`不包括空结束字符`。\n\n## 请说出static和const关键字尽可能多的作用\n\n##### static关键字至少有下列n个作用： \n\n（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； \n（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； \n（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； \n（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； \n（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。  \n\n##### const关键字至少有下列n个作用： \n\n（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了； \n（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const； \n（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； \n（4）<u>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的 成员变量；</u> \n（5）<u>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：</u> \nconst classA operator*(const classA& a1,const classA& a2); \noperator * 的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错： \nclassA a, b, c; \n(a * b) = c; // 对a*b的结果赋值 \n操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。\n\n## 请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1\n\n```c++\nint checkCPU() {\n    { \n        union w {  \n            int a; \n            char b; \n        } c; \n        c.a = 1; \n        return (c.b == 1); //联合体union的存放顺序是所有成员都从低地址开始存放，\n    } \n} \n```\n\n## 写一个函数返回1+2+3+…+n的值（假定结果不会超过长整型变量的范围）\n\n```c++\nint Sum( int n ) {  \n    return ( (long)1 + n) * n / 2;　　//或return (1l + n) * n / 2; \n} \n\nint Sum( int n ) { \n    long sum = 0; \n    for( int i=1; i<=n; i++ ) { \n        sum += i; \n    } \n    return sum; \n}  \n```\n\n## 说一下static关键字的作用\n\n1. `全局静态变量`\n\n   在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.\n\n   静态存储区，在整个程序运行期间一直存在。\n\n   初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n\n   作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2. `局部静态变量`\n\n   在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。\n\n   内存中的位置：静态存储区\n\n   初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n\n   作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. `静态函数`\n\n   在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n\n   函数的`实现`使用static修饰，那么这个函数只可在`本cpp`内使用，不会同其他cpp中的同名函数引起冲突；\n\n   warning：`不要`在`头文件`中`声明`static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；\n\n4. 类的`静态成员`\n\n   在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的`静态函数`\n\n   静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n\n   在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n## 说一下C++和C的区别\n\n1. 设计思想上：\n\n   C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n2. 语法上：\n\n   C++具有封装、继承和多态三种特性\n\n   C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n\n   C++支持范式编程，比如模板类、函数模板等\n\n## 说一说c++中四种cast转换\n\nC++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast\n\n1. const_cast\n\n   <u>用于将const变量`转为非const`</u>\n\n2. static_cast\n\n   > `static_cast`是静态类型转换，一般代码中用得最多的就是它，可以用来转换常量类型，或者子类指针/引用转父类。C++里`void*转 T * `就要用它（C++禁止void*`隐式`转换为其他类型指针，反之可以。C语言二者都允许）\n\n3. dynamic_cast\n\n   用于`动态类型`转换。只能用于含有`虚函数`的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。\n\n   > 向上转换：指的是子类向基类的转换\n   >\n   > 向下转换：指的是基类向子类的转换\n\n   它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。\n\n   > `dynamic_cast`使用了RTTI来做类型检查，父类转子类的时候使用它更安全。如果是不能转换的类型，转引用会抛`std::bad_cast`异常，转指针会返回`nullptr`。用得非常少，因为一用就会引入RTTI，造成代码膨胀。而且需要根据实际类型作出行动可以抽象成虚函数，不需要cast。\n\n4. reinterpret_cast\n\n   几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；`非常危险`\n\n5. 为什么不使用C的强制转换？\n\n   C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。\n\n## 请说一下C/C++ 中指针和引用的区别？\n\n1. 指针有自己的一块`空间`，而引用只是一个别名；\n\n2. 使用`sizeof`看一个指针的大小是4，而引用则是被引用对象的大小；\n\n3. 指针可以被`初始化`为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n\n4. 作为`参数传递`时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n\n5. 可以有`const`指针，但是没有const引用；\n\n6. 指针在使用中可以`指向`其它对象，但是引用只能是一个对象的引用，不能 被改变；\n\n7. 指针可以有`多级`指针（**p），而引用至于一级；\n\n8. 指针和引用使用`++运算符`的意义不一样；\n\n9. 如果`返回动态内存`分配的对象或者内存，必须使用指针，引用可能引起`内存泄露`。\n\n## 给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码\n\n```c++\n#include<iostream>\n#include<math.h>\nusing namespace std;\nstruct point{\t//三角形点的坐标\n\tfloat x;\n\tfloat y;\n\tfloat z;\n};\n\n//s=sqrt(p*(p-a)(p-b)(p-c))    p=1/2(a+b+c)\nfloat sum(point A,point B,point C ) {\t//计算面积\n\tfloat AB = sqrt(pow(A.x - B.x, 2) + pow(A.y - B.y, 2) + pow(A.z - B.z, 2));//计算三角形三边长\n\tfloat AC = sqrt(pow(A.x - C.x, 2) + pow(A.y - C.y, 2) + pow(A.z - C.z, 2));\n\tfloat BC = sqrt(pow(B.x - C.x, 2) + pow(B.y - C.y, 2) + pow(B.z - C.z, 2));\n\tfloat p = (AB + AC + BC) / 2;//海伦公式\n\tfloat S = sqrt(p * (p - AB) * (p - AC) * (p - BC));//面积\n\treturn S;\n}\nint main() {\n\tfloat x,y,z;\n\twhile(1){//测试\n\tcin >> x >> y >> z;\n\tpoint P = {x,y,z};\n\tpoint A = { 0, 0, 0 }, B = { 0, 6, 0 },C = { 7, 0, 0 };//设置一个简单的z值都为0的三角形，方便验证\n\tif ((sum(P, A, B) + sum(P, A, C) + sum(P, B, C)-sum(A, B, C))<0.001)\n        cout << \"P在三角形ABC之内\\n\";\n\telse cout << \"P不在三角形ABC之内\\n\";\n\t}\n}\n```\n\n## 请你说一下你理解的c++中的smart pointer四个智能指针\n\nC++里面的四个智能指针: auto_ptr, `shared_ptr`, `weak_ptr`, `unique_ptr` 其中后三个是c++11支持，并且第一个已经被11弃用。\n\n`为什么要使用智能指针`：\n\n智能指针的作用是管理一个指针，因为存在以下这种情况：\n\n> 申请的空间在函数结束时`忘记释放，造成内存泄漏`。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个<u>==类==</u>，当超出了类的作用域是，类会自动调用<u>==析构函数==</u>，析构函数会自动释放资源。所以`智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。`\n\n1. auto_ptr（c++98的方案，cpp11已经抛弃）\n\n- 采用`所有权模式`。\n\n```c++\nauto_ptr<string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n\n- 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！\n\n2. unique_ptr（替换auto_ptr）\n\n- unique_ptr实现`独占式拥有`或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n- 采用`所有权`模式，还是上面那个例子\n\n````c++\nunique_ptr<string> p3 (new string  (\"auto\")); \nunique_ptr<string> p4；   \np4 = p3;//此时会报错！！\n````\n\n- 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。\n\n- 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个`临时右值`，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                   // #1 not allowed\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));  // #2 allowed\n```\n\n- 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。\n\n- 注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数`std::move()`，让你能够将一个unique_ptr赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1); //(ps1不在指向原来对象)\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n```\n\n3. <u>[==shared_ptr==](https://www.cnblogs.com/diysoul/p/5930361.html)</u>\n\n- shared_ptr实现`共享式拥有`概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“`最后一个引用被销毁`”时候`释放`。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。<u>==引用计数==</u>\n\n- shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n- 成员函数：\n\n  1. use_count 返回引用计数的个数\n  2. unique 返回是否是独占所有权( use_count 为 1)\n  3. swap 交换两个 shared_ptr 对象(即交换所拥有的对象)\n  4. reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少\n  5. get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的\n\n  ```c++\n  #include <iostream>\n  #include <memory>\n  using namespace std;\n  int main()\n  {\n      //构建 2 个智能指针\n      std::shared_ptr<int> p1(new int(10));\n      std::shared_ptr<int> p2(p1);\n      //输出 p2 指向的数据\n      cout << *p2 << endl;   //输出10\n      p1.reset();//引用计数减 1,p1为空指针\n      if (p1) {\n          cout << \"p1 不为空\" << endl;\n      }\n      else {\n          cout << \"p1 为空\" << endl;  //输出\n      }\n      //以上操作，并不会影响 p2\n      cout << *p2 << endl;    //输出10\n      //判断当前和 p2 同指向的智能指针有多少个\n      cout << p2.use_count() << endl;  //输出 1\n      return 0;\n  }\n  ```\n\n4. weak_ptr  ( `shared_ptr 指针的一种辅助工具`)\n\n- weak_ptr 是一种`不控制对象生命周期`的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, `它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放`。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。\n\n  ````c++\n  class B;\n  class A{\n  public:\n  \tshared_ptr<B> pb_;\n  \t~A(){\n      cout<<\"A delete\\n\";\n    }\n  };\n  \n  class B{\n  public:\n    shared_ptr<A> pa_;\n  \t~B(){\n      cout<<\"B delete\\n\";\n    }\n  };\n  \n  void fun(){\n    shared_ptr<B> pb(new B());\n    shared_ptr<A> pa(new A());\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl; //2\n    cout<<pa.use_count()<<endl; //2\n  }\n  \n  int main(){\n    fun();\n    return 0;\n  }\n  ````\n\n- 可以看到fun函数中pa ，pb之间`互相引用`，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（pa_，pb_未释放，因为AB是在堆上申请的内存），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。\n\n- 注意的是`我们不能通过weak_ptr直接访问对象的方法`，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 因为pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：\n\n  ````c++\n  shared_ptr p = pa->pb_.lock();  //将weak_ptr转换为shared_ptr\n  p->print();\n  ````\n\n## 怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码\n\n1. 判断一个数是不是二的倍数，即判断该数二进制末位是不是0：\n\n   `a % 2 == 0 或者a & 0x0001 == 0。`\n\n2. 求一个数中1的位数，可以直接逐位除十取余判断：\n\n   ```c++\n   int countOne(int x){\n       int ans = 0;\n       while(x){\n           if(x%10)\n               ans++;\n           x/=10;\n       }\n       return ans;\n   }\n   ```\n\n## 请回答一下数组和指针的区别\n\n指针和数组的主要区别如下：\n\n| 指针                                                         | 数组                                 |\n| ------------------------------------------------------------ | ------------------------------------ |\n| 保存数据的地址                                               | 保存数据                             |\n| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据，                       |\n| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |\n| 通过Malloc分配内存，free释放内存                             | 隐式的分配和删除                     |\n| 通常指向匿名数据，操作匿名函数                               | 自身即为数据名                       |\n\n## 请你回答一下野指针是什么？\n\n野指针  是  一个指向   已删除的对象的指针\n\n野指针  是  一个指向  未申请内存 或者 访问受限的   内存区域的 这么一个指针\n\n## 请你介绍一下C++中的智能指针\n\n智能指针<u>主要用于管理在堆上分配的内存</u>，它<u>将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏</u>。C++ 11中最常用的智能指针类型为shared_ptr,它采用`引用计数`的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。\n\n## 请你回答一下智能指针有没有内存泄露的情况\n\n当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：\n\n![image-20220415024028387](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415024028387.png)\n\n![image-20220415024039683](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415024039683.png)\n\n![image-20220415024051874](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415024051874.png)\n\n上述代码中，parent有一个shared_ptr类型的成员指向孩子，而child也有一个shared_ptr类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针c和p，随后将c和p分别又赋值给child的智能指针成员parent和parent的智能指针成员child。从而形成了一个循环引用：\n\n## 请你来说一下智能指针的内存泄漏如何解决\n\n<u>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针</u>，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n> 解决循环引用的问题就是在类对象中使用weak_ptr弱指针对象，弱指针对象不会使引用计数加1\n\n## 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数\n\n1. 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，`防止内存泄漏`。\n\n2. C++默认的析构函数不是虚函数是因为虚函数`需要额外的虚函数表和虚表指针`，`占用额外的内存`。而对于不会被继承的类来说，其析构函数如果是虚函数，就会`浪费内存`。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n## 请你来说一下函数指针\n\n1. 定义\n\n   函数指针是指向函数的指针变量。\n\n   函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。\n\n   C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途：\n\n   调用函数和做函数的参数，比如回调函数。\n\n3. 示例：\n\n   ```c++\n   char * fun(char * p)  {…}       // 函数fun\n   char * (*pf)(char * p);         // 函数指针pf\n   pf = fun;                       // 函数指针pf指向函数fun\n   pf(p);                          // 通过函数指针pf调用函数fun\n   ```\n\n4. 首先函数指针是一个指针，指向某一类型的函数 typedef int (*pFunc) (int,int) ； 定义一个函数指针类型，指向返回值是int参数为int，int的函数。 用途：`回调函数`\n\n## 请你来说一下fork函数\n\nFork：创建一个和当前进程映像一样的进程 可以通过fork( )系统调用：\n\n```c++\n#include <sys/types.h>\n#include <unistd.h>\npid_t fork(void);\n```\n\n- 成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。\n\n- 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“`派生加执行`”的方式是很常见的。\n\n- 在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了`写时复制`的方法，而不是对父进程空间进程整体复制。\n\n## 请你来说一下C++中析构函数的作用\n\n1. 析构函数与构造函数对应，当对象结束其生命周期，如<u>对象所在的函数已调用完毕时</u>，系统会自动执行析构函数。\n2. 析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n3. 如果用户没有编写析构函数，<u>编译系统会`自动生成`一个缺省的析构函数（即使`自定义`了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</u>\n4. 如果一个类中有指针，且在使用的过程中`动态的申请了内存`，那么最好显示构造析构函数在销毁类之前，`释放掉申请的内存空间`，避免内存泄漏。\n5. 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 (和构造函数 从基类到子类 正好相反)\n\n## 请你来说一下map和set有什么区别，分别又是怎么实现的？\n\nmap和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。\n\n==<u>map和set区别在于：</u>==\n\n1. map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。\n2. `set`的迭代器是const的，不允许`修改元素的值`；`map允许修改value，但不允许修改key`。其原因是因为`map和set是根据关键字排序来保证其有序性的`，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。\n3. map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，<u>因此下标运算符[ ]在map应用中需要慎用</u>，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用 `（用count函数）`，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。\n\n## 请你来介绍一下STL的allocator\n\n1. STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：\n\n   new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容\n\n   delete运算分两个阶段：(1)调用对象析构函数；(2)调用::operator delete释放内存\n\n2. 为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。\n\n3. 同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。\n\n## 请你来说一下C++中类成员的访问权限\n\nC++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员\n\n- public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；\n- `protected`：可以被该类中的函数、子类的函数、友元函数访问，但`不可以由该类的对象访问`；\n- `private`：可以被该类中的函数、友元函数访问，但`不可以由子类的函数、该类的对象、访问`。\n- 如果声明不写 public、protected、private，则默认为 private；\n\n## 请你来说一下C++中struct和class的区别\n\n在C++中，可以用struct和class定义类，都可以继承。区别在于：\n\n1. structural的`默认继承权限和默认访问权限`是public，而class`的默认继承权限和默认访问权限是`private。\n\n2. 另外，class还可以定义`模板类形参`，比如template <class T, int i>。\n\n## 请你来说一下一个C++源文件从文本到可执行文件经历的过程？\n\n对于C++源文件，从文本到可执行文件一般需要四个过程：\n\n1. `预处理`阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。\n2. `编译`阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件\n3. `汇编`阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件\n4. `链接`阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件\n\n## 请你来回答一下include头文件的顺序以及双引号””和尖括号<>的区别？\n\nInclude头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。\n\n- **双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。**\n\n  1. 对于使用双引号包含的头文件，查找头文件路径的顺序为：\n\n     `当前头文件目录`\n\n     编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）\n\n     系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径\n\n  2. 对于使用尖括号包含的头文件，查找头文件的路径顺序为：\n\n     编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）\n\n     系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径\n\n## 请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？\n\nMalloc函数`用于动态分配内存`。为了减少内存碎片和系统调用的开销，malloc其采用`内存池`的方式，<u>先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位</u>。\n\n当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。\n\n当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。\n\nMalloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。\n\n## 请你说一说C++的内存管理是怎样的？\n\n在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。\n\n1. 代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。\n2. 数据段：存储程序中已初始化的全局变量和静态变量\n3. bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。\n4. 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。\n5. 映射区:存储动态链接库以及调用mmap函数进行的文件映射\n6. 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值\n\n## 请你来说一下C++/C的内存分配\n\n![image-20220415031248787](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220415031248787.png)\n\n32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：\n\n各个段说明如下：\n\n3G用户空间和1G内核空间\n\n- 静态区域：\n\n  text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。\n\n  data segment(数据段)：存储程序中已初始化的全局变量和静态变量\n\n  bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0\n\n- 动态区域：\n\n  heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。\n\n  memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）\n\n  stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。\n\n## 请你来回答一下什么是memory leak，也就是内存泄漏\n\n内存泄漏(memory leak)是指由于`疏忽或错误`造成了`程序未能释放掉不再使用的内存`的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，`失去了对该段内存的控制`，因而<u>造成了内存的浪费</u>。\n\n内存泄漏的分类：\n\n1. `堆内存泄漏` （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.\n\n2. `系统资源泄露`（Resource Leak）。主要指程序使用系统分配的资源比如 <u>Bitmap,handle ,SOCKET</u>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。\n\n3. <u>没有将基类的`析构函数`定义为虚函数</u>。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。\n\n## 请你回答一下如何判断内存泄漏？\n\n内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是`缺少了对应的free/delete`。\n\n#### **Linux:**\n\n我们一方面可以使用linux环境下的内存泄漏检查工具**<u>==Valgrind==</u>**,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。\n\nValgrind：\n\n编译：g++ -g -o test test.cpp\n\n使用：valgrind --tool=memcheck ./test\n\n可以检测如下问题：\n\n使用未初始化的内存（全局/静态变量初始化为0，局部变量/动态申请初始化为随机值）；\n\n内存读写越界；\n\n内存覆盖（strcpy/strcat/memcpy）；\n\n动态内存管理（申请释放方式不同，忘记释放等）；\n\n内存泄露（动态内存用完后没有释放，又无法被其他程序使用）。\n\n#### **Windows(vs)**\n\n_CrtDumpMemoryLeaks()就是检测从程序开始到执行该函数进程的堆使用情况，通过使用 _CrtDumpMemoryLeaks()我们可以进行简单的内存泄露检测。\n\n```c++\n#define CRTDBG_MAP_ALLOC //放在程序最前\n#include <iostream>\n#include <stdlib.h>  \n#include <crtdbg.h> \nusing namespace std;\nint main(){\n    int *a = new int [10];\n    int *p = new int[1000];\n    _CrtDumpMemoryLeaks(); //放在程序最后  //会输出在第几行 泄露了多少\n    system(\"pause\");\n    return 0;\n}\n```\n\n## 请你来说一下什么时候会发生段错误\n\n段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：\n\n1. `使用野指针`（指针常量没有初始化；指向一块内存已经释放掉的地址；指针操作超过了定义域）\n\n2. <u>试图修改字符串常量的内容</u>\n\n## 请你来回答一下new和malloc的区别\n\n1. new分配内存按照`数据类型`进行分配，malloc分配内存按照指定的大小分配；\n2. new`返回`的是<u>指定对象的指针</u>，而malloc返回的是<u>void*</u>，因此malloc的返回值一般都需要进行类型转化。\n3. new不仅分配一段内存，而且会调`用构造函数`，malloc不会。\n4. new分配的内存要用`delete`销毁，malloc要用`free`来销毁；delete销毁的时候会调用对象的<u>析构</u>函数，而free则不会。\n5. new是一个操作符可以`重载`，malloc是一个库函数。\n6. malloc分配的内存不够的时候，可以用realloc`扩容`。扩容的原理？new没用这样操作。\n7. new如果`分配失败`了会抛出bad_malloc的异常（`程序中断`），而malloc失败了会返回NULL。\n8. 申请数组时： `new[]`一次分配所有内存，.0.0`多次调用构造函数`，搭配使用`delete[]`，delete[]`多次调用析构函数`，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。\n\n\n\n## 请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。\n\n### [可变参数模板](https://qianxunslimg.github.io/2022/03/16/c-ba-gu/#2-3-C-11中的可变参数模板)\n\nC++11的可变参数模板，`对参数进行了高度泛化`，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上`省略号`”。\n\n例如：\n\n```c++\nTemplate<class ... T>\nvoid func(T ... args){\n\tcout<<”num is”<<sizeof ...(args)<<endl;\n}\n```\n\nfunc();//args不含任何参数\n\nfunc(1);//args包含一个int类型的实参\n\nfunc(1,2.0);//args包含一个int一个double类型的实参\n\n其中T叫做模板参数包，args叫做函数参数包\n\n<u>省略号作用如下：</u>\n\n1）`声明`一个包含0到任意个模板参数的`参数包`\n\n2）在模板定义得右边，可以将参数包展成一个个独立的参数\n\nC++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：\n\n```c++\n#include<iostream>\nusing namespace std;\n// 最终递归函数\nvoid print(){\n  cout << \"empty\" << endl;\n}\n\n// 展开函数\ntemplate <class T, class ...Args>\nvoid print(T head, Args... args){\n  cout << \"parameter \" << head << endl;\n  print(args...);\n}\n\nint main(){\n  print(1, 2, 3, 4); return 0;\n}\n```\n\n参数包Args …在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程\n\n![image-20220417154116203](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417154116203.png)\n\n### [右值引用](https://qianxunslimg.github.io/2022/03/16/c-ba-gu/#1-9-C-11右值引用)\n\n右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：\n\n1. `消除`两个对象交互时`不必要的对象拷贝`，节省运算存储资源，提高效率。\n\n2. 能够更`简洁明确地定义泛型函数`。\n\n \n\n##### 左值和右值的概念：\n\n左值：`能对表达式取地址`、或具名对象/变量。一般指表达式结束后依然存在的`持久对象`。\n\n右值：`不能对表达式取地址`，或匿名对象。一般指表达式结束就不再存在的`临时对象`。\n\nC++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：\n\nT && a=ReturnRvale();\n\n假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。\n\n \n\n可以使用move将对左值进行右值引用\n\n```c++\n int k = 4;\n int&& s = move(k);\n```\n\n此时s和k地址一样。\n\n##### 1.9.1. 移动构造\n\n基于右值引用可以实现`转移语义`和`完美转发`新特性。\n\n移动语义：\n\n- 对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。\n\n- 但是如下列代码所示：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass HasPtrMem{\npublic:\n  HasPtrMem() : d(new int(0)){\n    cout<<\"Construct:\"<<++n_cstr<<endl;\n  }\n  HasPtrMem(const HasPtrMem &h) : d(new (int(*h.d))){\n    cout<<\"Copy construct:\"<<++n_cptr<<endl;\n\t}\n  ~HasPtrMem(){\n    cout<<\"Destruct:\"<<++n_dstr<<endl;\n\t}\n  int *d;\n  static int n_cstr;\n  static int n_dstr;\n  static int n_cptr;\n};\n\nint HasPtrMem::n_cstr == 0;\nint HasPtrMem::n_dstr == 0;\nint HasPtrMem::n_cptr == 0;\n\nHasPtrMem GetTemp(){retrun HasPtrMem();}\n\nint main(){\n  HasPtrMem a = GetTemp();\n}\n\nHasPtrMem(HasPtrMem && h) : d(h.d){ //移动构造函数\n  h.d = nullptr;\t\t\t\t\t\t\t\t\t\t//将移动值的指针成员置空\n  cout<<\"Move construct:\"<<++n_mvtr<<endl;\n}\n```\n\n- 当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。\n\n- 而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。\n\n- 如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。\n\n- 使用右值引用直接使用h里面的h.d。\n\n  否则将会用h.d构造d，因为拷贝构造不能浅拷贝指针，所以不能直接赋值。\n\n```c++\nHasPtrMem(HasPtrMem && h) : d(h.d){ //移动构造函数\n  h.d = nullptr;\t\t\t\t\t\t\t\t\t\t//将移动值的指针成员置空\n  cout<<\"Move construct:\"<<++n_mvtr<<endl;\n}\n```\n\n- 其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811301-2120007528.png)\n\n### [完美转发](https://blog.csdn.net/xiangbaohui/article/details/103673177)\n\nstd::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。\n\n```c++\ntemplate <typename T>\nT&& forward(typename std::remove_reference<T>::type& param)\n{\n  return static_cast<T&&>(param);\n}\n\ntemplate <typename T>\nT&& forward(typename std::remove_reference<T>::type&& param)\n{\n  return static_cast<T&&>(param);\n}\n```\n\n### [C++11 Lambda表达式](https://qianxunslimg.github.io/2022/03/16/c-ba-gu/#1-11-C-11-Lambda表达式)\n\nLambda表达式定义一个`匿名函数`，并且可以捕获一定范围内的变量，其定义如下：\n\n[capture] (params)mutable->return-type{statement}\n\n其中，\n\n- [capture]：捕获列表，捕获上下变量以供lambda使用。编译器根据符号[]判断接下来代码是否是lambda函数。\n- (Params)：参数列表，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。\n- mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。\n- ->return-type:返回类型是返回值类型\n- {statement}:函数体，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。\n\nLambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。其形式如下:\n\n> -  [var]表示值传递方式捕捉变量var\n> -  [=]表示值传递方式捕捉所有父作用域的变量（包括this)\n> -  [&var]表示引用传递捕捉变量var\n> -  [&]表示引用传递捕捉所有父作用域的变量（包括this）\n> -  [this]表示值传递方式捕捉当前的this指针\n\nLambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于简化仿函数的使用，同时`Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口`。\n\n## 数组与链表的区别\n\n从逻辑结构上来说，这两种数据结构都属于线性表。所谓线性表，就是所有数据都排列在只有一个维度的“线”上，就像羊肉串一样，把数据串成一串。对其中任意一个节点来说，除了头尾，只有一个前趋，也只有一个后继。\n\n### 从物理上来说，\n\n即在内存中，这两种逻辑结构所对应的物理存储分布上看，`数组占用的是一块连续的内存区`，而`链表在内存中，是分散的`，因为是分散的，就需要一种东西把他们串起来，这样才能形成逻辑上的线性表，不像数组，与生俱来具有“线性”的成分。因为链表比数组多了一个“串起来”的额外操作，这个操作就是加了个指向下个节点的指针，所以对于链表来说，存储一个节点，所要消耗的资源就多了。也正因为这种物理结构上的差异，导致了他们在**访问、增加、删除**节点这三种操作上所带来的时间复杂度不同。\n\n### 对于**访问**，\n\n- 数组在物理内存上是连续存储的，硬件上支持“随机访问”，所谓随机访问，就是你访问一个a[3]的元素与访问一个a[10000]，使用数组下标访问时，这两个元素的时间消耗是一样的。\n\n- 但是对于链表就不是了，链表也没有下标的概念，只能通过头节点指针，从每一个节点，依次往下找，因为下个节点的位置信息只能通过上个节点知晓（这里只考虑单向链表），所以访链表中的List(3)与List(10000)，时间就不一样了，访问List(3)，只要通过前两个节点，但要想访问List(10000)，不得不通过前面的9999个节点；而数组是一下子就跳到了a[10000]，无需逐个访问a[10000]之前的这些个元素。\n- 所以**对于访问，数组和链表时间复杂度分别是O(1)与O(n)，方式一种是“随机访问”，一种是“顺序访问”。**\n\n**数组在内存中的样子**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-d9ac253f44fabc79724a317280a09f64_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n**链表在内存中的样子**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-1c09bef42c92821936bee6d61463c6c1_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n### 对于**增加**，\n\n- 因为数组在内存中是连续存储的，要想在某个节点之前增加，且保持增加后数组的线性与完整性，必须要把此节点往后的元素依次后移。要是插在第一个节点之前，那就GG了，数组中所有元素位置都得往后移一格，最后把这个后来的“活宝元素”，稳稳的放在第一个腾出来的空闲位置上，真是不考虑其他元素的感受，就像我们日常生活排队时，出现的“加塞”现象一样。“加塞”位置前的人没什么意见，因为他们的领先位置没动，还是按原来的顺序先到先得的享受服务，“加塞”位置后的人就有意见了，他们不得不都往后挪一个位置，很有可能面对突然的后挪，踩到后面人的脚，享受服务的顺序也往后挪了一位。对于数组来说，有“加塞”时，一定要先做好数据迁移，不然就会踩到脚，数组元素丢了，而且数组下标也要往后+1，享受服务的顺序往后推了一位。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-51e68995b74cc1f4a55aafb5ea305016_b.jpg)\n\n\n\n- 而链表却为其他元素着想多了。由上图可知，链表中只需要改变节点中的“指针”，就可以实现增加。自身在内存中所占据的位置不变，只是这个节点所占据的这块内存中数据（指针）改变了，相对于数组“牵一发而动全身”的大动作，链表则要显示温和的多，局部数据改写就可以了。如下图所示：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-1ceb705030c14c0f7c793be3332d6567_b.webp)\n\n\n\n### 删除操作，同理。\n\n### 在操作系统**内存管理**方面也有不同。\n\n正因为数组与链表的物理存储结构不同，<u>在内存预读方面，内存管理会将连续的存储空间提前读入缓存（局部性原理），所以数组往往会被都读入到缓存中，这样`进一步提高了访问的效率`</u>，<u>而链表由于在内存中分布是分散的，往往不会都读入到缓存中，这样本来访问效率就低，这样`效率反而更低`了</u>。在实际应用中，因为`链表带来的动态扩容`的便利性，在做为算法的容器方面，用的更普遍一点。\n\n# 操作系统\n\n## 请你来说一下reactor模型组成\n\n[ 线程模型2：Reactor 模式](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#线程模型2：Reactor-模式)\n\nreactor模型要求`主线程只负责监听`文件描述上`是否有事件发生`，有的话就立即将该事件`通知`工作线程，除此之外，主线程不做任何其他实质性的工作，<u>读写数据、接受新的连接以及处理客户请求均`在工作线程`中完成</u>。\n\n\n\n## 请自己设计一下如何采用单线程的方式处理高并发\n\n单线程解决高并发的思路就是`非阻塞IO + 异步编程`。 \n\n- ​    采用`非阻塞`的IO复用方式（`epoll`，poll要强于select），epoll突破了文件描述符上限，底层使用红黑树实现，同时维护了一个ready list，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，内核将事件表中就绪的事件添加在ready list里面，使用epoll_wait等待调用，      \n\n  > 注意  select poll epoll都是非阻塞io, 用epoll应该是因为 处理高并发效率高\n\n- ​    事件处理（proactor），当有新请求来到，主线程接受并得到一个socket，然后主线程往epoll事件表中注册socket上的就绪事件，当socket上右数据可读时，epoll_wait通知主线程从socket上循环读取数据，然后把数据封装成一个请求对象插入到请求队列中。\n\n  > reactor从定义上就不符合要求 主线程监听 子线程读写数据，接受新的连接，以及处理客户请求 不是单线程\n  >\n  > Proactor 模式将所有 `I/O` 操作都交给主线程和内核来处理（进行`读、写`），工作线程仅仅负责业务逻辑。\n  >\n\n\n\n## 请你说一下`进程与线程`的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的\n\n### 基本概念：\n\n- <u>进程是对`运行时程序`的`封装`，是`系统`进行`资源调度`和`分配`的的基本单位，实现了`操作系统的并发`；</u>\n\n  > 1. 运行时程序的封装\n  > 2. 系统 资源调度和分配的 基本单位\n  > 3. 操作系统的并发\n\n- 1. 线程是进程的子任务，是==CPU调度和分派的基本单位==，用于保证程序的实时性，实现`进程内部的并发`；\n  2. 线程是操作系统可识别的==最小执行和调度单位==。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是==共享==同一`地址空间`（也就是同样的动态内存，映射文件，目标代码等等），打开的`文件队列`和其他`内核资源`。\n\n  > 1. 是进程的`子任务`，\n  > 2. `CPU调度和分配`的基本单位  操作系统可识别的最小执行和调度单位\n  > 3. 实现`进程内部的并发`\n\n### 线程产生的原因：\n\n1. 进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：\n\n   - 进程在同一时间只能干一件事（`一次一件事`）；\n   - 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（`阻塞挂起整个`）。\n\n2. （`为了减小并发的时空开销`）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：\n\n   - （相同的地址空间，所以`节省资源`）从资源上来讲，线程是一种非常\"节俭\"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种\"昂贵\"的多任务工作方式。 \n\n   - （相同的地址空间，所以`切换快`）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。\n\n   - （相同的地址空间，所以`通信快捷方便`）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。\n\n   - 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：\n\n     1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。\n\n     2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。\n\n\n\n### 区别：\n\n1. （`从属关系`）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程`依赖`于进程而存在。\n\n2. （`资源区别`）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。\n\n3. （`单位`）进程是资源分配的最小单位，线程是CPU调度的最小单位；\n\n4. （`系统开销`)： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。\n\n   类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。\n\n5. （`通信`)：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预\n\n6. （`调试难度可靠性`）进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。\n\n7. （`相互影响`）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉\n\n\n\n### [进程间通信方式](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#3-进程间通信方式-必考)\n\n进程间通信主要包括`管道`、`内存映射` 系统IPC（包括消息队列、信号量、`信号`、`共享内存`等）、以及套接字socket。\n\n\n\n### [线程通信同步方式](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#多线程，线程同步的几种方式)\n\n临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；\n\n线程通信方式：`互斥锁，条件变量，信号量`\n\n## 请你说一说Linux虚拟地址空间\n\n### [Linux虚拟地址空间](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#Linux虚拟地址空间)\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322144514836.png\" alt=\"image-20220322144514836\" style=\"zoom:50%;\" />\n\n`为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏`，<u>采用了虚拟内存</u>。\n\n>直接使用物理内存会产生一些问题\n>\n>1. 内存空间利用率的问题 （`内存碎片化`）\n>2. 读写内存的安全性问题（访问`权限`与`安全`问题）\n>3. `进程间的安全`问题\n>4. 内存读写的`效率`问题\n\n- 虚拟内存技术使得不同进程在运行过程中，<u>它所看到的是自己`独自占有`了当前系统的4G内存</u>。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间`映射并存储`到物理内存上。 \n\n- <u>事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）</u>，等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，`要动态分配内存`，比如malloc时，也`只是分配了虚拟内存`，即为这块虚拟内存对应的页表项做相应设置，`当进程真正访问到此数据时，才引发缺页异常`。\n\n- 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。\n\n  \n\n### **虚拟内存的好处：**\n\n1. `扩大`地址空间；\n\n2. 内存`保护`：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。  （==<u>互不干扰，防止进程互相恶意篡改</u>==）\n\n3. `公平`内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。\n\n4. 当进程`通信`时，可采用`虚存共享`的方式实现。   （==<u>实现共享内存</u>==）\n\n5. 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，`节省内存`\n\n6. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。<u>在内存中可以保留多个进程</u>，系统`并发度提高`\n\n7. 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片\n\n    \n\n### **虚拟内存的代价：**\n\n1. 虚存的管理需要建立很多数据结构，这些数据结构要占用`额外的内存`\n\n2. 虚拟地址到物理地址的转换，增加了指令的`执行时间`。\n\n3. 页面的换入换出需要`磁盘I/O`，这是很`耗时`的\n\n4. <u>如果一页中只有一部分数据，会浪费内存。</u>\n\n   \n\n## [请你说一说操作系统中的程序的内存结构](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#操作系统中的程序的内存结构)\n\n## [请你说一说操作系统中的缺页中断](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#9-6-操作系统中的缺页中断)\n\nmalloc()和mmap()等内存分配函数，<u>在分配时`只是建立了进程虚拟地址空间`</u>，<u>并`没有分配虚拟内存对应的物理内存`</u>。<u>当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</u>。  \n\n> （分配了虚拟的地址空间 但没有分配映射到物理内存，访问时会缺页异常）\n\n**缺页中断：**在请求分页系统中，可以<u>通过查询页表中的`状态位`来确定所要访问的`页面是否存在于内存`中</u>。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。\n\n缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：\n\n> 1、保护CPU现场\n>\n> 2、分析中断原因\n>\n> 3、转入缺页中断处理程序进行处理\n>\n> 4、恢复CPU现场，继续执行\n\n但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：\n\n> 1、<u>在指令执行期间产生和处理缺页中断信号</u>\n>\n> 2、<u>一条指令在执行期间，可能产生多次缺页中断</u>\n>\n> 3、<u>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</u>。\n\n## [请你回答一下fork和vfork的区别](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#2-16-fork和vfork的区别)\n\n## 请问如何修改文件最大句柄数？\n\nlinux默认最大文件句柄数是1024个，在linux服务器文件并发量比较大的情况下，系统会报\"too many open files\"的错误。故在linux服务器高并发调优时，往往需要预先调优Linux参数，修改Linux最大文件句柄数。\n\n有两种方法：\n\n\\1. ulimit -n <可以同时打开的文件数>，将当前进程的最大句柄数修改为指定的参数（注：该方法只针对当前进程有效，重新打开一个shell或者重新开启一个进程，参数还是之前的值）\n\n首先用ulimit -a查询Linux相关的参数，如下所示：\n\n```\ncore file size          (blocks, -c) 0\ndata seg size           (kbytes, -d) unlimited\nscheduling priority             (-e) 0\nfile size               (blocks, -f) unlimited\npending signals                 (-i) 94739\nmax locked memory       (kbytes, -l) 64\nmax memory size         (kbytes, -m) unlimited\nopen files                      (-n) 1024\npipe size            (512 bytes, -p) 8\nPOSIX message queues     (bytes, -q) 819200\nreal-time priority              (-r) 0\nstack size              (kbytes, -s) 8192\ncpu time               (seconds, -t) unlimited\nmax user processes              (-u) 94739\nvirtual memory          (kbytes, -v) unlimited\nfile locks                      (-x) unlimited\n```\n\n其中，open files就是最大文件句柄数，默认是1024个。\n\n修改Linux最大文件句柄数：  ulimit -n 2048， 将最大句柄数修改为 2048个。\n\n\n\n\\2. 对所有进程都有效的方法，修改Linux系统参数\n\nvi /etc/security/limits.conf 添加\n\n*　　soft　　nofile　　65536\n\n*　　hard　　nofile　　65536\n\n将最大句柄数改为65536\n\n修改以后保存，注销当前用户，重新登录，修改后的参数就生效了\n\n## [请你说一说并发(concurrency)和并行(parallelism)](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#7-并行并发)\n\n1. 并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。\n2. 并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。\n\n## 请问MySQL的端口号是多少，如何修改这个端口号\n\n#### 查看端口号：\n\n- 使用命令show global variables like 'port';查看端口号 ，mysql的默认端口是3306。（补充：sqlserver默认端口号为：1433；oracle默认端口号为：1521；DB2默认端口号为：5000；PostgreSQL默认端口号为：5432）\n\n#### 修改端口号：\n\n- 修改端口号：编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。\n\n## 请你说一说操作系统中的页表寻址\n\n页式内存管理，内存分成固定长度的一个个页片。<u>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫`页表`，</u>页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。\n\n\n\n### Linux最初的两级页表机制：\n\n两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。\n\n- PGD(Page Global Directory): 最高10位，全局页目录表索引\n\n- PTE(Page Table Entry)：中间10位，页表入口索引\n\n1. 当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；\n2. 从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；\n3. 在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。\n\n从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是<u>不断深入页表层次</u>，<u>逐渐定位到最终地址的过程</u>，所以这一过程被叫做page talbe walk。\n\n\n\n### Linux的三级页表机制：\n\n当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：\n\n字段      描述            位数\n\ncr3      指向一个PDPT      crs寄存器存储\n\nPGD    指向PDPT中4个项中的一个  位31~30\n\nPMD    指向页目录中512项中的一个  位29~21\n\nPTE      指向页表中512项中的一个  位20~12\n\npage offset  4KB页中的偏移      位11~0\n\n\n\n现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -> PMD -> PTE。那只使用2级页表(如非PAE的X86)怎么办？\n\n办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。\n\n\n\n### Linux的四级页表机制：\n\n硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：\n\n字段      描述            位数\n\nPML4    指向一个PDPT      位47~39\n\nPGD    指向PDPT中4个项中的一个  位38~30\n\nPMD    指向页目录中512项中的一个  位29~21\n\nPTE      指向页表中512项中的一个  位20~12\n\npage offset  4KB页中的偏移      位11~0\n\n\n\nLinux内核针为使用原来的3级列表(PGD->PMD->PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。\n\n在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -> PUD -> PMD -> PTE。\n\n## 请你说一说有了进程，为什么还要有线程？\n\n1. 进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：\n\n   - 进程在同一时间只能干一件事（`一次一件事`）；\n   - 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（`阻塞挂起整个`）。\n\n2. （`为了减小并发的时空开销`）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：\n\n   - （相同的地址空间，所以`节省资源`）从资源上来讲，线程是一种非常\"节俭\"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种\"昂贵\"的多任务工作方式。 \n\n   - （相同的地址空间，所以`切换快`）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。\n\n   - （相同的地址空间，所以`通信快捷方便`）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。\n\n   - 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：\n\n     1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。\n\n     2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。\n\n## 请问单核机器上写多线程程序，是否需要考虑加锁，为什么？\n\n在单核机器上写多线程程序，`仍然需要`线程锁。因为线程锁`通常用来实现线程的同步和通信`。在单核机器上的多线程程序，`仍然存在线程同步的问题`。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。<u>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突</u>。\n\n## 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的\n\n线程在切换的过程中需要保存`当前线程Id`、`线程状态`、`堆栈`、`寄存器状态`等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：\n\n- `SP:堆栈指针`，指向当前栈的栈顶地址 （`存地址`）\n\n- `PC:程序计数器`，存储下一条将要执行的指令（`存下一条指令`）\n\n- `EAX:累加寄存器`，用于加法乘法的缺省寄存器 ？\n\n  > 在[中央处理器](https://zh.wikipedia.org/wiki/中央處理器)中，**累加器** (accumulator) 是一种寄存器，用来储存计算产生的中间结果。如果没有像累加器这样的寄存器，那么在每次计算 (加法，乘法，移位等等) 后就必须要把结果写回到 [内存](https://zh.wikipedia.org/wiki/記憶體)，也许马上就得读回来。然而存取主存的速度是比从[算术逻辑单元](https://zh.wikipedia.org/wiki/算术逻辑单元)到有直接路径的累加器存取更慢。\n\n## [请你说一说线程间的同步方式，最好说出具体的系统调用]([操作系统面试 | qianxunslimgのblog](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#线程间的同步方式，最好说出具体的系统调用))\n\n==信号量==\n\n信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：\n\nP(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。 ==消费==线程 \n\n> 假设sv = 1, sv大于0表示有苹果 可以吃  --， 然后sv = 0还想吃 则挂起\n\nV(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。 ==生产==线程\n\n其系统调用为：\n\nsem_wait（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。\n\nsem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。\n\n \n\n==互斥量==\n\n互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：\n\npthread_mutex_init:初始化互斥锁\n\npthread_mutex_destroy：销毁互斥锁\n\npthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。\n\npthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。\n\n \n\n==条件变量==\n\n条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：\n\npthread_cond_init:初始化条件变量\n\npthread_cond_destroy：销毁条件变量\n\npthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。\n\npthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。\n\n## 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？\n\n游戏服务器应该为每个用户开辟一个==<u>进程</u>==。\n\n因为同一进程间的线程会`相互影响`，一个线程死掉会影响其他线程，从而`导致进程崩溃`。因此<u>为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</u>\n\n## [请你说一说OS缺页置换算法](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#8-11-OS缺页置换算法)\n\n当访问一个内存中不存在的页，并且==<u>内存已满</u>==，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：\n\n1. `先进先出(FIFO)算法`：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。  ==（那最早调入的替换掉）==\n\n2. `最近最少使用（LRU）算法`: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。  ==（替换最长时间没有使用的页面）==\n3. `最佳置换算法（OPT）算法`：最佳置换算法是由 **Belady** 于1966年提出的一种理论上的算法。`每次选择以后永不使用的`， 或许是在最长(未来)时间内不再被访问的页面的页面被淘汰。显然OPT算法是`最优`的，但是在实际操作往往无法预知未来，所以OPT只存在理论而`不能真的实现`，通常用于衡量其他置换算法的优劣。\n4. `时钟置换（Clock/NRU）算法`：也称为NRU算法（最近未使用算法）是LRU和FIFO的折中算法。\n\n当前最常采用的就是LRU算法。\n\n## 请你说一下多进程和多线程的使用场景\n\n多进程模型的优势是`CPU`，适用于`CPU密集型`。同时，多进程模型也适用于`多机分布式场景`中，易于多机扩展。\n\n多线程模型主要优势为`线程间切换代价较小`，因此适用于`I/O密集型`的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于`单机多核分布式场景`。\n\n## 请你说一说死锁发生的条件以及如何解决死锁\n\n**死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：**\n\n- 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；  （`互斥指的是资源的互斥 只能一个进程访问`）\n- 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源  （`我阻塞 但我不放手自己的资源`）\n- 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放  （`资源只能我自己释放`）\n- 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链  （`我需要你的 你需要他 他需要我...`）\n\n**解决死锁的方法即破坏上述四个条件之一，主要方法如下：**\n\n- 资源`一次性分配`，从而剥夺请求和保持条件\n- `可剥夺`资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件\n- 资源`有序分配`法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件\n\n## 请问虚拟内存和物理内存怎么对应\n\n### 概念：\n\n#### 物理地址(physical address)\n\n- <u>用于内存芯片级的单元寻址</u>，与`处理器`和`CPU连接的地址总线`相对应。\n\n- 虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。\n\n#### 虚拟地址(virtual memory)\n\n- 这是对整个内存（不要与机器上插那条对上号）的抽像描述。它是相对于物理内存来讲的，可以直接理解成“不直实的”，“假的”内存，例如，一个0x08000000内存地址，它并不对就物理地址上那个大数组中0x08000000 - 1那个地址元素；\n\n- 之所以是这样，是因为现代操作系统都提供了一种内存管理的抽像，即虚拟内存（virtual memory）。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。这个“转换”，是所有问题讨论的关键。\n\n- 有了这样的抽像，一个程序，就可以使用比`真实物理地址大得多的地址空间`。<u>甚至多个进程可以使用相同的地址。不奇怪，因为</u>`转换后的物理地址并非相同的`。\n\n- ——可以把连接后的程序反编译看一下，发现连接器已经为程序分配了一个地址，例如，要调用某个函数A，代码不是call A，而是call 0x0811111111 ，也就是说，函数A的地址已经被定下来了。没有这样的“转换”，没有虚拟地址的概念，这样做是根本行不通的。\n\n### 地址转换\n\n第一步：CPU段式管理中——`逻辑地址转线性地址`\n\nCPU要利用其段式内存管理单元，先将为个逻辑地址转换成一个线程地址。\n\n一个逻辑地址由两部份组成，【段标识符：段内偏移量】。\n\n段标识符是由一个16位长的字段组成，称为段选择符。其中前13位是一个索引号。后面3位包含一些硬件细节，如图：\n\n![image-20220418213541912](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418213541912.png)\n\n通过段标识符中的索引号从GDT或者LDT找到该段的段描述符，段描述符中的base字段是段的起始地址\n\n段描述符：Base字段，它描述了一个段的开始位置的线性地址。\n\n一些全局的段描述符，就放在“`全局段描述符表(GDT)`”中，一些局部的，例如每个进程自己的，就放在所谓的“`局部段描述符表(LDT)`”中。\n\nGDT在内存中的地址和大小存放在CPU的gdtr控制寄存器中，而LDT则在ldtr寄存器中。\n\n段起始地址+ 段内偏移量 = 线性地址\n\n![image-20220418213600791](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418213600791.png)\n\n首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，\n\n1. 看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。\n2. 拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。\n3. 把Base + offset，就是要转换的线性地址了。\n\n![image-20220418213619279](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418213619279.png)\n\n第一步：页式管理——线性地址转物理地址\n\n\n\n再利用其页式内存管理单元，转换为最终物理地址。\n\n\n\nlinux假的段式管理\n\n\n\nIntel要求两次转换，这样虽说是兼容了，但是却是很冗余，但是这是intel硬件的要求。\n\n\n\n其它某些硬件平台，没有二次转换的概念，Linux也需要提供一个高层抽像，来提供一个统一的界面。\n\n\n\n所以，Linux的段式管理，事实上只是“哄骗”了一下硬件而已。\n\n\n\n按照Intel的本意，全局的用GDT，每个进程自己的用LDT——不过Linux则对所有的进程都使用了相同的段来对指令和数据寻址。即用户数据段，用户代码段，对应的，内核中的是内核数据段和内核代码段。\n\n\n\n在Linux下，逻辑地址与线性地址总是一致的，即逻辑地址的偏移量字段的值与线性地址的值总是相同的。\n\n\n\nlinux页式管理\n\n\n\nCPU的页式内存管理单元，负责把一个线性地址，最终翻译为一个物理地址。\n\n\n\n线性地址被分为以固定长度为单位的组，称为页(page)，例如一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。\n\n\n\n另一类“页”，我们称之为物理页，或者是页框、页桢的。是分页单元把所有的物理内存也划分为固定长度的管理单位，它的长度一般与内存页是一一对应的。\n\n![image-20220418213640314](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418213640314.png)\n\n每个进程都有自己的页目录，当进程处于运行态的时候，其页目录地址存放在cr3寄存器中。\n\n\n\n每一个32位的线性地址被划分为三部份，【页目录索引(10位)：页表索引(10位)：页内偏移(12位)】\n\n\n\n依据以下步骤进行转换：\n\n从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；\n\n\n\n根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。\n\n\n\n根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；\n\n\n\n将页的起始地址与线性地址中最后12位相加。\n\n\n\n### 目的：\n\n内存节约：如果一级页表中的一个页表条目为空，那么那所指的二级页表就根本不会存在。这表现出一种巨大的潜在节约，因为对于一个典型的程序，4GB虚拟地址空间的大部份都会是未分配的；\n\n![image-20220418213740427](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418213740427.png)\n\n32位，PGD = 10bit，PUD = PMD = 0，table = 10bit，offset = 12bit\n\n64位，PUD和PMD ≠ 0\n\n## [请你说一说操作系统中的结构体对齐，字节对齐](https://qianxunslimg.github.io/2022/03/16/cao-zuo-xi-tong-ba-gu/#10-4-说操作系统中的结构体对齐，字节对齐)","tags":["面试"]},{"title":"排序算法","url":"/2022/04/17/pai-xu-suan-fa/","content":"\n# 排序算法\n\n| **排序方法**         | **平均时间** | **最好时间** | **最坏时间** |\n| -------------------- | ------------ | ------------ | ------------ |\n| 桶排序(不稳定)       | O(n)         | O(n)         | O(n)         |\n| 基数排序(稳定)       | O(n)         | O(n)         | O(n)         |\n| 归并排序(==稳定==)   | `O(nlogn)`   | `O(nlogn)`   | `O(nlogn)`   |\n| 快速排序(==不稳定==) | `O(nlogn)`   | `O(nlogn)`   | `O(n^2^)`    |\n| 堆排序(不稳定)       | O(nlogn)     | O(nlogn)     | O(nlogn)     |\n| 希尔排序(不稳定)     | O(n^1.25^)   |              |              |\n| 冒泡排序(稳定)       | O(n^2^)      | O(n)         | O(n^2^)      |\n| 选择排序(不稳定)     | O(n^2^)      | O(n^2^)      | O(n^2^)      |\n| 直接插入排序(稳定)   | O(n^2^)      | O(n)         | O(n^2^)      |\n\n## `桶排序`\n\n[桶排序](https://wiki.jikexueyuan.com/project/easy-learn-algorithm/bucket-sort.html)是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：\n\n1. 在额外空间充足的情况下，尽量增大桶的数量\n2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n\n同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。\n\n### 1. 什么时候最快\n\n当输入的数据可以均匀的分配到每一个桶中。\n\n### 2. 什么时候最慢\n\n当输入的数据被分配到了同一个桶中。\n\n### 3. 示意图\n\n元素分布在桶中：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/Bucket_sort_1.svg_.png)\n\n然后，元素在每个桶中排序：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/Bucket_sort_2.svg_.png)\n\n代码：\n\n````c++\n\n#include <iostream>\n#include <iterator>\n#include <vector>\nusing namespace std;\nconst int BUCKET_NUM = 10;\n\nstruct ListNode {\n\texplicit ListNode(int i = 0) : mData(i), mNext(NULL) {}\n\tListNode *mNext;\n\tint mData;\n};\n\n//有序链表插入val\nListNode *insert(ListNode *head, int val) {\n\tListNode dummyNode;\n\tListNode *newNode = new ListNode(val);\n\tListNode *pre, *curr;\n\tdummyNode.mNext = head;\n\tpre = &dummyNode;\n\tcurr = head;\n\twhile (NULL != curr && curr->mData <= val) {\n\t\tpre = curr;\n\t\tcurr = curr->mNext;\n\t}                      // 找到第一个大于val的node curr\n\tnewNode->mNext = curr; //插入val\n\tpre->mNext = newNode;  //拼接\n\treturn dummyNode.mNext;\n}\n\n//合并两个有序链表\nListNode *Merge(ListNode *head1, ListNode *head2) {\n\tListNode dummyNode;\n\tListNode *dummy = &dummyNode;\n\twhile (NULL != head1 && NULL != head2) {\n\t\tif (head1->mData <= head2->mData) {\n\t\t\tdummy->mNext = head1;\n\t\t\thead1 = head1->mNext;\n\t\t}\n\t\telse {\n\t\t\tdummy->mNext = head2;\n\t\t\thead2 = head2->mNext;\n\t\t}\n\t\tdummy = dummy->mNext;\n\t}\n\tif (NULL != head1)\n\t\tdummy->mNext = head1;\n\tif (NULL != head2)\n\t\tdummy->mNext = head2;\n\n\treturn dummyNode.mNext;\n}\n\nvoid BucketSort(int n, int arr[]) {\n\tvector<ListNode *> buckets(BUCKET_NUM, (ListNode *)(0));\n\tfor (int i = 0; i < n; ++i) {\n\t\tint index = arr[i] / BUCKET_NUM;\n\t\tListNode *head = buckets.at(index);\n\t\tbuckets.at(index) = insert(head, arr[i]);\n\t}\n\tListNode *head = buckets.at(0);\n\tfor (int i = 1; i < BUCKET_NUM; ++i) {\n\t\thead = Merge(head, buckets.at(i));\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tarr[i] = head->mData;\n\t\thead = head->mNext;\n\t}\n}\n\n````\n\n```c++\n\t//桶排序\n\tvoid bucketsort(int* A, int n) {\n\t\tvector<vector<int>> bucket(10);   //分配10个桶（0~9、10~19...）\n\t\tfor (int i = 0; i < 10; i++) {    //每个桶初始化\n\t\t\tvector<int> x = { 0 };\n\t\t\tbucket.push_back(x);\n\t\t}\n\t\t//把待排序列放入桶中\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbucket[A[i] / 10].push_back(A[i]); //10 桶大小\n\t\t}\n\t\t//把每个桶内的数据填充回到原序列中\n\t\tint k = 0;\n\t\tfor (int i = 0; i < 10; i++) {   \n\t\t\tsort(bucket[i].begin(), bucket[i].end());  //桶内排序\n\t\t\tfor (vector<int>::iterator it = bucket[i].begin(); it != bucket[i].end(); it++)\n\t\t\t\tA[k++] = *it;\t\n\t\t}\n\t}\n```\n\n\n\n## 冒泡排序\n\n冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢\"浮\"到数列的顶端。\n\n作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来\n\n说并没有什么太大作用。\n\n### 1. 算法步骤\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\n针对所有的元素重复以上的步骤，除了最后一个。\n\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n### 2. 动图演示\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bubbleSort.gif)\n\n每次遍历都会把极大值固定在最右侧，所以不需要完整的两个for\n\n### 3. 什么时候最快\n\n当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。\n\n### 4. 什么时候最慢\n\n当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。\n\n### 5. 代码\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename T> //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(>)运算符\nvoid bubble_sort(T arr[], int len) {\n        int i, j;\n        for (i = 0; i < len - 1; i++)\n                for (j = 0; j < len - 1 - i; j++)\n                        if (arr[j] > arr[j + 1])\n                                swap(arr[j], arr[j + 1]);\n}\nint main() {\n        int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };\n        int len = (int) sizeof(arr) / sizeof(*arr);\n        bubble_sort(arr, len);\n        for (int i = 0; i < len; i++)\n                cout << arr[i] << ' ';\n        cout << endl;\n        float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };\n        len = (float) sizeof(arrf) / sizeof(*arrf);\n        bubble_sort(arrf, len);\n        for (int i = 0; i < len; i++)\n                cout << arrf[i] << ' '<<endl;\n        return 0;\n}\n```\n\n#### [可视化](https://visualgo.net/en/sorting)\n\n```c++\nvoid bubbleSort(vector<int> &nums) {\n  int n = nums.size();\n  bool swapped;\n  do {\n    swapped = 0;\n    for (int i = 0; i < n - 1; i++) {\n      if (nums[i] > nums[i + 1]) {\n        swap(nums[i], nums[i + 1]);\n        swapped = 1;\n      }\n    }\n  } while (swapped);\n}\n\n```\n\n\n\n## `快速排序`\n\n### 1. 算法步骤\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n### 2. [动图演示](https://www.bilibili.com/video/BV1at411T75o)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/quickSort.gif)\n\n### 3. 代码 （二叉树的前序遍历）\n\n```c++\n//分割函数\nint paritition(vector<int>& A, int low, int high){\n    int pivotValue = A[low];\n    while(low<high){\n        while(low<high && A[high] >= pivotValue)\n            --high;  //从右向左查找到第一个小于pivot的坐标\n        A[low] = A[high];\n        while(low<high && A[low] <= pivotValue)\n            ++low;   //从左向右查找到第一个大于pivot的坐标\n        A[high] = A[low];\n    }\n    A[low] = pivotValue; //拿走的值返还 放到排序的位置\n    return low;   //返回的是一个位置\n    \n}\n\n// 洗牌算法，将输入的数组随机打乱 避免极端情况\nvoid shuffle(vector<int>& nums){\n    srand(time(0)); //随机数种子是必须有的? 因为一次shuffle函数调用 多次rand\n    for(int i = 0; i<nums.size(); i++){\n        int r = i + rand()%(nums.size() - i)\n        swap(nums[i], nums[r]);\n    }\n}\n\n//快排母函数\nvoid quickSort(vector<int>& A, int low, int high){\n    if(low<high){\n        int pivotIndex = paritition(A, low, high);\n        quickSort(A, low, pivotIndex-1);\n        quickSort(A, pivotIndex+1, high);\n    }\n}\n```\n\n从大到小排序修改\n\n```c++\n    //分割函数\n    int Paritition(vector<int>& A, int low, int high){\n        int pivot = A[low];\n        while(low<high){\n            while(low<high && A[high] <= pivot) //<=\n                --high;\n            A[low] = A[high];\n            while(low<high && A[low] >= pivot)  //>=\n                ++low;\n            A[high] = A[low];\n        }\n        A[low] = pivot;  //拿走的值返还 放到排序的位置\n        return low;  //返回的是一个位置\n    }\n```\n\n\n\n### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=215&target=gitee)[思路](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/#)\n\n难度中等1553\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n\n \n\n**示例 1:**\n\n```\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n```\n\n**示例 2:**\n\n```\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n```\n\n**提示：**\n\n- `1 <= k <= nums.length <= 104`\n- `-104 <= nums[i] <= 104`\n\n思路： \n\n1. 快速排序  洗牌算法打乱原数组\n2. 明确排序区间 分治 以及 及时返回\n\n```c++\n//快速排序\nclass Solution {\npublic:\n    //分割函数\n    int Paritition(vector<int>& A, int low, int high){\n        int pivot = A[low];\n        while(low<high){\n            while(low<high && A[high] >= pivot)\n                --high;\n            A[low] = A[high];\n            while(low<high && A[low] <= pivot)\n                ++low;\n            A[high] = A[low];\n        }\n        A[low] = pivot;  //拿走的值返还 放到排序的位置\n        return low;  //返回的是一个位置\n    }\n\n    void quickSort(vector<int>& A, int low, int high){\n        if(low<high){\n            int pivot = Paritition(A, low, high);\n            //注意 每一次快排都会确定一个位置，位置满足时，直接返回\n            if(pivot == A.size()-k) \n                return;\n\n            //优化排序区间 有点类似于二分查找了\n            if(pivot>= A.size() - k)\n                quickSort(A, low, pivot-1);\n            else quickSort(A, pivot+1, high);\n        }\n    }\n    int k;\n    int findKthLargest(vector<int>& nums, int k) {\n        this->k = k;\n        shuffle(nums);\n        quickSort(nums, 0, nums.size()-1);\n        return nums[nums.size()-k];\n    }\n\n    // 洗牌算法，将输入的数组随机打乱 避免极端情况\n    void shuffle(vector<int>& nums){\n        srand(time(0));\n        for(int i = 0; i<nums.size(); i++){\n            int r = i + rand()%(nums.size() - i);\n            swap(nums[i], nums[r]);\n        }\n    }\n};\n```\n\n从大到小\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n      shuffel(nums);\n      quickSort(nums, 0, nums.size() - 1, k);\n      for(int num : nums) cout<<num<<\" \";\n      return nums[k - 1];\n    }\n\n    void quickSort(vector<int>& nums, int left, int right, int k){\n      if(left < right){\n        int pivotIndex = paritation(nums, left, right);\n        if(pivotIndex > k - 1)\n          quickSort(nums, left, pivotIndex - 1, k);\n        else if(pivotIndex < k - 1)\n          quickSort(nums, pivotIndex + 1, right, k);\n        else return;\n      }\n    }\n\n    int paritation(vector<int>& nums, int left, int right){\n      int pivotVal = nums[left];\n      while(left < right){\n        while(left < right && nums[right] <= pivotVal){\n          right--;\n        }\n        nums[left] = nums[right];\n\n        while(left < right && nums[left] >= pivotVal){\n          left++;\n        }\n        nums[right] = nums[left];\n      }\n      nums[left] = pivotVal;\n      return left;\n    }\n\n    void shuffel(vector<int>& nums){\n      int n = nums.size();\n      for(int i = 0; i<n; i++){\n        int j = i + rand()%(n - i);\n        swap(nums[i], nums[j]);\n      }\n    }\n};\n```\n\n\n\n## `归并排序`\n\n归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。\n\n作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n- 自下而上的迭代；\n\n在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：\n\n> However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.\n>\n> 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。\n\n说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。\n\n### 1. 算法步骤\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n4. 重复步骤 3 直到某一指针达到序列尾；\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n### 2. 动图演示\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/mergeSort.gif)\n\n### 3. 代码 （二叉树的后序遍历）\n\n迭代：\n\n```c++\ntemplate<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(<)的運算子功能\nvoid merge_sort(T arr[], int len) {\n    T *a = arr;\n    T *b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\n```\n\n递归：\n\n````c++\nclass Solution {\n    vector<int> tmp;\n    void mergeSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        int mid = (l + r) >> 1;\n        mergeSort(nums, l, mid);\n        mergeSort(nums, mid + 1, r);\n        \n        //后序遍历的代码位置\n        int i = l, j = mid + 1;\n        int cnt = 0;\n        while (i <= mid && j <= r) {\n            if (nums[i] <= nums[j]) {\n                tmp[cnt++] = nums[i++];\n            }\n            else {\n                tmp[cnt++] = nums[j++];\n            }\n        }\n        while (i <= mid) {\n            tmp[cnt++] = nums[i++];\n        }\n        while (j <= r) {\n            tmp[cnt++] = nums[j++];\n        }\n        for (int i = 0; i < r - l + 1; ++i) {\n            nums[i + l] = tmp[i];\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        tmp.resize((int)nums.size(), 0);\n        mergeSort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n````\n\n`更好理解的一个写法` 记这个吧 反正都是需要开辟新的空间\n\n```c++\nvoid merge(vector<int> &nums, int left, int mid, int right) {\n\t// preconditions:\n\t// nums[left, mid] is sorted\n\t// nums[mid + 1, right] is sorted\n\t// Copy nums[left ... mid] to LeftSubNums\n\t// Copy nums[mid+1 ... end] to RightSubNums\n\tvector<int> LeftSubNums(nums.begin() + left, nums.begin() + mid + 1);\n\tvector<int> RightSubNums(nums.begin() + mid + 1, nums.begin() + right + 1);\n\tint indexLeft = 0, indexRight = 0;\n\tLeftSubNums.insert(LeftSubNums.end(), INT_MAX);\n\tRightSubNums.insert(RightSubNums.end(), INT_MAX);\n\t// Pick min of LeftSubnums[idxLeft] and RightSubnums[idxRight], and put into nums[i]\n\tfor (int i = left; i <= right; i++) {\n\t\tif (LeftSubNums[indexLeft] < RightSubNums[indexRight]) {\n\t\t\tnums[i] = LeftSubNums[indexLeft];\n\t\t\tindexLeft++;\n\t\t}\n\t\telse {\n\t\t\tnums[i] = RightSubNums[indexRight];\n\t\t\tindexRight++;\n\t\t}\n\t}\n}\n\nvoid mergeSort(vector<int> &nums, int left, int right) {\n\tif (left >= right)\n\t\treturn;\n\tint mid = left + (right - left) / 2;\n\tmergeSort(nums, left, mid);\n\tmergeSort(nums, mid + 1, right);\n\tmerge(nums, left, mid, right);\n}\n```\n\n### [剑指 Offer II 077. 链表排序](https://leetcode-cn.com/problems/7WHec2/)\n\n难度中等53\n\n给定链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。\n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/sort_list_1.jpg)\n\n```\n输入：head = [4,2,1,3]\n输出：[1,2,3,4]\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/sort_list_2.jpg)\n\n```\n输入：head = [-1,5,3,4,0]\n输出：[-1,0,3,4,5]\n```\n\n**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n\n\n\n进阶的话就是归并排序实现了，数组的归并排序需要用到额外的空间 而链表的归并则不需要\n\n#### 方法1\n\n自上而下的进行归并排序\n\n```c++\nclass Solution {\npublic:\n    ListNode* mergeTwo(ListNode* head1, ListNode* head2){\n      ListNode dumpyNode;\n      ListNode* dumpy = &dumpyNode;\n      while(head1 != nullptr && head2 != nullptr){\n        if(head1->val <head2->val){\n          dumpy->next = head1;\n          head1 = head1->next;\n        }else{\n          dumpy->next = head2;\n          head2 = head2->next;\n        } \n        dumpy = dumpy->next;\n      }\n      dumpy->next = head1?head1:head2;\n      return dumpyNode.next;\n    }\n\n    ListNode* sortList(ListNode* head, ListNode* tail){\n      if(head == nullptr) return head;\n      if(head->next == tail){\n        head->next = nullptr;\n        return head;\n      }\n      ListNode* slow = head, *fast = head;\n      while(fast!= tail && fast->next != tail){\n        fast = fast->next->next;\n        slow = slow->next;\n      }\n      ListNode* mid = slow;\n      return mergeTwo(sortList(head, mid), sortList(mid, tail));\n    }\n\n    ListNode* sortList(ListNode* head) {\n      return sortList(head, nullptr);\n    }\n};\n```\n\n### [剑指 Offer II 078. 合并排序链表](https://leetcode-cn.com/problems/vvXgSW/)\n\n难度困难37\n\n给定一个链表数组，每个链表都已经按升序排列。\n\n请将所有链表合并到一个升序链表中，返回合并后的链表。\n\n \n\n**示例 1：**\n\n```\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n```\n\n#### 方法1\n\n暴力merge2\n\n```c++\nclass Solution {\npublic:\n    ListNode* mergeTwo(ListNode* head1, ListNode* head2){\n      ListNode dumpy;\n      ListNode* dumpyNode = &dumpy;\n      while(head1 && head2){\n        if(head1->val <= head2->val){\n          dumpyNode->next = head1;\n          head1 = head1->next;\n        }else{\n          dumpyNode->next = head2;\n          head2 = head2->next;\n        }\n        dumpyNode = dumpyNode->next;\n      }\n      dumpyNode->next = head1?head1:head2;\n      return dumpy.next;\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n      if(lists.empty()) return nullptr;\n      ListNode dumpy;\n      dumpy.next = lists[0];\n      for(int i = 1; i<lists.size(); i++){\n        dumpy.next = mergeTwo(lists[i], dumpy.next);\n      }\n      return dumpy.next;\n    }\n};\n```\n\n#### 方法2\n\n多路归并\n\n```c++\nclass Solution {\npublic:\n    ListNode* mergeTwo(ListNode* head1, ListNode* head2){\n      ListNode dumpy;\n      ListNode* dumpyNode = &dumpy;\n      while(head1 && head2){\n        if(head1->val <= head2->val){\n          dumpyNode->next = head1;\n          head1 = head1->next;\n        }else{\n          dumpyNode->next = head2;\n          head2 = head2->next;\n        }\n        dumpyNode = dumpyNode->next;\n      }\n      dumpyNode->next = head1?head1:head2;\n      return dumpy.next;\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n      if(lists.empty()) return nullptr;\n      return mergeK(lists, 0, lists.size() - 1);\n    }\n\n    ListNode* mergeK(vector<ListNode*>& lists, int left, int right){\n      if(left == right) return lists[left];\n      if(left > right) return nullptr;\n      int mid = left + (right - left)/2;\n      ListNode* l1 = mergeK(lists, left, mid);\n      ListNode* l2 = mergeK(lists, mid + 1, right);\n      return mergeTwo(l1, l2);\n    }\n};\n```\n\n\n\n## 选择排序\n\n选择排序是一种简单直观的排序算法，<u>无论什么数据进去都是 `O(n²)` 的时间复杂度</u>。所以用到它的时候，`数据规模越小越好`。唯一的好处可能就是不占用额外的内存空间了吧。\n\n### 1. 算法步骤\n\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n重复第二步，直到所有元素均排序完毕。\n\n### 2. 动图演示\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/selectionSort.gif)\n\n```c++\ntemplate<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能\nvoid selection_sort(std::vector<T>& arr) {\n  for (int i = 0; i < arr.size() - 1; i++) {\n    int minIndex = i;\n    for (int j = i + 1; j < arr.size(); j++)\n      if (arr[j] < arr[minIndex])\n        minIndex = j;  //找到其他元素中的最小值对应的index\n    std::swap(arr[i], arr[minIndex]);  //交换\n  }\n}\n```\n\n## 插入排序\n\n插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，<u>在已排序序列中从后向前扫描，找到相应位置并插入</u>。\n\n插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。\n\n### 1. 算法步骤\n\n将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n### 2. 动图演示\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/insertionSort.gif)\n\n```c++\nvoid insertion_sort(vector<int> &nums) {\n  int n = nums.size();\n  for (int i = 0; i < n; i++) {\n    int key = nums[i]; //拿出来比较的元素\n    int j = i - 1;\n    //在排序好的元素中找第一个小于当前值的index\n    while ((j >= 0) && (key < nums[j])) {\n      nums[j + 1] = nums[j];\n      j--;\n    }\n    nums[j + 1] = key;\n  }\n}\n```\n\n# [STL里sort算法用的是什么排序算法？](https://zhuanlan.zhihu.com/p/36274119)\n\n### 正确答案\n\n**毫无疑问是用到了快速排序，但不仅仅只用了快速排序，还结合了插入排序和堆排序。**\n\n### 并非所有容器都使用sort算法\n\n既然问的是STL的sort算法实现，那么先确认一个问题，`哪些STL容器需要用到sort算法？`\n\n- 首先，关系型容器拥有自动排序功能，因为底层采用RB-Tree，所以不需要用到sort算法。\n- 其次，序列式容器中的stack、queue和priority-queue都有特定的出入口，不允许用户对元素排序。\n- 剩下的`vector、deque`，适用sort算法。\n\n### 实现逻辑\n\nSTL的sort算法，数据量大时采用**QuickSort快排算法**，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用**Insertion Sort插入排序**。如果递归层次过深，还会改用**HeapSort堆排序**。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-8fa032e195365f77fb6b980a4ed71958_r.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n结合`快速排序-插入排序-堆排序` 三种排序算法。\n\n### 具体代码\n\n源文件：`/usr/include/c++/4.2.1/bits/stl_algo.h`\n\n```c++\ntemplate<typename _RandomAccessIterator>\n    inline void\n    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n        _ValueType;\n\n      // concept requirements\n      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n            _RandomAccessIterator>)\n      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n      __glibcxx_requires_valid_range(__first, __last);\n\n      if (__first != __last)\n        {\n        //快速排序+插入排序\n          std::__introsort_loop(__first, __last,\n                                std::__lg(__last - __first) * 2);\n        //插入排序\n          std::__final_insertion_sort(__first, __last);\n        }\n    }\n```\n\n其中`__lg`函数是计算递归深度，用来控制分割恶化，当递归深度达到该值改用堆排序，因为堆排序是时间复杂度恒定为nlogn：\n\n```c++\ntemplate<typename _Size>\n    inline _Size\n    __lg(_Size __n)\n    {\n      _Size __k;\n      for (__k = 0; __n != 1; __n >>= 1)\n        ++__k;\n      return __k;\n    }\n```\n\n先来看，`__introsort_loop` 快排实现部分：对于区间小于`16`的采用快速排序，如果递归深度恶化改用`堆排序`。\n\n```c++\ntemplate<typename _RandomAccessIterator, typename _Size>\n    void\n    __introsort_loop(_RandomAccessIterator __first,\n                     _RandomAccessIterator __last,\n                     _Size __depth_limit)\n    {\n      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n        _ValueType;\n    //_S_threshold=16，每个区间必须大于16才递归\n      while (__last - __first > int(_S_threshold))\n        {\n        //达到指定递归深度，改用堆排序\n          if (__depth_limit == 0)\n            {\n              std::partial_sort(__first, __last, __last);\n              return;\n            }\n          --__depth_limit;\n          _RandomAccessIterator __cut =\n            std::__unguarded_partition(__first, __last,\n                                       _ValueType(std::__median(*__first,\n                                                                *(__first\n                                                                  + (__last\n                                                                     - __first)\n                                                                  / 2),\n                                                                *(__last\n                                                                  - 1))));\n          std::__introsort_loop(__cut, __last, __depth_limit);\n          __last = __cut;\n        }\n    }\n```\n\n再来看`插入排序`部分：\n\n```c++\ntemplate<typename _RandomAccessIterator>\n    void\n    __final_insertion_sort(_RandomAccessIterator __first,\n                           _RandomAccessIterator __last)\n    {\n      if (__last - __first > int(_S_threshold))\n        {\n        //先排前16个\n          std::__insertion_sort(__first, __first + int(_S_threshold));\n        //后面元素遍历插入到前面有序的正确位置 \n         std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);\n        }\n      else\n        std::__insertion_sort(__first, __last);\n    }\n```\n\n为什么用插入排序？因为插入排序在面对“几近排序”的序列时，表现更好。\n\n# [稳定排序和不稳定排序](https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html)\n\n   首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序`前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同`。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。\n\n   其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。\n\n1. 冒泡排序\n\n- 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n\n2. 选择排序\n\n- 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。\n\n3. 插入排序\n\n- 插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。\n\n4. 快速排序\n\n- 快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j，交换a[i]和a[j],重复上面的过程，直到i > j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。\n\n  <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220519112534018.png\" alt=\"image-20220519112534018\" style=\"zoom:50%;\" />\n\n  <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220519112602999.png\" alt=\"image-20220519112602999\" style=\"zoom:50%;\" />\n\n5. 归并排序\n\n- 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。\n\n6. 基数排序\n\n- 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。\n\n7. 希尔排序(shell)\n\n- 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。\n\n8. 堆排序\n\n- 我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。\n\n综上，得出结论: **选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法**","tags":["算法总结"]},{"title":"树","url":"/2022/04/16/shu/","content":"\n# 二叉树\n\n## 二叉树的遍历\n\n### 1. 概念\n\n树是连通的无环图，最常利用的有二叉树，即一个节点最多只有两个子节点，称为左子树和右子树。但是树都是相通的，无论是二叉树或者多个节点的树都能一般能用递归方法进行求解。二叉树节点之间的顺序一般不可调换，在数据结构定义时，左是左，右是右，不会说节点1，节点2。\n\n#### 二叉排序树又叫二叉查找树或者二叉搜索树：\n\n1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；\n\n2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n3）左、右子树也分别为二叉排序树；4）没有键值相等的节点\n\n### 2. 树的各种DFS遍历\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20211204202223075-1835072711.png\" alt=\"img\" style=\"zoom: 80%;\" />\n\n前序遍历，根-->左子树-->右子树\n\n中序遍历，左子树-->根-->右子树\n\n后序遍历，左子树-->右子树-->根\n\n前序/后序+中序能够确定一个完整的树结构，因为前序/后序的根在第一位/最后一位，这样在中序中找到对应的根节点，以此递归，具体的题见leetCode105、106\n\n#### 深度优先遍历（Depth First Search，DFS，主要有三种子方法，前中后序遍历）\n\n前中后序遍历的递归写法\n\n```c++\nclass Solution {\npublic:\n    //前序遍历：\n    void traversal(TreeNode* cur, vector<int>& vec) {\n        if (cur == NULL) return;\n        vec.push_back(cur->val);    // 中\n        traversal(cur->left, vec);  // 左\n        traversal(cur->right, vec); // 右\n    }\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        traversal(root, result);\n        return result;\n    }\n};\n//中序遍历：\nvoid traversal(TreeNode* cur, vector<int>& vec) {\n    if (cur == NULL) return;\n    traversal(cur->left, vec);  // 左\n    vec.push_back(cur->val);    // 中\n    traversal(cur->right, vec); // 右\n}\n//后序遍历：\nvoid traversal(TreeNode* cur, vector<int>& vec) {\n    if (cur == NULL) return;\n    traversal(cur->left, vec);  // 左\n    traversal(cur->right, vec); // 右\n    vec.push_back(cur->val);    // 中\n}\n```\n\n### 3.树的广度优先遍历\n\n#### 广度优先遍历（Breadth FirstSearch，BFS,实际上就是逐层查找，又叫层次遍历，宽度优先搜索或横向优先搜索）\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        queue<TreeNode*> que;\n        if (root != NULL) que.push(root);\n        vector<vector<int>> result;\n        while (!que.empty()) {\n            int size = que.size();\n            vector<int> vec;\n            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                vec.push_back(node->val);\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n            result.push_back(vec);\n        }\n        return result;\n    }\n};\n```\n\n\n\n## 二叉树的前序遍历\n\n前中后序 不再赘述\n\n有道题感觉挺有意思\n\n### [剑指 Offer II 049. 从根节点到叶节点的路径数字之和](https://leetcode-cn.com/problems/3Etpl5/)\n\n难度中等21\n\n给定一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。\n\n计算从根节点到叶节点生成的 **所有数字之和** 。\n\n**叶节点** 是指没有子节点的节点。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/num1tree.jpg)\n\n```\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/num2tree.jpg)\n\n```\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n```\n\n#### 思路\n\n1. 保存在每一个节点状态的 preSum 当最后左右子为空时 加到ans中\n2. 注意 不是node == nullptr时加 因为可能一个叶子节点为空 重复加了\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int ans;\n    int sumNumbers(TreeNode* root) {\n        ans = 0; \n        preOrder(root, 0);\n        return ans;\n    }\n\n    void preOrder(TreeNode* node, int preSum){\n        if(node == nullptr) return;\n\n        int total = preSum*10 + node->val;\n        if(node->left == nullptr && node->right == nullptr){\n            ans += total;\n            return;\n        }\n        preOrder(node->left, total);\n        preOrder(node->right, total);\n    }\n};\n```\n\n#### `思考`\n\n前序遍历可以按 根左右的顺序保存每个节点的值， 那么怎么才能输入 这道题中的每道数组成的数组序列呢？或者说 回溯在哪里？\n\n如上的要求可以 不优雅的通过`传值`实现\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> all;\n    void getAllPaths(TreeNode* root) {\n        all.clear();\n        vector<int> path;\n        preOrder(root, path);\n\n        for(int i = 0; i<all.size(); i++){\n            for(int j = 0; j<all[i].size(); j++){\n                cout<<all[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n    }//示例二输出为 4 9 5 /n   4 9 1 /n   4 0 /n 完全正确\n\n    void preOrder(TreeNode* node, vector<int> path){\n        if(node == nullptr) return;\n        path.push_back(node->val); //压入\n        if(node->left == nullptr && node->right == nullptr){\n            all.push_back(path);\n            return;\n        }\n\n        preOrder(node->left, path);\n        preOrder(node->right, path);\n    }\n};\n```\n\n但是 主要的问题是 回溯（一个path 进行pop）的话 在什么位置进行回溯呢\n\n经过可视化观察 和 思考\n\n##### 得出如下结论：\n\n1. 在每道的最底部 的 节点 需要进行回溯 即path.pop_back();\n2. 在前序遍历程序的结尾 也就是 遍历完右叶子节点后 需要进行回溯\n\n###### 代码实现如下\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> all;\n    vector<int> path;\n    int sumNumbers(TreeNode* root) {\n        all.clear();\n        preOrder(root); //经测试 输出正确 每道叶子路径完整的存储在all中\n    }\n\n    void preOrder(TreeNode* node){\n        if(node == nullptr)\n            return;\n\n        path.push_back(node->val);\n        //每道 最底部的 节点\n        if(node->left == nullptr && node->right == nullptr){\n            all.push_back(path);\n            path.pop_back();\n            return;\n        }\n        preOrder(node->left);\n        preOrder(node->right);\n        path.pop_back();  //右节点后的 回溯\n    }\n};\n```\n\n### [剑指 Offer II 050. 向下的路径节点之和](https://leetcode-cn.com/problems/6eUYwP/)\n\n难度中等32\n\n给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。\n\n**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/pathsum3-1-tree.jpg)\n\n```\n输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n输出：3\n解释：和等于 8 的路径有 3 条，如图所示。\n```\n\n#### 思路\n\n##### 首先实现一个dfs回溯求和函数 这个函数有如下要求\n\n1. 前序遍历求和\n\n2. 回溯减去退出节点的值\n\n此时需要从两个位置进行回溯 一个是`遍历完右节点后回溯` 也就是在dfs函数尾部 还有一个位置是`最底部的节点` 表现出来就是左右子树均为空\n\n##### 然后 究极暴力\n\n前序套前序，以每个节点为根节点求和为targetSum的个数 累加起来\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int bigAns;\n    int ans;\n    int pathSum(TreeNode* root, int targetSum) {\n      bigAns = 0;\n      bigDfs(root, targetSum);\n      return bigAns;\n    }\n\n    //每个节点都当作根节点 查找此节点下的路径和 == targetSum的个数\n    void bigDfs(TreeNode* node, int targetSum){\n      if(node == nullptr) return;\n      int temAns = pathSumBeginWithThisRoot(node, targetSum);\n      bigAns+=temAns;\n      //cout<<temAns<<endl;\n      bigDfs(node->left, targetSum);\n      bigDfs(node->right, targetSum);\n    }\n\n    //深搜根节点起始的路径，直到sum == targetSum\n    int pathSumBeginWithThisRoot(TreeNode* root, int targetSum){\n      ans = 0;\n      int sum = 0;\n      dfs(root, sum, targetSum);\n      return ans;\n    }\n\n    void dfs(TreeNode* node, int& sum, int targetSum){\n      if(node == nullptr) return;\n      \n      sum+=node->val;\n      if(sum == targetSum) ans++;\n      if(node->left == nullptr && node->right == nullptr){\n        sum-=node->val;\n        return;  //这里必须提前return 不然回溯了两遍\n      }\n\n      dfs(node->left, sum, targetSum);\n      dfs(node->right, sum, targetSum);\n      sum-=node->val;\n    }\n};\n```\n\n#### 官方的优雅写法\n\n```c++\nclass Solution {\npublic:\n  \t//以节点 p 为起点向下且满足路径总和为 val 的路径数目\n    int rootSum(TreeNode* root, int targetSum) {\n        if (!root) \n            return 0;\n\n        int ret = 0;\n        if (root->val == targetSum) \n            ret++;\n\n        ret += rootSum(root->left, targetSum - root->val);\n        ret += rootSum(root->right, targetSum - root->val);\n        return ret;\n    }\n\n    int pathSum(TreeNode* root, int targetSum) {\n        if (!root)\n            return 0;\n        \n        int ret = rootSum(root, targetSum);\n        ret += pathSum(root->left, targetSum);\n        ret += pathSum(root->right, targetSum);\n        return ret;\n    }\n};\n```\n\n#### `前缀和`\n\n### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=297)[思路](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/#)\n\n难度困难837\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\n\n```\n输入：root = [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]\n```\n\n```c++\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(root==nullptr){\n            return \"#\";\n        }\n      \t//前序遍历\n        return to_string(root->val) + ' ' + serialize(root->left) + ' ' + serialize(root->right);\n    }\n\n    TreeNode* mydeserialize(istringstream &ss){\n        string tmp;\n        ss>>tmp;\n        if(tmp==\"#\"){\n            return nullptr;\n        }\n        TreeNode* node = new TreeNode(stoi(tmp));\n        node->left = mydeserialize(ss);\n        node->right = mydeserialize(ss);\n        return node;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        istringstream ss(data);\n        return mydeserialize(ss);\n    }\n};\n```\n\n## 二叉树 中序遍历\n\n### [剑指 Offer II 053. 二叉搜索树中的中序后继](https://leetcode.cn/problems/P5rCT8/)\n\n难度中等35\n\n给定一棵二叉搜索树和其中的一个节点 `p` ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 `null` 。\n\n节点 `p` 的后继是值比 `p.val` 大的节点中键值最小的节点，即按中序遍历的顺序节点 `p` 的下一个节点。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/285_example_1.PNG)\n\n```\n输入：root = [2,1,3], p = 1\n输出：2\n解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/285_example_2.PNG)\n\n```\n输入：root = [5,3,6,2,4,null,null,1], p = 6\n输出：null\n解释：因为给出的节点没有中序后继，所以答案就返回 null 了。\n```\n\n#### 解法1 中序dfs\n\n二叉搜索树的中序遍历是递增的 所以搜索到该节点的 后一个就是结果\n\n但是 需要记录当前节点状态\n\n记给定节点及其之前的节点find为0，在找到给定节点时find置1，下一个节点find置2，之后直接返回 停止递归\n\n```c++\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n      TreeNode* res = nullptr;\n      int find = 0;\n      dfs(root, p, find, res);\n      return res;\n    }\n\n    void dfs(TreeNode* node, TreeNode* target, int& find, TreeNode*& res){\n      if(node == nullptr || find == 2) return;\n      dfs(node->left, target, find, res);\n\n      if(find == 1){\n        find = 2;\n        res = node;\n      }\n      if(target == node || target->val == node->val){\n        find = 1;\n      }\n      dfs(node->right, target, find, res);\n    }\n};\n```\n\n#### 解法2 二叉搜索树性质\n\n```c++\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n      TreeNode* res = nullptr;\n      int val = p->val;\n      while(root){\n        if(root->val > val){\n          // 当root->val > val时，会走到左节点，所以走得越深越接近val\n          // 保证了每次root->val都小于res->val\n          res = root;\n          root = root->left;\n        }else{\n          root = root->right;\n        }\n      }\n      return res;\n    }\n};\n```\n\n\n\n## 二叉树 后序遍历\n\n### [543. 二叉树的直径 后序遍历的使用](https://leetcode-cn.com/problems/diameter-of-binary-tree/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=543)[思路](https://leetcode-cn.com/problems/diameter-of-binary-tree/#)\n\n难度简单995\n\n给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n\n \n\n**示例 :**\n给定二叉树\n\n```\n          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n```\n\n返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n\n\n```c++\nclass Solution {\npublic:\n    int res;\n    int diameterOfBinaryTree(TreeNode* root) {\n      res = 0;\n      dfs(root);\n      return res;\n    }\n    //记录\n    int dfs(TreeNode* curr){\n      if(!curr) return 0;\n      int l = dfs(curr->left);// 左儿子为根的子树的深度\n      int r = dfs(curr->right);// 右儿子为根的子树的深度\n      res = max(res,l+r); //更新结果\n      return max(l,r)+1;// 返回该节点为根的子树的深度\n    }\n};\n```\n\n### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n\n[思路](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/#)\n\n难度困难1533英文版讨论区\n\n**路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。\n\n**路径和** 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/exx1.jpg)\n\n```\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/exx2.jpg)\n\n```\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n```\n\n#### 思路\n\n1. 后序遍历实现 和的累积 分别得到每个节点下的最大路径 其左右子节点的最大路径max 当前val相加即为其父节点的最大路径\n2. 当前节点下的最大路径和即为左右子节点的最大路径和  + 自己的val 但不一定是全局最大\n3. 更新全局的一个最大值 为 ans\n\n```c++\nclass Solution {\npublic:\n    int res = INT_MIN;\n    int maxPathSum(TreeNode* root) {\n      dfs(root);\n      return res;\n    }\n\t//返回当前节点下的值最大的一条路径的路径和\n    int dfs(TreeNode* curr){\n      if(!curr) return 0;\n      // 如果子树路径和为负则应当置0表示最大路径不包含子树\n      int leftMax = max(0, dfs(curr->left));\n      int rightMax = max(0, dfs(curr->right));\n      // 判断在该节点包含左右子树的路径和是否大于当前最大路径和\n      res = max(res, leftMax+rightMax+curr->val);\n      return max(leftMax, rightMax) + curr->val; \n    }\n};\n```\n\n## 层序遍历\n\n### [919. 完全二叉树插入器](https://leetcode-cn.com/problems/complete-binary-tree-inserter/)\n\n[思路](https://leetcode-cn.com/problems/complete-binary-tree-inserter/#)\n\n难度中等66\n\n**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。\n\n设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。\n\n实现 `CBTInserter` 类:\n\n- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；\n- `CBTInserter.insert(int v)` 向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；\n- `CBTInserter.get_root()` 将返回树的头节点。\n\n\n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/lc-treeinsert.jpg)\n\n```\n输入\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\n输出\n[null, 1, 2, [1, 2, 3, 4]]\n\n解释\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // 返回 1\ncBTInserter.insert(4);  // 返回 2\ncBTInserter.get_root(); // 返回 [1, 2, 3, 4]\n```\n\n#### 方法\n\n使用层序遍历 从左右子树不满的节点开始存 后续在push的子节点就是左右子树都不存在的了\n\n```c++\nclass CBTInserter {\npublic:\n    TreeNode*mRoot;\n    queue<TreeNode*>que;\n    TreeNode*cur;\n    CBTInserter(TreeNode* root) {\n        mRoot=root;\n        que.push(root);\n        while(que.empty()==false){\n            TreeNode*node=que.front();que.pop();\n            if(node->left)que.push(node->left);\n            if(node->right)que.push(node->right);\n            if(node->left==nullptr||node->right==nullptr){\n                cur=node; //存储当前头节点 后面插入需要插入到他上\n                break;\n            }\n        }\n    }\n    int insert(int val) {\n        if(cur->left==nullptr){\n            cur->left=new TreeNode(val);\n            que.push(cur->left);\n        }else if(cur->right==nullptr){\n            cur->right=new TreeNode(val);\n            que.push(cur->right);\n        }\n        int ans=cur->val;\n        //如果当前节点是满的 那么更新当前节点为队列的后一个\n        if(cur->right){ \n            cur=que.front();que.pop();\n        }\n        return ans;\n    }\n    TreeNode* get_root() {\n        return mRoot;\n    }\n};\n```\n\n\n\n## 枚举构建二叉树\n\n### [894. 所有可能的满二叉树](https://leetcode-cn.com/problems/all-possible-full-binary-trees/)\n\n[思路](https://leetcode-cn.com/problems/all-possible-full-binary-trees/#)\n\n难度中等255\n\n*满二叉树*是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。\n\n返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。\n\n答案中每个树的每个`结点`都**必须**有 `node.val=0`。\n\n你可以按任何顺序返回树的最终列表。\n\n \n\n**示例：**\n\n```\n输入：7\n输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n解释：\n```\n\n![image-20220417231809203](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417231809203.png)\n\n#### 思路\n\n首先`偶数是不能构成满二叉树`的。 思路是把总node数分别左边，根，右边进行递归，如7个node可以分成1,1,5；3,1,5；5,1,1（左,根,右）。 5个node又可以分为1,1,3和3,1,1。 3个node又可以分为1,1,1。 1个node直接返回。\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, vector<TreeNode*>> memo;\n    vector<TreeNode*> allPossibleFBT(int n) {\n        vector<TreeNode*> ans;\n        if(memo.count(n)) return memo[n];\n        if(n == 1) ans.push_back(new TreeNode(0));\n        else{\n            for(int i = 1; i<n; i+=2){\n                // 获得所有可行的左子树集合\n                vector<TreeNode*> left = allPossibleFBT(i);\n                // 获得所有可行的右子树集合\n                vector<TreeNode*> right = allPossibleFBT(n - i - 1);\n                // 相当于 左右子树随机组合 从而得到多种情况 \n                // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上\n                for(auto l : left){\n                    for(auto r : right){\n                        TreeNode* root = new TreeNode(0);\n                        root->left = l;\n                        root->right = r;\n                        ans.push_back(root);\n                    }\n                }\n            }\n        }\n        memo[n] = ans;\n        //cout<<ans.size()<<\" \";\n        return ans;\n    }\n};\n```\n\n### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=96)[思路](https://leetcode-cn.com/problems/unique-binary-search-trees/#)\n\n难度中等1703\n\n给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/uniquebstn3.jpg)\n\n```\n输入：n = 3\n输出：5\n```\n\n#### 思路\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417233328660.png\" alt=\"image-20220417233328660\" style=\"zoom: 50%;\" />\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int numTrees(int n) {\n      vector<int> dp(n+1);\n      dp[0] = 1;\n      for(int i = 1; i<=n; i++){\n        for(int j = 1; j<=i; j++)\n          dp[i]+=dp[j-1]*dp[i-j];\n      }\n      return dp[n];\n    }\n};\n```\n\n\n\n\n\n\n\n### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=95)[思路](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/#)\n\n难度中等1187\n\n给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/uniquebstn3.jpg)\n\n```\n输入：n = 3\n输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n```\n\n#### 思路\n\n对于连续整数序列`[left, right]`中的一点`i`，若要生成以`i`为根节点的BST，则有如下规律：\n\n- `i`左边的序列可以作为左子树结点，且左儿子可能有多个，所以有`vector<TreeNode *> left_nodes = generate(left, i - 1);`；\n- `i`右边的序列可以作为右子树结点，同上所以有`vector<TreeNode *> right_nodes = generate(i + 1, right);`；\n- 产生的以当前`i`为根结点的BST（子）树有`left_nodes.size() * right_nodes.size()`个，遍历每种情况，即可生成以`i`为根节点的BST序列；\n- 然后以`for`循环使得`[left, right]`中每个结点都能生成子树序列。\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int start, int end) {\n        if (start > end) {\n            return { nullptr };\n        }\n        vector<TreeNode*> allTrees;\n        // 枚举可行根节点\n        for (int i = start; i <= end; i++) {\n            // 获得所有可行的左子树集合\n            vector<TreeNode*> leftTrees = generateTrees(start, i - 1);\n\n            // 获得所有可行的右子树集合\n            vector<TreeNode*> rightTrees = generateTrees(i + 1, end);\n\n            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上\n            for (auto& left : leftTrees) {\n                for (auto& right : rightTrees) {\n                    TreeNode* currTree = new TreeNode(i);\n                    currTree->left = left;\n                    currTree->right = right;\n                    allTrees.emplace_back(currTree);\n                }\n            }\n        }\n        return allTrees;\n    }\n\n    vector<TreeNode*> generateTrees(int n) {\n        if (!n) {\n            return {};\n        }\n        return generateTrees(1, n);\n    }\n};\n```\n\n\n\n## 从遍历数据重建二叉树\n\n- 重建方式 递归\n\n- 三种遍历的数组分布\n\n  <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2.jpeg\" alt=\"img\" style=\"zoom:67%;\" />\n\n  <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/6.jpeg\" alt=\"img\" style=\"zoom:67%;\" />\n\n### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n```c++\nclass Solution {\npublic:\n  \t// 又臭又长的就 不看了\n    // TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    //   if(preorder.size() == 0) return nullptr;\n    //   int rootVal = preorder[0];\n    //   int inorder_rootPos = find(inorder.begin(), inorder.end(), rootVal) - inorder.begin();\n\n    //   //前序左右子树\n    //   vector<int> preorderL = vector<int>(preorder.begin()+1, preorder.begin()+1+inorder_rootPos);\n    //   vector<int> preorderR =vector<int>(preorder.begin()+1+inorder_rootPos, preorder.end());\n    //   //中序左右子树\n    //   vector<int> inorderL = vector<int>(inorder.begin(), inorder.begin()+inorder_rootPos);\n    //   vector<int> inorderR = vector<int>(inorder.begin() + inorder_rootPos + 1, inorder.end());\n    //   //cout<<inorder_rootPos;\n\n    //   TreeNode* root = new TreeNode(rootVal);\n    //   root->left = buildTree(preorderL, inorderL);\n    //   root->right = buildTree(preorderR, inorderR);\n      \n    //   return root;\n    // }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n      return build(preorder, 0 ,preorder.size()-1, inorder, 0, inorder.size()-1);\n    }\n\n    TreeNode* build(vector<int>& preorder, int preS, int preE, vector<int>& inorder, int inS, int inE){\n      if(preS>preE) return nullptr;\n      int rootVal = preorder[preS];\n      int index;\n      for(int i = inS; i<=inE; i++){   //注意这里是小于等于\n        if(inorder[i] == rootVal){\n          index = i;\n          break;\n        }\n      }\n      int leftSize = index - inS;\n      TreeNode* root = new TreeNode(rootVal);\n      root->left = build(preorder,preS + 1, preS + leftSize, inorder, inS, index-1);\n      root->right = build(preorder, preS + 1 + leftSize, preE, inorder, index+ 1, inE);\n      return root;\n    }\n};\n```\n\n### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n```c++\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n      return build(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);\n    }\n\n    TreeNode* build(vector<int>& inorder, int inS, int inE, vector<int>& postorder, int posS, int posE){\n      if(inS>inE) return nullptr;\n      int rootVal = postorder[posE];\n      int index = 0;\n      for(int i = inS; i<=inE; i++){  //注意这里是<= 需要全部遍历\n        if(inorder[i] == rootVal){\n          index = i;\n          break;\n        }\n      }\n      int leftSize = index - inS;\n      TreeNode* root = new TreeNode(rootVal);\n      root->left = build(inorder, inS, index-1, postorder, posS, posS + leftSize-1);\n      root->right = build(inorder, index+1, inE, postorder, posS + leftSize, posE-1);\n      return root;\n    }\n};\n```\n\n### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\n      return build(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1);\n    }\n\n    TreeNode* build(vector<int>& preorder, int preS, int preE, vector<int>& postorder, int posS, int posE){\n      if(preS>preE) return nullptr;\n      if(preS == preE) return new TreeNode(preorder[preS]);\n      int rootVal = preorder[preS];\n      int secVal = preorder[preS + 1];\n      int index = 0;\n      for(int i = posS; i<posE; i++){\n        if(postorder[i] == secVal){\n          index = i;\n          break;\n        }\n      }\n      int leftSize = index-posS;\n      TreeNode* node = new TreeNode(rootVal);\n      node->left = build(preorder, preS+1, preS+1+leftSize, postorder, posS, posS + leftSize);\n      node->right = build(preorder, preS+1+leftSize+ 1, preE, postorder, posS + leftSize+1, posE -1);\n      return node;\n    }\n};\n```\n\n\n\n## [递归改迭代](https://labuladong.gitee.io/algo/2/19/34/)\n\n简单说就是这样一个流程：\n\n**1、拿到一个节点，就一路向左遍历（因为 `traverse(root.left)` 排在前面），把路上的节点都压到栈里**。\n\n**2、往左走到头之后就开始退栈，看看栈顶节点的右指针，非空的话就重复第 1 步**。\n\n写成迭代代码就是这样：\n\n````c++\nprivate:\n\tStack<TreeNode*> stk;\n\npublic:\n\tvector<int> traverse(TreeNode* root) {\n    pushLeftBranch(root);\n    \n    while (!stk.isEmpty()) {\n        TreeNode p = stk.pop();\n        pushLeftBranch(p.right);\n    }\n}\n\n// 左侧树枝一撸到底，都放入栈中\nprivate:\n\tvoid pushLeftBranch(TreeNode* p) {\n    while (p != null) {\n        stk.push(p);\n        p = p.left;\n    }\n}\n\n````\n\n#### 迭代代码框架\n\n想在迭代代码中体现前中后序遍历，关键点在哪里？\n\n**当我从栈中拿出一个节点 `p`，我应该想办法搞清楚这个节点 `p` 左右子树的遍历情况**。\n\n如果 `p` 的左右子树都没有被遍历，那么现在对 `p` 进行操作就属于前序遍历代码。\n\n如果 `p` 的左子树被遍历过了，而右子树没有被遍历过，那么现在对 `p` 进行操作就属于中序遍历代码。\n\n如果 `p` 的左右子树都被遍历过了，那么现在对 `p` 进行操作就属于后序遍历代码。\n\n上述逻辑写成伪码如下：\n\n```c++\n// 模拟函数调用栈\nprivate :\n\tstack<TreeNode*> stk;\n\n// 左侧树枝一撸到底\nprivate:\n\tvoid pushLeftBranch(TreeNode* p) {\n    while (p != nullptr) {\n        /*******************/\n        /** 前序遍历代码位置 **/\n        /*******************/\n        stk.push(p);\n        p = p->left;\n    }\n}\n\npublic:\n\tvector<int> traverse(TreeNode* root) {\n    // 指向上一次遍历完的子树根节点\n    TreeNode* visited = new TreeNode(-1);\n    // 开始遍历整棵树\n    pushLeftBranch(root);\n    \n    while (!stk.isEmpty()) {\n        TreeNode* p = stk.top();\n        \n        // p 的左子树被遍历完了，且右子树没有被遍历过\n        if ((p->left == nullptr || p.left == visited) \n          && p->right != visited) {\n            /*******************/\n            /** 中序遍历代码位置 **/\n            /*******************/\n            // 去遍历 p 的右子树\n            pushLeftBranch(p->right);\n        }\n        // p 的右子树被遍历完了\n        if (p->right == nullptr || p->right == visited) {\n            /*******************/\n            /** 后序遍历代码位置 **/\n            /*******************/\n            // 以 p 为根的子树被遍历完了，出栈\n            // visited 指针指向 p\n            visited = stk.pop();\n        }\n    }\n}\n```\n\n# [字典树 (Trie)](https://oi-wiki.org/string/trie/)\n\n\n\n`Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。`\n\n为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：\n\n```C++\nstruct TreeNode {\n    VALUETYPE value;    //结点值\n    vector<TreeNode*> children;    //指向孩子结点\n};\n```\n\n\n而 Trie 的结点是这样的(假设只包含'a'~'z'中的字符)：\n\n```C++\nstruct TrieNode {\n    bool isEnd; //该结点是否是一个串的结束\n    vector<TrieNode*> next; //字母映射表 26 or 其他\n};\n```\n\n#### 包含三个单词 \"sea\",\"sells\",\"she\" 的 Trie\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220405131024751.png\" alt=\"image-20220405131024751\" style=\"zoom:50%;\" />\n\n## 模板\n\n```c++\nclass Trie{\nprivate:\n    vector<Trie*> next;\n    bool isEnd;\n    \npublic:\n    Trie(): next(26), isEnd(0){}\n\n    //树中插入单词\n    void insert(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            if(node->next[c - 'a'] == nullptr)\n                node->next[c - 'a'] = new Trie();\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = 1;  //最后不要忘了 置为1\n    }\n\n    //查找树中是否包含单词word\n    bool contianWord(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return node->isEnd;\n    }\n\n    //查找树中是否包含以word为前缀的单词\n    bool containWordStartsWith(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return 1;\n    }\n\n    //在树中查找word的最短前缀 没有则返回为空\n    string shortestPrefixOf(const string& word)  {\n        Trie* node = this;\n        string res = \"\";\n        for (auto ch : word){\n            if (node->isEnd || node->next[ch - 'a'] == nullptr) break;\n            res += ch;\n            node = node->next[ch - 'a'];\n        }\n        return node->isEnd ? res : \"\";         //有前缀返回前缀，没有则返回空字符串\n    }\n    \n    //带通配符.的匹配 例如 a.c 匹配 abc\n    bool hasKeyWithPattern(const string& word, int index){\n        Trie* node = this;\n        //字符串到头 检测树枝是否到头\n        if(index >= word.size()) return node->isEnd == 1;\n\n        char ch = word[index];\n        //没有遇到通配符\n        if(ch != '.' )\n            return node->next[ch - 'a'] != nullptr && node->next[ch -  'a']->hasKeyWithPattern(word, index+1);\n\n        //遇到通配符\n        for(int i = 0; i<26; i++){\n            if(node->next[i] != nullptr && node->next[i]->hasKeyWithPattern(word, index+1))\n                return 1;\n        }\n        //没有找到\n        return 0;\n    }\n};\n```\n\n### [前缀树算法模板秒杀 5 道算法题 (qq.com)](https://mp.weixin.qq.com/s/hGrTUmM1zusPZZ0nA9aaNw)\n\n#### 插入\n\n描述：向 Trie 中插入一个单词 word\n\n实现：这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。\n\n```c++\n    void insert(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            if(node->next[c - 'a'] == nullptr)\n                node->next[c - 'a'] = new Trie();\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = 1;  //最后不要忘了 置为1\n    }\n```\n\n#### 查找\n\n描述：查找 Trie 中是否存在单词 word\n\n实现：从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false，如果匹配到了最后一个字符，那我们只需判断 node->isEnd即可。\n\n```c++\n    bool contianWord(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return node->isEnd;\n    }\n```\n\n#### 前缀匹配\n\n描述：判断 Trie 中是或有以 word为前缀的单词\n\n实现：和 search 操作类似，只是不需要判断最后一个字符结点的isEnd，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的。\n\n```c++\n    bool containWordStartsWith(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return 1;\n    }\n```\n\n#### 最短词根\n\n描述：判断 string str在Trie 中的最短词根 （满足 isEnd）\n\n实现：在前缀树上遍历单词，如果当前isEnd（表示找到了一个词根）或者 遍历到树尖，停止遍历\n\n```c++\n    //查找并返回前缀\n    string shortestPrefixOf(const string& word)  {\n        Trie* node = this;\n        string res = \"\";\n        for (auto ch : word){\n            if (node->isEnd || node->next[ch - 'a'] == nullptr) break;\n            res += ch;\n            node = node->next[ch - 'a'];\n        }\n        return node->isEnd ? res : \"\";         //有前缀返回前缀，没有则返回空字符串\n    }\n```\n\n#### 带通配符的查找\n\n描述：使用通配符来匹配多个键，其关键就在于通配符`.`可以匹配所有字符。\n\n实现：见代码\n\n```c++\n    //带通配符.的匹配 例如 a.c 匹配 abc\n    bool hasKeyWithPattern(const string& word, int index){\n        Trie* node = this;\n        //字符串到头 检测树枝是否到头\n        if(index >= word.size()) return node->isEnd == 1;\n\n        char ch = word[index];\n        //没有遇到通配符\n        if(ch != '.' )\n            return node->next[ch - 'a'] != nullptr && node->next[ch -  'a']->hasKeyWithPattern(word, index+1);\n\n        //遇到通配符\n        for(int i = 0; i<26; i++){\n            if(node->next[i] != nullptr && node->next[i]->hasKeyWithPattern(word, index+1))\n                return 1;\n        }\n        //没有找到\n        return 0;\n    }\n```\n\n### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=208)\n\n难度中等1135收藏分享切换为英文接收动态反馈\n\n**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 \"try\"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。\n\n请你实现 Trie 类：\n\n- `Trie()` 初始化前缀树对象。\n- `void insert(String word)` 向前缀树中插入字符串 `word` 。\n- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。\n- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例：**\n\n```\n输入\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n输出\n[null, null, true, false, true, null, true]\n\n解释\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 True\ntrie.search(\"app\");     // 返回 False\ntrie.startsWith(\"app\"); // 返回 True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // 返回 True\n```\n\n#### 思路\n\n构建前缀树\n\n#### 代码\n\n```c++\nclass Trie {\nprivate:\n    vector<Trie*> next;\n    bool isEnd;\npublic:\n    Trie() : isEnd(0), next(26){}\n    \n    void insert(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            if(node->next[c - 'a'] == nullptr)\n                node->next[c - 'a'] = new Trie();\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = 1;  //最后不要忘了 置为1\n    }\n    \n    bool search(string word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return node->isEnd;\n    }\n    \n    bool startsWith(string prefix) {\n        Trie* node = this;\n        for(char c : prefix){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return 1;\n    }\n};\n```\n\n### [648. 单词替换 查找最短前缀](https://leetcode-cn.com/problems/replace-words/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=648)\n\n难度中等163收藏分享切换为英文接收动态反馈\n\n在英语中，我们有一个叫做 `词根`(root) 的概念，可以词根**后面**添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词`(successor)。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。\n\n现在，给定一个由许多**词根**组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence`。你需要将句子中的所有**继承词**用**词根**替换掉。如果**继承词**有许多可以形成它的**词根**，则用**最短**的词根替换它。\n\n你需要输出替换之后的句子。\n\n \n\n**示例 1：**\n\n```\n输入：dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n输出：\"the cat was rat by the bat\"\n```\n\n**示例 2：**\n\n```\n输入：dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n输出：\"a a b c\"\n```\n\n#### 代码\n\n```c++\nclass Trie{\nprivate:\n    vector<Trie*> next;\n    bool isEnd;\n    \npublic:\n    Trie(): next(26), isEnd(0){}\n\n    //树中插入单词\n    void insert(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            if(node->next[c - 'a'] == nullptr)\n                node->next[c - 'a'] = new Trie();\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = 1;  //最后不要忘了 置为1\n    }\n\n    //查找树中是否包含单词word\n    bool contianWord(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return node->isEnd;\n    }\n\n    //查找树中是否包含以word为前缀的单词\n    bool containWordStartsWith(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr) return 0;\n        }\n        return 1;\n    }\n\n    //在树中查找word的最短前缀 没有则返回为空\n    string shortestPrefixOf(const string& word)  {\n        Trie* node = this;\n        string res = \"\";\n        for (auto ch : word){\n            if (node->isEnd || node->next[ch - 'a'] == nullptr) break;\n            res += ch;\n            node = node->next[ch - 'a'];\n        }\n        return node->isEnd ? res : \"\";         //有前缀返回前缀，没有则返回空字符串\n    }\n};\n\nclass Solution {\npublic:\n    string replaceWords(vector<string>& dictionary, string sentence) {\n        Trie* trie = new Trie;\n        stringstream ss(sentence);\n        string s;\n        sort(dictionary.begin(), dictionary.end());\n\n        //词根存入字典树\n        for(string str : dictionary)\n            trie->insert(str);\n\n        string ans = \"\";\n        vector<string> all;\n        while(ss >> s)\n            all.push_back(s);\n\n        for(string word : all){\n            string prefix = trie->shortestPrefixOf(word);\n            if(prefix.size() != 0){\n                ans += prefix;\n            }else{\n                ans += word;\n            }\n            ans += \" \";\n        }\n        \n        ans.pop_back();\n        return ans;\n    }\n};\n```\n\n### [211. 添加与搜索单词 - 数据结构设计 带通配符的查找](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=211)\n\n难度中等416英文版讨论区\n\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 `WordDictionary` ：\n\n- `WordDictionary()` 初始化词典对象\n- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配\n- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。\n\n \n\n**示例：**\n\n```\n输入：\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n输出：\n[null,null,null,null,false,true,true,true]\n\n解释：\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // 返回 False\nwordDictionary.search(\"bad\"); // 返回 True\nwordDictionary.search(\".ad\"); // 返回 True\nwordDictionary.search(\"b..\"); // 返回 True\n```\n\n#### 思路\n\n前缀树带通配符的匹配 加入startIndex进行递归\n\n#### 代码\n\n```c++\nclass Trie{\nprivate:\n    vector<Trie*> next;\n    bool isEnd;\npublic:\n    Trie(): next(26), isEnd(0) {}\n\n    void insert(const string& word){\n        Trie* node = this;\n        for(char ch : word){\n            if(node->next[ch - 'a'] == nullptr)\n                node->next[ch - 'a'] = new Trie;\n            node = node->next[ch - 'a'];\n        }\n        node->isEnd = 1;\n    }\n\n    bool hasKeyWithPattern(const string& word, int index){\n        Trie* node = this;\n        //字符串到头 检测树枝是否到头\n        if(index >= word.size()) return node->isEnd == 1;\n\n        char ch = word[index];\n        //没有遇到通配符\n        if(ch != '.' )\n            return node->next[ch - 'a'] != nullptr && node->next[ch -  'a']->hasKeyWithPattern(word, index+1);\n\n        //遇到通配符\n        for(int i = 0; i<26; i++){\n            if(node->next[i] != nullptr && node->next[i]->hasKeyWithPattern(word, index+1))\n                return 1;\n        }\n        //没有找到\n        return 0;\n    }\n};\n\nclass WordDictionary {\npublic:\n    Trie* trie;\n    WordDictionary() {\n        trie = new Trie;\n    }\n    \n    void addWord(string word) {\n        trie->insert(word);\n    }\n    \n    bool search(string word) {\n        return trie->hasKeyWithPattern(word, 0);\n    }\n};\n```\n\n### [720. 词典中最长的单词 经典](https://leetcode-cn.com/problems/longest-word-in-dictionary/)\n\n难度简单301\n\n给出一个字符串数组 `words` 组成的一本英语词典。返回 `words` 中最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。\n\n若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。\n\n \n\n**示例 1：**\n\n```\n输入：words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n输出：\"world\"\n解释： 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"逐步添加一个字母组成。\n```\n\n**示例 2：**\n\n```\n输入：words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n输出：\"apple\"\n解释：\"apply\" 和 \"apple\" 都能由词典中的单词组成。但是 \"apple\" 的字典序小于 \"apply\" \n```\n\n#### 思路\n\n1. 哈希解法 sort后 依次substr检查是否存在 存在则压入\n2. 字典树  需要自己构建函数 isGoodWord查找单词路径上每个节点 是否都是isEnd\n\n#### 代码\n\n```c++\nclass Trie{\nprivate:\n    vector<Trie*> next;\n    bool isEnd;\n    \npublic:\n    Trie(): next(26), isEnd(0){}\n\n    //树中插入单词\n    void insert(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            if(node->next[c - 'a'] == nullptr)\n                node->next[c - 'a'] = new Trie();\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = 1;  //最后不要忘了 置为1\n    }\n\n    //查找树中是否包含单词word\n    bool isGoodWord(const string& word) {\n        Trie* node = this;\n        for(char c : word){\n            node = node->next[c - 'a'];\n            if(node == nullptr || node->isEnd == 0) return 0;\n        }\n        return node->isEnd;\n    }\n};\n\nclass Solution {\npublic:\n    string longestWord(vector<string>& words) {\n        Trie trie;\n        for(string word : words)  trie.insert(word);\n        string ans = \"\";\n        for(string word : words){\n            if(trie.isGoodWord(word)){\n                if(word.size()>ans.size() || (word.size() == ans.size() && word<ans))\n                    ans = word;\n            }\n        }\n        return ans;\n    }\n};\n\n\n//哈希解法\nclass Solution {\npublic:\n    string longestWord(vector<string>& words) {\n        sort(words.begin(), words.end());\n        unordered_set<string> sett;\n        string ans = \"\";\n        sett.insert(ans);\n        for(int i = 0; i<words.size(); i++){\n            if(sett.count(words[i].substr(0, words[i].size() -1))){\n                if(words[i].size()>ans.size())\n                    ans = words[i];\n                sett.insert(words[i]); //满足条件才会insert\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [剑指 Offer II 064. 神奇的字典](https://leetcode-cn.com/problems/US1pGT/)\n\n难度中等19\n\n设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 **互不相同** 。 如果给出一个单词，请判定能否只将这个单词中**一个**字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。\n\n实现 `MagicDictionary` 类：\n\n- `MagicDictionary()` 初始化对象\n- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同\n- `bool search(String searchWord)` 给定一个字符串 `searchWord` ，判定能否只将字符串中 **一个** 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例：**\n\n```\n输入\ninputs = [\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\ninputs = [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n输出\n[null, null, false, true, false, false]\n\n解释\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([\"hello\", \"leetcode\"]);\nmagicDictionary.search(\"hello\"); // 返回 False\nmagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 True\nmagicDictionary.search(\"hell\"); // 返回 False\nmagicDictionary.search(\"leetcoded\"); // 返回 False\n```\n\n#### 思路\n\n用字典树的解法 其实没有那么麻烦 不要想的太复杂\n\n每一位都用其他的25个字母替换一下就行了\n\n#### 代码\n\n```c++\nclass MagicDictionary {\nprivate:\n    vector<MagicDictionary*> next;\n    bool isEnd;\n\n    void insert(const string& str){\n      MagicDictionary* node = this;\n      for(auto ch : str){\n        if(node ->next[ch - 'a'] == nullptr)\n          node->next[ch - 'a'] = new MagicDictionary;\n        node = node->next[ch - 'a'];\n      }\n      node->isEnd = 1;\n    }\n\n    bool find(const string& searchWord) {\n      MagicDictionary* node = this;\n      for(auto ch : searchWord){\n        if(node->next[ch - 'a'] == nullptr)\n          return 0;\n        node = node->next[ch - 'a'];\n      }\n      return node->isEnd;\n    }\n\npublic:\n    /** Initialize your data structure here. */\n    MagicDictionary() : next(26), isEnd(0){\n    }\n    \n    void buildDict(vector<string> dictionary) {\n      for(auto str : dictionary)\n        this->insert(str);\n    }\n    \n    //替换每一位的字母 简单暴力\n    bool search(string searchWord) {\n      for(int i = 0; i<searchWord.size(); i++){\n        string temp = searchWord;\n        for(int j = 0; j<26; j++){\n          char ch = 'a' + j;\n          if(ch != searchWord[i]){\n            temp[i] = ch;\n            if(this->find(temp))\n              return 1;\n          }\n        }\n      }\n      return 0;\n    }\n};\n```\n\n大佬的解法 击败高得多\n\n```c++\n//前缀树的程序表示\nclass TrieNode {\npublic:\n    bool isWord;//当前节点为结尾是否是字符串\n    vector<TrieNode*> children;\n    TrieNode() : isWord(false), children(26, nullptr) {}\n    ~TrieNode() {\n        for (TrieNode* child : children)\n            if (child) delete child;\n    }\n};\n\nclass MagicDictionary {\nprivate:\n    TrieNode *trieRoot;//构建的单词后缀树\n    //在树中插入一个单词的方法实现\n    void addWord(string &word) {\n        TrieNode *ptr = trieRoot;//扫描这棵树，将word插入\n        //将word的字符逐个插入\n        for (auto ch : word) {\n            if (ptr->children[ch - 'a'] == NULL) {\n                ptr->children[ch - 'a'] = new TrieNode();\n            }\n            ptr = ptr->children[ch - 'a'];\n        }\n        ptr->isWord = true;//标记为单词\n    }\n    //在nowTreePtr中搜索word[index]，isMod代表的是是否使用了替换一个字母的机会\n    bool myFindWord(TrieNode *nowTreePtr, string &word, int index, bool isMod){\n        if (nowTreePtr == NULL){\n            return false;\n        }\n        if (word.size() == index){\n            //此时搜索完毕，必须保证nowTreePtr也到达了一个单词的尾端，并且替换一个字母的机会也使用了\n            return isMod && nowTreePtr->isWord;\n        }\n        else{\n            //搜索nowTreePtr的26个节点\n            for (int i = 0; i < 26; ++i){\n                if (nowTreePtr->children[i] != NULL){\n                    if ('a' + i == word[index]){\n                        //成功匹配，继续搜索下一个字母\n                        if (myFindWord(nowTreePtr->children[i], word, index + 1, isMod)){\n                            return true;\n                        }\n                    }\n                    else if (isMod == false && myFindWord(nowTreePtr->children[i], word, index + 1, true)){\n                        //如果'a' + i ！= word[index]，则使用替换字母的机会（在此之前替换字母的机会是没有使用的，因为只能使用一次）\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\npublic:\n    /** Initialize your data structure here. */\n    MagicDictionary() {\n        trieRoot = new TrieNode();\n    }\n\n    /** Build a dictionary through a list of words */\n    void buildDict(vector<string> dict) {\n        //构建字典树\n        for (auto &word : dict){\n            addWord(word);\n        }\n    }\n\n    /** Returns if there is any word in the trie that equals to the given word after modifying exactly one character */\n    bool search(string word) {\n        return myFindWord(trieRoot, word, 0, false);\n    }\n};\n\n```\n\n### [剑指 Offer II 065. 最短的单词编码](https://leetcode-cn.com/problems/iSwD2y/)\n\n难度中等16\n\n单词数组 `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：\n\n- `words.length == indices.length`\n- 助记字符串 `s` 以 `'#'` 字符结尾\n- 对于每个下标 `indices[i]` ，`s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'`）的 **子字符串** 恰好与 `words[i]` 相等\n\n给定一个单词数组 `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。\n\n \n\n**示例 1：**\n\n```\n输入：words = [\"time\", \"me\", \"bell\"]\n输出：10\n解释：一组有效编码为 s = \"time#bell#\" 和 indices = [0, 2, 5] 。\nwords[0] = \"time\" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#bell#\"\nwords[1] = \"me\" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#bell#\"\nwords[2] = \"bell\" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 \"time#bell#\"\n```\n\n**示例 2：**\n\n```\n输入：words = [\"t\"]\n输出：2\n解释：一组有效编码为 s = \"t#\" 和 indices = [0] 。\n```\n\n#### 解法1\n\n单词倒序插入字典树\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422181126201.png\" alt=\"image-20220422181126201\" style=\"zoom:50%;\" />\n\n```c++\nclass Trie { //创建前缀树\npublic:\n  vector<Trie *> next;\n  Trie() : next(26) {}\n\n  void insertReverse(const string &word) { //向树中倒序插入字符串\n    Trie *node = this;\n    for (int i = word.size() - 1; i >= 0; i--) {\n      if (node->next[word[i] - 'a'] == nullptr)\n        node->next[word[i] - 'a'] = new Trie();\n      node = node->next[word[i] - 'a'];\n    }\n  }\n\n  bool containWordStartsWithReverse(const string word) { //判断字符串倒序后是否为字典树的前缀\n    Trie *node = this;\n    for (int i = word.size() - 1; i >= 0; i--) {\n      node = node->next[word[i] - 'a'];\n      if (node == nullptr)\n        return 0;\n    }\n    return 1;\n  }\n};\n\nclass Solution {\npublic:\n  int minimumLengthEncoding(vector<string> &words) {\n    int res = 0; //结果\n    Trie *node = new Trie();\n    sort(words.begin(), words.end(), [](string& str1, string& str2) {\n      return str1.size() > str2.size();\n    }); //将字符串按长度从大到小排序\n    for (string str : words) {\n      if (!node->containWordStartsWithReverse(str)){\n        res += (str.size() + 1); //若其不是前缀树的前缀，则结果+=字符串长度+1\n      \tnode->insertReverse(str); //并将字符串插入到前缀树中     \n      }\n    }\n    return res;\n  }\n};\n```\n\n#### 解法2\n\n哈希 检查互为后缀\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220422181047635.png\" alt=\"image-20220422181047635\" style=\"zoom: 50%;\" />\n\n```c++\nclass Solution {\npublic:\n    int minimumLengthEncoding(vector<string>& words) {\n      unordered_set<string> sett(words.begin(), words.end());\n      for(auto word : words){\n        for(int i = 1; i<word.size(); i++){\n          if(sett.find(word.substr(i)) != sett.end())\n            sett.erase(word.substr(i));\n        }\n      }\n\n      int ans = 0;\n      for(auto word : sett)\n        ans += word.size() + 1;\n      return ans;\n    }\n};\n```\n\n### [剑指 Offer II 066. 单词之和](https://leetcode-cn.com/problems/z1R5dt/)\n\n难度中等15\n\n实现一个 `MapSum` 类，支持两个方法，`insert` 和 `sum`：\n\n- `MapSum()` 初始化 `MapSum` 对象\n- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。\n- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。\n\n \n\n**示例：**\n\n```\n输入：\ninputs = [\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\ninputs = [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n输出：\n[null, null, 3, null, 5]\n\n解释：\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // return 3 (apple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // return 5 (apple + app = 3 + 2 = 5)\n```\n\n#### 解法1\n\n前缀树 在最后一个字母存储节点的值\n\n注意前缀树的dfs 求节点下 所有节点的值的和\n\n```c++\nclass MapSum {\n    struct Trie{\n      int val;\n      vector<shared_ptr<Trie>> next;\n      Trie() : val(0), next(26){}\n    };\n\n    shared_ptr<Trie> root = make_shared<Trie>();\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {}\n    \n    void insert(string key, int val) {\n      auto node = root;\n      for(char& ch : key){\n        if(node->next[ch - 'a'] == nullptr)\n          node->next[ch - 'a'] = make_shared<Trie>();\n        node = node->next[ch -'a'];\n      }\n      node->val = val;\n    }\n    //累加这个树节点代表的整个子树\n    int dfs(shared_ptr<Trie> node){\n      if(node == nullptr) return 0;\n      \n      int res = node->val;\n      for(auto& nxt : node->next){\n        res += dfs(nxt);\n      }\n      return res;\n    }\n\n    int sum(string prefix) {\n      auto node = root;\n      for(char& ch : prefix){\n        if(node->next[ch - 'a'] == nullptr)\n          return 0;\n        node = node->next[ch - 'a'];\n      }\n      return dfs(node);\n    }\n};\n```\n\n#### 解法2\n\n哈希\n\n```c++\nclass MapSum {\n    unordered_map<string, int> mapp;\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {}\n    \n    void insert(string key, int val) {\n      mapp[key] = val;\n    }\n    \n    int sum(string prefix) {\n      int ans = 0;\n      for(auto& [word, val] : mapp){\n        if(word.size() >= prefix.size() && word.find(prefix) == 0){\n          ans += val;\n        }\n      }\n      return ans;\n    }\n};\n\n//判断的写法比价糙 其实可以\nif(word.substr(0, prefix.size()) == prefix)\n\t...\n//也就是说\n\tstring s = \"123\";\n\tstring ss = s.subsre(0, 100) //还是\"123\"\n```\n\n\n\n# [线段树](https://oi-wiki.org/ds/seg/)和树状数组\n\n### 线段树\n\n线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。\n\n线段树可以在Ologn 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。\n\n![image-20220405022002717](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220405022002717.png)\n\n### 树状数组\n\n树状数组和线段树具有相似的功能，但他俩毕竟还有一些区别：树状数组能有的操作，线段树一定有；线段树有的操作，树状数组不一定有。但是树状数组的代码要比线段树短，思维更清晰，速度也更快，在解决一些单点修改的问题时，树状数组是不二之选。\n\n![image-20220405024155141](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220405024155141.png)\n\n\n\n### <u>[307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)</u>\n\n难度中等470英文版讨论区\n\n给你一个数组 `nums` ，请你完成两类查询。\n\n1. 其中一类查询要求 **更新** 数组 `nums` 下标对应的值\n2. 另一类查询要求返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** ，其中 `left <= right`\n\n实现 `NumArray` 类：\n\n- `NumArray(int[] nums)` 用整数数组 `nums` 初始化对象\n- `void update(int index, int val)` 将 `nums[index]` 的值 **更新** 为 `val`\n- `int sumRange(int left, int right)` 返回数组 `nums` 中索引 `left` 和索引 `right` 之间（ **包含** ）的nums元素的 **和** （即，`nums[left] + nums[left + 1], ..., nums[right]`）\n\n \n\n**示例 1：**\n\n```\n输入：\n[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n输出：\n[null, 9, null, 8]\n\n解释：\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1,2,5]\nnumArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8\n```\n\n```c++\n//线段树\nclass NumArray {\nprivate:\n\tvector<int> segmentTree;\n\tint n;\n\n\tvoid build(int node, int left, int right, vector<int>& nums) {\n\t\tif (left == right) {\n\t\t\tsegmentTree[node] = nums[left];\n\t\t\treturn;\n\t\t}\n\t\tint mid = left + (right - left) / 2;\n\t\tbuild(node * 2 + 1, left, mid, nums);\n\t\tbuild(node * 2 + 2, mid + 1, right, nums);\n\t\tsegmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n\t}\n\n\tvoid change(int index, int val, int node, int left, int right) {\n\t\tif (left == right) {\n\t\t\tsegmentTree[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint mid = left + (right - left) / 2;\n\t\tif (index <= mid)  //注意 全是小于等于\n\t\t\tchange(index, val, node * 2 + 1, left, mid);\n\t\telse \n\t\t\tchange(index, val, node * 2 + 2, mid + 1, right);\n\t\tsegmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n\t}\n\n\tint range(int searchLeft, int searchRight, int node, int left, int right) {\n\t\tif (searchLeft == left && searchRight == right)\n\t\t\treturn segmentTree[node];\n\t\tint mid = left + (right - left) / 2;\n\t\tif (searchRight <= mid)\n\t\t\treturn range(searchLeft, searchRight, node * 2 + 1, left, mid);\n\t\telse if (searchLeft > mid)\n\t\t\treturn range(searchLeft, searchRight, node * 2 + 2, mid + 1, right);\n\t\telse //注意这里，right left 两个地方换mid\n            return range(searchLeft, mid, node * 2 + 1, left, mid) + range(mid + 1, searchRight, node * 2 + 2, mid + 1, right);\n\t}\npublic:\n\tNumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {\n\t\tbuild(0, 0, n - 1, nums);\n\t}\n\n\tvoid update(int index, int val) {\n\t\tchange(index, val, 0, 0, n - 1);\n\t}\n\n\tint sumRange(int left, int right) {\n\t\treturn range(left, right, 0, 0, n - 1);\n\t}\n};\n\n//树状数组\nclass NumArray {\npublic:\n    vector<int> A;// 原数组\n    vector<int> C;   // 树状数组\n\n    int lowBit(int x) {\n        return x & (-x);\n    }\n\n    NumArray(vector<int>& nums):A(nums) {\n        C = vector<int> (A.size() + 1, 0);\n        //构造树形数组\n        for(int i = 1; i<=A.size(); i++) {\n            C[i] += A[i - 1];\n            //父结点要加上子结点的值\n            if(i + lowBit(i) <= A.size()) \n                C[i + lowBit(i)] += C[i];\n        }\n    }\n    \n    void update(int index, int val) {\n        int d = val - A[index];\n        for(int i = index + 1; i < C.size(); i += lowBit(i)) \n            C[i] += d; // 更新树状数组       \n        A[index] = val; // 更新原数组\n    }\n    \n    int sumRange(int left, int right) {\n        int r = 0, l = 0;\n        //求right的前缀和\n        for(int i = right + 1; i >= 1; i -= lowBit(i)) r += C[i];\n        //求left的前缀和\n        for(int i = left; i >= 1; i -= lowBit(i)) l += C[i];\n        return r - l;\n    }\n};\n```\n\n\n\n\n\n### 最高分是多少\n\n老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.\n\n##### **输入描述:**\n\n```\n每组输入第一行是两个正整数N和M（0 < N <= 30000,0 < M < 5000）,分别代表学生的数目和操作的数目。\n学生ID编号从1编到N。\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩\n接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为'Q'的时候, 表示这是一条询问操作，假设A<B，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少\n当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\n\n注意：输入包括多组测试数据。\n```\n\n##### **输出描述:**\n\n```\n对于每一次询问操作，在一行里面输出最高成绩.\n```\n\n##### **输入例子1:**\n\n```\n5 7\n1 2 3 4 5\nQ 1 5\nU 3 6\nQ 3 4\nQ 4 5\nU 4 5\nU 2 9\nQ 1 5\n```\n\n##### **输出例子1:**\n\n```\n5\n6\n5\n9\n```\n\n##### **输入例子2:**\n\n```\n3 2\n1 2 3\nU 2 8\nQ 3 1\n```\n\n##### **输出例子2:**\n\n```\n8\n```\n\n#### ACM模式\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n//线段树\nclass NumArray {\nprivate:\n\tvector<int> segmentTree;\n\tint n;\n\n\tvoid build(int node, int s, int e, vector<int> &nums) {\n\t\tif (s == e) {\n\t\t\tsegmentTree[node] = nums[s];\n\t\t\treturn;\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tbuild(node * 2 + 1, s, m, nums);\n\t\tbuild(node * 2 + 2, m + 1, e, nums);\n\t\tsegmentTree[node] = max(segmentTree[node * 2 + 1], segmentTree[node * 2 + 2]);\n\t}\n\n\tvoid change(int index, int val, int node, int s, int e) {\n\t\tif (s == e) {\n\t\t\tsegmentTree[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tif (index <= m) {\n\t\t\tchange(index, val, node * 2 + 1, s, m);\n\t\t}\n\t\telse {\n\t\t\tchange(index, val, node * 2 + 2, m + 1, e);\n\t\t}\n\t\tsegmentTree[node] = max(segmentTree[node * 2 + 1], segmentTree[node * 2 + 2]);\n\t}\n\n\tint range(int left, int right, int node, int s, int e) {\n\t\tif (left == s && right == e) {\n\t\t\treturn segmentTree[node];\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tif (right <= m) {\n\t\t\treturn range(left, right, node * 2 + 1, s, m);\n\t\t}\n\t\telse if (left > m) {\n\t\t\treturn range(left, right, node * 2 + 2, m + 1, e);\n\t\t}\n\t\telse {\n\t\t\treturn max(range(left, m, node * 2 + 1, s, m), range(m + 1, right, node * 2 + 2, m + 1, e));\n\t\t}\n\t}\n\npublic:\n\tNumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {\n\t\tbuild(0, 0, n - 1, nums);\n\t}\n\n\tvoid update(int index, int val) {\n\t\tchange(index, val, 0, 0, n - 1);\n\t}\n\n\tint rangeMax(int left, int right) {\n\t\treturn range(left, right, 0, 0, n - 1);\n\t}\n};\n\nint getMax(vector<int>& nums, int left, int right) {\n\tint ans = 0;\n\tfor (int i = left; i <= right; i++) {\n\t\tans = max(ans, nums[i]);\n\t}\n\treturn ans;\n}\n\n//线段树\nint main() {\n\twhile (cin) {\n\t\tvector<int> scores;\n\t\tint size;\n\t\tcin >> size;\n\t\tint steps;\n\t\tcin >> steps;\n\t\tscores.resize(size);\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tcin >> scores[i];\n\t\t\t//cout<<scores[i]<<\" \";\n\t\t}\n\t\tNumArray nArray(scores);\n\t\twhile (steps) {\n\t\t\tsteps--;\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\t\t\tif (ch == 'Q') {\n\t\t\t\tint left;\n\t\t\t\tcin >> left;\n\t\t\t\tint right;\n\t\t\t\tcin >> right;\n\t\t\t\tleft--;\n\t\t\t\tright--;\n\t\t\t\tif (left > right) {\n\t\t\t\t\tswap(left, right);\n\t\t\t\t}\n\t\t\t\tif (right >= size) right = size - 1;\n\t\t\t\tint ans = nArray.rangeMax(left, right);\n\t\t\t\t//int ans = getMax(scores, left, right);\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pos, val;\n\t\t\t\tcin >> pos;\n\t\t\t\tpos--;\n\t\t\t\tcin >> val;\n\t\t\t\t//scores[pos] = val;\n\t\t\t\tnArray.update(pos, val);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\n\n\n\n","tags":["算法总结"]},{"title":"笔试面试算法题目","url":"/2022/04/16/bi-shi-mian-shi-suan-fa-ti-mu/","content":"\n### LeetCode 1152. 用户网站访问行为分析\n\n#### 1. 题目\n\n为了评估某网站的用户转化率，我们需要对用户的访问行为进行分析，并建立用户行为模型。\n\n日志文件中已经记录了用户名、访问时间 以及 页面路径。\n\n为了方便分析，日志文件中的 N 条记录已经被解析成三个长度相同且长度都为 N 的数组，分别是：用户名 username，访问时间 timestamp 和 页面路径 website。\n\n第 i 条记录意味着用户名是 username[i] 的用户在 timestamp[i] 的时候访问了路径为 website[i] 的页面。\n\n我们需要找到用户访问网站时的 『共性行为路径』，也就是有最多的用户都 至少按某种次序访问过一次 的三个页面路径。需要注意的是，用户 可能不是连续访问 这三个路径的。\n\n『共性行为路径』是一个 长度为 3 的页面路径列表，列表中的路径 不必不同，并且按照访问时间的先后升序排列。\n\n如果有多个满足要求的答案，那么就请返回按字典序排列最小的那个。（页面路径列表 X 按字典序小于 Y 的前提条件是：X[0] < Y[0] 或 X[0] == Y[0] 且 (X[1] < Y[1] 或 X[1] == Y[1] 且 X[2] < Y[2])）\n\n题目保证一个用户会至少访问 3 个路径一致的页面，并且一个用户不会在同一时间访问两个路径不同的页面。\n\n```c++\n示例：\n输入：\nusername = [\"joe\",\"joe\",\"joe\",\"james\",\"james\",\"james\",\"james\",\"mary\",\"mary\",\"mary\"], \ntimestamp = [1,2,3,4,5,6,7,8,9,10], \nwebsite = [\"home\",\"about\",\"career\",\"home\",\"cart\",\"maps\",\"home\",\"home\",\"about\",\"career\"]\n输出：[\"home\",\"about\",\"career\"]\n解释：\n由示例输入得到的记录如下：\n[\"joe\", 1, \"home\"]\n[\"joe\", 2, \"about\"]\n[\"joe\", 3, \"career\"]\n[\"james\", 4, \"home\"]\n[\"james\", 5, \"cart\"]\n[\"james\", 6, \"maps\"]\n[\"james\", 7, \"home\"]\n[\"mary\", 8, \"home\"]\n[\"mary\", 9, \"about\"]\n[\"mary\", 10, \"career\"]\n有 2 个用户至少访问过一次 (\"home\", \"about\", \"career\")。\n有 1 个用户至少访问过一次 (\"home\", \"cart\", \"maps\")。\n有 1 个用户至少访问过一次 (\"home\", \"cart\", \"home\")。\n有 1 个用户至少访问过一次 (\"home\", \"maps\", \"home\")。\n有 1 个用户至少访问过一次 (\"cart\", \"maps\", \"home\")。\n \n提示：\n3 <= N = username.length = timestamp.length = website.length <= 50\n1 <= username[i].length <= 10\n0 <= timestamp[i] <= 10^9\n1 <= website[i].length <= 10\nusername[i] 和 website[i] 都只含小写字符\n```\n\n> 这道题主要是解题思路 数据结构的使用 没什么难点 主要是要想明白问题 明确流程\n\n#### 2. 解题\n\n```c++\nclass Solution {\n\tmap<vector<string>,unordered_set<string>> count;//网站路径，用户集合\n\tunordered_map<string, vector<pair<int,string>>> m;//用户名，《用户访问时间,网站》\npublic:\n    vector<string> mostVisitedPattern(vector<string>& username, vector<int>& timestamp, vector<string>& website) {\n    \tint i, n = username.size();\n    \tfor(i = 0; i < n; i++){  //存取每个用户 浏览的网站及对应的时间\n    \t\tm[username[i]].push_back({timestamp[i],website[i]});\n    \t}\n    \tfor(auto it = m.begin(); it != m.end(); ++it){\n    \t\tsort(it->second.begin(), it->second.end(),[&](auto a, auto b){\n    \t\t\treturn a.first < b.first;//某用户访问的网站按时间排序\n    \t\t});\n    \t}\n    \tvector<string> path;\n    \tfor(auto it = m.begin(); it != m.end(); ++it){\n    \t\tdfs(it->second, path, 0, it->first);//回溯生成所有的三元组\n    \t}\n    \tint maxcount = 0;\n    \tvector<vector<string>> result;\n    \tfor(auto it = count.begin(); it != count.end(); ++it){\t//选出人数最多的最大的路径\n    \t\tif(it->second.size() > maxcount){ //人数多\n    \t\t\tresult.clear();\n    \t\t\tresult.push_back(it->first);\n    \t\t\tmaxcount = it->second.size();\n    \t\t}\n    \t\telse if(it->second.size() == maxcount)//人数相等\n    \t\t\tresult.push_back(it->first);\n    \t}\n    \tsort(result.begin(), result.end());//取字典序最小的\n    \treturn result[0];\n    }\n\n  \t//回溯全组合\n    void dfs(vector<pair<int,string>>& web, vector<string>& path, int idx, string username){\n    \tif(path.size()==3){\n    \t\tcount[path].insert(username);\n    \t\treturn;\n    \t}\n    \tfor(int i = idx; i < web.size(); ++i) {\n    \t\tpath.push_back(web[i].second);\n    \t\tdfs(web, path, i+1, username);\n    \t\tpath.pop_back();\n    \t}\n    }\n};\n\n```\n\n### [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)\n\n难度简单221英文版讨论区\n\n不使用任何内建的哈希表库设计一个哈希集合（HashSet）。\n\n实现 `MyHashSet` 类：\n\n- `void add(key)` 向哈希集合中插入值 `key` 。\n- `bool contains(key)` 返回哈希集合中是否存在这个值 `key` 。\n- `void remove(key)` 将给定值 `key` 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\n\n**示例：**\n\n```\n输入：\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n输出：\n[null, null, null, true, false, null, true, null, false]\n\n解释：\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // 返回 True\nmyHashSet.contains(3); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // 返回 False ，（已移除）\n```\n\n**提示：**\n\n- `0 <= key <= 106`\n- 最多调用 `104` 次 `add`、`remove` 和 `contains`\n\n#### 思路\n\n1. 找合适的质数\n\n   | lwr    | upr    | % err     |   prime    |\n   | :----- | :----- | :-------- | :--------: |\n   | 2525   | 2626   | 10.416667 |     53     |\n   | 2626   | 2727   | 1.041667  |     97     |\n   | 2727   | 2828   | 0.520833  |    193     |\n   | 2828   | 2929   | 1.302083  |    389     |\n   | 2929   | 210210 | 0.130208  |    769     |\n   | 210210 | 211211 | 0.455729  |    1543    |\n   | 211211 | 212212 | 0.227865  |    3079    |\n   | 212212 | 213213 | 0.113932  |    6151    |\n   | 213213 | 214214 | 0.008138  |   12289    |\n   | 214214 | 215215 | 0.069173  |   24593    |\n   | 215215 | 216216 | 0.010173  |   49157    |\n   | 216216 | 217217 | 0.013224  |   98317    |\n   | 217217 | 218218 | 0.002543  |   196613   |\n   | 218218 | 219219 | 0.006358  |   393241   |\n   | 219219 | 220220 | 0.000127  |   786433   |\n   | 220220 | 221221 | 0.000318  |  1572869   |\n   | 221221 | 222222 | 0.000350  |  3145739   |\n   | 222222 | 223223 | 0.000207  |  6291469   |\n   | 223223 | 224224 | 0.000040  |  12582917  |\n   | 224224 | 225225 | 0.000075  |  25165843  |\n   | 225225 | 226226 | 0.000010  |  50331653  |\n   | 226226 | 227227 | 0.000023  | 100663319  |\n   | 227227 | 228228 | 0.000009  | 201326611  |\n   | 228228 | 229229 | 0.000001  | 402653189  |\n   | 229229 | 230230 | 0.000011  | 805306457  |\n   | 230230 | 231231 | 0.000000  | 1610612741 |\n\n2. mod 得到bucket 然后存入链表（如果链表当前不存在这个数的话）\n\n#### 代码\n\n```c++\nclass MyHashSet {\nprivate:\n    vector<list<int>> data;\n    static const int base = 769;\n    static int hash(int key){\n        return key % base;\n    }\npublic:\n    MyHashSet() :data(base){}\n    \n    //函数基本都是一样的 计算bucket的值 遍历list\n    void add(int key) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!=data[h].end(); it++){\n            if(*(it) == key)  //存在这个数\n                return;\n        }\n        data[h].push_back(key);\n    }\n    \n    void remove(int key) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!=data[h].end(); it++){\n            if(*(it) == key){\n                data[h].erase(it);\n                return;\n            }\n        }\n        return;\n    }\n    \n    bool contains(int key) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!=data[h].end(); it++){\n            if(*(it) == key){\n                return 1;\n            }\n        }\n        return 0;        \n    }\n};\n```\n\n### [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)\n\n难度简单285\n\n不使用任何内建的哈希表库设计一个哈希映射（HashMap）。\n\n实现 `MyHashMap` 类：\n\n- `MyHashMap()` 用空映射初始化对象\n- `void put(int key, int value)` 向 HashMap 插入一个键值对 `(key, value)` 。如果 `key` 已经存在于映射中，则更新其对应的值 `value` 。\n- `int get(int key)` 返回特定的 `key` 所映射的 `value` ；如果映射中不包含 `key` 的映射，返回 `-1` 。\n- `void remove(key)` 如果映射中存在 `key` 的映射，则移除 `key` 和它所对应的 `value` 。\n\n#### 思路\n\n没有什么不同 只是存储的值变为了pair\n\n#### 代码\n\n```c++\nclass MyHashMap {\nprivate:\n    static const int base = 769;\n    vector<list<pair<int, int>>> data;\n    static int hash(int key){\n        return key % base;\n    }\npublic:\n    MyHashMap() : data(base){}\n    \n    void put(int key, int value) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!=data[h].end(); it++){\n            if(it->first == key){\n                it->second = value;\n                return;\n            }\n        }\n        data[h].push_back(pair<int, int>(key, value));\n    }\n    \n    int get(int key) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!= data[h].end(); it++){\n            if(it->first == key)\n                return it->second;\n        }\n        return -1;\n    }\n    \n    void remove(int key) {\n        int h = hash(key);\n        for(auto it = data[h].begin(); it!= data[h].end(); it++){\n            if(it->first == key){\n                data[h].erase(it);\n                return;\n            }\n        }  \n    }\n};\n```\n\n\n\n### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)\n\n难度中等2046\n\n请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\n- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。\n\n函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。\n\n \n\n**示例：**\n\n```\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n#### 思路\n\n主要是双向链表需要实现几个函数\n\n1. 头部插入函数\n2. 删除节点函数（其实是断开连接，节点并不删除）\n3. 尾部删除函数 （依靠`删除节点`函数，需要删除key 所以返回节点）\n4. 移动到头部函数 （依靠`删除节点`函数和`头部插入`函数）\n\n```c++\nstruct DLinkedNode{\n    int key, value; //k是为了溯源 hash中删除key\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode():key(0), value(0), prev(nullptr), next(nullptr){}\n    DLinkedNode(int _key, int _value):key(_key),value(_value),prev(nullptr),next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    //虚拟头 虚拟尾\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity):capacity(_capacity), size(0) {\n        //使用虚拟头 和 虚拟尾节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!cache.count(key)){\n            return -1;\n        }\n        //如果key存在 先通过哈希定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(!cache.count(key)){\n            //如果key不存在 创建一个新节点\n            DLinkedNode* node  = new DLinkedNode(key, value);\n            cache[key] = node;\n            addToHead(node);\n            size++;\n            if(size>capacity){\n                //超出容量 删除尾部节点\n                DLinkedNode* removed = removeTail();\n                cache.erase(removed->key);\n                delete removed;\n                --size;\n            }\n        }else{\n            //如果key存在 先哈希定位 再修改val 在移动头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    //头部插入新节点\n    void addToHead(DLinkedNode* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    //删除某个节点\n    void removeNode(DLinkedNode* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    //移动到头部\n    void moveToHead(DLinkedNode* node){\n        removeNode(node);\n        addToHead(node);\n    }\n    //删除尾部节点\n    DLinkedNode* removeTail(){\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n\n### [剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器](https://leetcode-cn.com/problems/FortPu/)\n\n难度中等28英文版讨论区\n\n设计一个支持在*平均* 时间复杂度 **O(1)** 下，执行以下操作的数据结构：\n\n- `insert(val)`：当元素 `val` 不存在时返回 `true` ，并向集合中插入该项，否则返回 `false` 。\n- `remove(val)`：当元素 `val` 存在时返回 `true` ，并从集合中移除该项，否则返回 `false` 。\n- `getRandom`：随机返回现有集合中的一项。每个元素应该有 **相同的概率** 被返回。\n\n \n\n**示例 :**\n\n```\n输入: inputs = [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n输出: [null, true, false, true, 2, true, false, 2]\n解释:\nRandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合\nrandomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\n\nrandomSet.remove(2); // 返回 false，表示集合中不存在 2 \n\nrandomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] \n\nrandomSet.getRandom(); // getRandom 应随机返回 1 或 2 \n  \nrandomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] \n\nrandomSet.insert(2); // 2 已在集合中，所以返回 false \n\nrandomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 \n```\n\n#### 思路\n\n典型的用空间换时间\n\n哈希存储数组下标，提高访问速度\n\n#### 代码\n\n```c++\nclass RandomizedSet {\nprivate:\n    unordered_map<int, int> mapp;\n    vector<int> nums;\npublic:\n    /** Initialize your data structure here. */\n    RandomizedSet() {}\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    bool insert(int val) {\n        if(!mapp.count(val)){\n            int n = nums.size();\n            mapp[val] = n;\n            nums.push_back(val);\n            return 1;\n        }else return 0;\n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    bool remove(int val) {\n        if(mapp.count(val)){\n            int pos = mapp[val];\n            //注意这里要移位\n            mapp[nums.back()] = pos;\n            swap(nums[pos], nums.back());\n            nums.pop_back();\n            mapp.erase(val);\n            return 1;\n        }else return 0;\n    }\n    \n    /** Get a random element from the set. */\n    int getRandom() {\n        //srand(time(0));\n        return nums[rand()%nums.size()];\n    }\n};\n```\n\n#### 关于srand(time(0)) rand() 的理解\n\n- 计算机没有办法产生真正的随机数的，是用算法模拟，所以你只调用rand，每次出来的东西是一样的。设置一个种子后，根据种子的不同，就可以产生不同的数了。而怎么保证种子的不同呢？最简单的办法当然是用永远在向前的时间。\n\n- Srand是种下随机种子数，你每回种下的种子不一样，用Rand得到的随机数就不一样。为了每回种下一个不一样的种子，所以就选用Time(0)，Time(0)是得到当前时时间值（因为每时每刻时间是不一样的了）。\n\n> 我理解的是 一次函数调用内 多次用到rand才需要srand(time(0))，一次函数调用一次是不需要种子的\n\n### 最高分是多少\n\n老师想知道从某某同学当中，分数最高的是多少，现在请你编程模拟老师的询问。当然，老师有时候需要更新某位同学的成绩.\n\n##### **输入描述:**\n\n```\n每组输入第一行是两个正整数N和M（0 < N <= 30000,0 < M < 5000）,分别代表学生的数目和操作的数目。\n学生ID编号从1编到N。\n第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩\n接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为'Q'的时候, 表示这是一条询问操作，假设A<B，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少\n当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。\n\n注意：输入包括多组测试数据。\n```\n\n##### **输出描述:**\n\n```\n对于每一次询问操作，在一行里面输出最高成绩.\n```\n\n##### **输入例子1:**\n\n```\n5 7\n1 2 3 4 5\nQ 1 5\nU 3 6\nQ 3 4\nQ 4 5\nU 4 5\nU 2 9\nQ 1 5\n```\n\n##### **输出例子1:**\n\n```\n5\n6\n5\n9\n```\n\n\n\n##### **输入例子2:**\n\n```\n3 2\n1 2 3\nU 2 8\nQ 3 1\n```\n\n##### **输出例子2:**\n\n```\n8\n```\n\n#### ACM模式\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\n//线段树\nclass NumArray {\nprivate:\n\tvector<int> segmentTree;\n\tint n;\n\n\tvoid build(int node, int s, int e, vector<int> &nums) {\n\t\tif (s == e) {\n\t\t\tsegmentTree[node] = nums[s];\n\t\t\treturn;\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tbuild(node * 2 + 1, s, m, nums);\n\t\tbuild(node * 2 + 2, m + 1, e, nums);\n\t\tsegmentTree[node] = max(segmentTree[node * 2 + 1], segmentTree[node * 2 + 2]);\n\t}\n\n\tvoid change(int index, int val, int node, int s, int e) {\n\t\tif (s == e) {\n\t\t\tsegmentTree[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tif (index <= m) {\n\t\t\tchange(index, val, node * 2 + 1, s, m);\n\t\t}\n\t\telse {\n\t\t\tchange(index, val, node * 2 + 2, m + 1, e);\n\t\t}\n\t\tsegmentTree[node] = max(segmentTree[node * 2 + 1], segmentTree[node * 2 + 2]);\n\t}\n\n\tint range(int left, int right, int node, int s, int e) {\n\t\tif (left == s && right == e) {\n\t\t\treturn segmentTree[node];\n\t\t}\n\t\tint m = s + (e - s) / 2;\n\t\tif (right <= m) {\n\t\t\treturn range(left, right, node * 2 + 1, s, m);\n\t\t}\n\t\telse if (left > m) {\n\t\t\treturn range(left, right, node * 2 + 2, m + 1, e);\n\t\t}\n\t\telse {\n\t\t\treturn max(range(left, m, node * 2 + 1, s, m), range(m + 1, right, node * 2 + 2, m + 1, e));\n\t\t}\n\t}\n\npublic:\n\tNumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {\n\t\tbuild(0, 0, n - 1, nums);\n\t}\n\n\tvoid update(int index, int val) {\n\t\tchange(index, val, 0, 0, n - 1);\n\t}\n\n\tint rangeMax(int left, int right) {\n\t\treturn range(left, right, 0, 0, n - 1);\n\t}\n};\n\nint getMax(vector<int>& nums, int left, int right) {\n\tint ans = 0;\n\tfor (int i = left; i <= right; i++) {\n\t\tans = max(ans, nums[i]);\n\t}\n\treturn ans;\n}\n\n//线段树\nint main() {\n\twhile (cin) {\n\t\tvector<int> scores;\n\t\tint size;\n\t\tcin >> size;\n\t\tint steps;\n\t\tcin >> steps;\n\t\tscores.resize(size);\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tcin >> scores[i];\n\t\t\t//cout<<scores[i]<<\" \";\n\t\t}\n\t\tNumArray nArray(scores);\n\t\twhile (steps) {\n\t\t\tsteps--;\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\t\t\tif (ch == 'Q') {\n\t\t\t\tint left;\n\t\t\t\tcin >> left;\n\t\t\t\tint right;\n\t\t\t\tcin >> right;\n\t\t\t\tleft--;\n\t\t\t\tright--;\n\t\t\t\tif (left > right) {\n\t\t\t\t\tswap(left, right);\n\t\t\t\t}\n\t\t\t\tif (right >= size) right = size - 1;\n\t\t\t\tint ans = nArray.rangeMax(left, right);\n\t\t\t\t//int ans = getMax(scores, left, right);\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pos, val;\n\t\t\t\tcin >> pos;\n\t\t\t\tpos--;\n\t\t\t\tcin >> val;\n\t\t\t\t//scores[pos] = val;\n\t\t\t\tnArray.update(pos, val);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/) 字节\n\n难度困难1450\n\n给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。\n\n请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,0]\n输出：3\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,4,-1,1]\n输出：2\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,8,9,11,12]\n输出：1\n```\n\n#### 解法1\n\n原地构建哈希\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220424160420133.png\" alt=\"image-20220424160420133\" style=\"zoom:67%;\" />\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n      int n = nums.size();\n      for(int& num : nums){\n        if(num <= 0)\n          num = INT_MAX;\n      }\n      for(int i = 0; i<n; i++){\n        int num = abs(nums[i]);\n        if(num <= n){\n          //注意不能修改为任意值 因为后面还会用到他的绝对值 记录的位置\n          nums[num - 1] = -abs(nums[num - 1]);\n        }\n      }\n      for(int i = 0; i<n; i++){\n        if(nums[i] > 0)\n          return i+1;\n      }\n      return n+1;\n    }\n};\n```\n\n#### 解法2\n\n```c++\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums[nums[i] - 1], nums[i]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n};\n```\n\n\n\n## 华为4.13笔试\n\n### 1. 硬件资源分配\n\n有M台服务器，每台服务器有以下属性：编号、CPU核数（1~100）、内存、CPU架构（0~8）、是否支持NP加速的标识（0,1）。然后有一个资源分配要求，要求分配N台满足要求的服务器。具体如下：CPU核数>=cpuCount、内存>=memSize、CPU架构=cpuArch、是否支持NP加速=supportNP。其中，cpuCount、memSize、cpuArch、supportNP为这个要求输入的分配参数。\n分配时会指定优先级策略，策略如下：\n策略1：CPU优先，优先选择CPU核数满足分配要求并且最接近分配要求的cpuCount。如果CPU核数相同，在按内存满足要求并选择最接近memSize的服务器分配。\n策略2：内存优先，优先选择内存满足分配要求并且最接近分配要求的memSize。如果内存相同，在按cpu核数满足要求并选择最接近cpuCount的服务器分配\n如果两台服务器属性都相同，则按服务器编号从小到大选择（编号不会重复）\n\n输入：\n第一行：服务器数量M\n接下来M行为M台服务器属性的数组\n下一行为分配要求：最大分配数量N，分配策略strategy，cupCount，memSize，cpuArch，supportNP\n其中：\n1<=M<=1000\n1<=N<=1000\nstrategy：1表示策略1,2表示策略2\n1<=cpuCount<=100\n10<=memSize<=1000\n0<=cpuArch<=8，另外，cpuArch使用9表示所有服务器架构都满足分配要求\n0<=supportNP<=1，另外，为2时表示无论是否支持NP加速都满足分配要求\n\n输出\n先输出实际分配数量，后按照分配的服务器编号从小到大依次输出，以空格分开\n\n#### 样例1\n\n> 输入\n> 4\n> 0,2,200,0,1\n> 1,3,400,0,1\n> 2,3,400,1,0\n> 3,3,300,0,1\n> 3 1 3 200 0 1\n> 输出\n> 2 1 3\n> 解释：只有1和3满足要求，要求分配2台服务器，所以结果为2 1 3\n\n#### 样例2\n\n> 输入\n> 6\n> 0,2,200,0,1\n> 1,4,330,2,1\n> 2,3,400,3,1\n> 3,3,310,1,1\n> 4,3,320,8,1\n> 5,3,330,0,1\n> 3 2 3 300 9 2\n> （这里注意一下输入的格式，最后一行是空格分开）\n> 输出\n> 3 3 4 5\n> 解释：编号1~5都满足分配要求，按策略2分配即内存优先，内存>=300并且最接近300的服务器编号是3 4 1 5 2。\n> 其中1和5内存相同，然后会比较CPU，即CPU>=3且最接近的，所以5优先于1.因此最后分配的三台服务器是3 4 5。\n> 输出时先输出数量3，再按编号排序输出3 4 5\n\n#### 思路\n\n建立结构体 先按照策略规则排序， 在按照id排序  `自定义排序规则`\n\n#### 知识点\n\n1. 分割字符串的函数 背一下\n\n   ```c++\n   vector<string> splitStr(string str, char target) {\n   \tvector<string> ans;\n   \tstringstream ss(str);\n   \twhile (getline(ss, str, target)) {\n   \t\tans.push_back(str);\n   \t}\n   \treturn ans;\n   }\n   ```\n\n2. cin>> 和 getline\n\n    cin 按 `回车 tab 空格` 分割 但是<u>没有在缓冲区清除 回车 tab 空格</u>，连续cin没有什么影响 \n\n   但是后面如果用getline就有影响了 getline不会忽略前面的 回车 tab 空格\n\n```c++\nstruct serverInfo {\n\tint id;\n\tint cupCount;\n\tint memSize;\n\tint cpuArch;\n\tint supportNP;\n};\n\nvector<string> splitStr(string str, char target) {\n\tvector<string> ans;\n\tstringstream ss(str);\n\twhile (getline(ss, str, target)) {\n\t\tans.push_back(str);\n\t}\n\treturn ans;\n}\n\nvoid huaWei413_1() {\n\tint size;\n\tcin >> size;\n\tcin.ignore(); //好像cin 到 geline需要清空缓冲区？\n\tstring temp;\n\tvector<serverInfo> allServer;\n\twhile (size) {\n\t\tgetline(cin, temp);\n\t\tstring num;\n\t\tserverInfo tmpServer;\n\t\tvector<string> oneServer = splitStr(temp, ',');\n\t\tallServer.push_back(serverInfo{ stoi(oneServer[0]), stoi(oneServer[1]),\n\t\t\t\t\t\t\t\t\t   stoi(oneServer[2]), stoi(oneServer[3]),\n\t\t\t\t\t\t\t\t\t   stoi(oneServer[4]) });\n\t\tsize--;\n\t}\n\n\tserverInfo need;\n\tstring ne;\n\tgetline(cin, ne); // cin 在空格/tab/回车终止 getline在回车终止\n\tvector<string> needed = splitStr(ne, ' ');\n\n\tint N = stoi(needed[0]);\n\tint strategy = stoi(needed[1]);\n\tint minCupCount = stoi(needed[2]);\n\tint minMemSize = stoi(needed[3]);\n\tint certainCpuArch = stoi(needed[4]);\n\tint certainSuportNP = stoi(needed[5]);\n\n\tvector<serverInfo> goodServer;\n\tfor (auto &server : allServer) {\n\t\tif (server.cupCount >= minCupCount && server.memSize > minMemSize &&\n\t\t\t(server.supportNP == certainSuportNP || certainSuportNP == 2) &&\n\t\t\t(server.cpuArch == certainCpuArch || certainCpuArch == 9)) {\n\t\t\tgoodServer.push_back(server);\n\t\t}\n\t}\n\n\tsort(goodServer.begin(), goodServer.end(),\n\t\t[&](const serverInfo &a, const serverInfo &b) -> bool {\n\t\tif (strategy == 1) {\n\t\t\tif (a.cupCount != b.cupCount) {\n\t\t\t\treturn a.cupCount < b.cupCount;\n\t\t\t}\n\t\t\telse {\n                  //可能是有必要的 goodserver远远大于N\n\t\t\t\tif (a.memSize == b.memSize)\n\t\t \t\t\treturn a.id < b.id;\n\t\t\t\treturn a.memSize < b.memSize;\n\t\t\t}\n\t\t}\n\t\telse if (strategy == 2) {\n\t\t\tif (a.memSize != b.memSize) {\n\t\t\t\treturn a.memSize < b.memSize;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (a.cupCount == b.cupCount)\n\t\t\t\t\treturn a.id < b.id;\n\t\t\t\treturn a.cupCount < b.cupCount;\n\t\t\t}\n\t\t}\n\t});\n\n\tgoodServer.resize(min(N, goodServer.size()));\n\tsort(goodServer.begin(), goodServer.end(),\n\t\t[](const serverInfo &a, const serverInfo &b) -> bool {\n\t\treturn a.id < b.id;\n\t});\n\tcout << goodServer.size() << \" \";\n\tfor (int i = 0; i < goodServer.size(); i++) {\n\t\tcout << goodServer[i].id << \" \";\n\t}\n}\n```\n\n### 2. 工单调度策略\n\n当小区通信设备上报警时，系统会自动生成待处理的工单，工单调度系统需要根据不同的策略，调度外线工程师（FME）上站去修复工单对应的问题。\n根据与运营商签订的合同，不同严重程度的工单被处理并修复的时长要求不同，这个要求被修复的时长我们称之为SLA时间。假设华为与运营商A签订了运维合同，部署了一套调度系统，只有1个外线工程师（FME），每个工单根据问题严重程度会给一个评分，在SLA时间内完成修复的工单，华为员工获得工单对应的积分，超过SLA完成的工单不获得积分，但必须完成该工单，运营商最终会根据积分付款。\n请设计一种调度策略，根据现状得到调度结果完成所有工单，让这个外线工程师处理的工单处理的工单获得的总积分最多。\n假设从某个调度时刻开始，当前工单数量N，不会产生新的工单，每个工单处理修复耗时为1小时。请设计你的调度策略，完成业务目标。不考虑外线工程师在小区之间行驶的耗时。\n\n输入\n第一行为一个整数N，表示工单的数量。\n接下来N行，每行包括两个整数，第一个整数表示工单的SLA时间（小时），第二个数表示工单的积分。\n\n输出\n输入一个整数表示可以获得的最大积分\n\n```\n输入\n7\n1 6\n1 7\n3 2\n3 1\n2 4\n2 5\n6 1\n输出 \n15\n提示：\n工单数量N ≤106\nSLA时间 ≤ 7×105\n答案的最大积分不会超过2147483647\n```\n\n#### 思路\n\n1. 直接使用一个顶堆是不对的 因为会有如下的情况\n\n   ```\n   3\n   1 2\n   2 8\n   2 8\n   最大应该是16，却输出10\n   ```\n\n2. 正确思路应该是 先进行自定义排序 先按截止时间sla从小到大排序 sla相同则按积分从大到小排序\n\n   优先级的队列的size + 1 即为当前的时间，比较堆顶和当前，动态维护队列\n\n#### 代码\n\n```c++\nvoid huaWei413_2() {\n\tint cnt;\n\tcin >> cnt;\n\tvector<vector<int>> allTimeAndScore(cnt, vector<int>(2));\n\tint i = 0;\n\twhile (cnt) {\n\t\tcnt--;\n\t\tint last_time, score;\n\t\tcin >> last_time >> score;\n\t\tallTimeAndScore[i][0] = last_time;\n\t\tallTimeAndScore[i][1] = score;\n\t\ti++;\n\t}\n\tsort(allTimeAndScore.begin(), allTimeAndScore.end(),\n\t\t[](vector<int> a, vector<int> b) -> bool {\n\t\treturn a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n\t});\n\tint ans = 0;\n\tpriority_queue<int, vector<int>, greater<int>> que;\n\tque.push(allTimeAndScore[0][1]);\n\tans += allTimeAndScore[0][1];\n\tfor (int i = 1; i < allTimeAndScore.size(); i++) {\n\t\tint k = que.size() + 1;\n\t\tif (allTimeAndScore[i][0] >= k) {\n\t\t\tque.push(allTimeAndScore[i][1]);\n\t\t\tans += allTimeAndScore[i][1];\n\t\t}\n\t\telse {\n\t\t\tif (!que.empty() && allTimeAndScore[i][1] > que.top() && allTimeAndScore[i][0] == k - 1) {\n\t\t\t\tans -= que.top();\n\t\t\t\tque.pop();\n\t\t\t\tque.push(allTimeAndScore[i][1]);\n\t\t\t\tans += allTimeAndScore[i][1];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}\n```\n\n## 【2021】阿里巴巴编程题\n\n### [编程题]1. 子集\n\n![image-20220416151505101](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416151505101.png)\n\n##### **输出描述:**\n\n```\n输出行,每一行对应每组数据的输出.\n```\n\n##### **输入例子1:**\n\n```\n2\n3\n1 3 2\n0 2 3\n4\n1 5 4 2 \n10 32 19 21\n```\n\n##### **输出例子1:**\n\n```\n2\n3\n```\n\n#### 思路\n\n1. 排序 最长递增子序列dp  超时\n\n   还是要注意一下dp的含义， 用到当前元素的 子序列的 最大长度\n\n2. 二分 妈的 不看还不行了\n\n   二分的思路是这样的[动态规划设计：最长递增子序列 :: labuladong的算法小抄](https://labuladong.github.io/algo/3/24/77/)\n\n   大佬的文章中提到了扑克牌的思路，其中有几个点\n\n   ![image-20220416161203581](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416161203581.png)\n\n   1. 每一堆扑克牌的最上方纸牌 是单调递增的\n\n   2. 结论：扑克牌的堆数 就是LIS的大小\n\n   3. 思路：因为每次放一张扑克牌，堆顶都是单调递增的\n\n      所以可以每次去`二分查找`放在哪一堆（即找到`最接近的` 大于当前的 牌的 index），如果没有找到（即index == 堆的size）\n\n      `开辟新的一堆`\n\n   4. 因此，使用的左边界的二分查找！\n\n3. 注意点\n\n   lower_bound查找超范围的判断\n\n   ```c++\n     vector<int> v{0, 1, 2, 3, 4};\n     auto it = lower_bound(v.begin(), v.end(), 6);\n     int pos = it - v.begin(); // pos = 5 返回的就是查找区间的大小\n     if (pos == v.size())\n       cout << \"超范围了。。。查找的元素比所有元素都大\" << endl;\n   ```\n\n#### 代码\n\n1. dp\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid ali12() {\n  int bigSize;\n  cin >> bigSize;\n  while (bigSize) {\n    bigSize--;\n    int cnt;\n    cin >> cnt;\n    vector<pair<int, int>> all(cnt);\n    for (int i = 0; i < cnt; i++) {\n      cin >> all[i].first;\n    }\n    for (int i = 0; i < cnt; i++) {\n      cin >> all[i].second;\n    }\n    sort(all.begin(), all.end(),\n         [](pair<int, int> a, pair<int, int> b) -> bool {\n           return a.second == b.second?a.first>b.first:a.second < b.second;\n         });\n    vector<int> dp(all.size(), 1);\n      \n    int ans = 1;\n    for (int i = 0; i < all.size(); i++) {\n      for (int j = 0; j < i; j++) {\n        if (all[i].first > all[j].first) {\n          dp[i] = max(dp[i], dp[j] + 1);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    cout << ans << endl;\n  }\n}\n\nint main() {\n  // huaWei413_1();\n  ali12();\n  return 0;\n}\n```\n\n二分\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid ali12() {\n\tint bigSize;\n\tcin >> bigSize;\n\twhile (bigSize) {\n\t\tbigSize--;\n\t\tint cnt;\n\t\tcin >> cnt;\n\t\tvector<pair<int, int>> all(cnt);\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tcin >> all[i].first;\n\t\t}\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tcin >> all[i].second;\n\t\t}\n\t\tsort(all.begin(), all.end(),\n\t\t\t[](pair<int, int> a, pair<int, int> b) -> bool {\n\t\t\treturn a.second == b.second ? a.first > b.first:a.second < b.second;\n\t\t});\n\t\tvector<int> top(all.size()); //最大堆数\n\t\tint piles = 0; //也就是ans\n\t\tfor (int i = 0; i < all.size(); i++) {\n\t\t\tint nowCard = all[i].first;\n\t\t\tint pos = lower_bound(top.begin(), top.begin() + piles, nowCard) - top.begin();\n\t\t\tif (pos == piles)\n\t\t\t\tpiles++;\n\t\t\ttop[pos] = nowCard;\n\t\t}\n\t\tcout << piles << endl;\n\t}\n}\n\nint main() {\n\t// huaWei413_1();\n\tali12();\n\treturn 0;\n}\n```\n\n### [编程题]2. 小强爱数学\n\n![image-20220416164232407](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416164232407.png)\n\n##### **输入例子1:**\n\n```\n3\n4 4 3\n2 3 4\n5 2 6\n```\n\n##### **输出例子1:**\n\n```\n16\n999999993\n9009\n```\n\n#### 思路\n\n数学问题\n记 Rn = x^n + y^n, a = x + y, b = x * y\n\n递推公式：Rn = a * Rn-1 - b * Rn-2\n\n#### 代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll 1000000007\n// X+Y = A;\n// XY = B\n\nvoid ali2() {\n\tint bigSize;\n\tcin >> bigSize;\n\twhile (bigSize--) {\n\t\tint A, B, n;\n\t\tlong long ANS = 0;\n\t\tcin >> A >> B >> n;\n\n\t\tvector<long> dp(n + 1);\n\t\tdp[0] = 2;\n\t\tdp[1] = A;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = ((A * dp[i - 1] % ll) - (B * dp[i - 2] % ll) + ll) % ll;\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n}\n\nint main() {\n\tali2();\n\treturn 0;\n}\n\n```\n\n","tags":["面试"]},{"title":"char","url":"/2022/04/14/char/","content":"\nconst char * arr = \"123\";\n\n> //字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，`所以加不加const效果都一样`\n\nchar * brr = \"123\";（vs下不加const报错）\n\n> //字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改\"123\"的值\n\nconst char crr[] = \"123\";\n\n> //这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区\n\nchar drr[] = \"123\";     `//保存在栈区 只有这个可以修改`\n\n> //字符串123保存在栈区，可以通过drr去修改\n\n \n\n### 运行分析\n\n![image-20220414110033578](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220414110033578.png)\n\n1. const char * arr = \"123\" 和 char * brr = \"123\"都保存在常量区 值相同 猜测可能是处理器优化 索性`指向了同一地址`\n2. 由于两者都分配在了常量区 只是指向他们的指针不同 所以`不能通过指针去修改常量区的字符串`\n3. char* 和 const char* 指针的指向是可以修改的 例如 char* bbrr = \"456\"; brr = bbrr;\n\n![image-20220414111142974](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220414111142974.png)\n\n1. const char crr[] = \"123\";明显与其他“123”的地址不同，因为其是字符串数组 const修饰数组不可修改。<u>crr[0] = '2'提示crr是不可修改的左值</u> \n\n2. char crr[] 本身crr指向就是不可更改的 也不能++-- \n\n   ```c++\n     int *pp = new int(1);\n     int ppp[3];\n     ppp[0] = 2;\n     ppp[1] = 3;\n     ppp[2] = 4;\n   \n     //   ppp = pp; //不可\n     pp = ppp;  //可\n   ```\n\n网上详细总计的char\n\n```c++\n  const char *p1 = \"Hello world\"; // p1 指向的地址可更改\n  // 但是不可更改p指向的内容，比如*p1='c'是错误的\n  p1 = \"New Hello world\"; // ok\n  p1[0] = 'c';            // Compile ERROR !!!\n\n  char const *p2 = \"Hello world\"; // 同p1\n  p2 = \"New Hello world\";         // ok\n  p2[0] = 'c';                    // Compile ERROR !!!\n  char str[] = \"Hello world\";\n\n  char *const p3 = str; // p3指向地址不可更改，但是可以更改所指向地址内容\n  p3 = \"New Hello world\"; // Compile ERROR !!!\n  p3[0] = 'c';            // ok\n  p3[1] = 'p';            // ok\n  p3[2] = 'p';            // ok\n\n  char const *const p4 = \"Hello world\"; // p4指向地址和内容均不可更改\n  p4 = \"New Hello world\";               // ERROR !!!\n  p4[0] = 'c';                          // ERROR !!!\n  const char *const p5 = \"Hello world\"; // 同p4\n```\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220502005138787.png\" alt=\"image-20220502005138787\" style=\"zoom:80%;\" />\n\n![image-20220502005845314](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220502005845314.png)","tags":["开发随笔"]},{"title":"-nan","url":"/2022/04/14/nan/","content":"\n-nan\n\n### 起因\n\n在做题时发现了一个问题，三目运算符和max得出的结果不一致，max结果正确而三目运算符结果有问题\n\n#### [812. 最大三角形面积](https://leetcode.cn/problems/largest-triangle-area/)\n\n难度简单145\n\n给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。\n\n```\n示例:\n输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n输出: 2\n解释: \n这五个点如下图所示。组成的橙色三角形是最大的，面积为2。\n```\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1027.png)\n\n简单题简单做，枚举所有三点组合，应用海伦公式计算面积，代码如下`\n\n```c++\nclass Solution {\npublic:\n    double largestTriangleArea(vector<vector<int>>& points) {\n      int n = points.size();\n      double ans = 0;\n      for(int i = 0; i<n; i++){\n        for(int j = i+1; j<n; j++){\n          for(int jj = j+1; jj<n; jj++){\n            double a = distance(points[i], points[j]);\n            double b = distance(points[i], points[jj]);\n            double c = distance(points[j], points[jj]);\n            //cout << a << \" \"<< b <<\" \" << c<<endl;\n            double s = (a + b + c) / 2;\n            double area = sqrt(s*(s-a)*(s-b)*(s-c));\n            //cout << area<<endl;\n            //ans = ans > area ? ans : area;  //错误\n            ans = max(ans, area); //正确\n          }\n        }\n      }\n      return ans;\n    }\n\n    double distance(vector<int>& a, vector<int>& b){\n      return sqrt((a[0] - b[0])*(a[0] - b[0]) + (a[1] - b[1])*(a[1] - b[1]));\n    }\n};\n```\n\n结果显示三目运算符更新ans出错，而max更新则正确，vs调试了一下\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220515160743815.png\" alt=\"image-20220515160743815\" style=\"zoom: 67%;\" />\n\n由于double精度的问题导致相减出现了负值，在sqrt计算后产生了 -nan(ind) \n\n导致后续的三目运算符比较出错！\n\n### 归纳下-nan的产生原因\n\n#### **nan: not a number 非数字**\n\n##### **1. 出现原因：**\n\n（1）分母为“0”，如果分母为零，自然时不能得到一个确定的数字的。\n（2）对负数开平方、对负数求对数（log(-1.0)）。注：0/0会产生操作异常；0.0/0.0不会产生操作异常，而是会得到nan。\n（3）有些[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)在对无穷大与无穷小的计算时也会出现此类情况。\n\n##### **2. 辨别办法：**\n\nisnan(): ture is nan, false otherwise","tags":["开发随笔"]},{"title":"dp","url":"/2022/04/14/dp/","content":"\n# 框架\n\n```c++\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n```\n\n# 一些dp问题\n\n### [剑指 Offer II 088. 爬楼梯的最少成本](https://leetcode-cn.com/problems/GzCJIP/)\n\n难度简单38英文版讨论区\n\n数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`（下标从 `0` 开始）。\n\n每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。\n\n请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。\n\n \n\n**示例 1：**\n\n```\n输入：cost = [10, 15, 20]\n输出：15\n解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。\n```\n\n **示例 2：**\n\n```\n输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出：6\n解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。\n```\n\n#### 解法1\n\ndp\n\n1. dp数组含义： dp[i]表示到达当前台阶的最小花费\n2. 状态转移： 当前台阶由之前两个台阶跳跃抵达dp[i] = min(dp[i-1] + nums[i-1], dp[i-2] + nums[i-2]);\n3. base case: 第一和第二的花费为0\n\n```c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& nums) {\n      vector<int> dp(nums.size() + 1);\n      for(int i = 2; i<nums.size() + 1; i++){\n        dp[i] = min(dp[i-1] + nums[i-1], dp[i-2] + nums[i-2]);\n      }\n      return dp.back();\n    }\n};\n```\n\n### [剑指 Offer II 091. 粉刷房子](https://leetcode-cn.com/problems/JEj789/)\n\n难度中等35英文版讨论区\n\n假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。\n\n例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。\n\n请计算出粉刷完所有房子最少的花费成本。\n\n \n\n**示例 1：**\n\n```\n输入: costs = [[17,2,17],[16,16,5],[14,3,19]]\n输出: 10\n解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。\n     最少花费: 2 + 5 + 3 = 10。\n```\n\n#### 解法 dp\n\n1. dp数组含义：dp[i] [j]表示粉刷到第i个房子 用第j个颜色的最小花费\n2. 状态转移方程：当前房子当前颜色 的值 为上一个房子 其他颜色中的最小值\n3. base case：第一个房子 的花费 结尾当前颜色的cost\n\n```c++\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& costs) {\n      int m = costs.size();\n      int n = m == 0?0:costs[0].size();\n      vector<vector<int>> dp(m, vector<int>(n));\n      dp[0] = costs[0];\n      for(int i = 1; i<m; i++){\n        for(int j = 0; j<n; j++){\n          int tempMin = INT_MAX;\n          for(int k = 0; k<n; k++){\n            if(k != j){\n              tempMin = min(tempMin, dp[i-1][k]);\n            }\n          } \n          dp[i][j] = costs[i][j] + tempMin;\n        }\n      }\n      return *min_element(dp.back().begin(), dp.back().end());\n    }\n};\n```\n\n### [剑指 Offer II 092. 翻转字符](https://leetcode-cn.com/problems/cyJERH/)\n\n难度中等28英文版讨论区\n\n如果一个由 `'0'` 和 `'1'` 组成的字符串，是以一些 `'0'`（可能没有 `'0'`）后面跟着一些 `'1'`（也可能没有 `'1'`）的形式组成的，那么该字符串是 **单调递增** 的。\n\n我们给出一个由字符 `'0'` 和 `'1'` 组成的字符串 s，我们可以将任何 `'0'` 翻转为 `'1'` 或者将 `'1'` 翻转为 `'0'`。\n\n返回使 s **单调递增** 的最小翻转次数。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"00110\"\n输出：1\n解释：我们翻转最后一位得到 00111.\n```\n\n**示例 2：**\n\n```\n输入：s = \"010110\"\n输出：2\n解释：我们翻转得到 011111，或者是 000111。\n```\n\n#### dp解法\n\n1. dp数组含义：单调递增的子字符串 ：dp[0] [i]最后一个是0   dp[1] [i]最后一个是1\n\n2. 状态转移方程：\n\n   当前为0 = 之前为0 + 现在的数（是1的话 需要反转+1，0的话则不需要加）\n\n   当前为1 = 之前为0 和 之前为1 中的小值 + 现在的数（是1的话 不需要反转，0的话需要反转+1）\n\n3. base case：\n\n```c++\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n      int n = s.size();\n      vector<vector<int>> dp(2, vector<int>(n));\n      dp[0][0] = s[0] == '0'?0:1;\n      dp[1][0] = s[0] == '1'?0:1;\n      for(int i = 1; i<n; i++){\n        dp[0][i] = dp[0][i-1] + (s[i] == '0'?0:1);\n        dp[1][i] = min(dp[0][i-1], dp[1][i-1]) + (s[i] == '1'?0:1);\n      }\n      return min(dp[0][n-1], dp[1][n-1]);\n    }\n};\n```\n\n### [剑指 Offer II 093. 最长斐波那契数列](https://leetcode-cn.com/problems/Q91FMA/)\n\n难度中等31英文版讨论区\n\n如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 *斐波那契式* 的：\n\n- `n >= 3`\n- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`\n\n给定一个**严格递增**的正整数数组形成序列 `arr` ，找到 `arr` 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。\n\n*（回想一下，子序列是从原序列 `arr` 中派生出来的，它从 `arr` 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， `[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的一个子序列）*\n\n \n\n\n\n**示例 1：**\n\n```\n输入: arr = [1,2,3,4,5,6,7,8]\n输出: 5\n解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。\n```\n\n**示例 2：**\n\n```\n输入: arr = [1,3,7,11,12,14,18]\n输出: 3\n解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n```\n\n#### 暴力解法\n\n因为是斐波那契 所以两个数就可以确定整个序列\n\n暴力也就是枚举所有的两个数的组合 然后交替查找下一个数是否在nums中 并更新ans\n\n```c++\nclass Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        int N = A.size();\n        unordered_set<int> S(A.begin(), A.end());\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                int x = A[j], y = A[i] + A[j];\n                int length = 2;\n                while (S.find(y) != S.end()) {\n                    int z = x + y;\n                    x = y;\n                    y = z;\n                    ans = max(ans, ++length);\n                }\n            }\n\n        return ans >= 3 ? ans : 0;\n    }\n};\n```\n\n#### dp解法\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220501231554023.png\" alt=\"image-20220501231554023\" style=\"zoom: 67%;\" />\n\n```c++\nclass Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& nums) {\n      int n = nums.size();\n      if(n == 0) return 0;\n      vector<vector<int>> dp(n, vector<int>(n, 2));\n      unordered_map<int, int> mapp;\n      for(int i = 0; i<n; i++)\n        mapp[nums[i]] = i;\n      int ans = 0;\n      for(int i = 0; i<n; i++){\n        for(int j = i+1; j<n; j++){\n          int diff = nums[j] - nums[i];\n          if(mapp.count(diff)){\n            int preIndex = mapp[diff];\n            if(preIndex<i)\n              dp[i][j] = max(dp[i][j], dp[preIndex][i] + 1);\n          }\n          ans = max(ans, dp[i][j]);\n        }\n      }\n      return ans>2?ans:0;\n    }\n};\n```\n\n### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\n给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132135089.gif)\n\n \n\n**示例 1:**\n\n```\n输入: numRows = 5\n输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n```\n\n#### 思路\n\n1. dp迭代 生成二维ans数组\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> ans;\n        for(int i = 0; i<numRows; i++){\n            vector<int> temp(i+1);\n            temp[0] = temp[i] = 1;  //首位数据是确定的 base case\n            for(int j = 1; j<i; j++){\n                //状态转移方程\n                temp[j] = ans[i-1][j-1] + ans[i-1][j];\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```\n\n### [119. 杨辉三角 II ](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132138328.gif)\n\n示例 1:\n\n输入: rowIndex = 3\n输出: [1,3,3,1]\n\n#### 思路\n\n1. 注意 此处的rowIndex 从0开始\n\n#### 朴素的dp解法\n\n```c++\n//dp解法\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<vector<int>> C(rowIndex + 1); //这道题rowindex从0开始\n        for (int i = 0; i <= rowIndex; ++i) {\n            C[i].resize(i + 1);\n            C[i][0] = C[i][i] = 1; //base case 首尾必定是1\n            for (int j = 1; j < i; ++j) {\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n            }\n        }\n        return C[rowIndex];\n    }\n};\n```\n\n#### 滚动数组优化\n\n```c++\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> pre, cur;\n        for (int i = 0; i <= rowIndex; ++i) {\n            cur.resize(i + 1);\n            cur[0] = cur[i] = 1;\n            for (int j = 1; j < i; ++j) {\n                cur[j] = pre[j - 1] + pre[j];\n            }\n            pre = cur;\n        }\n        return pre;\n    }\n};\n```\n\n#### 继续优化 从后到前\n\n```c++\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> row(rowIndex + 1);\n        row[0] = 1;\n        for (int i = 1; i <= rowIndex; ++i) {\n            for (int j = i; j > 0; --j) {\n                row[j] += row[j - 1];\n            }\n        }\n        return row;\n    }\n};\n```\n\n#### 线性递推\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203132145601.jpeg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n```c++\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> row(rowIndex + 1);\n        row[0] = 1;\n        for (int i = 1; i <= rowIndex; ++i) {\n          \t//杨辉三角 组合数规律\n            row[i] = 1LL * row[i - 1] * (rowIndex - i + 1) / i;\n        }\n        return row;\n    }\n};\n```\n\n\n\n# 打家劫舍\n\n### [剑指 Offer II 089. 房屋偷盗](https://leetcode-cn.com/problems/Gu0c2T/)\n\n难度中等19\n\n一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n\n给定一个代表每个房屋存放金额的非负整数数组 `nums` ，请计算 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n```\n\n#### 解法1 dp\n\n1. dp含义：dp[i] 表示0 - i个房屋 能够偷的最多钱\n2. 状态转移：max（偷当前房屋（这家存款 + 前前dp），不偷当前房屋（前dp）)\n3. base case：   dp[0] = nums[0]; dp[1] = max(dp[0], nums[1]);\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n      int n = nums.size();\n      if(n == 1) return nums.front();\n      vector<int> dp(n);\n      dp[0] = nums[0];\n      dp[1] = max(dp[0], nums[1]);\n      for(int i = 2; i<n; i++){\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i]);\n      }\n      return dp.back();\n    }\n};\n```\n\n### [剑指 Offer II 090. 环形房屋偷盗](https://leetcode-cn.com/problems/PzWKhm/)\n\n难度中等17\n\n一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。\n\n给定一个代表每个房屋存放金额的非负整数数组 `nums` ，请计算 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n```\n\n#### 解法\n\n首尾房间不能同时被抢，那么只可能有三种不同情况：\n\n- 要么都不被抢；\n- 要么第一间房子被抢最后一间不抢；\n- 要么最后一间房子被抢第一间不抢。\n\n所以只需要计算 `第一家不抢和最后一家不抢`的 情况 取最大值\n\n```c++\nclass Solution {\npublic:\n    //首尾房间不能同时被抢，那么只可能有三种不同情况：\n    //要么都不被抢；\n    //要么第一间房子被抢最后一间不抢；\n    //要么最后一间房子被抢第一间不抢。\n    //所以只需要计算 第一家不抢和最后一家不抢的 情况 取最大值\n    int rob(vector<int>& nums) {\n      int n = nums.size();\n      if(n == 1) return nums.front();\n      if(n <= 3) return *max_element(nums.begin(), nums.end());\n      vector<int> dp(n);\n      // 从第二家 抢到最后\n      dp[1] = nums[1];\n      dp[2] = max(nums[1], nums[2]);\n      for(int i = 3; i<n; i++){\n        dp[i] = max(dp[i-2] + nums[i], dp[i-1]);\n      }\n      int tempMax = dp[n-1];\n      //第一家抢到倒数第二家\n      dp[0] = nums[0];\n      dp[1] = max(nums[0], nums[1]);\n      for(int i = 2; i<n - 1; i++){\n        dp[i] = max(dp[i-2] + nums[i], dp[i-1]);\n      }\n      return max(tempMax, dp[n-2]);\n    }\n};\n```\n\n### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=337)[思路](https://leetcode-cn.com/problems/house-robber-iii/#)\n\n难度中等1272\n\n小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。\n\n除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。\n\n给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。\n\n \n\n**示例 1:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob1-tree.jpg)\n\n```\n输入: root = [3,2,3,null,3,null,1]\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\n```\n\n**示例 2:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rob2-tree.jpg)\n\n```\n输入: root = [3,4,5,1,3,null,1]\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n```\n\n####  解法1 记忆化递归\n\n**本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算**。\n\n与198.打家劫舍，213.打家劫舍II一样，关键是要讨论当前节点抢还是不抢。\n\n如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（**注意这里说的是“考虑”**）\n\n使用一个map把计算过的结果保存一下，这样如果计算过孙子了，那么计算孩子的时候可以复用孙子节点的结果。不然会超时\n\n```c++\nclass Solution {\npublic:\n    unordered_map<TreeNode*, int> mapp;\n    int rob(TreeNode* root) {\n      if(root == nullptr) return 0;\n      if(root->left == nullptr && root->right == nullptr)\n        return root->val;\n      if(mapp[root]) return mapp[root];\n      //偷父节点\n      int val1 = root->val;\n      if(root->left) val1 += rob(root->left->left) + rob(root->left->right);\n      if(root->right) val1 += rob(root->right->left) + rob(root->right->right);\n      //不偷父节点\n      int val2 = rob(root->left) + rob(root->right);\n      mapp[root] = max(val1, val2);\n      return max(val1, val2);\n    }\n};\n```\n\n#### 解法2 树形dp\n\ndp含义：使用一个pair记录当前节点 偷 与 不偷 可以获得的最大金钱\n\n状态转移：偷当前节点（当前val + 左子树不偷 + 右子树不偷），不偷当前（左子树偷 + 右子树偷）\n\nbase case：节点为空 偷不偷都为0\n\n```c++\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n      pair<int, int> ans = helper(root);\n      return max(ans.first, ans.second);\n    }\n    //first偷 second不偷\n    pair<int, int> helper(TreeNode* node){\n      if(node == nullptr) return pair<int, int>(0, 0);\n      pair<int, int> left = helper(node->left);\n      pair<int, int> right = helper(node->right);\n      //偷父节点\n      int val1 = node->val + left.second + right.second;\n      //不偷父节点\n      int val2 = max(left.first, left.second) + max(right.first, right.second);\n      return pair<int, int>(val1, val2);\n    }\n};\n```\n\n### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n\n> 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n>\n> 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n>\n> 你可以认为每种硬币的数量是无限的。\n>\n>  \n>\n> 示例 1：\n>\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n> 示例 2：\n>\n> 输入：coins = [2], amount = 3\n> 输出：-1\n> 示例 3：\n>\n> 输入：coins = [1], amount = 0\n> 输出：0\n\n```c++\nclass Solution {\npublic:\n    //递归暴力\n    int coinChange(vector<int>& coins, int amount) {\n      if(amount == 0) return 0;\n      if(amount < 0) return -1;\n      \n      int res = INT_MAX;\n      for(int i = 0; i<coins.size(); i++){\n        int subproblem = coinChange(coins, amount - coins[i]);\n        if(subproblem == -1) continue;\n        res = min(res, subproblem+1);\n      }\n      return res==INT_MAX?-1:res;\n    }\n\n    // //递归优化\n    vector<int> memo;\n    int coinChange(vector<int>& coins, int amount) {\n      memo = vector<int>(amount+1, -666);\n      return dp(coins, amount);\n    }\n    int dp(vector<int>& coins, int amount) {\n      if(amount == 0) return 0;\n      if(amount < 0) return -1;\n      \n      // 查备忘录，防止重复计算\n      if (memo[amount] != -666)\n        return memo[amount];\n\n      int res = INT_MAX;\n      for(int i = 0; i<coins.size(); i++){\n        int subproblem = dp(coins, amount - coins[i]);\n        if(subproblem == -1) continue;\n        res = min(res, subproblem+1);\n      }\n      memo[amount] = res==INT_MAX?-1:res;\n      return memo[amount];\n    }\n\n    //dp\n    int coinChange(vector<int>& coins, int amount) {\n      if(amount == 0) return 0;\n      if(amount < 0) return -1;\n      vector<int> dp(amount + 1, amount+1);\n\n      dp[0] = 0;\n      // 外层 for 循环在遍历所有状态的所有取值\n      for(int i = 0; i<dp.size(); i++){\n        // 内层 for 循环在求所有选择的最小值\n        for(int coin : coins){\n          //子问题无解 跳过\n          if(i - coin <0) continue;\n          dp[i] = min(dp[i], 1+dp[i-coin]);\n        }\n      }\n      return (dp[amount] == amount + 1) ? -1 : dp[amount];\n    }\n};\n```\n\n# 背包问题\n\n## 总结\n\n### 背包递推公式\n\n问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：\n\n- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.分割等和子集.html)\n- [动态规划：1049.最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.最后一块石头的重量II.html)\n\n问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：\n\n- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.目标和.html)\n- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)\n- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.组合总和Ⅳ.html)\n- [动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)\n\n问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：\n\n- [动态规划：474.一和零(opens new window)](https://programmercarl.com/0474.一和零.html)\n\n问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：\n\n- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.零钱兑换.html)\n- [动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)\n\n### [#](https://programmercarl.com/背包总结篇.html#遍历顺序)遍历顺序\n\n#### [#](https://programmercarl.com/背包总结篇.html#_01背包)01背包\n\n在[01背包](https://programmercarl.com/背包理论基础01背包-1.html)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。\n\n和[01背包（滚动数组）](https://programmercarl.com/背包理论基础01背包-2.html)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。\n\n**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**\n\n#### [#](https://programmercarl.com/背包总结篇.html#完全背包)完全背包\n\n说完01背包，再看看完全背包。\n\n在[完全背包](https://programmercarl.com/背包问题理论基础完全背包.html)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。\n\n但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。\n\n<u>**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。</u>\n\n<u>**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。</u>\n\n相关题目如下：\n\n- 求组合数：[动态规划：518.零钱兑换II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)\n- 求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)、[动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)\n\n如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：\n\n- 求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.零钱兑换.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)\n\n## 01背包\n\n#### 二维数组\n\n背包最大重量为4， 每个物品只能用一次，问背包能装的最大价值？\n\n| 物品  | 重量 | 价值 |\n| ----- | ---- | ---- |\n| 物品0 | 1    | 15   |\n| 物品1 | 3    | 20   |\n| 物品2 | 4    | 30   |\n\n对于背包问题，有一种写法， 是使用二维数组，即**dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。\n\n![动态规划-背包问题5](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202101101032124.png)\n\n```c++\nvoid test_2_wei_bag_problem1() {\n    vector<int> weight = {1, 3, 4};\n    vector<int> value = {15, 20, 30};\n    int bagweight = 4;\n\n    // 二维数组\n    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));\n\n    // 初始化\n    for (int j = weight[0]; j <= bagweight; j++) {\n        dp[0][j] = value[0];\n    }\n\n    // weight数组的大小 就是物品个数\n    for(int i = 1; i < weight.size(); i++) { // 遍历物品\n        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量\n            if (j < weight[i]) dp[i][j] = dp[i - 1][j];\n            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n\n        }\n    }\n\n    cout << dp[weight.size() - 1][bagweight] << endl;\n}\n\nint main() {\n    test_2_wei_bag_problem1();\n}\n```\n\n#### 滚动一维数组\n\n```c++\nvoid test_1_wei_bag_problem() {\n    vector<int> weight = {1, 3, 4};\n    vector<int> value = {15, 20, 30};\n    int bagWeight = 4;\n\n    // 初始化\n  \t//dp[i]表示前*个物品 背包容量为i时的最大价值\n    vector<int> dp(bagWeight + 1, 0);\n    for(int i = 0; i < weight.size(); i++) { // 遍历物品\n        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);  //dp复用\n        }\n    }\n    cout << dp[bagWeight] << endl;\n}\n\nint main() {\n    test_1_wei_bag_problem();\n}\n```\n\n### [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n> 示例 1：\n>\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n>\n> 示例 2：\n>\n> 输入：nums = [1,2,3,5]\n> 输出：false\n> 解释：数组不能分割成两个元素和相等的子集。\n\n这也是一道经典的背包题\n\n理解：\n\n>背包的最大重量为sum/2\n>\n>物品的重量为nums[i]\n>\n>物品的价值为nums[i]\n>\n>`每个物品只有一个 求背包装最大的价值`\n\n```c++\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n      int allSum = accumulate(begin(nums), end(nums), 0);\n      if(allSum%2) return 0;\n      int target = allSum/2;\n      vector<vector<int>> dp(nums.size(), vector<int>(target+1, 0));\n      for(int j = nums[0]; j<=target; j++){\n        dp[0][j] = nums[0];\n      }\n\n      for(int i = 1; i<nums.size(); i++){\n        for(int j = 0; j<=target; j++){\n          if(j < nums[i]) dp[i][j] = dp[i-1][j];\n          else{\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i]);            \n          }\n        }\n      }\n      return dp[nums.size()-1][target] == target;\n    }\n};\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n      int allSum = accumulate(begin(nums), end(nums), 0);\n      if(allSum%2) return 0;\n      int target = allSum/2;\n\n      // dp[i]中的i表示背包内总和\n      // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200\n      // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以\n      vector<int> dp(10001, 0);\n      //begin 0/1\n      for(int i = 0; i<nums.size(); i++){\n        for(int j = target; j>=nums[i]; j--){\n          dp[\n            \n            \n            \n            j] = max(dp[j], dp[j-nums[i]] + nums[i]);\n        }\n      }\n      return dp[target] == target;\n    }\n};\n```\n\n### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)\n\n难度中等449收藏分享切换为英文接收动态反馈\n\n有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n\n- 如果 `x == y`，那么两块石头都会被完全粉碎；\n- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n\n最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。\n\n \n\n**示例 1：**\n\n```\n输入：stones = [2,7,4,1,8,1]\n输出：1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n```\n\n**示例 2：**\n\n```\n输入：stones = [31,26,33,21,40]\n输出：5\n```\n\n#### 解法\n\n转换为等和子集问题，尽量一半一半的放，看凑的最接近一半的重量是多少\n\n```c++\nclass Solution {\npublic:\n    int lastStoneWeightII(vector<int>& nums) {\n      int sum = accumulate(nums.begin(), nums.end(), 0);\n      int target = sum/2;\n      int n = nums.size();\n      vector<int> dp(target + 1, 0);\n      for(int i = 0; i<n; i++){\n        for(int j = target; j>=nums[i]; j--){\n          dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);\n        }\n      }\n      //sum - dp是另一半 最后结果是另一半-这一半\n      return sum - dp[target] - dp[target];\n    }\n};\n```\n\n### [494. 目标和](https://leetcode.cn/problems/target-sum/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=494)[思路](https://leetcode.cn/problems/target-sum/#)\n\n难度中等1201收藏分享切换为英文接收动态反馈\n\n给你一个整数数组 `nums` 和一个整数 `target` 。\n\n向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：\n\n- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `\"+2-1\"` 。\n\n返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,1,1,1,1], target = 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n```\n\n1. 确定dp数组以及下标的含义 dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\n2. 例如：dp[j]，j 为5，\n   - 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。\n   - 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。\n   - 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]\n   - 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]\n   - 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]\n3. dp数组如何初始化  dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品\n\n```c++\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n      int sum = accumulate(nums.begin(), nums.end(), 0);\n      int summ = sum+target;\n      if(abs(target) > sum) return 0;\n      if(summ%2) return 0;\n      target = summ/2;\n      vector<int> dp(target + 1, 0);\n      //装满容量为0的背包，有1种方法，就是装0件物品\n      dp[0] = 1;\n      for(int i = 0; i<nums.size(); i++){\n        for(int j = target; j>=nums[i]; j--){\n          dp[j] += dp[j - nums[i]];\n        }\n      }\n      return dp[target];\n    }\n};\n```\n\n### [`474. 一和零`](https://leetcode.cn/problems/ones-and-zeroes/)\n\n难度中等715收藏分享切换为英文接收动态反馈\n\n给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。\n\n请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。\n\n如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。\n\n \n\n**示例 1：**\n\n```\n输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n输出：4\n解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n```\n\n**示例 2：**\n\n```\n输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n输出：2\n解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 \n```\n\n#### 解法\n\n1. 确定dp数组（dp table）以及下标的含义\n\n   dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]。\n\n2. 确定递推公式\n\n   dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。\n\n   dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。\n\n   然后我们在遍历的过程中，取dp[i][j]的最大值。\n\n   所以递推公式：dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);\n\n   此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n   对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。\n\n   **这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。\n\n```c++\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n      //dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。\n      vector<vector<int>> dp(m+1, vector<int>(n+1, 0)); // 默认初始化0\n      for(string str: strs){// 遍历物品\n        int oneNum = 0, zeroNum = 0;\n        for(char ch: str){\n          if(ch == '0') zeroNum++;\n          else oneNum++;\n        }\n        for(int i = m; i>=zeroNum; i--){ // 遍历背包容量且从后向前遍历！\n          for(int j = n; j>=oneNum; j--){\n            dp[i][j] =  max(dp[i][j], dp[i-zeroNum][j-oneNum] + 1);\n          }\n        }\n      }\n      return dp[m][n];\n    }\n};\n```\n\n## 完全背包\n\n背包最大重量为4， **每件商品都有无限个**，问背包能装的最大价值？\n\n| 物品  | 重量 | 价值 |\n| ----- | ---- | ---- |\n| 物品0 | 1    | 15   |\n| 物品1 | 3    | 20   |\n| 物品2 | 4    | 30   |\n\n01背包和完全背包唯一不同就是体现在`遍历顺序`上\n\n`反过来了`\n\n\n\n**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。   1 2 和 2 1一样  （爬楼梯）\n\n**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。    1 2 和 2 1 不同 （爬楼梯）\n\n```c++\n// 组合数  先遍历物品，在遍历背包\nvoid test_CompletePack() {\n    vector<int> weight = {1, 3, 4};\n    vector<int> value = {15, 20, 30};\n    int bagWeight = 4;\n    vector<int> dp(bagWeight + 1, 0);\n    for(int i = 0; i < weight.size(); i++) { // 遍历物品\n        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n    cout << dp[bagWeight] << endl;\n}\nint main() {\n    test_CompletePack();\n}\n\n\n// 排列数 先遍历背包，再遍历物品\nvoid test_CompletePack() {\n    vector<int> weight = {1, 3, 4};\n    vector<int> value = {15, 20, 30};\n    int bagWeight = 4;\n\n    vector<int> dp(bagWeight + 1, 0);\n\n    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量\n        for(int i = 0; i < weight.size(); i++) { // 遍历物品\n            if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n    cout << dp[bagWeight] << endl;\n}\nint main() {\n    test_CompletePack();\n}\n```\n\n### [剑指 Offer II 103. 最少的硬币数目](https://leetcode.cn/problems/gaM7Ch/)\n\n难度中等34收藏分享切换为英文接收动态反馈\n\n给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。\n\n你可以认为每种硬币的数量是无限的。\n\n \n\n**示例 1：**\n\n```\n输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n```\n\n**示例 2：**\n\n```\n输入：coins = [2], amount = 3\n输出：-1\n```\n\n#### 解法 完全背包\n\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int i = 0; i < coins.size(); i++) { // 遍历物品\n            for (int j = coins[i]; j <= amount; j++) { // 遍历背包\n                dp[j] += dp[j - coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)\n\n难度中等636收藏分享切换为英文接收动态反馈\n\n给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。\n\n题目数据保证答案符合 32 位整数范围。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3], target = 4\n输出：7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n```\n\n#### 解法 回溯 记忆化 dp\n\n```c++\n//回溯\nclass Solution {\npublic:\n    int ans;\n    int combinationSum4(vector<int>& nums, int target) {\n        ans = 0;\n        backtrack(nums, 0, target);\n        return ans;\n    }\n\n    void backtrack(vector<int>& nums, int nowSum, int target){\n        if(nowSum>target) return;\n        if(nowSum == target){\n            ans++;\n            return;\n        }\n        for(int i = 0; i<nums.size(); i++){\n            backtrack(nums, nowSum+nums[i], target);\n        }\n    }\n};\n\n//记忆化回溯\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        return dfs(nums, target);\n    }\n    //备忘录，保存每层递归的计算结果，用于实现记忆化。\n    unordered_map<int, int> memo;\n    //dfs(target)的定义： 用nums中的元素凑成总和为target（每个元素可以使用多次），用多少中凑法。\n    int dfs(vector<int>& nums, int target){\n        if(target == 0)\n            return 1;\n        if(target < 0)\n            return 0;\n        if(memo.count(target) == 1)\n            return memo[target];\n        int res = 0;\n        for(int i = 0; i < nums.size(); i++){\n            res += dfs(nums, target - nums[i]);\n        }\n        memo[target] = res;\n        return res;\n    }\n};\n\n//完全背包dp\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        //使用dp数组，dp[i]代表组合数为i时使用nums中的数能组成的组合数的个数\n        //dp[i]=dp[i-nums[0]]+dp[i-nums[1]]+dp[i=nums[2]]+...\n        //举个例子比如nums=[1,3,4],target=7;\n        //dp[7]=dp[6]+dp[4]+dp[3]\n        //其实就是说7的组合数可以由三部分组成，1和dp[6]，3和dp[4],4和dp[3];\n        vector<unsigned long long> dp(target+1);\n        //是为了算上自己的情况，比如dp[1]可以由dp【0】和1这个数的这种情况组成。\n        dp[0] = 1;\n        for(int i = 0; i<=target; i++)\n            for(int num : nums)\n                //dp用int的话 有一个很傻逼的越界，需要 && dp[i - num] < INT_MAX - dp[i]\n                if(i>=num)  \n                    dp[i] += dp[i-num];\n        return dp[target];\n    }\n};\n```\n\n### [`70. 爬楼梯`](https://leetcode.cn/problems/climbing-stairs/)\n\n[思路](https://leetcode.cn/problems/climbing-stairs/#)\n\n难度简单2410\n\n假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n\n每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n \n\n**示例 1：**\n\n```\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n```\n\n**示例 2：**\n\n```\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n```\n\n#### 解法1 斐波那契\n\n```c++\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n == 1) return 1;\n        if(n == 2) return 2 ;\n        vector<int> dp(n+1, 0);\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i<=n; ++i){\n          dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};\n```\n\n#### 解法2 完全背包 \n\n1 2 中 和为n的排列数\n\n```c++\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        int m = 2;\n        for (int i = 1; i <= n; i++) { // 遍历背包\n            for (int j = 1; j <= m; j++) { // 遍历物品\n                if (i - j >= 0) dp[i] += dp[i - j];\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n#### `扩展 每次可以跳 a-b 阶`\n\n```c++\nclass Solution {\npublic:\n    int climbStairs(int n, int a, int b) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++)  // 遍历背包\n            for (int j = a; j <= b; j++)  // 遍历物品\n                if (i - j >= 0) dp[i] += dp[i - j];\n        return dp[n];\n    }\n};\n```\n\n### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。\n\n**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。\n\n \n\n**示例 1：**\n\n```\n输入：n = 12\n输出：3 \n解释：12 = 4 + 4 + 4\n```\n\n**示例 2：**\n\n```\n输入：n = 13\n输出：2\n解释：13 = 4 + 9\n```\n\n#### 解法 完全背包\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, 0);\n        for(int i = 1; i<=n; i++){\n            int minVal = INT_MAX;\n            for(int j = 1; j*j<=i; j++){\n                //i-j*j是从大到小的遍历dp,这样才可以保证最小次数\n                minVal = min(minVal, dp[i-j*j]);  \n            }\n            dp[i] = minVal + 1;\n        }\n        return dp[n];\n    }\n};\n\n//相比上面 耗时较多 难度是数组的赋值比较费时间？\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, n + 1);\n        dp[0] = 0;\n        for(int i = 1; i<=n; i++){ // 遍历背包\n            for(int j = 1; j*j<=i; j++){ // 遍历物品\n                //i-j*j是从大到小的遍历dp,这样才可以保证最小次数\n                dp[i] = min(dp[i], dp[i-j*j] + 1);  \n            }\n        }\n        return dp[n];\n    }\n};\n\n// 先物品 再背包\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i * i <= n; i++) { // 遍历物品\n            for (int j = 1; j <= n; j++) { // 遍历背包\n                if (j - i * i >= 0) {\n                    dp[j] = min(dp[j - i * i] + 1, dp[j]);\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n### [`139. 单词拆分`](https://leetcode.cn/problems/word-break/)\n\n[思路](https://leetcode.cn/problems/word-break/#)\n\n难度中等1615收藏分享切换为英文接收动态反馈\n\n给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。\n\n**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n \n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n     注意，你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n# 炒股专题\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220505094926693.png\" alt=\"image-20220505094926693\" style=\"zoom: 67%;\" />\n\n### [121. 买卖股票的最佳时机 一次买卖](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) \n\n给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n\n你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n \n\n**示例 1：**\n\n```\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**示例 2：**\n\n```\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n#### 思路\n\n1. 贪心 一次遍历 得到 当前值和当前之前的最小值做差 取max\n\n2. 动态规划\n\n   > dp数组的含义\n   >\n   > 1. dp{i}{0}表述第i天手中==没有==股票 时 的最大利润    = max(昨天手中就没有股票， 昨天手中有股票但是今天(i)给==卖==了)\n   >\n   > 2. dp{i}{1}表述第i天手中==有==股票 时 的最大利润       = max(昨天手中就有股票， 昨天手中没有股票但是今天(i)==买==了)\n   >\n   > ```c++\n   >         dp[i][0]= max(dp[i-1][0], dp[i-1][1] + prices[i]);\n   >         dp[i][1] = max(dp[i-1][1], -prices[i]);\n   > ```\n\n#### 代码\n\n```c++\n//dp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        vector<vector<int>> dp(n, vector<int>(2));\n        for(int i = 0; i<n; i++){\n            if(i == 0){\n                //base case\n                dp[i][0] = 0;\n                dp[i][1] = INT_MIN;\n                continue;\n            }\n            dp[i][0]= max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            //注意这里不能时dp[i-1][0],因为只有一次操作\n            //前面没有股票买卖 没有利润\n            dp[i][1] = max(dp[i-1][1], -prices[i]);\n        }\n        return dp[n-1][0];\n    }\n\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int dp_i_0 = 0;\n        int dp_i_1 = INT_MIN;\n        for(int i = 0; i<n; i++){\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]);\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\n            dp_i_1 = max(dp_i_1, -prices[i]);\n        }\n        return dp_i_0;\n    }\n};\n\n//贪心\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n =prices.size();\n        int left = 0; int right = 0;\n        int ans = 0;\n        while(right<n){\n            if(prices[left]<prices[right])\n                ans = max(ans, prices[right] - prices[left]);\n            else left = right;\n            right++;            \n        }\n        return ans;\n    }\n\n    int maxProfit(vector<int>& prices) {    \n        int mmin = INT_MAX;//遇到最小的数\n        int mmax = 0;//差值最大数\n        for(int i : prices) {\n            mmin = min(i, mmin); \n            mmax = max(i - mmin, mmax);\n        }\n        return mmax ;\n    }\n};\n```\n\n\n\n### [122. 买卖股票的最佳时机 无限次买卖](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n给定一个数组 `prices` ，其中 `prices[i]` 表示股票第 `i` 天的价格。\n\n在每一天，你可能会决定购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以购买它，然后在 **同一天** 出售。\n返回 *你能获得的 **最大** 利润* 。\n\n \n\n**示例 1:**\n\n```\n输入: prices = [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n**示例 2:**\n\n```\n输入: prices = [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n#### 思路\n\n1. 贪心 每次相邻两天涨价都卖股票\n\n2. dp 同上 但是更为贴近经典模板 允许多次买卖 注意状态方程\n\n   ```c++\n           dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n           dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);\n   ```\n\n#### 代码\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    //没有购买次数的限制\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        vector<vector<int>> dp(n, vector<int>(2));\n        for(int i = 0; i<n; i++){\n            if(i == 0){\n                dp[i][0] = 0;\n                dp[i][1] = -prices[i];\n                continue;\n            }\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);\n        }\n        return dp[n-1][0];\n    }\n\n    //滚动优化\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int dp_i_0 = 0;\n        int dp_i_1 = INT_MIN;\n        for(int i = 0; i<n; i++){\n            int temp = dp_i_0; //临时存储上个dp_i_0     dp_i_1写在dp_i_0之前则无需temp \n            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]);\n            dp_i_1 = max(dp_i_1, temp - prices[i]);\n        }\n        return dp_i_0;\n    }\n    \n    //贪心 每次相邻两天涨价都卖股票\n    int maxProfit(vector<int>& prices) {\n        int max = 0;\n        for (int i = 0; i < prices.size()-1; i++){\n            if(prices[i]<prices[i+1]){\n                max+=prices[i+1]-prices[i];\n            }  \n        }   \n        return max;\n    }\n};\n```\n\n### [714. 买卖股票的最佳时机 含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n \n\n**示例 1：**\n\n```\n输入：prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出：8\n解释：能够达到的最大利润:  \n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n```\n\n**示例 2：**\n\n```\n输入：prices = [1,3,7,5,10,3], fee = 3\n输出：6\n```\n\n#### 思路\n\n一样的套路 只是注意 -fee -fee.......在dp0上可能引发的越界问题 除非给定特别合适的初始值（-1？错）\n\n> [9,8,7,1,2] 3\n>\n> 例如上面那个 会导致dp1错误  老老实实放在dp1上吧   -1000000是可以通过的\n\n\n\n#### 代码\n\n\n\n```````c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.size();\n        int dp_0 = 0;\n        int dp_1 = INT_MIN;\n        for(int i = 0; i<n; i++){\n            int temp = dp_0;\n            //注意 这里-fee最好不要写在dp0上 不然INT_MIN可能越界，不好控制初始值\n            dp_0 = max(dp_0, dp_1 + prices[i]);\n            dp_1 = max(dp_1, temp - prices[i] - fee);\n        }\n        return dp_0;\n    }\n};\n```````\n\n### [309. 最佳买卖股票时机 含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n**示例 1:**\n\n```\n输入: prices = [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n```\n\n#### 思路\n\n0 1单独判断  注意代码中的状态方程\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        vector<vector<int>> dp(n, vector<int>(2));\n        for(int i = 0; i<prices.size(); i++){\n            if(i == 0){\n                dp[i][0] = 0;\n                dp[i][1] = -prices[i];\n                continue;\n            }\n            if(i == 1){\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n                dp[i][1] = max(dp[i-1][1], -prices[i]);\n                continue;\n            }\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);\n        }\n        return dp[n-1][0];\n    }\n\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int dp_i_0 = 0;\n        int dp_i_1 = INT_MIN;\n        int dp_pre_0 = 0; //代表dp[i-2][0];\n        for(int i = 0; i<n; i++){\n            int temp = dp_i_0;\n            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]);\n            dp_i_1 = max(dp_i_1, dp_pre_0 - prices[i]);       \n            dp_pre_0 = temp;    \n        }\n        return dp_i_0;\n    }\n};\n```\n\n\n\n\n\n\n\n### [123. 买卖股票的最佳时机 限制两笔交易](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n**示例 1:**\n\n```\n输入：prices = [3,3,5,0,0,3,1,4]\n输出：6\n解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n```\n\n**示例 2：**\n\n```\n输入：prices = [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n#### 思路\n\n1. 有次数限制k for循环加一层k\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int maxk = 2;\n        int n = prices.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(maxk+1, vector<int>(2)));\n        for(int i = 0; i<n; i++){\n            for(int k = 1; k<=maxk; k++){\n                if(i == 0){\n                    dp[i][k][0] = 0;\n                    dp[i][k][1] = -prices[i];\n                    continue;\n                }\n                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n            }\n        }\n        return dp[n-1][maxk][0];\n    }\n\n    //滚动优化\n    int maxProfit(vector<int>& prices) {\n        int dp_i10 = 0, dp_i20 = 0;\n        int dp_i11 = INT_MIN, dp_i21 = INT_MIN;\n        for(int price: prices){\n            dp_i20 = max(dp_i20, dp_i21 + price);\n            dp_i21 = max(dp_i21, dp_i10 - price);\n            dp_i10 = max(dp_i10, dp_i11 + price);\n            dp_i11 = max(dp_i11, -price);\n        }\n        return dp_i20;\n    }\n};\n```\n\n### [188. 买卖股票的最佳时机 限制k笔交易](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。\n\n**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n \n\n**示例 1：**\n\n```\n输入：k = 2, prices = [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n```\n\n**示例 2：**\n\n```\n输入：k = 2, prices = [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n```\n\n#### 思路\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(int maxk, vector<int>& prices) {\n        int n = prices.size();\n        if(n<=0) return 0;\n        if(maxk>n/2){//一次交易完成需要两天\n            //复用之前交易次数k没有限制的情况\n            return maxProfit_k_inf(prices);\n        }\n\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(maxk+1, vector<int>(2)));\n        for(int i = 0; i<n; i++){\n            for(int k = 1; k<=maxk; k++){\n                if(i == 0){\n                    dp[i][k][0] = 0;\n                    dp[i][k][1] = -prices[i];\n                    continue;\n                }\n                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n                dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n            }\n        }\n        return dp[n-1][maxk][0];\n    }\n\n    //不限制次数k的买卖\n    int maxProfit_k_inf(vector<int>& prices) {\n        int n = prices.size();\n        int dp_i_0 = 0;\n        int dp_i_1 = INT_MIN;\n        for(int i = 0; i<n; i++){\n            dp_i_1 = max(dp_i_1, dp_i_0 - prices[i]);\n            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i]);\n        }\n        return dp_i_0;\n    }\n};\n```\n\n### `万法归一`\n\n输入股票价格数组 `prices`，你最多进行 `max_k` 次交易，每次交易需要额外消耗 `fee` 的手续费，而且每次交易之后需要经过 `cooldown` 天的冷冻期才能进行下一次交易，请你计算并返回可以获得的最大利润。\n\n怎么样，有没有被吓到？如果你直接给别人出一道这样的题目，估计对方要当场吐血，不过我们这样一步步做过来，你应该很容易发现这道题目就是之前我们探讨的几种情况的组合体嘛。\n\n所以，我们只要把之前实现的几种代码掺和到一块，**在 base case 和状态转移方程中同时加上 `cooldown` 和 `fee` 的约束就行了**：\n\n==怕难以理解 此处全用完整dp数组==\n\n```c++\nclass Solution{\npublic:\n    int maxProfit_all_in_one(int maxk, vector<int>& prices, int cooldown, int fee) {\n        int n = prices.size();\n        if(n<=0) return 0;\n        if(maxk>n/2){//一次交易完成需要两天\n            //复用之前交易次数k没有限制的情况\n            return maxProfit_k_inf_cool(prices, cooldown, fee);\n        }\n\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(maxk+1, vector<int>(2)));\n        for(int i = 0; i<n; i++){\n            for(int k = 1; k<=maxk; k++){\n            \tif(i - 1 == -1){\n                \tdp[i][k][0] = 0;\n                \tdp[i][k][1] = -prices[i];\n                \tcontinue;\n            \t}\n            \t// 包含 cooldown 的 base case\n            \tif(i-cooldown -1< 0){\n            \t\tdp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n                \t// 别忘了减 fee\n                \tdp[i][k][1] = max(dp[i-1][k][1], -prices[i]- fee);\n                \tcontinue;\n            \t}\n                dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n                dp[i][k][1] = max(dp[i-1][k][1], dp[i-cooldown-1][k-1][0] - prices[i] -fee);\n            }\n        }\n        return dp[n-1][maxk][0];\n    }\n    \n    // k 无限制，包含手续费和冷冻期\n    int maxProfit_k_inf_cool(vector<int>& prices, int cooldown, int fee) {\n        int n = prices.size();\n        vector<vector<int>> dp(n, vector<int>(2));\n        for(int i = 0; i<prices.size(); i++){\n            if(i - 1 == -1){\n                dp[i][0] = 0;\n                dp[i][1] = -prices[i];\n                continue;\n            }\n            // 包含 cooldown 的 base case\n            if(i-cooldown -1< 0){\n                dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n                // 别忘了减 fee\n                dp[i][1] = max(dp[i-1][1], -prices[i]- fee);\n                continue;\n            }\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);\n            // 同时考虑 cooldown 和 fee\n            dp[i][1] = max(dp[i-1][1], dp[i-cooldown-1][0] - prices[i]- fee);\n        }\n        return dp[n-1][0];\n    }\n};\n```\n\n# 子序列/子数组专题\n\n## [题目总结 最长上升子序列](https://leetcode-cn.com/problems/pile-box-lcci/solution/ti-mu-zong-jie-zui-chang-shang-sheng-zi-7jfd3/)\n\n### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=300)[思路](https://leetcode-cn.com/problems/longest-increasing-subsequence/#)\n\n难度中等2362收藏分享切换为英文接收动态反馈\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n#### 思路\n\n1. dp数组：注意 递增子序列与当前数字的大小有关 所以dp的含义为 以`当前数结尾的最长子序列长度`\n2. 状态转移：当前比之前的大  则更新dp[i] 为max(dp[j+1] , dp[i])\n3. base case: 所有单个数字的序列dp均为1\n\n> 这不就是暴力吗？好像？\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    //主要是注意dp数组的含义\n    //`当前数结尾的最长子序列长度`\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        int ans = 0;\n        for(int i = 0; i<n; i++){\n            int nowI = nums[i];//因为是nums[i]去比较的\n            for(int j = 0; j<i; j++){\n                if(nowI>nums[j]){\n                    dp[i] = max(dp[j] + 1, dp[i]);\n                }\n            }\n            ans = max(dp[i], ans);\n        }\n        return ans;\n    }\n};\n```\n\n#### 答案都看不懂啊 操他妈\n\nhttps://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/\n\n二分的思路是这样的[动态规划设计：最长递增子序列 :: labuladong的算法小抄](https://labuladong.github.io/algo/3/24/77/)\n\n大佬的文章中提到了扑克牌的思路，其中有几个点\n\n![image-20220416161203581](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220416161203581.png)\n\n1. 每一堆扑克牌的最上方纸牌 是单调递增的\n\n2. 结论：扑克牌的堆数 就是LIS的大小\n\n3. 思路：因为每次放一张扑克牌，堆顶都是单调递增的\n\n   所以可以每次去`二分查找`放在哪一堆（即找到`最接近的` 大于当前的 牌的 index），如果没有找到（即index == 堆的size）\n\n   `开辟新的一堆`\n\n4. 因此，使用的左边界的二分查找！\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n      \t//最多n堆\n        vector<int> top(nums.size());\n        //牌堆初始化为0\n        int piles = 0;\n        for(int num : nums) {\n            //要处理的扑克牌\n            int poker = num;\n            //搜索左边界的二分查找 确定插入位置\n            int left = 0, right = piles;\n            while(left < right) {\n                int m = (left + right) / 2;\n                if(top[m] < num) left = m + 1;\n                else right = m;  //左边界 在于 等于的时候仍然收缩有边界\n            }\n            // 没找到合适的牌堆，新建一堆\n            if(piles == left) piles++;\n            //将这张牌放到了 某一堆的最上方，也就是这堆的最小值\n            top[left] = num; \n        }\n        return piles;\n    }\n};\n```\n\n使用lower_bound的写法\n\n1. lower_bound查找超范围的判断\n\n   ```c++\n     vector<int> v{0, 1, 2, 3, 4};\n     auto it = lower_bound(v.begin(), v.end(), 6);\n     int pos = it - v.begin(); // pos = 5 返回的就是查找区间的大小\n     if (pos == v.size())\n       cout << \"超范围了。。。查找的元素比所有元素都大\" << endl;\n   \t//或者\n\tif(it == v.end())\n       cout<<\"超了...\";\n   ```\n   \n   \n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int> &nums) {\n\t    vector<int> top(nums.size());\n\t    //牌堆初始化为0\n\t    int piles = 0;\n\t    for (int num : nums) {\n\t    \t//要处理的扑克牌\n\t    \tint poker = num;\n\t    \t//搜索左边界的二分查找\n\t    \tauto it = lower_bound(top.begin(), top.begin() + piles, poker);\n\t    \tint pos = it - top.begin();\n\t    \t// 没找到合适的牌堆，新建一堆\n            // pos<0表示没找到 pos == piles表示在最后 也就是需要新建一堆\n\t    \tif (pos == piles) {  //或者写做 it == top.end()\n\t    \t\tpos = piles;\n\t    \t\tpiles++;\n\t    \t}\n\t    \t//将这张牌放到了 某一堆的最上方，也就是这堆的最小值\n\t    \ttop[pos] = num;\n\t    }\n\t    return piles;\n    }\n};\n```\n\n\n\n### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=354)[思路](https://leetcode-cn.com/problems/russian-doll-envelopes/#)\n\n难度困难705\n\n给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。\n\n当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。\n\n请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。\n\n**注意**：不允许旋转信封。\n\n**示例 1：**\n\n```\n输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]\n输出：3\n解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。\n```\n\n**示例 2：**\n\n```\n输入：envelopes = [[1,1],[1,1],[1,1]]\n输出：1\n```\n\n#### 思路\n\n1. 按照LIS进行dp\n2. 按照LIS进行优化 二分查找\n\n#### 代码\n\n```c++\n//按最长递增子序列进行升序 dp\nclass Solution {\npublic:\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\n        int m = envelopes.size();\n        vector<int> dp(m, 1);\n        int ans = 0;\n        sort(envelopes.begin(), envelopes.end(), [](vector<int> a, vector<int> b)->bool{return a[0]<b[0];});\n        for(int i = 0; i<m; i++){\n            vector<int> now = envelopes[i];\n            for(int j = 0; j<i; j++){\n                //if(j == i) continue;\n                if(now[0]>envelopes[j][0] && now[1]>envelopes[j][1]){\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n            ans = max(ans, dp[i]);\n        }\n        return ans;\n    }\n};\n\n//二分做法\nclass Solution {\npublic:\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\n        if (envelopes.empty()) \n            return 0;\n        \n        int n = envelopes.size();\n        sort(envelopes.begin(), envelopes.end(), [](const auto& e1, const auto& e2) {\n            return e1[0] < e2[0] || (e1[0] == e2[0] && e1[1] > e2[1]);\n        });\n\n        vector<int> f = {envelopes[0][1]};\n        for (int i = 1; i < n; ++i) {\n            if (int num = envelopes[i][1]; num > f.back()) {\n                f.push_back(num);\n            }\n            else {\n                //第一个>=num的位置\n                auto it = lower_bound(f.begin(), f.end(), num);\n                *it = num;\n            }\n        }\n        return f.size();\n    }\n};\n```\n\n### [面试题 08.13. 堆箱子](https://leetcode-cn.com/problems/pile-box-lcci/)\n\n难度困难66收藏分享切换为英文接收动态反馈\n\n堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。\n\n输入使用数组`[wi, di, hi]`表示每个箱子。\n\n**示例1:**\n\n```\n 输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n 输出：6\n```\n\n**示例2:**\n\n```\n 输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]\n 输出：10\n```\n\n#### 思路\n\n简简单单的 LIS dp dp[i]表示 箱子`i在最上`的 累积的最大高度\n\n注意 和套娃一样 由于存在相等的情况 所以需要排序\n\n##### 代码\n\n```c++\n// LIS dp\nclass Solution {\npublic:\n    int pileBox(vector<vector<int>>& box) {\n        sort(box.begin(), box.end());\n        int n = box.size();\n        //dp[i]表示 箱子i在最上的 累积的最大高度\n        vector<int> dp(n , 0);\n        for(int i = 0; i<n; i++){\n            //初始化dp base为箱子本身的高度\n            dp[i] = box[i][2]; \n        }\n        //注意 ans在i=0时没有比较 需要初始化为dp[0]\n        int ans = dp[0];\n        for(int i = 1; i<n; i++){\n            for(int j = 0; j<i; j++){\n                //下面箱子的宽度、高度和深度必须大于上面的箱子\n                if(box[i][0]>box[j][0] && box[i][1]>box[j][1] && box[i][2]>box[j][2])\n                    dp[i] = max(dp[i], dp[j] + box[i][2]);\n            }\n            ans = max(ans, dp[i]);\n        }\n        return ans;\n    }\n};\n```\n\n### [面试题 17.08. 马戏团人塔](https://leetcode-cn.com/problems/circus-tower-lcci/)\n\n难度中等88英文版讨论区\n\n有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。\n\n**示例：**\n\n```\n输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]\n输出：6\n解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)\n```\n\n#### 思路\n\n- 先排序：高度升序排列，相同高度的宽度降序排列\n- 然后DP数组下标 i 位置记录长为 i+1 最长递增序列末尾数字最小值\n- 最后返回DP数组长度\n- PS（新瓶装旧酒，和 俄罗斯套娃信封 问题一样）\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int bestSeqAtIndex(vector<int>& height, vector<int>& weight) {\n        int n = weight.size();\n        vector<vector<int>> matrix = build(height, weight);\n        sort(matrix.begin(), matrix.end(), [](vector<int> a, vector<int> b)\n            ->bool{return a[0] < b[0]; });\n        vector<int> dp(n, 1);\n        int ans = 0;\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<i; j++){\n                if(matrix[j][0]<matrix[i][0] && matrix[j][1] < matrix[i][1])\n                    dp[i] = max(dp[i], dp[j] + 1);\n            }\n            ans = max(ans, dp[i]);\n        }\n        return ans;\n    }\n\n    vector<vector<int>> build(vector<int>& height, vector<int>& weight){\n        int n = weight.size();\n        vector<vector<int>> res(n, vector<int>(2));\n        for(int i = 0; i<n; i++){\n            res[i][0] = height[i];\n            res[i][1] = weight[i];\n        }\n        return res;\n    }\n};\n\n\nclass Solution {\npublic:\n    int bestSeqAtIndex(vector<int>& height, vector<int>& weight) {\n        vector<pair<int,int>> tmp;\n        for(int i = 0; i < height.size(); i++) tmp.push_back({height[i], weight[i]});\n        sort(tmp.begin(), tmp.end(), [](const pair<int,int> &a, const pair<int,int> &b) {\n            return a.first == b.first ? a.second > b.second : a.first < b.first;\n        });\n        vector<int> dp; //长度为N的地方 最小的数字\n        for(const auto &[h, w]: tmp) {\n            auto p = lower_bound(dp.begin(), dp.end(), w);  //二分查找第一个大于等于的地方\n            if(p == dp.end()) dp.push_back(w);\n            else *p = w;\n        }\n        return dp.size();\n    }\n};\n```\n\n## 重叠区间问题\n\n### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=435)[思路](https://leetcode-cn.com/problems/non-overlapping-intervals/#)\n\n难度中等663\n\n给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 * 需要移除区间的最小数量，使剩余区间互不重叠* \n\n \n\n**示例 1:**\n\n```\n输入: intervals = [[1,2],[2,3],[3,4],[1,3]]\n输出: 1\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n```\n\n**示例 2:**\n\n```\n输入: intervals = [ [1,2], [1,2], [1,2] ]\n输出: 2\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n```\n\n**示例 3:**\n\n```\n输入: intervals = [ [1,2], [2,3] ]\n输出: 0\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n```\n\n#### 思路\n\n1. 反向推断 移除区间的最小数量 只需要计算 满足不重复条件的区间的最大数量 LIS dp\n\n2. 贪心 也是反向查找的思路 不过是按照右边界 拼接查找无重叠的最大区间数\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20201221201553618.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n   如图 按照右边界排序 可以简单的找出无重叠的最大区间序列 1 4 6\n\n   每次取非交叉区间的时候，都是可右边界最小的来做分割点（==<u>这样留给下一个区间的空间就越大</u>==），所以第一条分割线就是区间1结束的位置。\n\n   接下来就是找大于区间1结束位置的区间，是从区间4开始。那有同学问了为什么不从区间5开始？别忘已经是按照右边界排序的了。\n\n   区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。\n\n   总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。\n\n#### 代码\n\n```c++\n//LIS dp 反向推断\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& matrix) {\n        sort(matrix.begin(), matrix.end());\n        int n = matrix.size();\n        //dp含义 不重叠的最大子区间个数\n        vector<int> dp(n, 1);\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<i; j++){\n                //反向思考 可以装入 即 不重叠\n                if(matrix[j][1]<=matrix[i][0])\n                    dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        return n - dp[n-1];\n    }\n};\n\n//按右端排序 贪心\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& matrix) {\n        sort(matrix.begin(), matrix.end(), \n            [](const vector<int>& a, const vector<int>& b)->bool{return a[1] < b[1];});\n        int n = matrix.size();\n        int maxNotOverlap = 1;\n        int beginVal = matrix[0][1];\n        for(int i = 1; i<n; i++){\n            // 丑陋的代码 脑子不转。。\n            // while(i<n && matrix[i][0]<beginVal){\n            //     i++;\n            // }\n            // if(i == n) break;\n            // beginVal = matrix[i][1];\n            // maxNotOverlap++;\n\n            if(matrix[i][0]>=beginVal){\n                beginVal = matrix[i][1];\n                maxNotOverlap++;\n            }\n        }\n        return n - maxNotOverlap;\n    }\n};\n```\n\n### [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)\n\n难度中等214\n\n给出 `n` 个数对。 在每一个数对中，第一个数字总是比第二个数字小。\n\n现在，我们定义一种跟随关系，当且仅当 `b < c` 时，数对`(c, d)` 才可以跟在 `(a, b)` 后面。我们用这种形式来构造一个数对链。\n\n给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。\n\n \n\n**示例：**\n\n```\n输入：[[1,2], [2,3], [3,4]]\n输出：2\n解释：最长的数对链是 [1,2] -> [3,4]\n```\n\n#### 思路\n\n1. LIS dp\n2. 贪心 按右端排序 同上\n\n#### 代码\n\n```c++\n//dp解法\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        sort(matrix.begin(), matrix.end());\n        vector<int> dp(n, 1);\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<i; j++){\n                if(matrix[j][1] < matrix[i][0])\n                    dp[i] = max(dp[j] + 1, dp[i]);\n            }\n        }\n        return dp[n - 1];\n    }\n};\n\n//贪心解法\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        sort(matrix.begin(), matrix.end(),[](const vector<int>& a, const vector<int>& b)->\n             bool{ return a[1] == b[1]? a[0]<b[0] : a[1]<b[1]; });\n        int beginVal = matrix[0][1];\n        int ans = 1;\n        for(int i = 1; i<n; i++){\n            if(matrix[i][0] > beginVal){\n                beginVal = matrix[i][1];\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=452)[思路](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/#)\n\n难度中等561收藏分享切换为英文接收动态反馈英文版讨论区\n\n有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。\n\n一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。\n\n给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。\n\n**示例 1：**\n\n```\n输入：points = [[10,16],[2,8],[1,6],[7,12]]\n输出：2\n解释：气球可以用2支箭来爆破:\n-在x = 6处射出箭，击破气球[2,8]和[1,6]。\n-在x = 11处发射箭，击破气球[10,16]和[7,12]。\n```\n\n**示例 2：**\n\n```\n输入：points = [[1,2],[3,4],[5,6],[7,8]]\n输出：4\n解释：每个气球需要射出一支箭，总共需要4支箭。\n```\n\n#### 思路\n\nLIS我特么射爆 其实不算LIS吧\n\n#### 代码\n\n```c++\n//贪心正解\nclass Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        sort(matrix.begin(), matrix.end(),[](const vector<int>& a, const vector<int>& b)->\n             bool{ return a[1] == b[1]? a[0]<b[0] : a[1]<b[1]; });\n        int beginVal = matrix[0][1];\n        int ans = 1;\n        for(int i = 1; i<n; i++){\n            //出范围 需要额外用一只箭\n            if(matrix[i][0] > beginVal){\n                beginVal = matrix[i][1];\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n\n//dp超时\nclass Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        sort(matrix.begin(), matrix.end());\n        //dp[i]表示射爆当前及其之前所有气球 需要的箭数\n        vector<int> dp(n, 1);\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<i; j++){\n                if(matrix[i][0] > matrix[j][1])\n                    dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        return dp[n - 1];\n    }\n};\n```\n\n### [960. 删列造序 III](https://leetcode-cn.com/problems/delete-columns-to-make-sorted-iii/)\n\n难度困难64收藏分享切换为英文接收动态反馈英文版讨论区\n\n给定由 `n` 个小写字母字符串组成的数组 `strs` ，其中每个字符串长度相等。\n\n选取一个删除索引序列，对于 `strs` 中的每个字符串，删除对应每个索引处的字符。\n\n比如，有 `strs = [\"abcdef\",\"uvwxyz\"]` ，删除索引序列 `{0, 2, 3}` ，删除后为 `[\"bef\", \"vyz\"]` 。\n\n假设，我们选择了一组删除索引 `answer` ，那么在执行删除操作之后，最终得到的数组的行中的 **每个元素** 都是按**字典序**排列的（即 `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])` 和 `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])` ，依此类推）。\n\n请返回 *`answer.length` 的最小可能值* 。\n\n \n\n**示例 1：**\n\n```\n输入：strs = [\"babca\",\"bbazb\"]\n输出：3\n解释：\n删除 0、1 和 4 这三列后，最终得到的数组是 A = [\"bc\", \"az\"]。\n这两行是分别按字典序排列的（即，A[0][0] <= A[0][1] 且 A[1][0] <= A[1][1]）。\n注意，A[0] > A[1] —— 数组 A 不一定是按字典序排列的。\n```\n\n**示例 2：**\n\n```\n输入：strs = [\"edcba\"]\n输出：4\n解释：如果删除的列少于 4 列，则剩下的行都不会按字典序排列。\n```\n\n## 其他\n\n### [674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)\n\n难度`简单`269英文版讨论区\n\n给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。\n\n**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,3,5,4,7]\n输出：3\n解释：最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,2,2,2]\n输出：1\n解释：最长连续递增序列是 [2], 长度为1。\n```\n\n```c++\nclass Solution {\npublic:\n    int findLengthOfLCIS(vector<int>& nums) {\n      int n = nums.size();\n      //dp表示 当前为结束的递增子序列的长度\n      vector<int> dp(n, 1);\n      int maxx = 1;\n      for(int i = 1; i<n; i++){\n        if(nums[i] > nums[i-1])\n          dp[i] = dp[i-1] + 1;\n        maxx = max(dp[i], maxx);\n      }\n      return maxx;\n    }\n};\n```\n\n### [718. `最长重复子数组`](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n\n难度中等673\n\n给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。\n\n \n\n**示例 1：**\n\n```\n输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n输出：3\n解释：长度最长的公共子数组是 [3,2,1] 。\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n输出：5\n```\n\n#### [思路](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/)\n\n1. dp数组的含义：dp[i] [j] 表示 以0 - i-1  0 - j-1的子数组中，以i-1和j-1为结尾的最大重复子数组的长度\n2. base case: i == 0 || j == 0 时 则二者没有公共部分 dp[i] [j] = 0;\n\n3. 状态转移： \n   - dp[i] [j] ：长度为i，末尾项为A[i-1]的子数组，与长度为j，末尾项为B[j-1]的子数组，二者的最大公共后缀子数组长度。\n     如果 A[i-1] != B[j-1]， 有 dp[i] [j] = 0\n     如果 A[i-1] == B[j-1] ， 有 dp[i] [j] = dp[i-1] [j-1] + 1\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n      int m = nums1.size(), n = nums2.size();\n      //dp[i][j]表示 0-i 0-j 以最后数字结尾的 最长重复子数组的长度\n      vector<vector<int>> dp(m+1, vector<int>(n+1));\n      int ans = 0;\n      for(int i = 1; i<=m; i++){\n        for(int j = 1; j<=n; j++){\n          if(nums1[i - 1] == nums2[j - 1]){\n            dp[i][j] = dp[i-1][j-1] + 1;\n            ans = max(dp[i][j], ans);\n          }\n        }\n      }\n      return ans;\n    }\n};\n```\n\n### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=516)[思路](https://leetcode-cn.com/problems/longest-palindromic-subsequence/#)\n\n难度中等777收藏分享切换为英文接收动态反馈英文版讨论区\n\n给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。\n\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"bbbab\"\n输出：4\n解释：一个可能的最长回文子序列为 \"bbbb\" 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：2\n解释：一个可能的最长回文子序列为 \"bb\" 。\n```\n\n```c++\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n      int n = s.size();\n      //在子串 s[i..j] 中，最长回文子序列的长度为 dp[i][j]。\n      vector<vector<int>> dp(n, vector<int>(n));\n      for(int i = 0; i<n; i++)\n        dp[i][i] = 1;//base case\n      for(int i = n - 1; i>=0; i--){\n        for(int j = i+1; j<n; j++){\n          //状态转移\n          if(s[i] == s[j])\n            dp[i][j] = dp[i+1][j-1] + 2;\n          else dp[i][j] = max(dp[i][j-1], dp[i+1][j]);\n        }\n      }\n      return dp[0][n-1];\n    }\n};\n```\n\n### [剑指 Offer II 095. 最长公共子序列](https://leetcode-cn.com/problems/qJnOS7/)\n\n难度中等65英文版讨论区\n\n给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n- 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n**示例 1：**\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n**示例 2：**\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 \n```\n\n#### dp解法\n\n1. dp数组含义：dp[i] [j]表示 substr分别到 i和j的最大公共子序列长度\n\n2. 状态转移方程：\n\n   当前字符相同时：dp[i] [j] = dp[i-1] [j-1] + 1;\n\n   当前字符不同时：dp[i] [j] = max(dp[i-1] [j], dp[i] [j-1]);\n\n3. base case：处理第一行和第一列\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n      int m = text1.size(), n = text2.size();\n      vector<vector<int>> dp(m, vector<int>(n));\n      for(int i = 0; i<m; i++){\n        if(text1[i] == text2[0])\n          while(i<m)\n            dp[i++][0] = 1;\n      }\n      for(int i = 0; i<n; i++){\n        if(text1[0] == text2[i])\n          while(i<n)\n            dp[0][i++] = 1;\n      }\n\n      for(int i = 1; i<m; i++){\n        for(int j = 1; j<n ; j++){\n          if(text1[i] == text2[j]){\n            //注意 这里 是在-1-1的基础上加1\n            //例如 abcce ace 两个c的情况\n            dp[i][j] = dp[i-1][j-1] + 1;\n          }else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n        }\n      }\n      return dp[m-1][n-1];\n    }\n};\n```\n\nbase case的简单写法 前插一行一列为0\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n      int m = text1.size(), n = text2.size();\n      vector<vector<int>> dp(m+1, vector<int>(n+1));\n      for(int i = 1; i<=m; i++){\n        for(int j = 1; j<=n ; j++){\n          if(text1[i-1] == text2[j-1]){\n            //注意 这里 是在-1-1的基础上加1\n            //例如 abcce ace 两个c的情况\n            dp[i][j] = dp[i-1][j-1] + 1;\n          }else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n        }\n      }\n      return dp[m][n];\n    }\n};\n```\n\n### [剑指 Offer II 096. 字符串交织](https://leetcode-cn.com/problems/IY6buf/)\n\n难度中等14\n\n给定三个字符串 `s1`、`s2`、`s3`，请判断 `s3` 能不能由 `s1` 和 `s2` **交织（交错）** 组成。\n\n两个字符串 `s` 和 `t` **交织** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：\n\n- `s = s1 + s2 + ... + sn`\n- `t = t1 + t2 + ... + tm`\n- `|n - m| <= 1`\n- **交织** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**提示：**`a + b` 意味着字符串 `a` 和 `b` 连接。\n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg)\n\n```\n输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出：true\n```\n\n#### dp解法\n\n1. dp数组含义：前i j个元素可以构成s3前i+j个\n2. 状态转移方程：见代码 \n3. base case：dp[0] [0] = 1，初始化第一行第一列\n\n```c++\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n      int m = s1.size(), n = s2.size();\n      int nn = s3.size();\n      if(m + n != nn) return 0;\n      //dp含义 前i j个元素可以构成s3前i+j个\n      vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n      dp[0][0] = 1;\n      for(int i = 1; i<=m; i++){\n        if(s1[i-1] != s3[i-1])\n          break;\n        dp[i][0] = 1;\n      }\n      for(int i = 1; i<=n; i++){\n        if(s2[i-1] != s3[i-1])\n          break;\n        dp[0][i] = 1;\n      }\n\n      for(int i = 1; i<=m; i++){\n        for(int j = 1; j<=n; j++){\n          if(s1[i-1] == s3[i+j-1])\n            dp[i][j] = dp[i-1][j];\n          if(s2[j-1] == s3[i+j-1])\n            dp[i][j] = dp[i][j] || dp[i][j-1];\n        }\n      }\n      return dp[m][n];\n    }\n};\n```\n\n### [剑指 Offer II 097. 子序列的数目](https://leetcode-cn.com/problems/21dk04/)\n\n难度困难20收藏分享切换为英文接收动态反馈\n\n给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。\n\n字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`\"ACE\"` 是 `\"ABCDE\"` 的一个子序列，而 `\"AEC\"` 不是）\n\n题目数据保证答案符合 32 位带符号整数范围。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"rabbbit\", t = \"rabbit\"\n输出：3\n解释：\n如下图所示, 有 3 种可以从 s 中得到 \"rabbit\" 的方案。\nrabbbit\nrabbbit\nrabbbit\n```\n\n#### dp解法\n\n1. dp数组含义：s的前i 对应t的钱j 的子序列数目\n\n2. 状态转移方程\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1631176639-giAMKQ-image.png\" alt=\"image.png\" style=\"zoom: 50%;\" />\n\n3. base case：dp[0] [0] = 1,dp[all] [0] = 1;\n\n```c++\nclass Solution {\npublic:\n    int numDistinct(string s, string t) {\n        if (s.size() < t.size())\n            return 0;\n\n        vector<vector<unsigned int>> dp(s.size() + 1, vector<unsigned int>(t.size() + 1, 0));\n        dp[0][0] = 1;\n\n        for (int i = 0; i < s.size(); ++i) {\n            dp[i + 1][0] = 1;\n            for (int j = 0; j <= i && j < t.size(); ++j) \n                dp[i + 1][j + 1] = (s[i] == t[j]) ? dp[i][j] + dp[i][j + 1] : dp[i][j + 1];\n        }\n        return dp.back().back();\n    }\n};\n```\n\n\n\n# 二维矩阵dp\n\n### [62. 不同路径 经典简单的二维dp](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/robot_maze.png)\n\n```\n输入：m = 3, n = 7\n输出：28\n```\n\n#### 思路\n\n1. dp的含义：当前位置可以到达的路径数\n\n   所以base case为横竖1\n\n2. 状态转移方程 dp [i] [j] = dp[i-1] [j] + dp[i] [j-1]\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n));\n        for(int i = 0; i<n; i++){\n            dp[0][i] = 1;\n        }\n        for(int i = 0; i<m; i++){\n            dp[i][0] = 1;\n        }\n\n        for(int i = 1; i<m; i++){\n            for(int j = 1; j<n; j++){\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```\n\n### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=64&target=gitee)[思路](https://leetcode-cn.com/problems/minimum-path-sum/#)\n\n难度中等1191\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/minpath.jpg)\n\n```\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n**示例 2：**\n\n```\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n```\n\n#### 思路\n\n1. 可以记一下这个短路的万能写法\n2. 横 竖的 路径和是确定的 所以 这是base case\n3. 状态转移方程 dp[i] [j] = min(dp[i-1] [j], dp[i] [j-1]) + grid[i] [j];\n\n#### 代码\n\n1. 回溯超时\n2. dp\n\n```c++\nclass Solution {\npublic:\n    // vector<int> allAns;\n    // int minPathSum(vector<vector<int>>& grid) {\n    //   int ans = 0;\n    //   int m = grid.size();\n    //   int n = grid[0].size();\n    //   goWay(ans, grid, 0 , 0);\n    //   return *std::min_element(allAns.begin(), allAns.end());\n    // }\n\n    // void goWay(int tempans, vector<vector<int>> grid, int x, int y){\n    //   if(x == grid.size()-1 && y == grid[0].size()-1){\n    //     tempans+=grid[x][y];\n    //     allAns.push_back(tempans);       \n    //   }\n    //   if(x >= grid.size() || y >= grid[0].size())\n    //     return;\n    //   tempans += grid[x][y];\n    //   goWay(tempans, grid, x+1, y);\n    //   goWay(tempans, grid, x, y+1);\n    // }\n\n    int minPathSum(vector<vector<int>>& grid) {\n        //这个判断应该比较万能\n        if (grid.size() == 0 || grid[0].size() == 0)\n            return 0;\n        int m = grid.size(), n = grid[0].size();\n        auto dp = vector <vector<int>>(m, vector <int> (n));\n        dp[0][0] = grid[0][0];\n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)\n\n难度中等995\n\n给定一个三角形 `triangle` ，找出自顶向下的最小路径和。\n\n每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。\n\n \n\n**示例 1：**\n\n```\n输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n```\n\n**示例 2：**\n\n```\n输入：triangle = [[-10]]\n输出：-10\n```\n\n#### 思路\n\n同上\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n\tint minimumTotal(vector<vector<int>> &nums) {\n\t\tint ans = INT_MAX;\n\t\tint m = nums.size();\n\t\tif (m == 0)\n\t\t\treturn 0;\n\t\tvector<vector<int>> dp(m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tvector<int> temp(i + 1);\n\t\t\t// base case\n\t\t\tif (i == 0) {\n\t\t\t\ttemp[0] = nums[i][0];\n\t\t\t\tdp[i] = temp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < i + 1; j++) {\n\t\t\t\tif (j == 0)\n\t\t\t\t\ttemp[j] = dp[i - 1][j] + nums[i][j];\n\t\t\t\tif (j == i)\n\t\t\t\t\ttemp[j] = dp[i - 1][j - 1] + nums[i][j];\n\t\t\t\tif (j != 0 && j != i)\n\t\t\t\t\ttemp[j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i][j];\n\t\t\t}\n\t\t\tdp[i] = temp;\n\t\t}\n\n\t\tfor (int i = 0; i < dp[m - 1].size(); i++) {\n\t\t\t//cout << dp[m - 1][i] << endl;\n\t\t\tans = min(ans, dp[m - 1][i]);\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n#### \n\n### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n\n难度中等1091英文版讨论区\n\n在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/max1grid.jpg)\n\n```\n输入：matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n输出：4\n```\n\n#### 思路\n\n1. dp含义： 当前点 之上 的最大正方形的面积\n2. 状态转移：之前三方向的 最小dp值（最小说明受这个方向的限制） + 1\n3. base case: 第一行第一列 为1的位置\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int maxSide = 0;\n        if(matrix.size() == 0 || matrix[0].size() == 0) return 0;\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(matrix[i][j] == '1'){\n                    if(i == 0 || j == 0){\n                        dp[i][j] = 1;\n                    }else{\n                        dp[i][j] = min(min(dp[i-1][j], dp[i-1][j-1]), dp[i][j-1]) + 1;\n                    }\n                    maxSide = max(maxSide, dp[i][j]);\n                }     \n            }\n        }\n        return maxSide* maxSide;\n    }\n};\n```\n\n# 二叉树的dp\n\n二叉树的种类情况存在状态方程 随意有些dp的题目\n\n### n个节点不超过m高度的二叉树种类数\n\n链接：https://www.nowcoder.com/questionTerminal/aaefe5896cce4204b276e213e725f3ea\n\n![image-20220417172957421](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417172957421.png)\n\n![image-20220417173007635](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173007635.png)\n\n\n\n![image-20220417173040449](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417173040449.png)\n\n#### 思路\n\n动态规划：\n\n1. dp[i] [j]的含义为 i个节点 最大高度为j的二叉树种类数\n2. 状态转移方程：\n\n#### 代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n; // 节点个数\n    int m; // 最大高度\n    cin >> n >> m;\n    \n    // dp[i][j] 表示 i 个节点能够组成的高度不超过 j 的树的个数\n    vector<vector<long long>> dp(n + 1, vector<long long>(m + 1));\n    for(int i = 0; i <= m; ++i) {\n        dp[0][i] = 1;\n    }\n    \n    for(int i = 1; i <= n; ++i) {\n        for(int j = 1; j <= m; ++j) {\n            // 选取一个节点作为根节点\n            // k 个节点作为左子树，i - k - 1 个节点作为右子树\n            for(int k = 0; k < i; ++k) {\n                dp[i][j] = (dp[i][j] + dp[k][j - 1] * dp[i - k - 1][j - 1] % MOD) % MOD;\n            }\n        }\n    }\n    \n    cout << dp[n][m] << endl;\n}\n```\n\n# 字符串\n\n### [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)\n\n[思路](https://leetcode.cn/problems/interleaving-string/#)\n\n难度中等698收藏分享切换为英文接收动态反馈\n\n给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。\n\n两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：\n\n- `s = s1 + s2 + ... + sn`\n- `t = t1 + t2 + ... + tm`\n- `|n - m| <= 1`\n- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/interleave.jpg)\n\n```\n输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n输出：false\n```\n\n#### 解法 dp\n\n很简单的就能想到应该用dp 但是dp的实现：大小 basecase初始化 状态转移方程需要注意下\n\n1. dp数组含义：dpij 标识 s1的前i个字母 s2的前j个字母 可不可以构成s3的前i+j\n2. basecase：初始化dp00为真 不能太纠结这东西 重点是初始化第一行第一列\n3. 状态转移：dp[i] [j] = （dp[i-1] [j]为真 并且s1的当前字母等于当前s3的字母） || （dp[i] [j-1]为真 并且s2的当前字母等于当前s3的字母）\n\n```c++\nclass Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n      int m1 = s1.size(), m2 = s2.size(), n = s3.size();\n      if(m1 + m2 != n) return 0;\n      //dp[i][j]表示s1[0~i-1]和s2[0~j-1]能否交错组成s3[0~i+j-1]。 想好边缘条件，字符串涉及子串匹配啥的统统dp完事。\n      vector<vector<bool>> dp(m1 + 1, vector<bool>(m2 + 1));\n      dp[0][0] = 1;\n      for(int i = 1; i<=m1; i++){\n        dp[i][0] = dp[i-1][0] && (s1[i-1] == s3[i-1]);\n      }\n      for(int j = 1; j<=m2; j++){\n        dp[0][j] = dp[0][j-1] && (s2[j-1] == s3[j-1]);\n      }\n      for(int i = 1; i<=m1; i++){\n        for(int j = 1; j<=m2; j++){\n          dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || (dp[i][j-1] && s2[j-1] == s3[i+j-1]);\n        }\n      }\n      return dp.back().back();\n    }\n};\n```\n\n### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=72&target=gitee)[思路](https://leetcode-cn.com/problems/edit-distance/#)\n\n难度困难2239英文版讨论区\n\n给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n \n\n**示例 1：**\n\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n#### 思路\n\n1. dp含义：由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]**。\n\n2. 状态方程：\n\n   - 如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。\n\n   - 如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：\n     - 如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;\n     - 如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;\n     - 如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有**dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;**\n\n3. base case: 当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。\n\n> 大佬：90%的字符串问题都可以用dp解决\n>\n> 我：** * **\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\n        for(int i = 1; i<=m; i++)\n            dp[i][0] = dp[i-1][0] + 1;\n        for(int i = 1; i<=n; i++)\n            dp[0][i] = dp[0][i-1] + 1;\n        for(int i = 1; i<=m; i++){\n            for(int j = 1; j<=n; j++){\n                if(word1[i-1] == word2[j-1])\n                    dp[i][j] = dp[i-1][j-1];\n                else\n                    dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=10&target=gitee)[思路](https://leetcode-cn.com/problems/regular-expression-matching/#)\n\n难度困难2842英文版讨论区\n\n给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。\n\n- `'.'` 匹配任意单个字符\n- `'*'` 匹配零个或多个前面的那一个元素\n\n所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。\n\n```c++\n//背这个\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if (p.empty()) return s.empty();\n        //当前位置匹配\n        auto first_match = !s.empty() && (s[0] == p[0] || p[0] == '.');\n        \n        if (p.length() >= 2 && p[1] == '*') {\n            //通配符匹配0次 || 通配符匹配多次\n            return isMatch(s, p.substr(2)) || (first_match && isMatch(s.substr(1), p));\n        } else {\n            //无通配符，向前匹配\n            return first_match && isMatch(s.substr(1), p.substr(1));\n        }\n    }\n};\n\nclass Solution {\npublic:\n    unordered_map<string, int> memo;\n\n    bool isMatch(string s, string p) {\n        return dp(s, 0, p, 0);\n    }\n\t/* 计算 p[j..] 是否匹配 s[i..] */\n    bool dp(string& s, int i, string& p, int j) {\n        int m = s.size(), n = p.size();\n        // base case\n        if (j == n) {\n            return i == m;\n        }\n        if (i == m) {\n            // 如果能匹配空串，一定是字符和 * 成对儿出现\n            if ((n - j) % 2 == 1) {\n                return false;\n            }\n            // 检查是否为 x*y*z* 这种形式\n            for (; j + 1 < n; j += 2) {\n                if (p[j + 1] != '*') {\n                    return false;\n                }\n            }\n            return true;\n        }\n    \n        // 记录状态 (i, j)，消除重叠子问题\n        string key = to_string(i) + \",\" + to_string(j);\n        if (memo.count(key)) return memo[key];\n    \n        bool res = false;\n    \n        if (s[i] == p[j] || p[j] == '.') {\n            // 匹配\n            if (j < n - 1 && p[j + 1] == '*') {\n\t\t\t   // 1.1 通配符匹配 0 次或多次\n                res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j);\n            } else {\n                // 1.2 常规匹配 1 次\n                res = dp(s, i + 1, p, j + 1);\n            }\n        } else {\n             // 不匹配\n            if (j < n - 1 && p[j + 1] == '*') {\n                // 2.1 通配符匹配 0 次\n                res = dp(s, i, p, j + 2);\n            } else {\n                // 2.2 无法继续匹配\n                res = false;\n            }\n        }\n        // 将当前结果记入备忘录\n        memo[key] = res;\n        return res;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"贪心","url":"/2022/04/13/tan-xin/","content":"\n暂时懒得整理了 指个路\n\n# [代码随想录 (programmercarl.com)](https://programmercarl.com/贪心算法理论基础.html#什么是贪心)\n\n# 其他的贪心题\n\n### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)\n\n难度困难326\n\n这里有 `n` 门不同的在线课程，按从 `1` 到 `n` 编号。给你一个数组 `courses` ，其中 `courses[i] = [durationi, lastDayi]` 表示第 `i` 门课将会 **持续** 上 `durationi` 天课，并且必须在不晚于 `lastDayi` 的时候完成。\n\n你的学期从第 `1` 天开始。且不能同时修读两门及两门以上的课程。\n\n返回你最多可以修读的课程数目。\n\n \n\n**示例 1：**\n\n```\n输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n输出：3\n解释：\n这里一共有 4 门课程，但是你最多可以修 3 门：\n首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。\n第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。\n第三，修第 2 门课，耗时 200 天，在第 1300 天完成。\n第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。\n```\n\n#### 思路\n\n什么是最优的？每个先排序 都想一遍， 看能不能实现最优\n\n1. 持续时间越短，截止时间越晚的课程 越好  其中最最重要的截止时间\n2. 实现上述：应该按一方排序 另一方使用优先级队列优化\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int scheduleCourse(vector<vector<int>>& courses) {\n        sort(courses.begin(), courses.end(), [](const auto& c0, const auto& c1) {\n            return c0[1] < c1[1];\n        });\n\n        priority_queue<int> q;\n        // 优先队列中所有课程的总时间\n        int total = 0;\n\n        for (const auto& course: courses) {\n            int ti = course[0], di = course[1];\n            if (total + ti <= di) {\n                total += ti;\n                q.push(ti);\n            }\n            else { //表示直接向上累计 失败\n                //但是当前的截止时间大于堆内所以课程的截止时间\n                //只要当前的持续时间 小于 堆内最大的持续时间 就应该替换\n                //因为这个课程是最优的 持续时间短 截止时间晚\n                if (!q.empty() && q.top() > ti) {\n                    total -= q.top() - ti;\n                    q.pop();\n                    q.push(ti);\n                }   \n            }\n        }\n        return q.size();\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"window开机内存占用高","url":"/2022/04/04/window-kai-ji-nei-cun-zhan-yong-gao/","content":"\n16g的内存，开机动不动就飙过50%\n\n尤其是之前发现但从未去解决的 Lenovo.Modern.ImController.exe 服务 不断跑内存的情况 下定决心处理一下\n\n### 流程\n\n1. win + r  msconfig\n\n   服务->隐藏所有Microsoft服务  然后剩余的服务 感觉用不到的该关关 \n\n   不建议全部禁用 影响一些自己设置的开机启动项，个人就是lenovo全部禁用 解决了Lenovo.Modern.ImController.exe的问题\n\n   其他的 也多多少少禁用下 很多没用的服务\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220404164932465.png\" alt=\"image-20220404164932465\" style=\"zoom: 67%;\" />\n\n2. 任务管理器的 启动项 该关关\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220404165413230.png\" alt=\"image-20220404165413230\" style=\"zoom: 67%;\" />","tags":["开发随笔"]},{"title":"双指针","url":"/2022/04/03/shuang-zhi-zhen/","content":"\n### [剑指 Offer II 007. 数组中和为 0 的三个数](https://leetcode-cn.com/problems/1fGaJU/)\n\n难度中等50收藏分享切换为英文接收动态反馈英文版讨论区\n\n给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a` ，`b` ，`c` *，*使得 `a + b + c = 0` ？请找出所有和为 `0` 且 **不重复** 的三元组。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：nums = [0]\n输出：[]\n```\n\n#### 思路\n\n1. 遍历起始点 然后双指针遍历\n2. 注意 去重去重 每一个数 都需要去重\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n = nums.size();\n        if(n<3 || n == 0) return {}; //特判\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n\n        //遍历 然后双指针\n        for(int i = 0; i < n; i++){\n            if(nums[i]>0) break; //剪枝\n            if(i>0 && nums[i] == nums[i-1]) continue; //去重\n            int left = i+1;\n            int right = n-1;\n            //注意 这里并不是二分判定 而是双指针\n            while(left < right){ \n                int sum = nums[i] + nums[left] + nums[right];\n                if(sum > 0){\n                    right--;\n                }else if(sum<0){\n                    left++;\n                }else{\n                    ans.push_back({nums[i], nums[left], nums[right]});\n                    //很重要的去重\n                    while(left<right && nums[left] == nums[left+1]) left++;\n                    while(left<right && nums[right] == nums[right-1]) right--;\n                    left++;right--;\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n**题目**：\n\n- [26. 删除有序数组中的重复项 🟢](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)\n- [83. 删除排序链表中的重复元素 🟢](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)\n- [27. 移除元素 🟢](https://leetcode-cn.com/problems/remove-element)\n- [283. 移动零 🟢](https://leetcode-cn.com/problems/move-zeroes)\n- [167. 两数之和 II - 输入有序数组 🟢](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)\n- [344. 反转字符串 🟢](https://leetcode-cn.com/problems/reverse-string)","tags":["算法总结"]},{"title":"回文","url":"/2022/04/02/hui-wen/","content":"\n### [剑指 Offer II 018. 有效的回文](https://leetcode-cn.com/problems/XltzEq/)\n\n难度简单18\n\n给定一个字符串 `s` ，验证 `s` 是否是 **回文串** ，只考虑字母和数字字符，可以忽略字母的大小写。\n\n本题中，将空字符串定义为有效的 **回文串** 。\n\n \n\n**示例 1:**\n\n```\n输入: s = \"A man, a plan, a canal: Panama\"\n输出: true\n解释：\"amanaplanacanalpanama\" 是回文串\n```\n\n**示例 2:**\n\n```\n输入: s = \"race a car\"\n输出: false\n解释：\"raceacar\" 不是回文串\n```\n\n#### 思路\n\n1. 开辟新string 判断是否回文\n2. 原地判断 一次遍历\n\n#### 代码\n\n开辟新string 判断是否回文\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        string ss;\n        for(int i = 0; i<s.size(); i++){\n            if(tolower(s[i])>='a' && tolower(s[i])<='z'  ||(s[i]>='0' &&s[i]<='9'))\n                ss += tolower(s[i]);\n        }\n        return isHuiWen(ss);\n    }\n    bool isHuiWen(string s){\n        string ss = s;\n        reverse(s.begin(), s.end());\n        cout<<s<<endl;\n        return ss == s;\n    }\n};\n```\n\n原地判断 一次遍历\n\n```c++\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        int left = 0, right = s.size()-1;\n        while(left<right){\n            while(left<s.size() && !isValid(s[left])){\n                left++;\n            }\n            while(right>=0 && !isValid(s[right])){\n                right--;\n            }\n            //越界 为空 直接返回1\n            if(left>=s.size()|| right<0) return 1;\n            if(tolower(s[left]) != tolower(s[right]))\n                return 0;\n            left++;\n            right--;\n        }\n        return 1;\n    }\n    bool isValid(char& ch){\n        if(tolower(ch)>='a' && tolower(ch)<='z'  ||(ch>='0' &&ch<='9'))\n            return 1;\n        return 0;\n    }\n};\n```\n\n### [剑指 Offer II 027. 回文链表](https://leetcode-cn.com/problems/aMhZSa/)\n\n难度简单42\n\n给定一个链表的 **头节点** `head` **，**请判断其是否为回文链表。\n\n如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。\n\n \n\n**示例 1：**\n\n**![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626421737-LjXceN-image.png)**\n\n```\n输入: head = [1,2,3,3,2,1]\n输出: true\n```\n\n**示例 2：**\n\n**![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626422231-wgvnWh-image.png)**\n\n```\n输入: head = [1,2]\n输出: false\n```\n\n#### 思路\n\n1. 笨比vector\n2. 快慢指针 反转一半\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        vector<int> nums;\n        while(head){\n            nums.push_back(head->val);\n            head = head->next;\n        }\n        return isPalindrome(nums);\n    }\n\n    bool isPalindrome(vector<int>& nums) {\n        int left = 0, right = nums.size()-1;\n        while(left<right){\n            if(nums[left]!=nums[right])\n                return 0;\n            left++;\n            right--;\n        }\n        return 1;\n    }\n\n};\n```\n\n快慢指针 反转一半\n\n```c++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head){\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        ListNode* last = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return last;\n    }\n\t\t//奇数中间 偶数前面最后一个\n    ListNode* findMiddleOfList(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* preSlow;\n        while(fast && fast->next){\n            preSlow = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return fast == nullptr?preSlow:slow;\n    }\n\n    bool isPalindrome(ListNode* head) {\n        ListNode* middle = findMiddleOfList(head);\n        ListNode* secondBegin = middle->next;\n        middle->next = nullptr;\n        secondBegin = reverseList(secondBegin);\n        ListNode* firstBegin = head;\n\n        ListNode* cpySecondBegin = secondBegin;\n\n        bool ans = 1;\n        while(firstBegin && secondBegin){\n            if(firstBegin->val!= secondBegin->val){\n                ans = 0;\n                break;\n            }\n            firstBegin = firstBegin->next;\n            secondBegin = secondBegin->next;\n        }\n\n        //还原链表\n        secondBegin = reverseList(cpySecondBegin);\n        middle->next = secondBegin;\n\n        return ans;\n    }\n};\n```\n\n### [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)\n\n难度简单1921\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。\n\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n- 例如，`121` 是回文，而 `123` 不是。\n\n \n\n**示例 1：**\n\n```\n输入：x = 121\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n```\n\n**进阶：**你能不将整数转为字符串来解决这个问题吗？\n\n#### 思路\n\n1. 难点在于不转换为字符串或者数组\n2. 反转一半 反转后的数字为大半 剩余的为小半\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n};\n```\n\n### [面试题 01.04. 回文排列](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)\n\n难度简单78英文版讨论区\n\n给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。\n\n回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。\n\n回文串不一定是字典当中的单词。\n\n \n\n**示例1：**\n\n```\n输入：\"tactcoa\"\n输出：true（排列有\"tacocat\"、\"atcocta\"，等等）\n```\n\n#### 思路\n\n用到回文一个性质 奇数个数的元素 只可能存在一个 或 0个\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        unordered_map<int, int> mapp;\n        int oddCount = 0;\n        for(char ch:s)\n            mapp[ch]++;\n        for(auto it = mapp.begin(); it!=mapp.end(); it++){\n            if(it->second%2)\n                oddCount++;\n            if(oddCount>1)\n                return false;\n        }\n        return 1;\n    }\n};\n```\n\n### [剑指 Offer II 019. 最多删除一个字符得到回文](https://leetcode-cn.com/problems/RQku0D/)\n\n难度简单28英文版讨论区\n\n给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。\n\n \n\n**示例 1:**\n\n```\n输入: s = \"aba\"\n输出: true\n```\n\n**示例 2:**\n\n```\n输入: s = \"abca\"\n输出: true\n解释: 可以删除 \"c\" 字符 或者 \"b\" 字符\n```\n\n**示例 3:**\n\n```\n输入: s = \"abc\"\n输出: false\n```\n\n#### 思路\n\n不等的时候 判断两次字串\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool validPalindrome(string s) {\n        bool ans = 0;\n        int left = 0, right = s.size()-1;\n        while(left < right){\n            if(s[left] != s[right]){\n                //cout<<s.substr(left + 1, right-left)<<endl;\n                //cout<<s.substr(left, right-left)<<endl;\n                return isPalidromee(s.substr(left + 1, right-left)) || \n                isPalidromee(s.substr(left, right-left));\n                //return isPalidrome(s, left) || isPalidrome(s, right);\n            }\n            left++;\n            right--;\n        }\n        return 1;\n    }\n\n    bool isPalidrome(string& s, int pos){\n        int left = 0, right = s.size()-1;\n        while(left<right){\n            if(left == pos || right == pos){\n                if(left == pos)\n                    left++;\n                else right--;\n            }\n            if(s[left] != s[right]){\n                return 0;\n            }\n            left++;\n            right--;\n        }\n        return 1;\n    }\n\n    bool isPalidromee(string s){\n        int left = 0, right = s.size()-1;\n        while(left < right){\n            if(s[left] != s[right])\n                return 0;\n            left++;\n            right--;\n        }\n        return 1;\n    }\n};\n```\n\n### [866. 回文素数](https://leetcode-cn.com/problems/prime-palindrome/) 构造回文数\n\n难度中等77英文版讨论区\n\n求出大于或等于 `N` 的最小回文素数。\n\n回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是*素数*。\n\n例如，2，3，5，7，11 以及 13 是素数。\n\n回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是*回文数。*\n\n例如，12321 是回文数。\n\n \n\n**示例 1：**\n\n```\n输入：6\n输出：7\n```\n\n**示例 2：**\n\n```\n输入：8\n输出：11\n```\n\n**示例 3：**\n\n```\n输入：13\n输出：101\n```\n\n#### 思路\n\n枚举所有回文数, 并判断是否为质数;\n模拟回文数的方法, 计算回文根, 再生成回文数;\n举例: 回文根为123, 可以构成的回文数为12321, 123321; \n\n>left - right 1-10 一次while生成的回文数 1-9 和11 22 33 44 55...99\n>\n>left - right 10-100 一次while生成的回文数 101 111 121 131...999 和 1001 1111 1221 1331...9999\n>\n>......\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool isPrim(int x) { /* 质数判断 */\n        if (x == 1) {\n            return false;\n        }\n        for (int i = 2; i <= sqrt(x); i++) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //重点函数 背一下\n    int primePalindrome(int n) {\n        int left = 1;\n        while (1) {\n            int right = left * 10;\n            for (int op = 0; op < 2; op++) {\n                for (int i = left; i < right; i++) {\n                    int sum = i;\n                    int x = (op == 0) ? i / 10 : i;\n                    while (x > 0) { /* 构造回文数 */\n                        sum = sum * 10 + x % 10;\n                        x /= 10;\n                    }\n                    if (sum >= n && isPrim(sum)) { /* 判断是否>=n且为质数 */\n                        return sum;\n                    }\n                }\n            }\n            left = right;\n        }\n        return 1;\n    }\n};\n```\n\n### [剑指 Offer II 020. 回文子字符串的个数](https://leetcode-cn.com/problems/a7VOhD/)\n\n难度中等40\n\n给定一个字符串 `s` ，请计算这个字符串中有多少个回文子字符串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n```\n\n#### 思路\n\n1. 假设size = 4 一个循环解决回文中心奇数 偶数两种情况\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220406112344685.png\" alt=\"image-20220406112344685\" style=\"zoom: 67%;\" />\n\n2. 马拉车算法，我选择放弃[有什么浅显易懂的Manacher Algorithm讲解？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/37289584)\n\n#### 代码\n\n```c++\n//一次\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int ans = 0;\n        for(int i = 0; i<s.size()*2-1; i++){\n            int left = i/2, right = left + i%2;\n            while(left>=0 && right<s.size()){\n                if(s[left] == s[right])\n                    ans++;\n                else break;\n                left--;\n                right++;\n            }\n        }\n        return ans;\n    }\n};\n\n//两次好理解\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int ans = 0;\n        for(int i = 0; i<s.size(); i++){\n            int left = i, right = i;\n            while(left>=0 && right<s.size()){\n                if(s[left] == s[right])\n                    ans++;\n                else break;\n                left--;\n                right++;\n            }\n\n            left = i, right = i+1;\n            while(left>=0 && right<s.size()){\n                if(s[left] == s[right])\n                    ans++;\n                else break;\n                left--;\n                right++;\n            }\n        }\n        return ans;\n    }\n};\n\n//马拉车算法\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int n = s.size();\n        string t = \"$#\";\n        for (const char &c: s) {\n            t += c;\n            t += '#';\n        }\n        n = t.size();\n        t += '!';\n\n        auto f = vector <int> (n);\n        int iMax = 0, rMax = 0, ans = 0;\n        for (int i = 1; i < n; ++i) {\n            // 初始化 f[i]\n            f[i] = (i <= rMax) ? min(rMax - i + 1, f[2 * iMax - i]) : 1;\n            // 中心拓展\n            while (t[i + f[i]] == t[i - f[i]]) ++f[i];\n            // 动态维护 iMax 和 rMax\n            if (i + f[i] - 1 > rMax) {\n                iMax = i;\n                rMax = i + f[i] - 1;\n            }\n            // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整\n            ans += (f[i] / 2);\n        }\n\n        return ans;\n    }\n};\n```\n\n### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=5)[思路](https://leetcode-cn.com/problems/longest-palindromic-substring/#)\n\n难度中等5101\n\n给你一个字符串 `s`，找到 `s` 中最长的回文子串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n#### 思路\n\n中心扩展 直接返回string还好操作一点 \n\n返回左右下标 节省空间 \n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    string expandCenter(string& s, int left, int right){\n      while(left>= 0 && right<s.size() && s[left] == s[right]){\n        left--;\n        right++;\n      }\n      return s.substr(left + 1, right - 1 - left); //right - 1 - (left + 1) - 1\n    }\n    string longestPalindrome(string s) {\n      string ans;\n      for(int i = 0; i<s.size(); i++){\n        string p1 = expandCenter(s, i, i);\n        string p2 = expandCenter(s, i, i+1);\n        ans = ans.size()<p1.size()?p1:ans;\n        ans = ans.size()<p2.size()?p2:ans;\n      }\n      return ans;\n    }\n};\n\n\nclass Solution {\npublic:\n    pair<int,int> expandFromCenter(const string& s, int l, int r){\n        while(l>=0 && r<s.size() && s[l] == s[r]){\n            l--;\n            r++;\n        }\n        return {l+1, r-1};\n    }\n    string longestPalindrome(string s) {\n        int start = 0; \n        int end  = 0;\n        for(int i = 0; i<s.size()-1; i++){\n            auto [l1, r1] = expandFromCenter(s, i,i);\n            auto [l2, r2] = expandFromCenter(s, i,i+1);\n            if(r1-l1>end-start){\n                end = r1;\n                start = l1;\n            }\n            if(r2-l2>end-start){\n                end = r2;\n                start = l2;\n            }\n        }\n        return s.substr(start, end-start +1);\n    }\n};\n```\n\n### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)\n\n难度中等1089\n\n给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。\n\n**回文串** 是正着读和反着读都一样的字符串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"aab\"\n输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\"\n输出：[[\"a\"]]\n```\n\n#### 思路\n\n回溯，检测每个字串是否是回文 回文的话压入path 否则跳过\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> ans;\n    vector<string> path;\n    vector<vector<string>> partition(string s) {\n      backtrack(s, 0);\n      return ans;\n    }\n\n    void backtrack(string& s, int startIndex){\n      if(startIndex>=s.size()){\n        ans.push_back(path);\n        return;\n      }\n\n      for(int i = startIndex; i<s.size(); i++){\n        if(isP(s, startIndex, i))\n          path.push_back(s.substr(startIndex, i-startIndex + 1));\n        else continue;\n        backtrack(s, i+1);\n        path.pop_back();\n      }\n    }\n\n    bool isP(string& s, int left, int right){\n      while(left < right){\n        if(s[left] != s[right])\n          return 0;\n        left++;\n        right--;\n      }\n      return 1;\n    }\n};\n```\n\n优化回文的判断 存储f[ i ] [ j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串  记忆化搜索\n\n```c++\n    vector<vector<int>> f;\n\t\t// 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串\n    int isP(string& s, int left, int right){\n      if(f[left][right] != 0)\n        return f[left][right];\n      if(left >= right){\n        //赋值 并返回1\n        return f[left][right]  = 1;\n      }\n      return f[left][right] = (s[left] == s[right]? isP(s,  left+1, right-1) : -1);\n    }\n```\n\n\n\n### `回文子序列问题`\n\n回文子序列问题 涉及到 `dp` `回文`\n\n更多的是`dp`\n\n### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=516)[思路](https://leetcode-cn.com/problems/longest-palindromic-subsequence/#)\n\n难度中等777\n\n给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。\n\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"bbbab\"\n输出：4\n解释：一个可能的最长回文子序列为 \"bbbb\" 。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：2\n解释：一个可能的最长回文子序列为 \"bb\" 。\n```\n\n","tags":["算法总结"]},{"title":"window下添加右键操作","url":"/2022/04/02/window-xia-tian-jia-you-jian-cao-zuo/","content":"\n\n\n\n\n### 以sublime为例\n\n#### 右键打开文件\n\n1. Win + R，输入regedit,打开注册表\n2. 找到如图路径，做成我的目录结构就可以了\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402160540332.png\" style=\"zoom: 67%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402160516575.png\" alt=\"image-20220402160516575\" style=\"zoom: 67%;\" />\n\n#### 右键打开文件夹\n\n##### 和上面差不多 做成类似如图的目录结构 简简单单\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402160806130.png\" alt=\"image-20220402160806130\" style=\"zoom: 67%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402160823636.png\" alt=\"image-20220402160823636\" style=\"zoom: 67%;\" />","tags":["开发随笔"]},{"title":"模拟加减乘除","url":"/2022/04/01/mo-ni-yun-suan/","content":"\n### [剑指 Offer II 002. 二进制加法](https://leetcode-cn.com/problems/JFETK5/)\n\n难度简单27\n\n给定两个 01 字符串 `a` 和 `b` ，请计算它们的和，并以二进制字符串的形式输出。\n\n输入为 **非空** 字符串且只包含数字 `1` 和 `0`。\n\n \n\n**示例 1:**\n\n```\n输入: a = \"11\", b = \"10\"\n输出: \"101\"\n```\n\n**示例 2:**\n\n```\n输入: a = \"1010\", b = \"1011\"\n输出: \"10101\"\n```\n\n#### 思路\n\n1. 模拟相加 注意下写法\n2. 位运算\n\n#### 代码\n\n模拟\n\n```c++\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans;\n        reverse(a.begin(), a.end());\n        reverse(b.begin(), b.end());\n        int n = max(a.size(), b.size()), carry = 0;\n        for(int i = 0; i<n; i++){\n            carry+= i<a.size()?a[i] =='1':0;\n            carry+= i<b.size()?b[i] =='1':0;\n            ans += to_string(carry%2);\n            carry/=2;\n        }\n        if (carry) {\n            ans.push_back('1');\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n难度简单191\n\n整数的 **数组形式** `num` 是按照从左到右的顺序表示其数字的数组。\n\n- 例如，对于 `num = 1321` ，数组形式是 `[1,3,2,1]` 。\n\n给定 `num` ，整数的 **数组形式** ，和整数 `k` ，返回 *整数 `num + k` 的 **数组形式*** 。\n\n \n\n\n\n**示例 1：**\n\n```\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n```\n\n**示例 2：**\n\n```\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n```\n\n**示例 3：**\n\n```\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n```\n\n#### 思路\n\nk转为vector 按位相加\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        vector<int> num2;\n        while(k){\n            int temp = k%10;\n            k/=10;\n            num2.push_back(temp);\n        }\n        reverse(num.begin(), num.end());\n        int maxSize = max(num.size(), num2.size());\n        int carry = 0;\n        for(int i = 0; i<maxSize; i++){\n            carry+=i<num.size()?num[i]:0;\n            carry+=i<num2.size()?num2[i]:0;\n            ans.push_back(carry%10);\n            carry/=10;\n        }\n        if(carry) ans.push_back(1);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n### [66. 加一](https://leetcode-cn.com/problems/plus-one/)\n\n难度简单972\n\n给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n \n\n**示例 1：**\n\n```\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n```\n\n**示例 2：**\n\n```\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n```\n\n**示例 3：**\n\n```\n输入：digits = [0]\n输出：[1]\n```\n\n#### 代码\n\n```c++\n//统一写法\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        vector<int> ans(digits.size());\n        int carry = 0;\n        for(int i = digits.size()-1; i>=0; i--){\n            if(i == digits.size()-1){\n                carry++;\n            }\n            carry+=digits[i];\n            ans[i] = (carry%10);\n            carry/=10;\n        }\n        if(carry) ans.insert(ans.begin(), 1);\n        return ans;\n    }\n};\n\n//原地修改\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for(int i = digits.size()-1; i>=0; i--){\n            if (digits[i] == 9){\n                digits[i] = 0;\n            }else{\n                digits[i]++;\n                break;\n            }\n        }\n\n        if(digits[0] == 0){\n            digits[0] = 1;\n            digits.push_back(0); \n        }\n        return digits;\n    }\n};\n```\n\n### [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)\n\n难度简单534\n\n给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。\n\n你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。\n\n \n\n**示例 1：**\n\n```\n输入：num1 = \"11\", num2 = \"123\"\n输出：\"134\"\n```\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string ans = \"\";\n        int maxSize = max(num1.size(), num2.size());\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        int carry = 0;\n        for(int i = 0; i<maxSize; i++){\n            carry+=i<num1.size()?(num1[i] - '0'):0;\n            carry+=i<num2.size()?(num2[i] - '0'):0;\n            ans+=to_string(carry%10);a\n            carry/=10;\n        }\n        if(carry) ans+=\"1\";\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) 链表\n\n[思路](https://leetcode-cn.com/problems/add-two-numbers/#)\n\n难度中等7812\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/addtwonumber1.jpg)\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例 2：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n#### 思路\n\n就模拟吗\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ans = new ListNode();\n        ListNode* temp = ans;\n        int carry = 0;\n        while(l1 || l2){\n            carry+= l1?l1->val:0;\n            carry+= l2?l2->val:0;\n            l1 = l1?l1->next:l1;\n            l2 = l2?l2->next:l2;\n            temp->next = new ListNode(carry%10);\n            temp = temp->next;\n            carry/=10;\n        }\n        if(carry) temp->next = new ListNode(1);\n        return ans->next;\n    }\n};\n```\n\n### [剑指 Offer II 025. 链表中的两数相加](https://leetcode-cn.com/problems/lMSNwu/)\n\n难度中等42\n\n给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。\n\n可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n \n\n**示例1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626420025-fZfzMX-image.png)\n\n```\n输入：l1 = [7,2,4,3], l2 = [5,6,4]\n输出：[7,8,0,7]\n```\n\n**示例2：**\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[8,0,7]\n```\n\n#### 思路\n\n反转 套上面 再反转\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head){\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        ListNode* last = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return last;\n    }\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* L1 = reverseList(l1);\n        ListNode* L2 = reverseList(l2);\n        //这样写 不存在内存泄漏 同时 又有了一个可以直接移动的指针\n        ListNode dumpyHead;  \n        ListNode* pre = &dumpyHead;\n        int carry = 0;\n        while(L1 || L2){\n            carry += L1?L1->val:0;\n            carry += L2?L2->val:0;\n            pre->next = new ListNode(carry%10);\n            carry /= 10;         \n            pre = pre->next;\n            L1 = L1?L1->next:L1;\n            L2 = L2?L2->next:L2;\n        }\n        //md又忘了\n        if(carry) pre->next = new ListNode(1);\n        return reverseList(dumpyHead.next);\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"单调栈","url":"/2022/03/30/dan-diao-zhan/","content":"\n<u>**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。</u>\n\n时间复杂度为$O(n)$。\n\n例如本题其实就是找找到一个元素右边第一个比自己大的元素。\n\n此时就应该想到用单调栈了。\n\n那么单调栈的原理是什么呢？为什么时间复杂度是$O(n)$就可以找到每一个元素的右边第一个比它大的元素位置呢？\n\n单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素的元素，优点是只需要遍历一次。\n\n在使用单调栈的时候首先要明确如下几点：\n\n1. 单调栈里存放的元素是什么？\n\n单调栈里只需要存放元素的`下标i`就可以了，如果需要使用对应的元素，直接T[i]就可以获取。\n\n2. 单调栈里元素是递增呢？ 还是递减呢？\n\n**注意一下顺序为 从栈头到栈底的顺序**，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。\n\n这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。\n\n使用单调栈主要有三个判断条件。\n\n- 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况\n- 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况\n- 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况\n\n==<u>约定： 递增栈为头到底递增</u>==\n\n### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=739)\n\n难度中等1081收藏分享切换为英文接收动态反馈\n\n给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指在第 `i` 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n \n\n**示例 1:**\n\n```\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n**示例 2:**\n\n```\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n```\n\n**示例 3:**\n\n```\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n```\n\n#### [思路](https://programmercarl.com/0739.每日温度.html#思路)\n\n递增单调栈  （元素<=栈顶元素时 入栈）\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& nums) {\n        stack<int> stk;\n        int n = nums.size();\n        vector<int> ans(n);\n        for(int i = 0; i<n; i++){\n            //0特判\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            //元素<=栈顶元素时 入栈\n            if(nums[i]<=nums[stk.top()]){\n                stk.push(i);\n            }else{\n                while(!stk.empty() && nums[stk.top()]<nums[i]){\n                    int now = stk.top();\n                    stk.pop();\n                    ans[now] = (i - now);                    \n                }\n                stk.push(i); // 不要忘了入栈\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=496)\n\n难度简单676英文版讨论区\n\n`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。\n\n给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。\n\n对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。\n\n返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。\n\n \n\n**示例 1：**\n\n```\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [2,4], nums2 = [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n#### 思路\n\n1. 这道题虽然是简单题 但是难度比每日温度大\n2. 用一个哈希记录nums1，再对nums2使用单调栈\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size();\n        vector<int> ans(m, -1);\n        stack<int> stk;\n        unordered_map<int, int> mapp;\n        for(int i = 0; i<m; i++)\n            mapp[nums1[i]] = i;\n        int n = nums2.size();\n        for(int i = 0; i<n; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            if(nums2[stk.top()]>= nums2[i])\n                stk.push(i);\n            else{\n                while(!stk.empty() && nums2[stk.top()] < nums2[i]){\n                    int nowI = stk.top();\n                    //判断是否是nums1中的元素\n                    if(mapp.count(nums2[nowI])){\n                        int index = mapp[nums2[nowI]];\n                        ans[index] = nums2[i];\n                    }\n                    stk.pop();\n                }\n                stk.push(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=503)\n\n难度中等586英文版讨论区\n\n给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。\n\n数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,2,1]\n输出: [2,-1,2]\n解释: 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,2,3,4,3]\n输出: [2,3,4,-1,4]\n```\n\n#### 思路\n\n1. 再拼接一个数组 对二倍长度的数组进行统计 最后将结果resize为原大小\n2. 循环起来，遍历的时候遍历二倍大小 用%n来进行循环\n\n#### 代码\n\n##### 二倍数组拼接\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        n*=2;\n        vector<int> nums1(nums.begin(), nums.end());\n        nums.insert(nums.end(), nums1.begin(), nums1.end());\n        stack<int> stk;\n        vector<int> ans(n, -1);\n        for(int i = 0; i<n; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n\n            if(nums[stk.top()]>=nums[i]){\n                stk.push(i);\n            }else{\n                while(!stk.empty() && nums[stk.top()]<nums[i]){\n                    ans[stk.top()] = nums[i];\n                    stk.pop();\n                }\n                stk.push(i);\n            }\n        }\n        ans.resize(n/2);\n        return ans;\n    }\n};\n```\n\n##### 二倍循环%n\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        stack<int> stk;\n        vector<int> ans(n, -1);\n        for(int i = 0; i<n*2; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            while(!stk.empty() && nums[stk.top()]<nums[i%n]){\n                ans[stk.top()] = nums[i%n];\n                stk.pop();\n            }\n            stk.push(i%n);\n        }\n        return ans;\n    }\n};\n```\n\n### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=42)[思路](https://leetcode-cn.com/problems/trapping-rain-water/#)\n\n难度困难3289英文版讨论区\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rainwatertrap.png)\n\n```\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n```\n\n**示例 2：**\n\n```\n输入：height = [4,2,0,3,2,5]\n输出：9\n```\n\n#### 思路\n\n1. On2暴力 \n2. dp 多次遍历 保存最值\n3. 最小栈\n\n#### 代码\n\n##### On2暴力\n\n```c++\n//暴力超时\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        for(int i = 0; i<n; i++){\n            if(i == 0 || i == n-1) continue;\n            int rHeight = height[i];\n            int lHeight = height[i];\n            for(int r = i+1; r<n; r++){\n                if(height[r]>rHeight) rHeight = height[r];\n            }\n            for(int l = i-1; l>=0; l--){\n                if(height[l]>lHeight) lHeight = height[l];\n            }\n            int h = min(lHeight, rHeight) - height[i];\n            if(h>0) sum+=h;\n        }\n        return sum;\n    }\n};\n```\n\n##### dp 多次遍历 保存最值\n\n```c++\n// dp解法\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        vector<int> leftH(n, 0);\n        vector<int> rightH(n, 0);\n        leftH[0] = height[0];\n        rightH[n-1] = height[n-1];\n        for(int i = 1; i<n; i++){\n            leftH[i] = max(height[i], leftH[i-1]);\n        }\n        for(int i = n-2; i>=0; i--){\n            rightH[i] = max(height[i], rightH[i+1]);\n        }\n        for(int i = 0; i<n; i++){\n            int h = min(leftH[i], rightH[i]) - height[i];\n            if(h>0) sum+=h;\n        }\n        return sum;\n    }\n};\n```\n\n##### 最小栈\n\n```c++\n//最小栈\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        stack<int> stk;\n        stk.push(0);\n        for(int i = 1; i<n; i++){\n            if(height[i]<height[stk.top()])\n                stk.push(i);\n            else if(height[i] == height[stk.top()]){\n                stk.pop();\n                stk.push(i);\n            }else{\n                //每个坑坑洼洼的地方计算一次\n                while(!stk.empty() && height[i]>height[stk.top()]){\n                    int mid = stk.top();\n                    stk.pop();\n                    if(!stk.empty()){\n                        int h = min(height[stk.top()], height[i]) - height[mid];\n                        int w = i - stk.top() - 1;\n                        sum += h*w;\n                    }\n                }\n                stk.push(i);\n            }\n        }\n        return sum;\n    }\n};\n```\n\n### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n难度困难1849\n\n给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n \n\n**示例 1:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram.jpg)\n\n```\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram-1.jpg)\n\n```\n输入： heights = [2,4]\n输出： 4\n```\n\n#### 思路\n\n1. 动态规划\n\n   本题动态规划的写法整体思路和[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)是一致的，但要比[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)难一些。难就难在本题要记录记录每个柱子 左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。所以需要循环查找，也就是下面在寻找的过程中使用了while\n\n2. 单调栈\n\n   本地单调栈的解法和接雨水的题目是遥相呼应的。\n\n   为什么这么说呢，[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n\n   **这里就涉及到了单调栈很重要的性质，就是单调栈里的顺序，是从小到大还是从大到小**。\n\n   在题解[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)中我讲解了接雨水的单调栈从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。\n\n   那么因为本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！\n\n   我来举一个例子，如图：\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20210223155303971.jpg\" alt=\"84.柱状图中最大的矩形\" style=\"zoom:50%;\" />\n\n   只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。\n\n   所以本题单调栈的顺序正好与接雨水反过来。\n\n   此时大家应该可以发现其实就是**栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度**\n\n   理解这一点，对单调栈就掌握的比较到位了。\n\n   除了栈内元素顺序和接雨水不同，剩下的逻辑就都差不多了，在题解[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)我已经对单调栈的各个方面做了详细讲解，这里就不赘述了。\n\n   剩下就是分析清楚如下三种情况：\n\n   - 情况一：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况\n   - 情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况\n   - 情况三：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220331164646464.png\" alt=\"image-20220331164646464\" style=\"zoom: 67%;\" />\n\n#### 代码\n\n##### 动态规划\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> minLeftIndex(heights.size());\n        vector<int> minRightIndex(heights.size());\n        int size = heights.size();\n\n        // 记录每个柱子 左边第一个小于该柱子的下标\n        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环\n        for (int i = 1; i < size; i++) {\n            int t = i - 1;\n            // 这里不是用if，而是不断向左寻找的过程\n            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];\n            minLeftIndex[i] = t;\n        }\n        // 记录每个柱子 右边第一个小于该柱子的下标\n        minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环\n        for (int i = size - 2; i >= 0; i--) {\n            int t = i + 1;\n            // 这里不是用if，而是不断向右寻找的过程\n            while (t < size && heights[t] >= heights[i]) t = minRightIndex[t];\n            minRightIndex[i] = t;\n        }\n        // 求和\n        int result = 0;\n        for (int i = 0; i < size; i++) {\n            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);\n            result = max(sum, result);\n        }\n        return result;\n    }\n};\n```\n\n##### 单调栈  略微背一下吧\n\n```c++\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<int> stk;\n        heights.insert(heights.begin(), 0);\n        heights.push_back(0);\n        stk.push(0);\n        int ans = 0;\n        for(int i = 1; i<heights.size(); i++){\n            if(heights[i]>heights[stk.top()])\n                stk.push(i);\n            else if(heights[i] == heights[stk.top()]){\n                stk.pop();\n                stk.push(i);\n            }else{\n                while(heights[i] < heights[stk.top()]){\n                    int mid = stk.top(); //当前矩形高的位置\n                    stk.pop();\n                    int left = stk.top();\n                    int right = i;  //记录当前值以计算宽\n                    int w = right - left - 1;\n                    int h = heights[mid];\n                    ans = max(ans, w*h);\n                }\n                stk.push(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"栈","url":"/2022/03/30/zhan/","content":"\n<u>**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。</u>\n\n\n\n# 普通栈\n\n### [剑指 Offer II 037. 小行星碰撞](https://leetcode-cn.com/problems/XagZNi/)\n\n难度中等24收藏分享切换为英文接收动态反馈英文版讨论区\n\n给定一个整数数组 `asteroids`，表示在同一行的小行星。\n\n对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。\n\n找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。\n\n \n\n**示例 1：**\n\n```\n输入：asteroids = [5,10,-5]\n输出：[5,10]\n解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\n```\n\n**示例 2：**\n\n```\n输入：asteroids = [8,-8]\n输出：[]\n解释：8 和 -8 碰撞后，两者都发生爆炸。\n```\n\n#### 解题思路\n情况讨论如下：\n\n直接压入栈的情况：\n\n     a. 栈空；\n     b. 栈顶是负数（向左运动的行星）；\n     c. 栈顶与asteroids[i]符号相同（当前行星运动方向一致）\n栈顶是正数\n\n     a.如果asteroids[i]的绝对值小于栈顶，++i；\n     b.如果相等，则弹出栈顶元素并 ++i；\n     c.如果大于，则弹出栈顶元素，asteroids[i]继续进行一轮判断\n         （因为每次循环都有++i操作，故进行--i操作）\n最初开始用栈实现，其实用vector就可以实现\n\n#### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& nums) {\n        vector<int> ans;\n        for(int i = 0; i<nums.size(); i++){\n            if(ans.empty() || ans.back()<0 || ans.back()*nums[i]>0)\n                ans.push_back(nums[i]);\n            else if(ans.back() + nums[i] <= 0){\n                if(ans.back() + nums[i] < 0) --i;\n                ans.pop_back();\n            }\n        }\n        return ans;\n    }\n};\n\n//我的笨比解法\nclass Solution {\npublic:\n\tvector<int> asteroidCollision(vector<int> &nums) {\n\t\tvector<int> ans;\n\t\tstack<int> stk;\n\t\tint n = nums.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (stk.empty()) {\n\t\t\t\tstk.push(nums[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//判断是否需要跳过当前for\n\t\t\t//撞出0 跳过当前\n\t\t\tbool jump = 0;\n\t\t\t//之前向右 当前向左 会撞\n\t\t\tif (stk.top() > 0 && nums[i] < 0) {\n\t\t\t\tint temp = nums[i];\n\t\t\t\twhile (!stk.empty() && stk.top() > 0 && temp < 0) {\n\t\t\t\t\tint flag = temp + stk.top();\n\t\t\t\t\t//撞出0 出栈并跳过当前\n\t\t\t\t\tif (flag == 0) {\n\t\t\t\t\t\tstk.pop();\n\t\t\t\t\t\tjump = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//更新未进栈的行星 并出栈top\n\t\t\t\t\ttemp = max(abs(stk.top()), abs(temp)) * flag / abs(flag);\n\t\t\t\t\tstk.pop();\n\t\t\t\t}\n\t\t\t\tif (jump) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//撞剩下的行星入栈\n\t\t\t\tstk.push(temp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstk.push(nums[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!stk.empty()) {\n\t\t\tans.push_back(stk.top());\n\t\t\tstk.pop();\n\t\t}\n\t\treturn{ ans.rbegin(), ans.rend() };\n\t}\n};\n```\n\n# 单调栈\n\n**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。\n\n时间复杂度为$O(n)$。\n\n例如本题其实就是找找到一个元素右边第一个比自己大的元素。\n\n此时就应该想到用单调栈了。\n\n那么单调栈的原理是什么呢？为什么时间复杂度是$O(n)$就可以找到每一个元素的右边第一个比它大的元素位置呢？\n\n单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素的元素，优点是只需要遍历一次。\n\n在使用单调栈的时候首先要明确如下几点：\n\n1. 单调栈里存放的元素是什么？\n\n单调栈里只需要存放元素的`下标i`就可以了，如果需要使用对应的元素，直接T[i]就可以获取。\n\n2. 单调栈里元素是递增呢？ 还是递减呢？\n\n**注意一下顺序为 从栈头到栈底的顺序**，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。\n\n这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。\n\n使用单调栈主要有三个判断条件。\n\n- 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况\n- 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况\n- 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况\n\n==<u>约定： 递增栈为头到底递增</u>==\n\n### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=739)\n\n难度中等1081收藏分享切换为英文接收动态反馈\n\n给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指在第 `i` 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n \n\n**示例 1:**\n\n```\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n**示例 2:**\n\n```\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n```\n\n**示例 3:**\n\n```\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n```\n\n#### [思路](https://programmercarl.com/0739.每日温度.html#思路)\n\n递增单调栈  （元素<=栈顶元素时 入栈）\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& nums) {\n        stack<int> stk;\n        int n = nums.size();\n        vector<int> ans(n);\n        for(int i = 0; i<n; i++){\n            //0特判\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            //元素<=栈顶元素时 入栈\n            if(nums[i]<=nums[stk.top()]){\n                stk.push(i);\n            }else{\n                while(!stk.empty() && nums[stk.top()]<nums[i]){\n                    int now = stk.top();\n                    stk.pop();\n                    ans[now] = (i - now);                    \n                }\n                stk.push(i); // 不要忘了入栈\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=496)\n\n难度简单676英文版讨论区\n\n`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。\n\n给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。\n\n对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。\n\n返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。\n\n \n\n**示例 1：**\n\n```\n输入：nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出：[-1,3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n**示例 2：**\n\n```\n输入：nums1 = [2,4], nums2 = [1,2,3,4].\n输出：[3,-1]\n解释：nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。\n```\n\n#### 思路\n\n1. 这道题虽然是简单题 但是难度比每日温度大\n2. 用一个哈希记录nums1，再对nums2使用单调栈\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size();\n        vector<int> ans(m, -1);\n        stack<int> stk;\n        unordered_map<int, int> mapp;\n        for(int i = 0; i<m; i++)\n            mapp[nums1[i]] = i;\n        int n = nums2.size();\n        for(int i = 0; i<n; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            if(nums2[stk.top()]>= nums2[i])\n                stk.push(i);\n            else{\n                while(!stk.empty() && nums2[stk.top()] < nums2[i]){\n                    int nowI = stk.top();\n                    //判断是否是nums1中的元素\n                    if(mapp.count(nums2[nowI])){\n                        int index = mapp[nums2[nowI]];\n                        ans[index] = nums2[i];\n                    }\n                    stk.pop();\n                }\n                stk.push(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=503)\n\n难度中等586英文版讨论区\n\n给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。\n\n数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,2,1]\n输出: [2,-1,2]\n解释: 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,2,3,4,3]\n输出: [2,3,4,-1,4]\n```\n\n#### 思路\n\n1. 再拼接一个数组 对二倍长度的数组进行统计 最后将结果resize为原大小\n2. 循环起来，遍历的时候遍历二倍大小 用%n来进行循环\n\n#### 代码\n\n##### 二倍数组拼接\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        n*=2;\n        vector<int> nums1(nums.begin(), nums.end());\n        nums.insert(nums.end(), nums1.begin(), nums1.end());\n        stack<int> stk;\n        vector<int> ans(n, -1);\n        for(int i = 0; i<n; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n\n            if(nums[stk.top()]>=nums[i]){\n                stk.push(i);\n            }else{\n                while(!stk.empty() && nums[stk.top()]<nums[i]){\n                    ans[stk.top()] = nums[i];\n                    stk.pop();\n                }\n                stk.push(i);\n            }\n        }\n        ans.resize(n/2);\n        return ans;\n    }\n};\n```\n\n##### 二倍循环%n\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        stack<int> stk;\n        vector<int> ans(n, -1);\n        for(int i = 0; i<n*2; i++){\n            if(stk.empty()){\n                stk.push(i);\n                continue;\n            }\n            while(!stk.empty() && nums[stk.top()]<nums[i%n]){\n                ans[stk.top()] = nums[i%n];\n                stk.pop();\n            }\n            stk.push(i%n);\n        }\n        return ans;\n    }\n};\n```\n\n### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=42)[思路](https://leetcode-cn.com/problems/trapping-rain-water/#)\n\n难度困难3289英文版讨论区\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/rainwatertrap.png)\n\n```\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n```\n\n**示例 2：**\n\n```\n输入：height = [4,2,0,3,2,5]\n输出：9\n```\n\n#### 思路\n\n1. On2暴力 \n2. dp 多次遍历 保存最值\n3. 最小栈\n\n#### 代码\n\n##### On2暴力\n\n```c++\n//暴力超时\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        for(int i = 0; i<n; i++){\n            if(i == 0 || i == n-1) continue;\n            int rHeight = height[i];\n            int lHeight = height[i];\n            for(int r = i+1; r<n; r++){\n                if(height[r]>rHeight) rHeight = height[r];\n            }\n            for(int l = i-1; l>=0; l--){\n                if(height[l]>lHeight) lHeight = height[l];\n            }\n            int h = min(lHeight, rHeight) - height[i];\n            if(h>0) sum+=h;\n        }\n        return sum;\n    }\n};\n```\n\n##### dp 多次遍历 保存最值\n\n```c++\n// dp解法\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        vector<int> leftH(n, 0);\n        vector<int> rightH(n, 0);\n        leftH[0] = height[0];\n        rightH[n-1] = height[n-1];\n        for(int i = 1; i<n; i++){\n            leftH[i] = max(height[i], leftH[i-1]);\n        }\n        for(int i = n-2; i>=0; i--){\n            rightH[i] = max(height[i], rightH[i+1]);\n        }\n        for(int i = 0; i<n; i++){\n            int h = min(leftH[i], rightH[i]) - height[i];\n            if(h>0) sum+=h;\n        }\n        return sum;\n    }\n};\n```\n\n##### 最小栈\n\n```c++\n//最小栈\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int sum = 0;\n        stack<int> stk;\n        stk.push(0);\n        for(int i = 1; i<n; i++){\n            if(height[i]<height[stk.top()])\n                stk.push(i);\n            else if(height[i] == height[stk.top()]){\n                stk.pop();\n                stk.push(i);\n            }else{\n                //每个坑坑洼洼的地方计算一次\n                while(!stk.empty() && height[i]>height[stk.top()]){\n                    int mid = stk.top();\n                    stk.pop();\n                    if(!stk.empty()){\n                        int h = min(height[stk.top()], height[i]) - height[mid];\n                        int w = i - stk.top() - 1;\n                        sum += h*w;\n                    }\n                }\n                stk.push(i);\n            }\n        }\n        return sum;\n    }\n};\n```\n\n### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n难度困难1849\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n \n\n**示例 1:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram.jpg)\n\n```\n输入：heights = [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/histogram-1.jpg)\n\n```\n输入： heights = [2,4]\n输出： 4\n```\n\n#### 思路\n\n1. 动态规划\n\n   本题动态规划的写法整体思路和[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)是一致的，但要比[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)难一些。难就难在本题要记录记录每个柱子 左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。所以需要循环查找，也就是下面在寻找的过程中使用了while\n\n2. 单调栈\n\n   本地单调栈的解法和接雨水的题目是遥相呼应的。\n\n   为什么这么说呢，[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n\n   **这里就涉及到了单调栈很重要的性质，就是单调栈里的顺序，是从小到大还是从大到小**。\n\n   在题解[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)中我讲解了接雨水的单调栈从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。\n\n   那么因为本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！\n\n   我来举一个例子，如图：\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20210223155303971.jpg\" alt=\"84.柱状图中最大的矩形\" style=\"zoom:50%;\" />\n\n   只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。\n\n   所以本题单调栈的顺序正好与接雨水反过来。\n\n   此时大家应该可以发现其实就是**栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度**\n\n   理解这一点，对单调栈就掌握的比较到位了。\n\n   除了栈内元素顺序和接雨水不同，剩下的逻辑就都差不多了，在题解[42. 接雨水 (opens new window)](https://programmercarl.com/0042.接雨水.html)我已经对单调栈的各个方面做了详细讲解，这里就不赘述了。\n\n   剩下就是分析清楚如下三种情况：\n\n   - 情况一：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况\n   - 情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况\n   - 情况三：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220331164646464.png\" alt=\"image-20220331164646464\" style=\"zoom: 67%;\" />\n\n#### 代码\n\n##### 动态规划\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        vector<int> minLeftIndex(heights.size());\n        vector<int> minRightIndex(heights.size());\n        int size = heights.size();\n\n        // 记录每个柱子 左边第一个小于该柱子的下标\n        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环\n        for (int i = 1; i < size; i++) {\n            int t = i - 1;\n            // 这里不是用if，而是不断向左寻找的过程\n            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];\n            minLeftIndex[i] = t;\n        }\n        // 记录每个柱子 右边第一个小于该柱子的下标\n        minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环\n        for (int i = size - 2; i >= 0; i--) {\n            int t = i + 1;\n            // 这里不是用if，而是不断向右寻找的过程\n            while (t < size && heights[t] >= heights[i]) t = minRightIndex[t];\n            minRightIndex[i] = t;\n        }\n        // 求和\n        int result = 0;\n        for (int i = 0; i < size; i++) {\n            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);\n            result = max(sum, result);\n        }\n        return result;\n    }\n};\n```\n\n##### 单调栈  略微背一下吧\n\n```c++\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<int> stk;\n        heights.insert(heights.begin(), 0);\n        heights.push_back(0);\n        stk.push(0);\n        int ans = 0;\n        for(int i = 1; i<heights.size(); i++){\n            if(heights[i]>heights[stk.top()])\n                stk.push(i);\n            else if(heights[i] == heights[stk.top()]){\n                stk.pop();\n                stk.push(i);\n            }else{\n                while(heights[i] < heights[stk.top()]){\n                    int mid = stk.top(); //当前矩形高的位置\n                    stk.pop();\n                    int left = stk.top();\n                    int right = i;  //记录当前值以计算宽\n                    int w = right - 1 - left;\n                    int h = heights[mid];\n                    //right - 1为右边界 i-1\n                    //left为左边界 当前栈顶index\n                    ans = max(ans, w*h);\n                }\n                stk.push(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"c++STL","url":"/2022/03/30/c-stl-duan/","content":"\n### 什么是C++ STL？\n\nC++ STL从广义来讲包括了三类：`算法`，`容器`和`迭代器`。\n\n- 算法包括排序，复制等常用算法，以及不同容器特定的算法。\n- 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。\n- 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。\n\n### 什么时候需要用hash_map，什么时候需要用map?\n\n总体来说，hash_map `查找速度`会比 map 快，而且查找速度基本和数据数据量大小无关，属于常数级别;而 map 的查找速度是 log(n) 级别。\n\n并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑 hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map 可能会让你陷入尴尬，特别是当你的 hash_map 对象特别多时，你就更无法控制了。而且 hash_map 的构造速度较慢。\n\n现在知道如何选择了吗？权衡三个因素: <u>查找速度, 数据量, 内存使用</u> 。\n\n> 查找速度快 hashmap  数据量大 对内存有要求用map\n\n### STL中hashtable的底层实现？\n\nSTL中的hashtable使用的是**开链法**解决hash冲突问题，如下图所示。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220328102101102.png\" alt=\"image-20220328102101102\" style=\"zoom:67%;\" />\n\nhashtable中的bucket（桶）所维护的list既不是list也不是slist，而是其自己定义的由<u>hashtable_node</u>数据结构组成的linked-list，而<u>bucket聚合体本身使用vector进行存储</u>。hashtable的迭代器只提供前进操作，不提供后退操作\n\n在hashtable设计bucket的数量上，其`内置了28个质数`[53, 97, 193,…,429496729]，<u>在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度）</u>，`其中每个bucket所维护的linked-list长度也等于hashtable的容量`==<u>(消耗内存)</u>==。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。\n\n### vector 底层原理及其相关面试题\n\n##### 1. vector的底层原理\n\n<u>vector底层是一个动态数组，包含三个迭代器，`start`和`finish`之间是已经被使用的空间范围，`end_ of_storage`是整块连续空间包括备用空间的尾部。</u>\n\n当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间【vector内存增长机制】。\n\n当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。\n\n因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/70.png\" alt=\"在这里插入图片描述\" style=\"zoom: 33%;\" />\n\n##### 2. vector中的reserve和resize的区别\n\n- reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。**reserve()只有一个参数。**\n\n- resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变（可能？）。resize()可以有多个参数。\n\n##### 3. vector中的size和capacity的区别\n\n- size表示当前vector中有多少个元素（finish – start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage – start）。\n\n##### 4. vector的元素类型可以是引用吗？\n\n- <u>vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用</u>。\n\n##### 5. vector迭代器失效的情况\n\n- <u>当插入一个元素到vector中，由于`引起了内存重新分配`，所以指向原内存的迭代器全部失效</u>。\n\n- 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it)\n\n  > `指向被删除元素的迭代器失效`\n\n##### 6. 正确释放vector的内存(clear(), swap(), shrink_to_fit())\n\nvec.clear()：清空内容，但是不释放内存。\n\n`vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。`\n\nvec.shrink_to_fit()：请求容器降低其capacity和size匹配。\n\n`vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。`\n\n##### 7. vector 扩容为什么要以1.5倍或者2倍扩容?\n\n根据查阅的资料显示，考虑可能产生的`堆空间浪费，成倍增长倍数不能太大`，使用较为广泛的扩容方式有两种，以2倍的方式扩容，或者以1.5倍的方式扩容。\n\n以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：\n\n![在这里插入图片描述](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20160915175318430.png)\n\n> 使用2倍（k=2）扩容机制扩容时，<u>每次扩容后的新内存大小必定大于前面的总和</u>。\n> 而<u>使用1.5倍（k=1.5)扩容时，在几次扩展以后，可以重用之前的内存空间了</u>。<u>==可以更好的实现对内存的重复利用==</u>。\n\n##### 8. vector的常用函数\n\n```c++\nvector<int> vec(10,100);        创建10个元素,每个元素值为100\nvec.resize(r,vector<int>(c,0)); 二维数组初始化\nreverse(vec.begin(),vec.end())  将元素翻转\nsort(vec.begin(),vec.end());    排序，默认升序排列\nvec.push_back(val);             尾部插入数字\nvec.size();                     向量大小\nfind(vec.begin(),vec.end(),1);  查找元素\niterator = vec.erase(iterator)  删除元素\n```\n\n### list 底层原理及其相关面试题\n\n##### 1. list的底层原理\n\nlist的底层是一个**双向链表**，以结点为单位存放数据，结点的地址在`内存中不一定连续`，每次插入或删除一个元素，就配置或释放一个元素空间。\n\n<u>list不支持随机存取，**适合需要大量的插入和删除**，而不关心随即存取的应用场景。</u>\n\n![在这里插入图片描述](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/format,png.png)\n\n##### 2. list的常用函数\n\nlist人称小vector 除了不能随机读取，几乎所有的vector函数都可以使用 还能`push_front`\n\n```c++\nlist.push_back(elem)    在尾部加入一个数据\nlist.pop_back()         删除尾部数据\nlist.push_front(elem)   在头部插入一个数据\nlist.pop_front()        删除头部数据\nlist.size()             返回容器中实际数据的个数\nlist.sort()             排序，默认由小到大 \nlist.unique()           移除数值相同的连续元素\nlist.back()             取尾部迭代器\nlist.erase(iterator)    删除一个元素，参数是迭代器，返回的是删除迭代器的下一个位置\n```\n\n### deque底层原理及其相关面试题\n\n##### 1. deque的底层原理\n\ndeque是一个双向开口的连续线性空间（**双端队列**），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。\n\n![img](https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/picture/1565876324016.png)\n\n##### 2. 什么情况下用vector，什么情况下用list，什么情况下用deque\n\nvector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，<u>适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。</u>\n\n<u>list不支持随机存储，适用于`对象大，对象数量变化频繁，插入和删除频繁`，比如`写多读少`的场景。</u>\n\n需要从首尾两端进行插入或删除操作的时候需要选择deque。\n\n##### 3. deque的常用函数\n\n```c++\ndeque.push_back(elem)   在尾部加入一个数据。\ndeque.pop_back()        删除尾部数据。\ndeque.push_front(elem)  在头部插入一个数据。\ndeque.pop_front()       删除头部数据。\ndeque.size()            返回容器中实际数据的个数。\ndeque.at(idx)           传回索引idx所指的数据，如果idx越界，抛出out_of_range。\n```\n\n### Vector如何释放空间?\n\n由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。`所有内存空间是在vector析构时候才能被系统回收`。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。\n\n`如果需要空间动态缩小`，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。\n\n> 动态缩小使用vector加shrink_to_fit 不可以吗？\n\n```C++\nvector(Vec).swap(Vec); //将Vec的内存清除；?????\nvector().swap(Vec); //清空Vec的内存；\n```\n\n### 如何在共享内存上使用STL标准库？\n\n#### 错误方法\n\n想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。\n\n我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。\n\n当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。\n\n<u>一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个`不可能完成`的任务</u>。例如下边进程A所做的事情：\n\n```c++\n//Attach to shared memory\nvoid* rp = (void*)shmat(shmId,NULL,0);\n//Construct the vector in shared\n//memory using placement new\nvector<int>* vpInA = new(rp) vector<int>*;\n//The vector is allocating internal data\n//from the heap in process A's address\n//space to hold the integer value\n(*vpInA)[0] = 22;\n```\n\n然后进程B希望从共享内存中取出数据：\n\n```c++\nvector<int>* vpInB =  (vector<int>*) shmat(shmId,NULL,0);\n\n//问题 - 向量包含\n//在进程A的地址中分配的指针和空间\n//在这里无效 \nint i = *(vpInB)[0];\n```\n\n#### [正确方法](http://blog.jqian.net/post/creating-stl-containers-in-shared-memory.html)\n\n进一步考察STL容器，我们发现它的模板定义中有第二个默认参数，也就是allocator 类，该类实际是一个内存分配模型。默认的allocator是从堆上分配内存（注：这就是STL容器的默认表现，我们甚至可以改造它从一个网络数据库中分配空间，保存数据）。下边是 vector 类的一部分定义：\n\n```c++\ntemplate<class T, class A = allocator<T> >\nclass vector\n{\n    //other stuff\n};\n```\n\n考虑如下声明：\n\n```c++\n//User supplied allocator myAlloc\nvector<int,myAlloc<int> > alocV;\n```\n\n假设 `myAlloc<int>` 从`共享内存上分配内存`，则 `alocV` 将完全在共享内存上被构造，所以进程A可以如下：\n\n```c++\n//Attach to shared memory\nvoid* rp = (void*)shmat(shmId,NULL,0);\n//Construct the vector in shared memory\n//using placement new\nvector<int>* vpInA =\n  new(rp) vector<int,myAlloc<int> >*;\n//The vector uses myAlloc<int> to allocate\n//memory for its internal data structure\n//from shared memory\n(*v)[0] = 22;\n```\n\n进程B可以如下读出数据：\n\n```c++\nvector<int>* vpInB = (vector<int,myAlloc<int> >*) shmat(shmId,NULL,0);\n\n//Okay since all of the vector is\n//in shared memory\nint i = *(vpInB)[0];\n```\n\n所有附着在共享内存上的进程都可以安全的使用该vector。在这个例子中，该类的所有内存都在共享内存上分配，同时可以被其他的进程访问。只要提供一个用户自定义的allocator，任何STL容器都可以安全的放置到共享内存上。\n\n> 有可用的`SharedAllocator`模板类 和 `Pool` 类完成共享内存的分配与回收。\n\n#### 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？\n\n一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。\n\n进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。\n\n### map插入方式有哪几种？\n\n1) 用insert函数插入pair数据，\n\n```cpp\nmapStudent.insert(pair<int, string>(1, \"student_one\")); \n```\n\n2) 用insert函数插入value_type数据\n\n```cpp\nmapStudent.insert(map<int, string>::value_type (1, \"student_one\"));\n```\n\n3) 在insert函数中使用make_pair()函数\n\n```cpp\nmapStudent.insert(make_pair(1, \"student_one\"));\n```\n\n4) 用数组方式插入数据    <u>key值已存在时是否会覆盖原value值</u> （insert重复插入 不会修改原始pair，直接视为无效）\n\n```cpp\nmapStudent[1] = \"student_one\";\n```\n\n### map 、set、multiset、multimap 底层原理及其相关面试题\n\n##### 1. map 、set、multiset、multimap的底层原理\n\nmap 、set、multiset、multimap的底层实现都是**红黑树**，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。\n\n![在这里插入图片描述](https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/picture/70.jpeg)\n\n红黑树的特性：\n\n> 1. 每个结点或是红色或是黑色；\n> 2. 根结点是黑色；\n> 3. 每个叶结点是黑的；\n> 4. 如果一个结点是红的，则它的两个儿子均是黑色；\n> 5. 每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。\n\n红黑树详解具体看这篇：[别再问我什么是红黑树了](https://www.iamshuaidi.com/?p=2061)\n\n对于STL里的map容器，count方法与find方法，都可以用来判断一个key是否出现，mp.count(key) > 0统计的是key出现的次数，因此只能为0/1，而mp.find(key) != mp.end()则表示key存在。\n\n##### 2. map 、set、multiset、multimap的特点\n\nset和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。\n\nmap和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（`因为红黑树也是二叉搜索树，所以map默认是按key排序的`），map中元素的key不允许重复，multimap可以重复。\n\nmap和set的增删改查速度为都是logn，是比较高效的。\n\n##### 3. 为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？\n\n因为存储的是结点，不需要内存拷贝和内存移动。\n\n因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。\n\n##### 4. 为何map和set不能像vector一样有个reserve函数来预分配数据?\n\n<u>因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。</u>也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。\n\n##### 5. map 、set、multiset、multimap的常用函数\n\n```c++\nit map.begin() 　 返回指向容器起始位置的迭代器（iterator）\nit map.end() 返回指向容器末尾位置的迭代器\nbool map.empty() 若容器为空，则返回true，否则false\nit map.find(k) 寻找键值为k的元素，并用返回其地址\nint map.size() 返回map中已存在元素的数量\nmap.insert({int,string}) 插入元素\t\n```\n\n### unordered_map、unordered_set 底层原理及其相关面试题\n\nunordered_map的底层是一个防冗余的哈希表（采用除留余数法）。`哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，时间复杂度为O(1)；而代价仅仅是消耗比较多的内存`。\n\n使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数（一般使用除留取余法），也叫做散列函数），使得每个元素的key都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照key为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。\n\n但是，不能够保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 一般可采用拉链法解决冲突\n\n```c++\nunordered_map.begin() 　　  返回指向容器起始位置的迭代器（iterator） \nunordered_map.end() 　　    返回指向容器末尾位置的迭代器 \nunordered_map.cbegin()　    返回指向容器起始位置的常迭代器（const_iterator） \nunordered_map.cend() 　　   返回指向容器末尾位置的常迭代器 \nunordered_map.size()  　　  返回有效元素个数 \nunordered_map.insert(key)  插入元素 \nunordered_map.find(key) 　 查找元素，返回迭代器\nunordered_map.count(key) 　返回匹配给定主键的元素的个数 \n```\n\n### 迭代器的底层机制和失效的问题\n\n##### 1. 迭代器的底层原理\n\n迭代器是连接容器和算法的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实现包含两个重要的部分：萃取技术和模板偏特化。\n\n<u>萃取技术（traits）可以进行类型推导</u>，根据不同类型可以执行不同的处理流程，比如容器是vector，那么traits必须推导出其迭代器类型为随机访问迭代器，而list则为双向迭代器。\n\n例如STL算法库中的distance函数，distance函数接受两个迭代器参数，然后计算他们两者之间的距离。显然对于不同的迭代器计算效率差别很大。比如对于vector容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而list容器是链式表，内存一般都不是连续分配，因此只能通过一级一级调用next()或其他函数，每调用一次再判断迭代器是否相等来计算距离。vector迭代器计算distance的效率为O(1),而list则为O(n),n为距离的大小。\n\n使用萃取技术（traits）进行类型推导的过程中会使用到模板偏特化。<u>模板偏特化可以用来推导参数</u>，如果我们自定义了多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于是个类型。\n\n```cpp\ntemplate <typename T>\nstruct TraitsHelper {\n     static const bool isPointer = false;\n};\ntemplate <typename T>\nstruct TraitsHelper<T*> {\n     static const bool isPointer = true;\n};\n\nif (TraitsHelper<T>::isPointer)\n     ...... // 可以得出当前类型int*为指针类型\nelse\n     ...... // 可以得出当前类型int非指针类型\n```\n\n###### 一个理解traits的例子\n\n```cpp\n// 需要在T为int类型时，Compute方法的参数为int，返回类型也为int，\n// 当T为float时，Compute方法的参数为float，返回类型为int\ntemplate <typename T>\nclass Test {\npublic:\n     TraitsHelper<T>::ret_type Compute(TraitsHelper<T>::par_type d);\nprivate:\n     T mData;\n};\n\ntemplate <typename T>\nstruct TraitsHelper {\n     typedef T ret_type;\n     typedef T par_type;\n};\n\n// 模板偏特化，处理int类型\ntemplate <>\nstruct TraitsHelper<int> {\n     typedef int ret_type;\n     typedef int par_type;\n};\n\n// 模板偏特化，处理float类型\ntemplate <>\nstruct TraitsHelper<float> {\n     typedef float ret_type;\n     typedef int par_type;\n};\n```\n\n当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同时，traits会是一种很好的解决方案。\n\n##### 2. 迭代器的种类\n\n1. 输入迭代器：是只读迭代器，在每个被遍历的位置上只能读取一次。例如上面find函数参数就是输入迭代器。\n\n2. 输出迭代器：是只写迭代器，在每个被遍历的位置上只能被写一次。\n3. 前向迭代器：兼具输入和输出迭代器的能力，但是它可以对同一个位置重复进行读和写。但它不支持operator–，所以只能向前移动。\n4. 双向迭代器：很像前向迭代器，只是它向后移动和向前移动同样容易。\n5. 随机访问迭代器：有双向迭代器的所有功能。而且，它还提供了“迭代器算术”，即在一步内可以向前或向后跳跃任意位置， 包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种Iterator的所有操作，并另外支持it + n、it – n、it += n、 it -= n、it1 – it2和it[n]等操作。\n\n##### 3. 迭代器失效的问题\n\n1. 插入操作\n\n   对于vector和string，如果`容器内存被重新分配`，iterators,pointers,references失效；如果没有重新分配，那么插入点之前的iterator有效，插入点之后的iterator失效；\n\n   对于deque，如果插入点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，deque的迭代器失效，但reference和pointers有效；\n\n   对于list和forward_list，所有的iterator,pointer和refercnce有效。\n\n2. 删除操作\n\n   对于vector和string，删除点之前的iterators,pointers,references有效；off-the-end迭代器总是失效的；\n\n   对于deque，如果删除点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，off-the-end失效，其他的iterators,pointers,references有效；\n\n   对于list和forward_list，所有的iterator,pointer和refercnce有效。\n\n   对于关联容器map来说，如果某一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为。\n\n### 为什么vector的插入操作可能会导致迭代器失效？\n\nvector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。\n\n### vector的reserve()和resize()方法之间有什么区别？\n\n首先，`vector`的容量`capacity()`是指在不分配更多内存的情况下可以保存的最多元素个数，而`vector`的大小`size()`是指实际包含的元素个数；\n\n其次，`vector`的`reserve(n)`方法只改变`vector`的容量，如果当前容量小于`n`，则重新分配内存空间，调整容量为`n`；如果当前容量大于等于`n`，则无操作；\n\n最后，`vector`的`resize(n)`方法改变`vector`的大小，如果当前容量小于`n`，则调整容量为`n`，同时将其全部元素填充为初始值；如果当前容量大于等于`n`，则不调整容量，只将其前`n`个元素填充为初始值。\n\n### 标准库中有哪些容器？分别有什么特点？\n\n标准库中的容器主要分为三类：顺序容器、关联容器、容器适配器。\n\n- 顺序容器包括五种类型：\n  - `array<T, N>`数组：固定大小数组，支持快速随机访问，但不能插入或删除元素；\n  - `vector<T>`动态数组：支持快速随机访问，尾位插入和删除的速度很快；\n  - `deque<T>`双向队列：支持快速随机访问，首尾位置插入和删除的速度很快；（可以看作是`vector`的增强版，与`vector`相比，可以快速地在首位插入和删除元素）\n  - `list<T>`双向链表：只支持双向顺序访问，任何位置插入和删除的速度都很快；\n  - `forward_list<T>`单向链表：只支持单向顺序访问，任何位置插入和删除的速度都很快。\n- 关联容器包含两种类型：\n  - map容器：\n  - `map<K, T>`关联数组：用于保存关键字-值对；\n  - `multimap<K, T>`：关键字可重复出现的`map`；\n  - `unordered_map<K, T>`：用哈希函数组织的`map`；\n  - `unordered_multimap<K, T>`：关键词可重复出现的`unordered_map`；\n  - set容器：\n  - `set<T>`：只保存关键字；\n  - `multiset<T>`：关键字可重复出现的`set`；\n  - `unordered_set<T>`：用哈希函数组织的`set`；\n  - `unordered_multiset<T>`：关键词可重复出现的`unordered_set`；\n- 容器适配器包含三种类型：\n  - `stack<T>`栈、`queue<T>`队列、`priority_queue<T>`优先队列。","tags":["面试"]},{"title":"项目问题","url":"/2022/03/26/xiang-mu-wen-ti/","content":"\n\n\n### 你的信号处理的软件的处理流程是什么样的\n\n微动处理系统主要是对采集到的原始信号进行分析，通过一系列算法运算，分析得到地下信息\n\n#### 1.原始信号的导入\n\n信号的原始信号是规范格式的二进制文件，seg2或者sac，首先读取文件头信息到结构体，例如几道信号，信号的起始时间，检波器的坐标和分量信息等，然后读取数据段内存\n\n#### 2.信号预处理\n\n采集到的原始信号经常是存在坏点的，需要对信号进行坏点筛除和有效信号的提取，用到了sta/lta算法，和阈值百分比的方法去筛选坏点，一般的算法运算都需要转到频域，因此还需要一个按频点分窗fft的过程\n\n#### 3.算法实现\n\n这主要设计一些地址算法的实现过程了，hv是水平垂直的功率谱比。 fk是频率波数域求解相速度， si的计算相干系数拟合到贝塞尔曲线去求解相速度。\n\n用到了多线程 qt::concurrent实现单个台站的线程， qt::concurrent::map实现单台站多频点的多线程实现\n\n#### 4.结果的导出与展示\n\n做一个结果的导出工作，然后基于qcustomplot对计算结果 例如频散曲线，概率分布极值点，做一个图像化的显示\n\n### QT的跨平台是如何实现的\n\n- 就像标准C库函数一样，`QT框架的函数在不同的平台调用该不同系统的api从而实现跨平台`\n\n- 针对每一种OS平台，QT都有一套对应的**底层类库**，而接口是完全一致的。因此只要是在QT库上开发的程序，放在任何一种平台下都可以编译运行（前提条件是：程序中没有使用某**OS**特有的机能，需要先在平台上安装qt）。也就是说在`OS和应用层之间，增加了一个平台层来保证可移植性。`\n\n- Qt跨平台是指 代码跨平台而不是编译出来的文件跨平台，`同一份代码需要放到另一个平台上时，需要重新编译`。\n\n  \n\n### [QT的信号槽是如何实现的](https://zhuanlan.zhihu.com/p/80539605)\n\n#### 使用\n\n1. 要使用信号-槽功能，先决条件是继承`QObject`类，并在类声明中增加`Q_OBJECT宏`。\n\n2. 之后在”signals:” 字段之后声明一些函数，这些函数就是信号。\n\n3. 在”public slots:” 之后声明的函数，就是槽函数。\n4. 信号-槽都准备好了，接下来创建两个对象实例，并使用QObject::connect将信号和槽连接起来。\n5. 最后使用emit发送信号，就会自动触发槽函数了。\n\n#### 实现\n\n<u>以Tom类 miao信号 jerry connect 为例</u>\n\n信号和槽的`本质都是函数`。\n\nC++中的函数要有声明(declare)，也要有实现(implement), 而`信号只要声明，不需要写实现。这是因为moc会为我们自动生成`。\n\n另外触发信号时，不写emit关键字，直接调用信号函数，也是没有问题的。这是因为`emit是一个空的宏`\n\n#####  **Q_OBJECT宏** \n\n在moc生成的cpp文件中 声明了一个只读的静态成员变量`staticMetaObject`，以及3个public的成员函数\n\n```cpp\n    static const QMetaObject staticMetaObject; \n\n    virtual const QMetaObject *metaObject() const; \n\n    virtual void *qt_metacast(const char *); \n\n    virtual int qt_metacall(QMetaObject::Call, int, void **);\n```\n\n还有一个private的静态成员函数`qt_static_metacall`\n\n```cpp\nstatic void qt_static_metacall(QObject *, QMetaObject::Call, int, void **)\n```\n\n生成的cpp文件中，就是变量staticMetaObject以及 那几个函数的实现。\n\n- staticMetaObject是一个结构体，用来存储Tom这个类的信号、槽等元信息，并把\n\n- qt_static_metacall静态函数作为函数指针存储起来。\n\n- 因为是`静态成员` （指`staticMetaObject`），所以实例化多少个Tom对象，它们的元信息都是一样的。\n\n- qt_static_metacall函数提供了两种“元调用的实现”：\n\n  > 如果是InvokeMetaMethod类型的调用，则直接 把参数中的QObject对象，\n  >\n  > 转换成Tom类然后调用其miao函数\n  >\n  > 如果是IndexOfMethod类型的调用，即获取元函数的索引号，则计算miao函数的偏移并返回。\n\n而moc_Tom.cpp末尾的  miao  就是信号函数的实现。\n\n```cpp\n// SIGNAL 0\nvoid Tom::miao()\n{\n    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);\n}\n```\n\n##### **信号的触发**\n\nmiao信号的实现，直接调用了QMetaObject::activate函数。其中0代表miao这个函数的索引号。\n\nQMetaObject::activate函数的实现，在Qt源码的QObject.cpp文件中，略微复杂一些，且不同版本的Qt，实现差异都比较大，\n\n这里总结一下大致的实现：\n\n`先找出与当前信号连接的所有对象-槽函数，再逐个处理`。\n\n这里处理的方式，分为三种：\n\n```cpp\nif((c->connectionType == Qt::AutoConnection && !receiverInSameThread)\n                || (c->connectionType == Qt::QueuedConnection)) {\n    // 队列处理\n} else if (c->connectionType == Qt::BlockingQueuedConnection) {\n    // 阻塞处理\n    // 如果同线程，打印潜在死锁。\n} else {\n    //直接调用槽函数或回调函数\n}\n```\n\nreceiverInSameThread表示当前线程id和接收信号的对象的所在线程id是否相等。\n\n> 如果信号-槽连接方式为QueuedConnection，不论是否在同一个线程，按队列处理。\n>\n> 如果信号-槽连接方式为Auto，且不在同一个线程，也按队列处理。\n>\n> 如果信号-槽连接方式为阻塞队列BlockingQueuedConnection，按阻塞处理。\n>\n> (注意同一个线程就不要按阻塞队列调用了。因为同一个线程，同时只能做一件事，本身就是阻塞的，直接调用就好了，\n>\n> 如果走阻塞队列，则多了加锁的过程。如果槽中又发了同样的信号，就会出现死锁：加锁之后还未解锁，又来申请加锁。)\n>\n> 队列处理，就是把槽函数的调用，转化成了QMetaCallEvent事件，通过QCoreApplication::postEvent放进了事件循环。\n>\n> 等到下一次事件分发，相应的线程才会去调用槽函数。\n\n\n\n### [Qt信号槽连接方式](https://blog.csdn.net/qq_33266987/article/details/79527495)\n\n##### signal/slot在底层会使用三种方式传递消息。参见QObject::connect()方法：\n\nbool QObject::connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoCompatConnection )\n最后一个参数是就是传递消息的方式了，有四个取值：\n\n**Qt::DirectConnection**\nWhen emitted, the signal is immediately delivered to the slot.\n假设当前有4个slot连接到QPushButton::clicked(bool)，当按钮被按下时，QT就把这4个slot按连接的时间顺序调用一遍。显然这种方式不能跨线程（传递消息）。\n\n**Qt::QueuedConnection**\nWhen emitted, the signal is queued until the event loop is able to deliver it to the slot.\n假设当前有4个slot连接到QPushButton::clicked(bool)，当按钮被按下时，QT就把这个signal包装成一个 QEvent，放到消息队列里。QApplication::exec()或者线程的QThread::exec()会从消息队列里取消息，然后调用 signal关联的几个slot。这种方式既可以在线程内传递消息，也可以跨线程传递消息。\n\n**Qt::BlockingQueuedConnection**\nSame as QueuedConnection, except that the current thread blocks until the slot has been delivered. This connection type should only be used for receivers in a different thread. Note that misuse of this type can lead to dead locks in your application.\n与Qt::QueuedConnection类似，但是会阻塞等到关联的slot都被执行。这里出现了阻塞这个词，说明它是专门用来多线程间传递消息的。\n\n**Qt::AutoConnection**\nIf the signal is emitted from the thread in which the receiving object lives, the slot is invoked directly, as with Qt::DirectConnection; otherwise the signal is queued, as with Qt::QueuedConnection.\n这种连接类型根据signal和slot是否在同一个线程里自动选择Qt::DirectConnection或Qt::QueuedConnection\n\n这样看来，第一种类型的效率肯定比第二种高，毕竟第二种方式需要将消息存储到队列，而且可能会涉及到大对象的复制（考虑sig_produced(BigObject bo)，bo需要复制到队列里）。\n\n\n\n### 讲述Qt信号槽机制与优势与不足\n\n优点：\n\n1. `类型安全`。需要关联的信号槽的签名必须是等同的。即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。  （`参数检查`）\n2. `松散耦合`。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。  （`只管发送 不管谁接受了`）\n3. `灵活性`。一个信号可以关联多个槽，或多个信号关联同一个槽。\n\n不足：\n\n- `速度较慢`。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数`慢10倍`。\n- 原因：\n  1. 需要定位接收信号的对象。  (`定位对象`)\n  2. 安全地遍历所有关联槽。 （`遍历槽`）\n  3. 编组、解组传递参数。     （`传参`）\n  4. 多线程的时候，信号需要排队等待。（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）   （`多线程需要排队`）\n\n### Qt信号和槽的本质是什么 \n\n- **回调函数。**\n  1. 信号是传递值，或是传递动作变化；\n  2. 槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。\n\n### 描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别\n\n1. 文件流(QTextStream)。操作`轻量级数据`（int,double,QString）数据写入文本件中以后以文本的方式呈现。\n2. 数据流(QDataStream)。通过数据流可以操作`各种数据类型`，`包括对象`，存储到文件中数据为二进制。\n\n文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。、\n\n> 数据流更加强大\n\n### 描述QT的TCP通讯流程\n\n#### 服务端：（QTcpServer）\n\n1. 创建QTcpServer对象\n2. 监听list需要的参数是地址和端口号\n3. 当有新的客户端连接成功回发送newConnect信号\n4. 在newConnection信号槽函数中，调用nextPendingConnection函数获取新连接QTcpSocket对象\n5. 连接QTcpSocket对象的readRead信号\n6. 在readRead信号的槽函数使用read接收数据\n7. 调用write成员函数发送数据\n\n```c++\nWidget::Widget(QWidget *parent) :\n    QWidget(parent),\n    ui(new Ui::Widget){\n    ui->setupUi(this);\n    tcpServer = new QTcpServer;\n    tcpServer->listen(QHostAddress(\"192.168.0.111\"),1234);\n    connect(tcpServer,SIGNAL(newConnection()),this,SLOT(new_connect()));\n}\n \nWidget::~Widget(){\n    delete ui;\n}\n \nvoid Widget::new_connect(){\n    qDebug(\"--new connect--\");\n    QTcpSocket* tcpSocket = tcpServer->nextPendingConnection();\n    connect(tcpSocket,SIGNAL(readyRead()),this,SLOT(read_data()));\n    socketArr.push_back(tcpSocket);\n}\n \nvoid Widget::read_data(){\n    for(int i=0; i<socketArr.size(); i++){\n        if(socketArr[i]->bytesAvailable()){\n            char buf[256] = {};\n            socketArr[i]->read(buf,sizeof(buf));\n            qDebug(\"---read:%s---\",buf);\n        }\n    }\n}\n```\n\n#### 客户端：（QTcpSocket）\n\n1. 创建QTcpSocket对象\n2. 当对象与Server连接成功时会发送connected 信号\n3. 调用成员函数`connectToHost`连接服务器，需要的参数是地址和端口号\n4. connected信号的槽函数开启发送数据\n5. 使用write发送数据，read接收数据\n\n```c++\nWidget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget){\n    ui->setupUi(this);\n    tcpSocket = new QTcpSocket;\n    connect(tcpSocket,SIGNAL(connected()),this,SLOT(connect_success()));\n    tcpSocket->connectToHost(\"172.20.10.3\",1234);\n}\n \nWidget::~Widget(){\n    delete ui;\n}\n \nvoid Widget::on_send_clicked(){\n    std::string msg = ui->msg->text().toStdString();\n    int ret = tcpSocket->write(msg.c_str(),msg.size()+1);\n    qDebug(\"--send:%d--\",ret);\n}\n \nvoid Widget::connect_success(){\n    ui->send->setEnabled(true);\n}\n```\n\n### 描述UDP 之 UdpSocket通讯\n\n> UDP（User Datagram Protocol即用户数据报协议）是一个轻量级的，不可靠的，面向数据报的无连接协议。在网络质量令人十分不满意的环境下，UDP协议数据包丢失严重。由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。所以QQ这种对保密要求并不太高的聊天程序就是使用的UDP协议。\n\n在Qt中提供了QUdpSocket 类来进行UDP数据报（datagrams）的发送和接收。Socket简单地说，就是一个IP地址加一个port端口  。\n\n流程：\n\n1. 创建QUdpSocket套接字对象 \n2. 如果需要接收数据，必须绑定端口 \n3. 发送数据用writeDatagram，接收数据用 readDatagram 。\n\n### 多线程使用使用方法\n\n方法一：\n\n1. 创建一个类从QThread类派生\n2. 在子线程类中重写 run 函数, 将处理操作写入该函数中 \n3. 在主线程中创建子线程对象, 启动子线程, 调用start()函数\n\n方法二：\n\n1. 将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数\n2. 在主线程中创建一QThread类对象 \n3. 在主线程中创建一个业务类对象 \n4. 将业务类对象移动到子线程中 \n5. 在主线程中启动子线程 \n6. 通过信号槽的方式, 执行业务类中的业务处理函数\n\n多线程使用注意事项: \n* 业务对象, 构造的时候不能指定父对象 \n* 子线程中不能处理ui窗口(ui相关的类) \n* 子线程中只能处理一些数据相关的操作, 不能涉及窗口\n\n### 多线程下，信号槽分别在什么线程中执行，如何控制\n\n可以通过`connect的第五个参数`进行控制信号槽执行时所在的线程\n\nconnect有几种连接方式，直接连接和队列连接、自动连接\n\n1. 直接连接（Qt::DirectConnection）：信号槽在信号发出者所在的线程中执行\n2. 队列连接 (Qt::QueuedConnection)：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行\n3. 自动连接  (Qt::AutoConnection)：多线程时为队列连接函数，单线程时为直接连接函数。\n\n### 事件机制：QT程序是事件驱动的，事件到处都可以遇到。能说说平时经常使用到哪些事件吗？\n\n常见的QT事件类型如下:\n\n1. 键盘事件: 按键按下和松开    \n2. 鼠标事件: 鼠标移动,鼠标按键的按下和松开\n3. 拖放事件: 用鼠标进行拖放    滚轮事件: 鼠标滚轮滚动\n4. 绘屏事件: 重绘屏幕的某些部分    定时事件: 定时器到时\n5. 焦点事件: 键盘焦点移动   进入和离开事件: 鼠标移入widget之内,或是移出\n6. 移动事件: widget的位置改变    大小改变事件: widget的大小改变\n7. 显示和隐藏事件: widget显示和隐藏    窗口事件: 窗口是否为当前窗口\n\n### **信号槽机制**：\n\n能说下你的理解吗？\n\n能用什么方法替代？槽函数可以是虚函数吗？\n\n答：回调函数。可以。\n\n### **信号槽同步与异步**：\n\n#### 信号槽是同步的还是异步的？分别如何实现？\n\n答：通常使用的connect，实际上最后一个参数使用的是Qt::AutoConnection类型：Qt支持6种连接方式，其中3中最主要:\n\n1. Qt::DirectConnection（直连方式）（信号与槽函数关系类似于函数调用，同步执行）\n\n   当信号发出后，相应的槽函数将立即被调用。emit语句后的代码将在所有槽函数执行完毕后被执行。\n\n2. Qt::QueuedConnection（排队方式）（此时信号被塞到信号队列里了，信号与槽函数关系类似于消息通信，异步执行）\n\n   当信号发出后，排队到信号队列中，需等到接收对象所属线程的事件循环取得控制权时才取得该信号，调用相应的槽函数。emit语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕。\n\n3. Qt::AutoConnection（自动方式）\n\n   Qt的默认连接方式，如果信号的发出和接收这个信号的对象同属一个线程，那个工作方式与直连方式相同；否则工作方式与排队方式相同。\n\n4. Qt::BlockingQueuedConnection(信号和槽必须在不同的线程中，否则就产生死锁)\n\n   这个是完全同步队列只有槽线程执行完成才会返回，否则发送线程也会一直等待，相当于是不同的线程可以同步起来执行。\n\n5. Qt::UniqueConnection\n\n   与默认工作方式相同，只是不能重复连接相同的信号和槽，因为如果重复连接就会导致一个信号发出，对应槽函数就会执行多次。\n\n6. Qt::AutoCompatConnection\n\n   是为了连接Qt4与Qt3的信号槽机制兼容方式，工作方式与Qt::AutoConnection一样。\n\n#### **如果这个参数不设置的话，默认表示的是那种方式呢？**\n\n没加的话与直连方式相同：当信号发出后，相应的槽函数将立即被调用。emit语句后的代码将在所有槽函数执行完毕后被执行。在这个线程内是顺序执行、同步的，但是与其它线程之间肯定是异步的了。如果使用多线程，仍然需要手动同步。\n\n### **知道QT事件机制有几种级别的事件过滤吗？能大致描述下吗？**\n\n答：根据对Qt事件机制的分析, 我们可以得到5种级别的事件过滤,处理办法. 以功能从弱到强, 排列如下:\n\n1. `重载特定事件处理函数`.\n\n   最常见的事件处理办法就是重载象mousePressEvent(), keyPressEvent(), paintEvent() 这样的特定事件处理函数.\n\n2. 重载`event()函数`.\n\n   通过重载event()函数,我们可以在事件被特定的事件处理函数处理之前(象keyPressEvent())处理它. 比如, 当我们想改变tab键的默认动作时,一般要重载这个函数. 在处理一些不常见的事件(比如:LayoutDirectionChange)时,evnet()也很有用,因为这些函数没有相应的特定事件处理函数. 当我们重载event()函数时, 需要调用父类的event()函数来处理我们不需要处理或是不清楚如何处理的事件.\n\n3. 在Qt对象上安装`事件过滤器`.\n\n   安装事件过滤器有两个步骤: (假设要用A来监视过滤B的事件)\n\n   1. 首先调用B的installEventFilter( const QOject *obj ), 以A的指针作为参数. 这样所有发往B的事件都将先由A的eventFilter()处理.\n\n   2. 然后, A要重载QObject::eventFilter()函数, 在eventFilter() 中书写对事件进行处理的代码.\n\n4. `给QAppliction对象安装事件过滤器`\n\n   一旦我们给qApp(每个程序中唯一的QApplication对象)装上过滤器,那么所有的事件在发往任何其他的过滤器时,都要先经过当前这个 eventFilter(). 在debug的时候,这个办法就非常有用, 也常常被用来处理失效了的widget的鼠标事件,通常这些事件会被QApplication::notify()丢掉. ( 在QApplication::notify() 中, 是先调用qApp的过滤器, 再对事件进行分析, 以决定是否合并或丢弃)\n\n5. 继承QApplication类,并重载`notify()`函数.\n\n   Qt 是用QApplication::notify()函数来分发事件的.想要在任何事件过滤器查看任何事件之前先得到这些事件,重载这个函数是唯一的办法. 通常来说事件过滤器更好用一些, 因为不需要去继承QApplication类. 而且可以给QApplication对象安装任意个数的事件。","tags":["面试"],"categories":["基础知识"]},{"title":"leetcode常用库函数","url":"/2022/03/24/c-leetcode-chang-yong-ku-han-shu/","content":"\n# c++ leetcode 常用库函数\n\n## 1. \n\n## 2. 字符(串)相关\n\n1. 判断字符是否为数字、字母\n\n   ```c++\n   isalpha(char c)//判断是否为字母\n   isdigit(char c)//判断是否为数字\n   isalnum(char c)//判断是否为数字或字母\n   ```\n\n2. 字母的大小写转换\n\n   ```c++\n   tolower(char c)//变成小写字母\n   toupper(char c)//变成大写字母\n   ```\n\n3. 字符串转整型 stoi:\n\n   stoi(s,start,base)//s是要转换的字符串，start是起始位置，base是要转换的整数进制，默认是从0位置开始，转换为10进制\n\n   ```c++\n   int main() {\n   \tstring str = \"123\";\n   \tint res = stoi(str);\n   \tcout << res << endl;\n   \tsystem(\"pause\");\n   \treturn 0;\n   \t}\n   ```\n\n4. 数值转字符串 to_string\n\n   to_string(val)//val可以是任何数值类型\n\n   ```c++\n   int main() {\n   \tint num = 123;\n   \tstring res = to_string(num);\n   \tcout << res << endl;\n   \tsystem(\"pause\");\n   \treturn 0;\n   }\n   ```\n\n   \n\n5. 分割字符串 分割字符串可以使用getline和istringstream联合实现。\n\n   ```c++\n   //根据','号分割字符串，getline默认的是按照行读取，但是指定就按照给定的标志分割。\n   int main() {\n   \tstring str = \"1,2,3,4,5\";\n   \tistringstream s_in(str);\n   \tstring c;\n   \twhile (getline(s_in, c, ',')) {\n   \t\tcout << c << endl;\n   \t}\n   \tsystem(\"pause\");\n   \treturn 0;\n   }\n   ```\n\n## 3. 有序查找\n\n1. lower_bound()  大于等于\n   用于在指定区域内(左闭右开)查找**不小于目标值的第一个元素**，也就是说最终查找的不一定是和目标值想等的元素，也可能是比目标值大的元素。其底层实现是二分查找。\n\n   ```c++\n   int main() {\n   \tvector<int>nums{ 1,2,3,5,5 };\n   \tauto it1 = lower_bound(nums.begin(), nums.end(), 3);\n   \tcout << *it1<< endl;  //3\n   \tauto it2 = lower_bound(nums.begin(), nums.end(), 4);\n   \tcout << *it2 << endl; //5\n   \tsystem(\"pause\");\n   \treturn 0;\n   }\n   ```\n\n   注意：lower_bound查找超范围的判断\n\n   ```c++\n     vector<int> v{0, 1, 2, 3, 4};\n     auto it = lower_bound(v.begin(), v.end(), 6);\n     int pos = it - v.begin(); // pos = 5 返回的就是查找区间的大小\n     if (pos == v.size())\n       cout << \"超范围了。。。查找的元素比所有元素都大\" << endl;\n   \tif(it == v.end())\n       cout << \"超范围了。。。查找的元素比所有元素都大\" << endl;\n   ```\n   \n   起始也没有这么麻烦 没找到的话返回的迭代器就是end()\n   \n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419164310609.png\" alt=\"image-20220419164310609\" style=\"zoom: 80%;\" />\n   \n2. upper_bound() 大于\n   在指定目标区域中查找**大于目标值的第一个元素**，返回该元素所在位置的迭代器。\n\n   ```c++\n   int main() {\n   \tvector<int>nums{ 1,2,3,5,5 };\n   \tauto it1 = upper_bound(nums.begin(), nums.end(), 3);\n   \tcout << it1-nums.begin()<< endl;  //3\n   \tauto it2 = upper_bound(nums.begin(), nums.end(), 4);\n   \tcout << it2-nums.begin() << endl;  //3\n   \tsystem(\"pause\");\n   \treturn 0;\n   }\n   ```\n\n\n这两个函数如果找不到 例如 查找6 `it-nums.begin() == nums.size();`\n\n","tags":["面试"]},{"title":"指针数组赋值越界引发的bug","url":"/2022/03/16/zhi-zhen-shu-zu-fu-zhi-yue-jie-yin-fa-de-bug/","content":"\n## 指针数组赋值越界引发的bug\n\n### 问题描述\n\n- 项目中写了这么一段代码，整段代码在while循环中循环读取数据\n\n```c++\n    if (!GetAveData(strFilePath, m_ppHVFreq[i], m_ppHV[i], m_pnHVSize[i]))  //读取hv数据\n      return FALSE;\n\n    nSize = m_pnHVSize[i];  //nSize为300\n    m_ppdHVFreqLog[i] = new double[nSize];\n\n    for (int m = 0; m < nSize; m++) {\n      m_ppdHVFreqLog[i][m] = log(m_ppHVFreq[i][m]);\n      allHvFreMax =\n          allHvFreMax > m_ppHVFreq[i][m] ? allHvFreMax : m_ppHVFreq[i][m];\n    }\n\n    //读取spec数据\n    if (!ReadSpecFile(m_arrDataFiles[i], m_ppdSpecFreq[i], m_ppdSpecV[i],\n                      m_pnSpecSize[i]))\n      return FALSE;\n\n    //保存spec 的 log frequency\n    int nnSize = m_pnSpecSize[i];\n\t//命名不规范，调试两行泪\n    m_ppdSpecFreqLog[i] = new double[nSize]; // 100 hv 300 spec\n\n    for (int m = 0; m < nnSize; m++) {\n      m_ppdSpecFreqLog[i][m] = log(m_ppdSpecFreq[i][m]);\n    }\n```\n\n- 在代码的第21行`m_ppdSpecFreqLog[i] = new double[nSize]; // 100 hv 300 spec`，这段代码中想着用nnSize(300)开辟，结果开辟成了nSize(100)大小，导致在后续的处理中，对数组进行了越界的赋值\n\n```c++\n    m_ppdSpecFreqLog[i] = new double[nSize]; // 100 hv 300 spec\n\n    for (int m = 0; m < nnSize; m++) {\n      m_ppdSpecFreqLog[i][m] = log(m_ppdSpecFreq[i][m]);\n    }\n```\n\n- 开辟了一百的大小却赋了300的值，这样的直接后果就是后面用new开辟指针数组 ==疯狂中断== 报访问异常，难以定位，难以排查\n\n  ![image-20220316192700569.png](https://github.com/qianxunslimg/cloudimg/blob/main/img/image-20220316192700569.png?raw=true)\n\n### 教训\n\n1. 命名不规范，调试两行泪\n2. 认真认真认真\n3. new出错，优先查找这个bug","tags":["开发随笔"]},{"title":"计算机网络面试","url":"/2022/03/16/ji-suan-ji-wang-luo-ba-gu/","content":"\n# 1. OSI模型和协议\n\n### 1.1 OSI七层模型及其包含的协议如下:\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-2d62ba265be486cb94ab531912aa3b9c_r.jpg)\n\n1.  物理层: `底层数据传输`，如网线；网卡标准，通过媒介传输比特,确定机械及电气规范,传输单位为`bit`，<u>01模数和数模转换 物理设备的标准和比特流的收发</u>      ==<u>比特流传输</u>==\n\n   主要包括的协议为：IEE802.3 CLOCK RJ45\n\n2. 数据链路层: `定义数据的基本格式，如何传输，如何标识`；如网卡MAC地址提供介质访问和链路管理，使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测，将比特组装成帧和点到点的传递,传输单位为`帧`,     ==<u>控制物理层和网络成之间通信</u>==\n\n   主要包括的协议为MAC VLAN PPP\n\n3. 网络层：`定义IP编址，定义路由功能；如不同设备的数据转发`，IP选址和路由选择，负责数据包从源到宿的传递和网际互连，传输单位为包或分组（`IP数据报`）,         ==<u>IP寻址和路由选择</u>==\n\n   > `进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择`\n\n   主要包括的协议为IP ARP ICMP\n\n4. 传输层：端到端传输数据的基本功能；提供端到端的可靠报文传递和错误恢复，传输单位为报文段（TCP）或用户数据报（UDP）  `段`，         ==<u>建立维护管理 端到端连接</u>==\n\n   > `建立 管理和维护 端到端的连接`          端口\n\n   主要包括的协议为TCP UDP\n\n5. 会话层：`控制应用程序之间会话能力；如不同软件数据分发给不同软件`，建立、管理和终止会话，传输单位为SPDU，  ==<u>建立维护管理 会话连接</u>==\n\n   主要包括的协议为RPC NFS\n\n6. 表示层:  `数据格式标识，基本压缩加密功能`；对数据进行翻译、加密和压缩,传输单位为PPDU，  ==<u>数据格式化 加解密</u>==\n\n   主要包括的协议为HTML ASCII\n\n7. 应用层:  `各种应用软件，包括 Web 应用，`为计算机用户提供应用接口，也为用户直接提供各种网络服务,   ==<u>为应用程序提供网络服务</u>==\n\n   传输单位为APDU，主要包括的协议为FTP HTTP DNS\n\n说明：\n\n- 在四层，既传输层数据被称作**段**（Segments）；\n- 三层网络层数据被称做**包**（Packages）；\n- 二层数据链路层时数据被称为**帧**（Frames）；\n- 一层物理层时数据被称为**比特流**（Bits）。\n\n##### [总结](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=总结)\n\n- 网络七层模型是一个标准，而非实现。\n- 网络四层模型是一个实现的应用模型。\n- 网络四层模型由七层模型简化合并而来。\n\n \n\n### TCP/IP 4层模型包括：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321112333895.png\" alt=\"image-20220321112333895\" style=\"zoom:80%;\" />\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-986e619269f3442d7df5896638512a2a_r.jpg)\n\n1. 网络访问层 - 网络访问层（或链路层）负责将TCP / IP`数据包放在网络介质`上，并从网络介质上接收TCP / IP数据包。 TCP / IP被设计为独立于网络访问方法，帧格式和介质。换句话说，它独立于任何特定的网络技术。这样，TCP / IP可以用于连接不同的网络类型，例如以太网，令牌环，X.25，帧中继和异步传输模式（ATM）。　 ==<u>以太网协议</u>==\n\n   > （这里只写了数据链路层）\n   >\n   > 将源自网络层来的数据可靠地传输到相邻节点的目标机网络层\n   >\n   > 该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。\n\n   有关数据链路层的重要知识点：\n\n   1. 数据链路层为网络层提供可靠的数据传输；\n   2. 基本数据单位为帧；\n   3.  主要的协议：`以太网协议`；\n   4.  两个重要设备名称：网桥和交换机。\n\n2. 网络层:<u>==IP  ICMP IGMP==</u>  ==<u>ARP RARP</u>== \n\n   网络层 - 网络层负责主机寻址，打包和路由功能。 网络层的核心协议是==IP==，地址解析协议（==ARP==），Internet控制消息协议（==ICMP==）和Internet组管理协议（==IGMP==）。 \n\n   > IP是可路由协议，负责`IP寻址`，`路由`以及`数据包的分段和重组`。 \n   >\n   > ARP负责`发现网络访问层地址`，例如与给定Internet层访问关联的`硬件地址`。\n   >\n   > 由于IP数据包传递失败，ICMP负责`提供诊断功能并报告错误`。 \n   >\n   > IGMP负责`IP多播组的管理`。 IP在此层中将标头添加到数据包中，称为IP地址。现在既有IPv4（32位）地址又有IPv6（128位）地址。\n\n   <u>网络层的`目的`是实现两个`主机`系统之间的`数据`透明`传送`，具体功能包括`寻址`和`路由选择`、`连接的建立、保持和终止`等。</u>\n\n   1. 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；\n   2. 传输单位为包或分组（IP数据报）\n   3. 重要的设备：路由器。\n\n3. 传输层:==TCP UDP==\n\n   向两台主机中`进程之间`的通信提供通用的`数据传输`服务。\n\n   网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。\n\n   有关传输层的重点：\n\n   1. 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；\n   2. 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；\n\n   3. 重要设备：网关。\n\n4. 应用层:HTTP DNS SMTP\n\n   通过应用进程间的交互来完成特定的网络应用。应用层协议是`应用`进程间`通信和交互的规则`。是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。传输单位为报文。\n\n   > rtt：报文段往返时间\n   >\n   > msl:报文段最大生存时间\n   >\n   > TTL：(IP包中的Time To Live，生存周期)\n\n### 1.2 网络通信的过程 `封装和分用`\n\n![image-20220321124746981](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321124746981.png)\n\n# 2. 传输层\n\n### [端口有效范围是多少到多少？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=32、端口有效范围是多少到多少？)\n\n`0-1023为知名端口号`，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）\n\n`UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535`。<u>动态端口的范围是从1024到65535</u>\n\n\n\n端口号用来`标识进程的唯一性`，一个进程不能占用多个端口号 \n\n其实端口就是一段缓冲区(读写缓冲区)，端口号就是唯一标识。\n\n\n\n\n\n\n\n### [为何需要把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=33、为何需要把-tcpip-协议栈分成-5-层（或7层）？开放式回答。)\n\n答：ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。\n\n`分层的好处：`\n\n> ①隔层之间是`独立`的\n>\n> ②`灵活`性好\n>\n> ③`结构`上可以`分隔`开\n>\n> ④易于`实现和维护`\n>\n> ⑤能促进`标准化`工作。\n\n## TCP可靠性保证\n\n序列号、确认应答、超时重传、拥塞控制 滑动窗口？\n\n### TCP保证可靠性：\n\n1. **序列号、确认应答、超时重传**\n\n   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。\n\n   这个时间一般是2*RTT(报文段往返时间）+一个偏差值。 ？\n\n   > - 当超时时间 **RTO 较大**时，重发就`慢`，丢了老半天才重发，没有效率，性能差；\n   > - 当超时时间 **RTO 较小**时，会导致`可能并没有丢就重发`，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n   >\n   > 根据上述的两种情况，我们可以得知，`超时重传时间 RTO 的值应该略大于报文往返 RTT 的值`。\n   >\n   > **每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**   由此引出快重传来解决超时时间可能过长的问题\n\n   \n\n2. **窗口控制与高速重发控制/快速重传（重复确认应答）**\n\n   TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值<u>==（一次发送多个段）==</u>。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。\n\n   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......\n\n3. **拥塞控制**\n\n   如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。\n\n   （这里的窗口大小为了方便以报文为单位，实际窗口是以字节为单位）\n\n   > **慢启动**：定义拥塞窗口，一开始将该窗口大小设为1，之后每经过一个传输轮次（经过一个rtt），将拥塞窗口大小*2。（每收到一个确认窗口加1）  <u>==（指数增长）==</u>\n   >\n   > **拥塞避免**：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每经过一个传输轮次/每个rtt，拥塞窗口大小<u>==+1==</u>），以此来避免拥塞。\n   >\n   > 将报文段的超时重传看做拥塞，则<u>一旦发生超时重传</u>，我们需要<u>先将阈值设为当前窗口大小的一半</u>，并且<u>将窗口大小设为初值1</u>，然后重新进入慢启动过程。\n   >\n   > **快速重传**：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。\n   >\n   > 然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3（3次重复确认应答，代表有3个报文结束传输）的大小。（可以+3可以不加）\n   >\n   > 这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。\n\n## [`👍TCP 重传，滑动窗口，流量控制`](https://zhuanlan.zhihu.com/p/133307545)\n\n### **重传机制**\n\nTCP 实现可靠传输的方式之一，是通过`序列号`与`确认应答`。\n\nTCP 针对数据包丢失的情况，会用**重传机制**解决。\n\n> 常见的重传机制：\n>\n> - 超时重传\n> - 快速重传\n> - SACK\n> - D-SACK\n\nTCP 会在以下两种情况发生`超时重传`：\n\n> - 数据包丢失\n> - 确认应答丢失\n\n`RTT`（Round-Trip Time 往返时延）：就是**数据从网络一端传送到另一端所需的时间**，也就是包的往返时间。\n\n超时重传时间是以 `RTO` （Retransmission Timeout 超时重传时间）表示\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-476d9da0b8e5f8209280c25efe217341_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n> - 当超时时间 **RTO 较大**时，`重发就慢`，丢了老半天才重发，没有效率，性能差；\n> - 当超时时间 **RTO 较小**时，会导致`可能并没有丢就重发`，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。\n\n超时重传时间 `RTO `的值应该`略大于`报文往返 `RTT` 的值。\n\n如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**\n\n也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**超时触发重传存在的问题是，超时周期可能相对较长。于是就可以用「快速重传」机制来解决超时重发的时间等待。\n\n### **快速重传**\n\n**不以时间为驱动，而是以数据驱动重传**。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-0434a2de30645ee6d809bb30f0ad551c_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n> - 第一份 Seq1 先送到了，于是就 Ack 回 2；\n> - 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；\n> - 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；\n> - **发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。**\n> - 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。\n\n所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。\n\n快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传之前的一个，还是重传所有的问题。**\n\n比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。\n\n> 就是没法偷懒 只重传Seq2  因为不知道后面的是 3 4 5 6 7 8 9中的那几个回复的，这几个是不是也有丢失，这几个是不是也需要重传\n\n### **SACK 方法**\n\n在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。\n\n### **Duplicate SACK**\n\nDuplicate SACK 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**\n\n### `滑动窗口`\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-d388476be4c044b1f0c055ad1b61d543_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n如果不使用滑动窗口就是上述情况 我发给你 你回复我 我收到你的ack之后 才能继续发送下一个\n\n缺点：数据包的`往返时间越长`，`通信的效率就越低`\n\n==<u>窗口</u>==：有了窗口，就可以指定窗口大小，窗口大小就是指`无需等待确认应答`，而可以`继续发送数据的最大值`。\n\n假设<u>窗口大小为 `3` 个 TCP 段</u>，那么发送方就可以「连续发送」 `3` 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-719ef8746c5e323e13f7e28ca8709b81_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**。\n\n#### 窗口大小由哪一方决定？\n\nTCP 头里有一个字段叫 `Window`，也就是窗口大小。\n\n这个字段是接收端`告诉发送端自己还有多少缓冲区可以接收数据`。于是发送端就可以`根据这个接收端的处理能力来发送数据`，而不会导致接收端处理不过来。\n\n所以，通常窗口的大小是由接收方的窗口大小来决定的。\n\n发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。\n\n####  发送方的滑动窗口\n\n我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-dab1fd117460ca012080fdb52a99f847_r.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n- \\#1 是已发送并收到 ACK确认的数据：1~31 字节\n- \\#2 是已发送但未收到 ACK确认的数据：32~45 字节\n- \\#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节\n- \\#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后\n\n在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-d486cc3872e9873ab2a646cd6908f739_r.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n在下图，当收到之前发送的数据 `32~36` 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则**滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认**，接下来 `52~56` 字节又变成了可用窗口，那么后续也就可以发送 `52~56` 这 5 个字节的数据了。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-609be3306d058eafc9a45c89adb21840_r.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n#### 接收方的滑动窗口\n\n接收窗口相对简单一些，根据处理的情况划分成三个部分：\n\n- \\#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；\n- \\#3 是未收到数据但可以接收的数据；\n- \\#4 未收到数据并不可以接收的数据；\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-3b0296641ead6800c3d3cf4fe3435a32_r.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n#### 接收窗口和发送窗口的大小是相等的吗？\n\n并不是完全相等，接收窗口的大小是**约等于**发送窗口的大小的。\n\n因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。\n\n### **流量控制**\n\n#### 什么是流量控制？流量控制的目的？\n\n如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。\n\n#### 如何实现流量控制？\n\n由`滑动窗口协议`（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。\n\n#### 注意的点\n\n如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。  （`发送方数据发多了 但是接收方没有足够的缓冲区接收 导致数据丢丢失`）\n\n**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**\n\n### **窗口关闭**\n\nTCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。\n\n**如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。**\n\n> 窗口为0是因为 数据处理过慢，缓冲区满了\n\n####  窗口关闭潜在的危险\n\n接收方向发送方通告窗口大小时，是通过 `ACK` 报文来通告的。\n\n那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。\n\n> 风险在于 我缓冲区有空闲了，想要发送方发送数据 `但是窗口非0的报文丢失了 造成了死锁`\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-4faa850ffa1ba88022f59e1c9c18927a_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n这会导致`发送方`一直`等待`接收方的`非 0 窗口通知`，`接收方`也一直`等待发送方的数据`，如不采取措施，这种相互等待的过程，会造成了`死锁`的现象。\n\n#### TCP 是如何解决窗口关闭时，潜在的死锁现象呢？\n\nTCP 为每个连接设有一个持续定时器，`只要` TCP 连接一方收`到对方的零窗口通知`，就`启动持续计时器`。\n\n如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-9b86a4ec3fe7718d2bc474c89998c1b8_r.jpg\" alt=\"img\" style=\"zoom:67%;\" />\n\n- 如果接收窗口仍然为 0，那么收到这个报文的一方就会`重新启动`持续计时器；\n- 如果接收窗口不是 0，那么死锁的局面就可以被打破了。\n\n窗口探测的`次数一般为 3 次`，每次大约 30-60 秒（不同的实现可能会不一样）。<u>如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接。</u>\n\n\n\n### **糊涂窗口综合症**\n\n如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。\n\n到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。\n\n要知道，<u>我们的 `TCP + IP` 头有 `40` 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</u>\n\n就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。\n\n糊涂窗口综合症的现象是可以发生在发送方和接收方：\n\n- `接收方可以通告一个小的窗口`\n- 而`发送方可以发送小数据`\n\n于是，要解决糊涂窗口综合症，就==<u>解决上面两个问题</u>==就可以了\n\n- `让接收方不通告小窗口给发送方`\n- `让发送方避免发送小数据`\n\n#### 怎么让接收方不通告小窗口呢？\n\n接收方通常的策略如下:\n\n当「窗口大小」小于 `min( MSS，缓存空间/2 )` ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。\n\n等到接收方处理了一些数据后，窗口大小 >= MSS，或者`接收方缓存空间有一半可以使用`，就可以把窗口打开让发送方发送数据过来。\n\n#### 怎么让发送方避免发送小数据呢？\n\n发送方通常的策略:\n\n使用 `Nagle 算法`，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：\n\n- 要等到窗口大小 >= `MSS` 或是 数据大小 >= `MSS`\n- 收到之前发送数据的 `ack` 回包     <u>？那岂不是滑动窗口没意义了 又变回了`发->收到ack->发`？</u>\n\n只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。\n\n另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。\n\n可以在 Socket 设置 `TCP_NODELAY` 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）\n\n```text\nsetsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&value, sizeof(int));\n```\n\n### **拥塞控制** 略\n\n### **慢启动** 略\n\n### **拥塞避免算法** 略\n\n### **快速恢复** 略\n\n## [TCP中的流量控制和拥塞控制](https://zhuanlan.zhihu.com/p/37379780)\n\n**拥塞控制：**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。<u>拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素</u>。\n\n**流量控制：**指`点对点`通信量，是`端到端`中的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收 \n\n发送窗口的大小等于Min[拥塞窗口，接收窗口]，因此是两种控制共同作用。\n\n### 流量控制\n\n#### 什么是流量控制？流量控制的目的？\n\n如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。\n\n#### 如何实现流量控制？\n\n由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 `ACK 中会包含自己的接收窗口的大小`，并且利用大小来`控制发送方的数据发送`。\n\n#### 流量控制引发的死锁？怎么避免死锁的发生？\n\n- 当发送者收到了一个==窗口为0的应答==，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。\n- <u>为了避免流量控制引发的死锁，TCP使用了`持续计时器`。</u>每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。\n\n### 拥塞控制和流量控制的区别 \n\n拥塞控制：拥塞控制是作用于`网络`的，<u>它是防止过多的数据注入到网络中，避免出现网络负载过大的情况</u>；\n\n常用的方法就是：（ 1 ）<u>慢开始、拥塞避免</u>（ 2 ）<u>快重传、快恢复</u>。\n\n流量控制：流量控制是作用于`接收者`的，<u>它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的</u>。\n\n> 作用者不同 所以目的不同\n>\n> 拥塞：作用在==<u>整个网络</u>==，目的是==<u>防止网络拥塞</u>==\n>\n> 流量：作用在==<u>接收者</u>==，目的是保证接收者能够接收的过来，<u>==防止分组丢失==</u>\n\n## `拥塞控制`\n\n我们在开始假定：1、数据是单方向传递，另一个窗口只发送确认；2、接收方的缓存足够大，因此发送方的大小的大小由网络的拥塞程度来决定。\n\n#### （一）慢开始算法：\n\n发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。\n\n慢开始算法的思路就是，不要一开始就发送大量的数据，先`探测`一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。\n\n这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。如下图：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-54715533f093170d50f1ff1be39006e9_r.jpg)\n\n\n\n从上图可以看到，一个传输轮次所经历的时间其实就是往返时间RTT，而且没经过一个传输轮次（transmission round），拥塞窗口cwnd就加倍。\n\n为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：\n\n- 当cwnd<ssthresh时，使用慢开始算法。\n- 当cwnd>ssthresh时，改用拥塞避免算法。\n- 当cwnd=ssthresh时，慢开始与拥塞避免算法任意\n\n注意，这里的“`慢`”并不是指cwnd的增长速率慢，而是`指在TCP开始发送报文段时先设置cwnd=1`，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。\n\n#### （二）拥塞避免算法：\n\n拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口<u>cwnd加`1`</u>，而不是加倍。这样拥塞窗口按线性规律缓慢增长。\n\n无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的`目的`就是要<u>迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕</u>。\n\n整个拥塞控制的流程如下图：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-f7db63b1f00cbd8170e1435616e06216_r.jpg)\n\n\n\n1. 拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16\n2. 执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长\n3. 假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法\n\n关于 `乘法减小`（Multiplicative Decrease）和`加法增大`（Additive Increase）：\n\n- “乘法减小”指的是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数。\n\n- “加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞。常合起来成为AIMD算法。\n\n注意：“拥塞避免”`并非完全能够避免`了阻塞，而是使网络`比较不容易出现`拥塞。\n\n#### （三）快重传算法：\n\n快重传要求接收方在<u>收到一个失序的报文段后就`立即`发出重复确认</u>（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而==<u>不要等到自己发送数据时捎带确认</u>==。\n\n快重传算法规定，发送方`只要一连收到三个重复确认`就应当`立即重传对方尚未收到的报文段`，而不必继续等待设置的重传计时器时间到期。如下图：\n\n\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-c72fce5494ca8ee12244189430f12cea_r.jpg)\n\n\n\n#### （四）快恢复算法：\n\n快重传配合使用的还有快恢复算法，有以下两个要点：\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno版本是目前使用最广泛的版本。\n\n\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-5f4034bc11c3a48a1d1a115f9ee0259b_r.jpg)\n\n\n\n注意：在采用快恢复算法时，<u>慢开始算法只是在TCP`连接建立时`和`网络出现超时`时才使用</u>\n\n### `整体流程`\n\n1. 执行慢开始算法 直到到达门限值ssh \n2. 执行拥塞避免算法 直到网络拥塞（接收者收到失序报文段）\n3. - 执行快重传算法 接受方立刻发送确认报文段 发送方收到三个确认 立刻重发丢失报文段\n   - 执行快恢复算法 拥塞值减半赋值给ssh 网络流量调整至门限值 执行拥塞避免算法\n\n## `流量控制`滑动窗口\n\n滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的可以接受缓冲区大小（`这个字段越大说明网络吞吐量越高`），从而控制发送方的发送速度，不过如果接收端的缓冲区一旦面临数据溢出，窗口大小值也会随之被设置一个更小的值通知给发送端，从而控制数据发送量（发送端会根据接收端指示，进行流量控制）。\n\n<u>==对ack的再认识==</u>，ack通常被理解为收到数据后给出的一个确认，ack包含两个非常重要的信息：\n\n- 一是`期望接收到的下一字节的序号n`，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的（接收方不会不对每一个字节进行确认，而是对多个字节进行累计确认）。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是 2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。 `(累计确认 序号没跟上 表示丢包)`\n\n- 二是`当前的窗口大小m`，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节 b n  ，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理.\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306215037687-532279114.png)\n\n发送窗口后延不能向后移动（左），前延一般情况不允许向后移动。\n\n \n\n<u>**传递效率**</u>\n    一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用`Nagle算法`，即：\n\n1. 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；\n2. 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；\n3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；.\n\nTCP传送的是字节流，其中字节流是信息比特；但是为了可以差错控制，TCP协议还在信息比特前面加入了一些额外比特及其他，这样就构成了一个报文段。所以虽然他每次只能传一个字节，但是却是以报文段的形式传送的。\n\n<u>**当接收方窗口为0时，发送方应该怎么做**</u>        ==？？？？==\n\n- 假设A主机向B主机发送数据，当B的窗口为0，则A不能再向B发送数据。只能等到B的应用进程将缓存中的数据清空，才能有新的rwnd的值。\n- 但是这里有一个问题，当B的应用进程清空缓存后，~~并不会主动告知A~~ ?  <u>应该是继续发送窗口不为0的消息，但是可能丢失吧</u>。 ==（阻塞）==\n- ==解决==：TCP规范中规定，当主机B的接受窗口为0时，主机A`继续发送只有一个字节数据的报文段`。这个报文段会被接收方确认。最终缓存将开始清空，并且确认报文段将包含一个非0的rwnd的值。\n\n \n\n## TCP建立连接和断开连接的过程\n\n位码即tcp标志位，有6种标示：\n\n> ① `SYN`(synchronous 同步，建立联机)；\n>\n> ② ACK(acknowledgement 确认)\n>\n> ③ PSH(push传送)\n>\n> ④ `FIN`(finish结束)\n>\n> ⑤ RST(reset重置)\n>\n> ⑥ URG(urgent紧急)\n\nTCP建立连接和断开连接的过程：\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306211449960-200286196.png)\n\n\n\n### 三次握手：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/net-55-1.png)\n\n1. Client将`标志位SYN置为1`，`随机产生一个值seq`=J，并将该`数据包发送给Serve`r，Client进入`SYN_SENT`状态，等待Server确认。\n\n2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，`Server将标志位SYN和ACK都置为1`，`ack=J+1`，`随机产生一个值seq`=K，并将该数据包发送给Client以确认连接请求，Server进入`SYN_RCVD`状态。\n\n3. Client收到确认后，`检查ack是否为J+1`，`ACK是否为1`，如果正确则将`标志位ACK置为1`，`ack=K+1`，并`将该数据包发送给Server`，`Server检查ack是否为K+1`，`ACK是否为1`，如果正确则连接建立成功，Client和Server进入`ESTABLISHED`状态，完成三次握手，随后Client与Server之间可以开始传输数据了。\n\n   > ACK: 一个是==<u>标志位</u>==确认值(Acknowledgement)，为1便是确认连接。\n   > ack: 另一个是==<u>确认编号</u>==(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。\n   >\n   > `seq（Sequence Number）：` `32bits`，表示这个`tcp`包的序列号。`tcp`协议拼凑接收到的数据包时，根据`seq`来确定顺序，并且能够确定是否有数据包丢失。\n\n<u>第三次握手时，[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)`可以携带正式数据`，</u>如果不携带，那么连接后客户端第一次的seq跟第三次握手的seq一样\n\n| 握手阶段： |      |       |               |      |      |\n| ---------- | ---- | ----- | ------------- | ---- | ---- |\n| 序号       | 方向 | seq   | ack           | SYN  | ACK  |\n| 1          | A->B | 10000 | 0             | 1    | 0    |\n| 2          | B->A | 20000 | 10000+1=10001 | 1    | 1    |\n| 3          | A->B | 10001 | 20000+1=20001 | 0    | 1    |\n\n### 四次挥手：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/net-61-1.png)\n\n`由于TCP连接是全双工的`，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n\n1. 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。\n\n2. 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。\n3. 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认\n4. 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接\n\n> `ACK: 好的 同意 收到`\n\n| 挥手阶段： |      |       |               |      |      |\n| ---------- | ---- | ----- | ------------- | ---- | ---- |\n| 序号       | 方向 | seq   | ack           | FIN  | ACK  |\n| 1          | A->B | 80000 | 90000         | 1    | 1    |\n| 2          | B->A | 90000 | 80000+1=80001 | 0    | 1    |\n| 3          | B->A | 95000 | 80001         | 1    | 1    |\n| 4          | A->B | 80001 | 95000+1=95001 | 0    | 1    |\n\n## TCP的三次握手和四次挥手的过程及原因\n\n### TCP状态机：\n\n下面两张图本质上是相同的\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306211449960-200286196.png)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306213925763-1525291350.png)\n\n> 蓝色实线是客户端的状态\n>\n> 红线虚线是服务端的状态\n\n\n\nTCP的三次握手过程如下：\n\n> C-> SYN -> S\n>\n> S->SYN&ACK->C\n>\n> C->ACK->S\n>\n\n### 三次握手的原因：\n\n`三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。` <u>==(迷路的SYN姗姗来迟，服务器独守空房)==</u>\n\n> 例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。`此时服务器会一直等待客户端发送数据从而造成资源浪费`。\n\nTCP的四次挥手过程如下：\n\n> C->FIN->S\n>\n> S->ACK->C\n>\n> S->FIN->C\n>\n> C->ACK->S\n>\n\n \n\n### 四次挥手的原因：\n\n由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。\n\n因为TCP是全双工通信的\n\n> 1. 第一次挥手\n>\n>    因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。\n>\n> 2. 第二次挥手\n>\n>    被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。\n>\n> 3. 第三次挥手\n>\n>    被动方在处理完数据报文后，便发送给主动方FIN报文；`这样可以保证数据通信正常可靠地完成`。发送完FIN报文后，被动方进入`LAST_ACK`阶段（超时等待）。\n>\n> 4. 第四挥手\n>\n>    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。\n\n \n\n## [三次握手过程中可以携带数据吗？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=59、-三次握手过程中可以携带数据吗？)\n\n其实==第三次握手的时候，是可以携带数据的==。但是，**第一次、第二次握手不可以携带数据**\n\n为什么这样呢?大家可以想一个问题，<u>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</u>\n\n也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会`让服务器更加容易受到攻击`了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**\n\n\n\n## [SYN攻击是什么？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=60、syn攻击是什么？)\n\n**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内==伪造大量不存在的IP地址==，并==向Server不断地发送SYN包==，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。`SYN 攻击是一种典型的 DoS/DDoS 攻击`。\n\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 `netstats` 命令来检测 SYN 攻击。\n\n```\nnetstat -n -p TCP | grep SYN_RECV\n```\n\n常见的防御 SYN 攻击的方法有如下几种：\n\n- 缩短超时（SYN Timeout）时间\n- 增加最大半连接数\n- 过滤网关防护\n- SYN cookies技术\n\n## TCP握手为什么两次不可以？为什么不用四次？\n\n### 两次不可以\n\ntcp是==<u>全双工通信</u>==，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常\n\n> 思考：如果是两次的话， 是哪两次呢？\n>\n> 如果是A SYN B, B ACK A的话， 只能保证A-》B的连接，不能保证反向\n>\n> 如果是A SYN B, B SYN A的话， 一次也不能保证，甚至不构成握手\n\n### 不用四次\n\n 本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是：\n\n>  1.客户端发送syn0给服务器\n>  2.服务器收到syn0，回复ack(syn0+1)\n>  3.服务器发送syn1\n>  4.客户端收到syn1，回复ack(syn1+1)\n\n 因为tcp是全双工的，上边的四步 确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手。 ==（服务器的ACK确认和 SYN请求可以合并为一次）==\n\n \n\n## [TCP的连接状态](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=48、常见tcp的连接状态有哪些？)\n\n- CLOSED：初始状态。\n- LISTEN：服务器处于监听状态。\n- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。\n- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。\n- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。\n- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。\n- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。\n- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。\n- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。\n- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。\n\n## tcp keepalive保活机制\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-c3fcc2b7b1db546b4a45b1a4ad7e87df_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n### Time_wait状态的作用？有什么不好的地方？\n\n首先调用close()发起`主动关闭的一方`，`在发送最后一个ACK之后会进入time_wait的状态`，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL值得是数据包在网络中的最大生存时间。 （timewait时间 1-4分钟）\n\n#### **原因**\n\n1. 为实现TCP连接的可靠释放，防止断开连接最后一次ACK报文丢失了。\n\n   > `（确保被动方 接受到最后一次ACK 不然被动方会重发FIN，关闭了就收不到被动方的重发了）`\n\n2. 为使旧的重复数据包在网络中因过期而消失\n\n可能存在一些数据包在传输过程中出现异常而导致严重推迟，而在它到来之前发送方已经重发了该报文，并完成其任务。如果在被推迟的报文未抵达前接收方断开了连接，随后又建立了一个与之前相同IP、Port的连接，而之前被推迟的报文在这时恰好到达，而此时此新连接非彼连接，从而会发生数据错乱，进而导致无法预知的情况。因此必须维持一段等待时间，使迟到的报文在网络中完全消失，并且在等待时间内，因为连接并未关闭，所以不能建立相同四元组的新连接，就不会出现数据错乱。\n\n#### 危害\n\n1. 产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的`四元组`（客户端IP地址和端口，服务端IP地址和端口号）`不能被使用`。`文件描述符`的使用是有上限的，`如果持续高并发，会导致一些连接失败`。\n\n2. 服务器，因为一些原因，服务器进程挂掉了，退出了，由于是服务器主动关闭连接，因此会有TIME_WAIT状态存在，也就意味着服务器进程想立即重启，如果TIME_WAIT状态维持60秒，60秒服务器都起不来。 ==（timewait时间内 服务器挂掉 服务器重启时间已过）==\n\n#### 如何避免？\n\n可设置套接字选项为SO_REUSEADDR，该选项的意思是，告诉操作系统，如果端口忙，但占用该端口TCP连接处于TIME_WAIT状态，并且套接字选项为SO_REUSEADDR，则该端口可被重用。如果TCP连接处于其他状态，依然返回端口被占用。该选项对服务程序重启非常有用。\n\n\n\n<img src=\"https://pic3.zhimg.com/v2-a33b1ab6ea6f27ee685703afee5d2296_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n### time-wait的作用，还有它的开始时间\n\ntime-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。\n\n然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，可为30s，1min或2min。2msl就是2倍的这个时间。工程上为2min，2msl就是4min。但一般根据实际的网络情况进行确定。\n\n然后，为什么要持续这么长的时间呢？\n\n1. 三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报<u>(**此处应该是客户端收到一个非法的报文段 (第三次的FIN)，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。**)</u>，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。\n\n2. 在第四次挥手后，`经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失`，这样下一次新的连接中就肯定不会出现旧连接的报文段了。也就是防止我们上一篇文章 [为什么tcp是三次握手而不是两次握手？](https://zhuanlan.zhihu.com/p/51448333) 中说的：已经失效的连接请求报文段出现在本次连接中。如果没有的话就可能这样：这次连接一挥手完马上就结束了，没有timewait。这次连接中有个迷失在网络中的syn包，然后下次连接又马上开始，下个连接发送syn包，迷失的syn包忽然又到达了对面，所以对面可能同时收到或者不同时间收到请求连接的syn包，然后就出现问题了。\n\n\n\n### [对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=81、对于fin_wait_2，close_wait状态和time_wait状态？你知道多少)\n\n- FIN_WAIT_2：\n\n  - ==<u>半关闭状态</u>==。\n\n    > 一、半连接\n    >\n    > 1.1 定义\n    >\n    > - 发生在TCP3次握手中。\n    > - 如果A向B发起TCP请求，B也按照正常情况进行响应了，但是A不进行第3次握手，这就是半连接\n    >\n    > 1.2 半连接攻击 `(SYN攻击)`\n    >\n    > - <u>半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽</u>。\n    >\n    >\n    > 二、半打开（Half-Open）\n    >\n    > 2.1 定义\n    >\n    > - <u>如果一方已经关闭或异常终止连接，而另一方却不知道。 我们将这样的TCP连接称为半打开（Half-Open</u>）。\n    >\n    >\n    > 三、半关闭\n    >\n    > 3.1 定义\n    >\n    > - TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是TCP的半关闭。\n    > - 当一方关闭发送通道后，仍可接受另一方发送过来的数据，这样的情况叫“半关闭”。（拆除TCP连接是：你关闭你的发送通道，我关闭我的发送通道）。\n    >\n    > 3.2 半关闭的产生\n    >\n    > - 客户端发送FIN，另一端发送对这个FIN的ACK报文段。 此时客户端就处于半关闭。\n    > - 调用shutdown，shutdown的第二个参数为SHUT_WR时，为半关闭。\n\n  - 发送断开请求一方还有接收数据能力，但已经没有发送数据能力（或者说只能发送FIN）。\n\n  - 不能长久的处于FIN_WAIT2状态 超时后会默默消失\n\n- CLOSE_WAIT状态：\n\n  - 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。\n  - 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。\n\n  > 第二次 第三次挥手之间的间隔\n\n- TIME_WAIT状态：\n\n  - 又叫2MSL等待状态。\n  - 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。\n  - 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。\n\n## 为什么 TCP 叫数据流模式？ UDP 叫数据报模式？\n\n- 所谓的“流模式”，是指`TCP发送端发送几次数据和接收端接收几次数据是没有必然联系`的，比如你通过 TCP连接给另一端发送数据，你只调用了一次 write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。\n\n- 原因：这是因为TCP是面向连接的，一个 socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。\n\n\n> <u>==流 的意思是数据时连续有序的，我接收方可以自己选择怎么读 都多少==</u>\n\n- 所谓的“数据报模式”，是指UDP发送端`调用了几次 write`，接收端必须用`相同次数的 read` 读完。`UDP是基于报文的`，在接收的时候，每次`最多只能读取一个报文`，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。\n\n- 原因：这是因为UDP是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。 这时候，如果一次能读取超过一个报文的数据， 则会乱套。\n\n> ==<u>报 的意思是数据时无序的，因此必须保证每次都读完 再读下一个，不然会乱套</u>==\n\n## [服务器出现大量close_wait的连接的原因是什么？有什么解决方法？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=103、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306211449960-200286196.png)\n\nclose_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：\n\n- `服务器内部业务处理占用了过多时间`，都没能处理完业务；或者`还有数据需要发送`；或者`服务器的业务逻辑有问题，没有执行close()方法`\n\n  > 1. 没有出错 只是服务器太忙 还是数据发送 所以不能主动断开\n  > 2. 逻辑错误 没有调用close\n\n- 服务器的`父进程派生出子进程`，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0`无法回收`\n\n处理方法：\n\n- 停止应用程序\n- 修改程序里的bug\n\n## [处于 TIME_WAIT 状态的 TCP 连接，收到同四元组SYN 后会发生什么？](https://zhuanlan.zhihu.com/p/474634990)\n\n**在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？**\n\n如果双方开启了时间戳机制：\n\n- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**大**，**并且**SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**大**（==<u>有效SYN</u>==）。那么就会重用该四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。\n- 如果客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要**小**，**或者**SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要**小**（<u>==无效SYN==</u>）。那么就会**再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端**。\n\n在 TIME_WAIT 状态，收到 RST 会断开连接吗？\n\n- 如果 `net.ipv4.tcp_rfc1337` 参数为 0，则提前结束 TIME_WAIT 状态，释放连接。\n- 如果 `net.ipv4.tcp_rfc1337` 参数为 1，则会丢掉该 RST 报文。\n\n\n\n## TCP连接异常的问题\n\n### [1. 三次握手和四次挥手的异常处理](https://zhuanlan.zhihu.com/p/398890723)\n\n#### **TCP 三次握手期间的异常**\n\n##### **第一次握手丢失了，会发生什么？**\n\n当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。\n\n在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发超时重传机制。\n\n不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。\n\n当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？\n\n在 Linux 里，客户端的 SYN 报文最大重传次数由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。\n\n通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。\n\n<u>当第五次超时重传后，会继续等待 32 秒，如果`服务端仍然没有回应 ACK`，客户端就不再发送 SYN 包，然后`断开 TCP 连接`。</u>\n\n所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。\n\n> ==<u>重传客户端的SYN 直到收到ACK 或者得到上限次数</u>==\n\n##### **第二次握手丢失了，会发生什么？**\n\n当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。\n\n第二次握手的 `SYN-ACK` 报文其实有两个目的 ：\n\n- 第二次握手里的 ACK， 是对第一次握手的确认报文；\n- 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；\n\n所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？\n\n因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。\n\n然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。\n\n那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。\n\n在 Linux 下，SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 5。\n\n因此，当第二次握手丢失了，客户端和服务端都会重传：\n\n- ==<u>客户端会重传 SYN 报文</u>==，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定。；\n- ==<u>服务端会重传 SYN-ACK 报文</u>==，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。\n\n##### **第三次握手丢失了，会发生什么？**\n\n客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。\n\n因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。\n\n注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文 然后再按逻辑发送ACK**。\n\n> ==<u>服务端重传SYN-ACK，然后客户端继续按逻辑ACK</u>==\n\n#### **TCP 四次挥手期间的异常**\n\n##### **第一次挥手丢失了，会发生什么？**\n\n当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 `FIN_WAIT_1` 状态。\n\n正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 `FIN_WAIT2` 状态。\n\n如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。\n\n当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，直接进入到 `close` 状态。\n\n> ==<u>主动关闭方重传FIN，直到收到ACK 或者得到上限次数</u>==\n\n##### **第二次挥手丢失了，会发生什么？**\n\n当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态。\n\n在前面我们也提了，<u>ACK 报文是不会重传的</u>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。\n\n这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 `FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。\n\n对于 close 函数关闭的连接，由于无法再发送和接收数据，所以`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。\n\n这意味着对于调用 close 关闭的连接，`如果在 60 秒后还没有收到 FIN 报文`，<u>==客户端（主动关闭方）的连接就会直接关闭==</u>。\n\n> 1. ==<u>主动方重新进行第一次挥手，直到收到第二次挥手的ACK</u>==\n> 2. 注意 和之前不同，第二次挥手不需要也没有ACK确认，所以不会单独重复第二次挥手\n\n##### **第三次挥手丢失了，会发生什么？**\n\n当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。\n\n此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。\n\n服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。\n\n如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retries` 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。\n\n> ==<u>重发第三次挥手 直到收到ACK 或者次数达到上限</u>==\n\n##### **第四次挥手丢失了，会发生什么？**\n\n当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 `TIME_WAIT` 状态。\n\n在 Linux 系统，<u>TIME_WAIT 状态会`持续 60 秒后才会进入关闭`状态</u>。\n\n然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。\n\n如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。\n\n> ==<u>重发第三次挥手 直到收到ACK 或者次数达到上限</u>==\n\n### [2. 拔掉网线后， 原本的 TCP 连接还存在吗？](https://zhuanlan.zhihu.com/p/467241401)\n\n**拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？**\n\n#### 有数据传输 按重传机制回答\n\n- 在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值（默认值为15次）之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。\n- 在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 `RST 报文`，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。\n\n#### 无数据传输 按keepalive保活机制回答\n\n- 如果双方`都没有`开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将`会一直保持存在`。\n- 如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会`探测`到对方的 TCP 连接没有存活，于是就会`断开 TCP 连接`。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。\n\n#### 其他场景\n\n除了客户端拔掉网线的场景，还有客户端「==<u>宕机和杀死进程</u>==」的两种场景。\n\n第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，，**服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态**，直到服务端重启进程。\n\n所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。\n\n> <u>宕机和拔网线是一样的效果</u>\n\n第二个场景，杀死客户端的进程后，客户端的内核就会向服务端发送 FIN 报文，**与客户端进行四次挥手**。\n\n所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。\n\n> 杀死进程 `内核会接替`完成挥手工作\n\n\n\n### 3. 一个tcp连接，`没有的打开keepalive`选项，`没有数据交互`，现在一端突然`掉电`和一段的`进程突然crash`，这两个有什么区别？\n\n#### 在没有开启 TCP keepalive，且双方==<u>一直没有数据交互</u>==的情况下，如果客户端的==<u>「主机崩溃」（或者掉电 拔网线</u>==）了，会发生什么。  （==<u>不交互就不知道出错了</u>==）\n\n如果客户端主机崩溃了，服务端是**无法感知到的**，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，**服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态**，直到服务端重启进程。\n\n所以，我们可以得知一个点。\n\n在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。\n\n#### 那题目中的==<u>「进程崩溃」</u>==的情况呢？\n\n我自己做了个实验，使用 kill -9 来模拟进程崩溃的情况，发现**在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手**。\n\n所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。\n\n> 内核感知 帮你体面\n\n### 4. FIN_WAIT2为什么有计时？\n\n> 计时问题前面提到过，主动端FIN然后收到ACK后进入FIN_WAIT2状态，`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。<u>==为什么呢？==</u>\n>\n> 注意的点：FIN_WAIT2状态无法接收数据 只能接受第三次挥手的FIN\n\n![TCP状态机](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220414155340612.png)\n\n断开本端连接，进入FIN_WAIT2状态后，如果对端`故意不发送FIN`，`且也不传输数据`，那么意味着本端始终处在FINWAIT-2状态而资源无法释放，这不正是一个DDoS的典型场景吗？但是如果不这么做，也不符合TCP双向全双工独立控制的规范啊！\n\n可能的答案\n\n- **收到对端的FIN之前，本端会一直保持FINWAIT-2状态**(标准的要求)\n- **收到对端的FIN之前，本端会保持FINWAIT-2状态一段足够的时间，超过此时间，连接即释放**(现实的要求)\n\n我们看到，历史选择了现实而摒弃了理想。Linux任意使用2.2内核以上的发行版，看tcp的manual，其中的：\n\n> tcp_fin_timeout (integer; default: 60; since Linux 2.2)  This specifies how many seconds to wait for a final FIN packet before the socket is forcibly closed. **This is  strictly a violation of the TCP specification**, but required to prevent denial-of-service attacks. In Linux 2.2,  the default value was 180.\n\n现在FINWAIT-2为什么会有个超时时间的问题已经解释清楚了，接下来的问题是，如果FINWAIT-2的timer超时了，这个TCP连接将何去何从？\n\n#### **连接在FINWAIT-2超时后并不会进入TIMEWAIT状态，也不会发送reset，而是直接默默消失。**\n\n## close 与 shutdown\n\n### [Linux-socket的close和shutdown区别及应用场景](https://www.cnblogs.com/JohnABC/p/7238241.html)\n\n#### **二者的区别**\n\n1. close-----关闭`本进程`的socket id，但链接还是开着的，用这个socket id的其它进程还能用这个链接，能读或写这个socket id。\n2. shutdown--破坏了socket 链接，读的时候可能侦探到EOF结束符，写的时候可能会收到一个SIGPIPE信号，这个信号可能直到socket buffer被填充了才收到，shutdown有一个关闭方式的参数，0 不能再读，1不能再写，2 读写都不能。\n\n#### **socket 多进程中的 shutdown、close 的使用**\n\n- 当所有的数据操作结束以后，你可以调用close()函数来释放该socket，从而停止在该socket上的任何数据操作：close(sockfd);使用close中止一个连接，但<u>它只是减少描述符的参考数</u>，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。所以在多进程/线程程序中，close只是确保了对于某个特定的进程或线程来说，该连接是关闭的。使用 client_fd = accept() 后 fork() 以在子进程中处理请求，此时在父进程中使用 close() 关闭该连接，子进程仍可以继续使用该连接。\n\n- 也可以调用shutdown()函数来关闭该socket。该函数允许你只停止在某个方向上的数据传输，而一个方向上的数据传输继续进行。如你可以关闭某socket的写操作而允许继续在该socket上接受数据，直至读入所有数据。int shutdown(int sockfd,int how);shutdown可直接关闭描述符，不考虑描述符的参考数，可选择中止一个方向的连接。\n\n#### **注意**\n\n1. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到`计数为0`时，也就是所用进程都调用了close，套接字将被释放。\n\n1. 在多进程中如果一个进程中shutdown(sfd, SHUT_RDWR)后其它的进程将无法进行通信。如果一个进程close(sfd)将不会影响到其它进程，得自己理解引用计数的用法了。有Kernel编程知识的更好理解了.\n\n#### **更多关于close和shutdown的说明**\n\n1. **只要TCP栈的读缓冲里还有未读取（read）数据，则调用close时会直接向对端发送RST**。\n\n2. **shutdown与socket描述符没有关系，即使调用shutdown(fd, SHUT_RDWR)也不会关闭fd，最终还需close(fd)**。\n\n3. 可以认为shutdown(fd, SHUT_RD)是空操作，因为shutdown后还可以继续从该socket读取数据，这点也许还需要进一步证实。在已发送FIN包后write该socket描述符会引发EPIPE/SIGPIPE。\n\n   > 所以 关闭我这段的 写 意思是 发送fin进入半关闭状态 我可以接收数据 但是我不可以发送数据 不然sigpipe\n   >\n   > 关闭读 同理\n\n4. 当有多个socket描述符指向同一socket对象时，调用close时首先会递减该对象的引用计数，计数为0时才会发送FIN包结束TCP连接。shutdown不同，只要以SHUT_WR/SHUT_RDWR方式调用即发送FIN包。\n\n5. SO_LINGER与close，当SO_LINGER选项开启但超时值为0时，调用close直接发送RST（这样可以避免进入TIME_WAIT状态，但破坏了TCP协议的正常工作方式），SO_LINGER对shutdown无影响。\n\n6. TCP连接上出现RST与随后可能的TIME_WAIT状态没有直接关系，主动发FIN包方必然会进入TIME_WAIT状态，**除非不发送FIN而直接以发送RST结束连接**。\n\n#### **应用场景** \n\n- 通常来说，socket是双向的，即数据是双向通信的。但有些时候，你会想在socket上实现单向的socket，即数据往一个方向传输。单向的socket便称为半开放Socket。要实现`半开放式`，需要用到shutdown()函数。\n\n- 一般来说，半开放socket适用于以下场合:\n\n  1. 当你想要确保所有写好的数据已经发送成功时。如果在发送数据的过程中，网络意外断开或者出现异常，系统不一定会返回异常，这是你可能以为对端已经接收到数据了。这时需要用shutdown()来确定数据是否发送成功，因为调用shutdown()时只有在缓存中的数据全部发送成功后才会返回。\n\n  1. 想用一种方法来捕获程序潜在的错误，这错误可能是因为往一个不能写的socket上写数据，也有可能是在一个不该读操作的socket上读数据。当程序尝试这样做时，将会捕获到一个异常，捕获异常对于程序排错来说是相对简单和省劲的。\n\n  1. 当您的程序使用了fork()或者使用多线程时，你想防止其他线程或进程访问到该资源，又或者你想立刻关闭这个socket，那么可以用shutdown()来实现。\n\n### SIGPIPE信号\n\nTCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了`close`还是`shutdown`.\n\n对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.？？？？？？\n\n迷迷糊糊\n\n#### 我的理解\n\n1. 假设 A B, A调用shutdown_write, A再write就会触发SIGPIPE\n\n2. 看上面的意思是：对端调用close后，我再发送数据就会触发SIGPIPE?\n\n   > 疑问，对端调用close，此时应该是半连接状态，A->B不能发送数据， 但是B->A是可以发送数据的，意思是，FIN_WAIT2状态下 不可以接受数据了吗？ 是的 close状态下 进入 FINWAIT只是在等待对端的FIN\n\n**解决方法：**signal(SIGPIPE, SIG_IGN);\n\n\n\n#### \n\n## Tcp代码实现\n\n### Socket\n\n#### 字节序\n\n本次可能采用大端或者小端字节序\n\n网络字节序采用大端排序方式， BSDsocket提供了封装好的字节序转换接口\n\n```c++\n/*\n    网络通信时，需要将主机字节序转换成网络字节序（大端），\n    另外一段获取到数据以后根据情况将网络字节序转换成主机字节序。\n\n    // 转换端口\n    //short 16位 端口两个字节\n    uint16_t htons(uint16_t hostshort);\t\t// 主机字节序 - 网络字节序\n    uint16_t ntohs(uint16_t netshort);\t\t// 主机字节序 - 网络字节序\n\n    // 转IP\n    //long 32位 ip4个字节\n    uint32_t htonl(uint32_t hostlong);\t\t// 主机字节序 - 网络字节序\n    uint32_t ntohl(uint32_t netlong);\t\t// 主机字节序 - 网络字节序\n*/\n\n#include <stdio.h>\n#include <arpa/inet.h>\n\nint main() {\n    // htons 转换端口\n    unsigned short a = 0x0102;\n    printf(\"a : %x\\n\", a);\t\t//a : 102\n    unsigned short b = htons(a); //b : 201\n    printf(\"b : %x\\n\", b);\n\n    printf(\"=======================\\n\");\n\n    // htonl  转换IP\n    char buf[4] = {192, 168, 1, 100};\n    int num = *(int *)buf;\n    int sum = htonl(num);\n    unsigned char *p = (char *)&sum;\n\n    printf(\"%d %d %d %d\\n\", *p, *(p+1), *(p+2), *(p+3));\n\n    printf(\"=======================\\n\");\n\n    // ntohl\n    unsigned char buf1[4] = {1, 1, 168, 192};\n    int num1 = *(int *)buf1;\n    int sum1 = ntohl(num1);\n    unsigned char *p1 = (unsigned char *)&sum1;\n    printf(\"%d %d %d %d\\n\", *p1, *(p1+1), *(p1+2), *(p1+3));\n    \n     // ntohs\n\n\n    return 0;\n}\n```\n\n\n\n### [建立TCP 服务器的各个系统调用过程是怎样的？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=83、建立tcp服务器的各个系统调用过程是怎样的？)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1567424004017.png)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1567423961699.png)\n\n- `服务器`：\n\n  - 创建socket -> int socket(int domain, int type, int protocol);  \n\n    > `创建一个用于监听的套接字`\n    >\n    > - 监听：监听有客户端的连接\n    >\n    > - 套接字：这个套接字实际上就是一个`文件描述符`\n\n    - domain：协议域，决定了socket的地址类型，IPv4为AF_INET。\n    - type：指定socket类型，SOCK_STREAM为TCP连接。\n    - protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。\n\n  - 绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n\n    > 将这个监听文件描述符和本地的ip和端口绑定（ip和端口就是服务器的地址信息）\n    >\n    > - 客户端连接服务器的时候使用的就是这个ip和端口\n\n    - sockfd：socket返回的套接字描述符，类似于文件描述符fd。\n    - addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。 （传出参数，记录连接成功后客户端的地址信息 ip 和端口）\n    - addrlen：地址长度。\n    - 返回值int: 用于通信的文件描述符\n\n    ```C++\n        // IPv4的sockaddr地址结构\n        struct sockaddr_in {\n            sa_family_t sin_family;    \t// 协议类型，AF_INET\n            in_port_t sin_port;    \t    // 端口号\n            struct in_addr sin_addr;    // IP地址\n        };\n        struct in_addr {\n            uint32_t s_addr;\n        }\n    ```\n\n  - 监听端口号 -> int listen(int sockfd, int backlog);\n\n    > 设置监听，监听的fd开始工作\n\n    - sockfd：要监听的sock描述字。\n    - backlog：socket可以排队的最大连接数。\n\n  - 接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n\n    > 阻塞等待 当有客户端发起连接 接触阻塞 接受客户端的连接 会得到一个和客户端通信的套接字\n    >\n    > - `新的文件描述符 原来的套接字只负责监听`\n\n    - sockfd：服务器socket描述字。\n    - addr：指向地址结构指针。\n    - addrlen：协议地址长度。\n    - 注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。\n\n  - 从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);\n\n    > 通信\n    >\n    > - 接受数据\n    > - 发送数据\n\n    - fd：连接描述字。\n    - buf：缓冲区buf。\n    - count：缓冲区长度。\n    - 注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。\n\n  - 关闭socket -> int close(int fd);\n\n    > 通信结束 断开连接\n\n    - fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。\n    - 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。\n\n- `客户机`：\n\n  - 创建socket -> int socket(int domain, int type, int protocol);\n\n    > 创建一个用于通信的套接字（fd）\n\n  - 连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);\n\n    > 连接服务器 需要指定连接的服务器的ip和端口\n\n    - sockfd客户端的sock描述字。\n    - addr：服务器的地址。\n    - addrlen：socket地址长度。\n\n  - 向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);\n\n    > 通信\n    >\n    > - 接受数据\n    > - 发送数据\n\n    - fd、buf、count：同read中意义。\n    - 大于0表示写了部分或全部数据，小于0表示出错。\n\n  - 关闭oscket -> int close(int fd);\n\n    > 通信结束 断开连接\n\n    - fd：同服务器端fd。\n  \n  ```c++\n  // TCP 通信的服务器端\n  #include <stdio.h>\n  #include <arpa/inet.h>\n  #include <unistd.h>\n  #include <string.h>\n  #include <stdlib.h>\n  \n  int main() {\n  \n      // 1.创建socket(用于监听的套接字)\n      //p1:协议域，决定了socket的地址类型，IPv4为AF_INET。\n      //p2:指定socket类型，SOCK_STREAM为TCP连接。\n      //p3:指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。\n      int lfd = socket(AF_INET, SOCK_STREAM, 0);\n  \n      if(lfd == -1) {\n          perror(\"socket\");\n          exit(-1);\n      }\n  \n      // 2.绑定\n      struct sockaddr_in saddr; //IPv4的sockaddr地址结构\n      saddr.sin_family = AF_INET;  // 协议类型，AF_INET\n      // inet_pton(AF_INET, \"192.168.193.128\", saddr.sin_addr.s_addr);\n      saddr.sin_addr.s_addr = INADDR_ANY;  // 0.0.0.0 ip地址\n      saddr.sin_port = htons(9999);\t\t//端口号\n      int ret = bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));\n      if(ret == -1) {\n          perror(\"bind\");\n          exit(-1);\n      }\n  \n      // 3.监听\n      ret = listen(lfd, 8); //最大连接数为8\n      if(ret == -1) {\n          perror(\"listen\");\n          exit(-1);\n      }\n  \n      // 4.接收客户端连接\n      struct sockaddr_in clientaddr;\n      int len = sizeof(clientaddr);\n      int cfd = accept(lfd, (struct sockaddr *)&clientaddr, &len);\n      \n      if(cfd == -1) {  //client 文件描述符 client_fd\n          perror(\"accept\");\n          exit(-1);\n      }\n  \n      // 输出客户端的信息\n      char clientIP[16];\n      inet_ntop(AF_INET, &clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP));\n      unsigned short clientPort = ntohs(clientaddr.sin_port);\n      printf(\"client ip is %s, port is %d\\n\", clientIP, clientPort);\n  \n      // 5.通信\n      char recvBuf[1024] = {0};\n      while(1) {    \n          // 获取客户端的数据\n          int num = read(cfd, recvBuf, sizeof(recvBuf));\n          if(num == -1) {\n              perror(\"read\");\n              exit(-1);\n          } else if(num > 0) {\n              printf(\"recv client data : %s\\n\", recvBuf);\n          } else if(num == 0) {\n              // 表示客户端断开连接\n              printf(\"clinet closed...\");\n              break;\n          }\n  \n          char * data = \"hello,i am server\";\n          // 给客户端发送数据\n          write(cfd, data, strlen(data));\n      }\n     \n      // 关闭文件描述符\n      close(cfd);\n      close(lfd);\n  \n      return 0;\n  }\n  \n  // TCP通信的客户端\n  #include <stdio.h>\n  #include <arpa/inet.h>\n  #include <unistd.h>\n  #include <string.h>\n  #include <stdlib.h>\n  \n  int main() {\n      // 1.创建套接字\n      int fd = socket(AF_INET, SOCK_STREAM, 0);\n      if(fd == -1) {\n          perror(\"socket\");\n          exit(-1);\n      }\n      \n      // 2.连接服务器端\n      struct sockaddr_in serveraddr;\n      serveraddr.sin_family = AF_INET;\n      inet_pton(AF_INET, \"192.168.33.134\", &serveraddr.sin_addr.s_addr);\n      serveraddr.sin_port = htons(9999);\n      int ret = connect(fd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));\n  \n      if(ret == -1) {\n          perror(\"connect\");\n          exit(-1);\n      }\n  \n      // 3. 通信\n      char recvBuf[1024] = {0};\n      while(1) {\n          char * data = \"hello,i am client\";\n          // 给客户端发送数据\n          write(fd, data , strlen(data));\n  \n          sleep(1);\n          \n          int len = read(fd, recvBuf, sizeof(recvBuf));\n          if(len == -1) {\n              perror(\"read\");\n              exit(-1);\n          } else if(len > 0) {\n              printf(\"recv server data : %s\\n\", recvBuf);\n          } else if(len == 0) {\n              // 表示服务器端断开连接\n              printf(\"server closed...\");\n              break;\n          }\n      }\n  \n      // 关闭连接\n      close(fd);\n      return 0;\n  }\n  ```\n\n### TCP通信并发\n\n要实现tcp通信服务器处理并发的任务，使用多线程或者多进程来解决\n\n思路：\n\n1. 一个父进程 多个子进程\n2. `父进程负责等待并接受客户端的连接`\n3. 子进程：完成通信 `接受一个客户端连接 就创建一个子进程用于通信`\n\n#### client.c\n\n```c++\n// TCP通信的客户端\n#include <stdio.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    // 1.创建套接字\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    if(fd == -1) {\n        perror(\"socket\");\n        exit(-1);\n    }\n\n    // 2.连接服务器端\n    struct sockaddr_in serveraddr;\n    serveraddr.sin_family = AF_INET;\n    inet_pton(AF_INET, \"192.168.193.128\", &serveraddr.sin_addr.s_addr);\n    serveraddr.sin_port = htons(9999);\n    int ret = connect(fd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));\n\n    if(ret == -1) {\n        perror(\"connect\");\n        exit(-1);\n    }\n    \n    // 3. 通信\n    char recvBuf[1024];\n    int i = 0;\n    while(1) {\n        sprintf(recvBuf, \"data : %d\\n\", i++);  \n        // 给服务器端发送数据\n        write(fd, recvBuf, strlen(recvBuf)+1);\n\n        int len = read(fd, recvBuf, sizeof(recvBuf));\n        if(len == -1) {\n            perror(\"read\");\n            exit(-1);\n        } else if(len > 0) {\n            printf(\"recv server : %s\\n\", recvBuf);\n        } else if(len == 0) {\n            // 表示服务器端断开连接\n            printf(\"server closed...\");\n            break;\n        }\n        sleep(1);\n    }\n    // 关闭连接\n    close(fd);\n\n    return 0;\n}\n```\n\n#### server_process.c\n\n```c++\n#include <stdio.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <wait.h>\n#include <errno.h>\n\nvoid recyleChild(int arg) {\n    while(1) {\n        int ret = waitpid(-1, NULL, WNOHANG);  //设置不阻塞\n        if(ret == -1) {\n            // 所有的子进程都回收了\n            break;\n        }else if(ret == 0) {\n            // 还有子进程活着\n            break;\n        } else if(ret > 0){\n            // 被回收了\n            printf(\"子进程 %d 被回收了\\n\", ret);\n        }\n    }\n}\n\nint main() {\n    struct sigaction act;\n    act.sa_flags = 0;\n    sigemptyset(&act.sa_mask);\n    act.sa_handler = recyleChild;\n    // 注册信号捕捉\n    sigaction(SIGCHLD, &act, NULL);\n    // 创建socket\n    int lfd = socket(PF_INET, SOCK_STREAM, 0);\n    if(lfd == -1){\n        perror(\"socket\");\n        exit(-1);\n    }\n\n    struct sockaddr_in saddr;\n    saddr.sin_family = AF_INET;\n    saddr.sin_port = htons(9999);\n    saddr.sin_addr.s_addr = INADDR_ANY;\n\n    // 绑定\n    int ret = bind(lfd,(struct sockaddr *)&saddr, sizeof(saddr));\n    if(ret == -1) {\n        perror(\"bind\");\n        exit(-1);\n    }\n    // 监听\n    ret = listen(lfd, 128);\n    if(ret == -1) {\n        perror(\"listen\");\n        exit(-1);\n    }\n\n    // 不断循环等待客户端连接\n    while(1) {\n        struct sockaddr_in cliaddr;\n        int len = sizeof(cliaddr);\n        // 接受连接\n        int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &len);\n        if(cfd == -1) {\n            if(errno == EINTR) {\n                continue;    //没有接入 while 跳过 继续循环\n            }\n            perror(\"accept\");\n            exit(-1);\n        }\n\n        // 每一个连接进来，创建一个子进程跟客户端通信\n        pid_t pid = fork();\n        if(pid == 0) {\n            // 子进程\n            // 获取客户端的信息\n            char cliIp[16];\n            inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp));\n            unsigned short cliPort = ntohs(cliaddr.sin_port);\n            printf(\"client ip is : %s, prot is %d\\n\", cliIp, cliPort);\n\n            // 接收客户端发来的数据\n            char recvBuf[1024];\n            while(1) {\n                int len = read(cfd, &recvBuf, sizeof(recvBuf));\n\n                if(len == -1) {\n                    perror(\"read\");\n                    exit(-1);\n                }else if(len > 0) {\n                    printf(\"recv client : %s\\n\", recvBuf);\n                } else if(len == 0) {\n                    printf(\"client closed....\\n\");\n                    break;\n                }\n                write(cfd, recvBuf, strlen(recvBuf) + 1);\n            }\n            close(cfd);\n            exit(0);    // 退出当前子进程\n        }\n\n    }\n    close(lfd);\n    return 0;\n}\n```\n\n#### server_thread.c\n\n```c++\n#include <stdio.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n\nstruct sockInfo {\n    int fd; // 通信的文件描述符\n    struct sockaddr_in addr;\n    pthread_t tid;  // 线程号\n};\n\nstruct sockInfo sockinfos[128];\n\nvoid * working(void * arg) {\n    // 子线程和客户端通信   cfd 客户端的信息 线程号\n    // 获取客户端的信息\n    struct sockInfo * pinfo = (struct sockInfo *)arg;\n\n    char cliIp[16];\n    inet_ntop(AF_INET, &pinfo->addr.sin_addr.s_addr, cliIp, sizeof(cliIp));\n    unsigned short cliPort = ntohs(pinfo->addr.sin_port);\n    printf(\"client ip is : %s, prot is %d\\n\", cliIp, cliPort);\n\n    // 接收客户端发来的数据\n    char recvBuf[1024];\n    while(1) {\n        int len = read(pinfo->fd, &recvBuf, sizeof(recvBuf));\n\n        if(len == -1) {\n            perror(\"read\");\n            exit(-1);\n        }else if(len > 0) {\n            printf(\"recv client : %s\\n\", recvBuf);\n        } else if(len == 0) {\n            printf(\"client closed....\\n\");\n            break;\n        }\n        write(pinfo->fd, recvBuf, strlen(recvBuf) + 1);\n    }\n    close(pinfo->fd);\n    return NULL;\n}\n\nint main() {\n    // 创建socket\n    int lfd = socket(PF_INET, SOCK_STREAM, 0);\n    if(lfd == -1){\n        perror(\"socket\");\n        exit(-1);\n    }\n\n    struct sockaddr_in saddr;\n    saddr.sin_family = AF_INET;\n    saddr.sin_port = htons(9999);\n    saddr.sin_addr.s_addr = INADDR_ANY;\n\n    // 绑定\n    int ret = bind(lfd,(struct sockaddr *)&saddr, sizeof(saddr));\n    if(ret == -1) {\n        perror(\"bind\");\n        exit(-1);\n    }\n\n    // 监听\n    ret = listen(lfd, 128);\n    if(ret == -1) {\n        perror(\"listen\");\n        exit(-1);\n    }\n\n    // 初始化数据\n    int max = sizeof(sockinfos) / sizeof(sockinfos[0]);\n    for(int i = 0; i < max; i++) {\n        bzero(&sockinfos[i], sizeof(sockinfos[i]));\n        sockinfos[i].fd = -1;\n        sockinfos[i].tid = -1;\n    }\n\n    // 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信\n    while(1) {\n        struct sockaddr_in cliaddr;\n        int len = sizeof(cliaddr);\n        // 接受连接\n        int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &len);\n\n        struct sockInfo * pinfo;\n        for(int i = 0; i < max; i++) {\n            // 从这个数组中找到一个可以用的sockInfo元素\n            if(sockinfos[i].fd == -1) {\n                pinfo = &sockinfos[i];\n                break;\n            }\n            if(i == max - 1) {\n                sleep(1);\n                i--;\n            }\n        }\n\n        pinfo->fd = cfd;\n        memcpy(&pinfo->addr, &cliaddr, len);\n\n        // 创建子线程\n        pthread_create(&pinfo->tid, NULL, working, pinfo);\n        pthread_detach(pinfo->tid);  //join是阻塞的 感觉很少用\n    }\n\n    close(lfd);\n    return 0;\n}\n\n```\n\n## IO多路复用\n\n### 1. I/O多路复用（I/O多路转接）\n\n<u>I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，</u>\n\nLinux 下实现 I/O 多路复用的系统调用主要有 `select、poll 和 epoll`。\n\n### 2. select\n\n> 主旨思想：\n>\n> 1. 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。\n>\n> 2. 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。\n>\n>    a.这个函数是阻塞\n>\n>    b.函数对文件描述符的检测的操作是由内核完成的\n>\n> 3. 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402112443772.png\" alt=\"image-20220402112443772\" style=\"zoom:80%;\" />\n\n#### select工作过程分析\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402163238461.png\" alt=\"image-20220402163238461\" style=\"zoom:50%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402154825981.png\" alt=\"image-20220402154825981\" style=\"zoom: 50%;\" />\n\n#### select缺点\n\n> 1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大\n> 2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多的时候也会很大\n> 3. select支持的文件描述符数量太少了，默认是1024\n> 4. fds集合不能重用，每次都需要重置\n\n\n\n#### 简要应用代码\n\n```c++\n#include <stdio.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n\nint main() {\n\n    // 创建socket\n    int lfd = socket(PF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in saddr;\n    saddr.sin_port = htons(9999);\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n\n    // 绑定\n    bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n    // 监听\n    listen(lfd, 8);\n\n    // 创建一个fd_set的集合，存放的是需要检测的文件描述符\n    fd_set rdset, tmp;\n    FD_ZERO(&rdset);  //全部初始化 置为0\n    FD_SET(lfd, &rdset); //监听的文件描述符也用select监听\n    int maxfd = lfd;  //监听文件描述符的最大长度\n\n    while(1) {\n        tmp = rdset;\n        // 调用select系统函数，让内核帮检测哪些文件描述符有数据\n        int ret = select(maxfd + 1, &tmp, NULL, NULL, NULL);\n        if(ret == -1) {\n            perror(\"select\");\n            exit(-1);\n        } else if(ret == 0) { //这时 没有检测到\n            continue;\n        } else if(ret > 0) {\n            // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变\n            if(FD_ISSET(lfd, &tmp)) {\n                // 表示有新的客户端连接进来了\n                struct sockaddr_in cliaddr;\n                int len = sizeof(cliaddr);\n                int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);\n\n                // 将新的文件描述符加入到集合中\n                FD_SET(cfd, &rdset);\n\n                // 更新最大的文件描述符\n                maxfd = maxfd > cfd ? maxfd : cfd;\n            }\n            for(int i = lfd + 1; i <= maxfd; i++) {  //遍历所有 长度范围内的fd lfd监听在最前\n                if(FD_ISSET(i, &tmp)) {\n                    // 说明这个文件描述符对应的客户端发来了数据\n                    char buf[1024] = {0};\n                    int len = read(i, buf, sizeof(buf));\n                    if(len == -1) {\n                        perror(\"read\");\n                        exit(-1);\n                    } else if(len == 0) {\n                        printf(\"client closed...\\n\");\n                        close(i);\n                        FD_CLR(i, &rdset);\n                    } else if(len > 0) {\n                        printf(\"read buf = %s\\n\", buf);\n                        write(i, buf, strlen(buf) + 1);\n                    }\n                }\n            }\n\n        }\n    }\n    close(lfd);\n    return 0;\n}\n```\n\n\n\n### **3. poll**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402112520601.png\" alt=\"image-20220402112520601\" style=\"zoom:80%;\" />\n\n### **4. epoll**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402112602829.png\" alt=\"image-20220402112602829\"  />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402164938945.png\" alt=\"image-20220402164938945\" style=\"zoom: 50%;\" />\n\n<u>rbr：存储所有文件描述符 红黑树的遍历和添加很快</u>\n\n<u>rdlist：存储有数据到达，响应了的文件描述符</u>\n\n#### Epoll 的工作模式：\n\n> 理解：缓冲区的读写可以理解为数据的转移？读完 读缓冲区的数据就没了\n\n- LT 模式 （水平触发）\n\n  假设委托内核检测读事件 -> 检测fd的读缓冲区\n\n  读缓冲区有数据 - > epoll检测到了会给用户通知\n\n  ​\ta.用户不读数据，数据一直在缓冲区，epoll 会一直通知\n\n  ​\tb.用户只读了一部分数据，epoll会通知\n\n  ​\tc.缓冲区的数据读完了，不通知\n\n  > LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这\n  >\n  > 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操\n  >\n  > 作。如果你不作任何操作，内核还是会继续通知你的。\n\n- ET 模式（边沿触发）\n\n  > 边沿的含义：状态的变化\n>\n  > `socket的接收缓冲区状态变化时触发读事件`\n> `socket的发送缓冲区状态变化时触发写事件`\n  >\n> 1. 从不可读变为可读：从接收缓冲区为空，到接收到数据后触发一次\n  >\n> 2. 从可读变为不可读：断开连接，从可读变为不可读触发一次\n  >\n> 3. 从不可写变为可写：从accept建立连接触发一次\n  >\n  > 4. 从可写变为不可写：断开连接，从可写变为不可写触发一次\n\n  假设委托内核检测读事件 -> 检测fd的读缓冲区\n\n  读缓冲区有数据 - > epoll检测到了会给用户通知\n\n  ​\ta.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了\n\n  ​\tb.用户只读了一部分数据，epoll不通知\n\n  ​\tc.缓冲区的数据读完了，不通知\n\n  > ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知<u>（`only once`）</u>。\n  >\n  > ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，<u>以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</u>\n  >\n  > > 理解一下：当消息到达 比如8个字节 如果我只读取了两个字节 并没有读完 但是有新消息到达时 epoll不会再进行通知 因此et的应用场景应该是 消息达到 一次读完数据 但是read读取数据 读完的话 后续没有数据又会阻塞在那里 因此 需要设置为非阻塞模式\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402113009940.png\" alt=\"image-20220402113009940\" style=\"zoom:67%;\" />\n\n#### 简要应用代码\n\n```c++\n#include <stdio.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/epoll.h>\n\nint main() {\n    // 创建socket\n    int lfd = socket(PF_INET, SOCK_STREAM, 0);\n    struct sockaddr_in saddr;\n    saddr.sin_port = htons(9999);\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    // 绑定\n    bind(lfd, (struct sockaddr *)&saddr, sizeof(saddr));\n    // 监听\n    listen(lfd, 8);\n    // 调用epoll_create()创建一个epoll实例\n    int epfd = epoll_create(100);\n    // 将监听的文件描述符相关的检测信息添加到epoll实例中\n    struct epoll_event epev;\n    epev.events = EPOLLIN; //监听读\n    epev.data.fd = lfd;  \n    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &epev);\n    \n    //用于接受检测到的数据\n    struct epoll_event epevs[1024];\n    while(1) {\n        int ret = epoll_wait(epfd, epevs, 1024, -1); // -1阻塞\n        if(ret == -1) {\n            perror(\"epoll_wait\");\n            exit(-1);\n        }\n        printf(\"ret = %d\\n\", ret); //发生改变的个数\n        for(int i = 0; i < ret; i++) {\n            int curfd = epevs[i].data.fd;\n            if(curfd == lfd) {\n                // 监听的文件描述符有数据达到，有客户端连接\n                struct sockaddr_in cliaddr;\n                int len = sizeof(cliaddr);\n                int cfd = accept(lfd, (struct sockaddr *)&cliaddr, &len);\n                epev.events = EPOLLIN;\n                epev.data.fd = cfd;\n                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &epev);  //将客户端加入监听\n            } else {\n                if(epevs[i].events & EPOLLOUT) {\n                    continue;\n                }   \n                // 有数据到达，需要通信\n                char buf[1024] = {0};\n                int len = read(curfd, buf, sizeof(buf));\n                if(len == -1) {\n                    perror(\"read\");\n                    exit(-1);\n                } else if(len == 0) {\n                    printf(\"client closed...\\n\");\n                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL);\n                    close(curfd);\n                } else if(len > 0) {\n                    printf(\"read buf = %s\\n\", buf);\n                    write(curfd, buf, strlen(buf) + 1);\n                }\n            }\n        }\n    }\n    close(lfd);\n    close(epfd);\n    return 0;\n}\n```\n\n## UDP\n\n### UDP通信\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220406164543655.png\" alt=\"image-20220406164543655\" style=\"zoom:67%;\" />\n\n```c++\n#include <sys/types.h> \n#include <sys/socket.h> \nssize_t sendto(int sockfd, const void *buf, size_t len, int flags,\n               const struct sockaddr *dest_addr, socklen_t addrlen); \n    - 参数：\n    - sockfd : 通信的fd \n    - buf : 要发送的数据 \n    - len : 发送数据的长度 \n    - flags : 0 \n    - dest_addr : 通信的另外一端的地址信息 \n    - addrlen : 地址的内存大小 \n    \nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, \n                 struct sockaddr *src_addr, socklen_t *addrlen); \n    - 参数：\n    - sockfd : 通信的fd \n    - buf : 接收数据的数组 \n    - len : 数组的大小\n    - flags : 0 \n    - src_addr : 用来保存另外一端的地址信息，不需要可以指定为NULL \n    - addrlen : 地址的内存大小\n```\n\n### 广播\n\n向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。\n\n​\ta. 只能在`局域网`中使用。\n\n​\tb. <u>客户端需要绑定服务器广播使用的端口，才可以接收到广播消息</u>。\n\n```c++\n// 设置广播属性的函数 \nint setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen); \n    - sockfd : 文件描述符 \n    - level : SOL_SOCKET \n    - optname : SO_BROADCAST \n    - optval : int类型的值，为1表示允许广播 \n    - optlen : optval的大小\n```\n\n### 组播(多播)\n\n单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。\n\n单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。\n\n​\ta.组播既可以用于局域网，也`可以用于广域网`\n\n​\tb.<u>客户端需要加入多播组，才能接收到多播的数据</u>\n\n#### 组播地址\n\nIP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 224.0.0.0 到 239.255.255.255 ，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220406181045478.png\" alt=\"image-20220406181045478\" style=\"zoom:67%;\" />\n\n#### 设置组播\n\n```c++\nint setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen); \n    // 服务器设置多播的信息，外出接口\\- level : IPPROTO_IP \n    - optname : IP_MULTICAST_IF \n    - optval : struct in_addr \n    \n    // 客户端加入到多播组： \n    - level : IPPROTO_IP \n    - optname : IP_ADD_MEMBERSHIP \n    - optval : struct ip_mreq \n\nstruct ip_mreq { \n    /* IP multicast address of group. */ \n\tstruct in_addr imr_multiaddr; // 组播的IP地址 \n    /* Local IP address of interface. */ \n\tstruct in_addr imr_interface; // 本地的IP地址 \n};\n\ntypedef uint32_t in_addr_t; \nstruct in_addr { \n    in_addr_t s_addr; \n};\n```\n\n## **本地套接字**\n\n\n\n本地套接字的作用：<u>本地的`进程`间通信</u>\n\n> 有关系的进程间的通信\n>\n> 没有关系的进程间的通信\n\n本地套接字实现流程和网络套接字类似，<u>一般采用`TCP`的通信流程。</u>\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220406181306554.png\" alt=\"image-20220406181306554\" style=\"zoom: 80%;\" />\n\n```c++\n// 本地套接字通信的流程 - tcp \n// 服务器端 \n1. 创建监听的套接字 \n    int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); \n\n2. 监听的套接字绑定本地的套接字文件 -> server端 \n    struct sockaddr_un addr; \n    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 \n    bind(lfd, addr, len); \n\n3. 监听\n    listen(lfd, 100); \n\n4. 等待并接受连接请求 \n    struct sockaddr_un cliaddr; \n    int cfd = accept(lfd, &cliaddr, len); \n\n5. 通信\n    接收数据：read/recv \n    发送数据：write/send \n\n6. 关闭连接 \n    close(); \n\n// 客户端的流程 \n1. 创建通信的套接字 \n    int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0); \n\n2. 监听的套接字绑定本地的IP 端口 \n    struct sockaddr_un addr; \n    // 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 \n    bind(lfd, addr, len); \n\n3. 连接服务器 \n    struct sockaddr_un serveraddr; \n    connect(fd, &serveraddr, sizeof(serveraddr)); \n\n4. 通信\n    接收数据：read/recv \n    发送数据：write/send \n\n5. 关闭连接 \n\tclose(); \n\n// 头文件: sys/un.h \n#define UNIX_PATH_MAX 108 \nstruct sockaddr_un { \n\tsa_family_t sun_family; // 地址族协议 af_local \n\tchar sun_path[UNIX_PATH_MAX]; // 套接字文件的路径, 这是一个伪文件, 大小永远=0 \n};\n```\n\n##  TCP和UDP的区别和各自适用的场景\n\n### TCP和UDP区别\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220307000947209-1959210844.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402110554290.png\" alt=\"image-20220402110554290\" style=\"zoom: 67%;\" />\n\n1. 连接\n\n   > TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。\n   >\n   > UDP无连接。\n\n2. 服务对象\n\n   > TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；\n   >\n   > UDP支持一对一，一对多，多对一，多对多的交互通信。\n\n3. 可靠性\n\n   > TCP是可靠交付：无差错，不丢失，不重复，按序到达。\n   >\n   > UDP是尽最大努力交付，不保证可靠交付。\n\n4. 拥塞控制，流量控制\n\n   > TCP有拥塞控制和流量控制保证数据传输的安全性。\n   >\n   > UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。\n\n5.  报文长度\n\n   > TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。\n   >\n   > UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。\n\n6. 首部开销\n\n   > TCP首部开销大，首部20个字节。\n   >\n   > UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）\n\n### TCP和UDP适用场景\n\n从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。\n\n若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如`文件传输、重要状态的更新`等）；反之，则使用 UDP 协议（如`视频传输、实时通信`等）。\n\n## 2.10. Tcp和Udp报文头\n\n### TCP报头结构\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220402110911807.png\" alt=\"image-20220402110911807\" style=\"zoom: 67%;\" />\n\n- 16位端口号，告知主机该报文段来自哪里（`源端口号`）以及传给哪个上层协议或应用程序（`目的端口`）的。TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器使用知名端口号。  \n\n- 32位序号：一次TCP通信过程中某个传输方向上的字节流的`每个字节的编号`。\n\n  第一个报文段中序号值被系统`初始化为某个随机值ISN`，那么该传输方向上后续的TCP报文段中序号值将被系统设置为ISN加上该报文段所携带的第一个字节在整个字节流的`偏移`。   `seq?`\n\n- 32位确认号：用作对另一方发送的TCP报文段的响应。其值是收到的TCP报文段的序号值加1.假如主机A和主机B进行TCP通信，那么A发送的TCP报文段不仅携带自己的序号，还有对B发送来的TCP报文段的确认号。`ack?`\n\n- 4位头部长度：标识该TCP头部有多少个32bit字（4字节），因为4位最大表示15所以TCP头部最长是60字节。   \n\n- 6位标志位：\n\n  > a）URG：表示紧急指针是否有效；\n  >\n  > b）ACK：表示确认号是否有效，携带ACK标志的数据报文段为确认报文段；\n  >\n  > c）PSH：提示接收端的应用程序应该立即从TCP接受缓冲区中读走数据，为接受后数据腾出空间；\n  >\n  > d）RST：表示要求对方重新建立连接，携带RST标志位的TCP报文段称为复位报文段；\n  >\n  > e）SYN： 表示请求建立一个连接，携带SYN标志的TCP报文段称为同步报文段；\n  >\n  > f）FIN：通知对方本端要关闭了，带FIN标志的TCP报文段称为结束报文段；\n\n- 16位窗口大小：指的是接受通告窗口。它告诉接受端自己接受缓冲区还能容纳多少字节的数据。  ==滑动窗口控制==\n\n- 16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法检验报文段在传输中是否损坏，检验TCP头部和数据部分。这是TCP可靠传输的一个重要保障。  ==可靠性校验==\n\n- 16位紧急指针：\n\n  > 已经建立连接的C/S两端中,当某一端发生了比较重要且紧急的事情时,需要在不建立新连接,即在当前连接的基础上将该信息迅速通知到对端,但是在TCP数据传输中肯定要遵循先写入缓冲区的数据先被发送的规则。\n  >\n  > 对于紧急数据的发送,要在TCP数据包首部设置URG标记和紧急指针,以上是可以找到相应的位置,URG 标记是用来让TCP检查紧急指针紧急偏移的,没有的话,是不会检查的,要是有的话,就通过检查紧急指针偏移量来定位紧急数据在TCP 数据部分所处的位置\n  >\n  > 紧急数据字节号(urgSeq)=TCP报文序号(seq)+紧急指针(urgpoint)−1\n  >\n  > 一次只能设置一个字节的紧急数据\n\n- 头部选项\n\n  还有最后一个选项字段是可变长的可选信息，最多40字节。。。\n\n### UDP首部\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321122023259.png\" alt=\"image-20220321122023259\" style=\"zoom:67%;\" />\n\n8字节。\n\n源端口，目的端口，数据长度，校验和\n\n每个占2字节\n\n## 2.11. 如何解决tcp通信中的粘包问题？\n\n短链接tcp不会粘包\n\n发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。\n\nTCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。  ==（极端情况，不同格式的信息的一起发送，可能是发送方封到了一个包，也可能是接收方一起接收）==\n\n### **造成TCP粘包的原因**\n\n1. 发送方原因\n\n   > TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：\n   >\n   > 只有上一个分组得到确认，才会发送下一个分组\n   >\n   > 收集多个小分组，在一个确认到来时一起发送\n   >\n   > Nagle算法造成了发送方可能会出现粘包问题\n\n2. 接收方原因\n\n   > TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。\n\n### **什么时候需要处理粘包现象？**\n\n1. 如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象\n\n2. 如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了\n\n### **处理粘包**\n\n1. 发送方\n\n   对于发送方造成的粘包问题，可以通过`关闭Nagle算法`来解决，使用TCP_NODELAY选项来关闭算法。\n\n2. 接收方\n\n   ==接收方没有办法==来处理粘包现象，只能将问题交给应用层来处理。\n\n3. ==应用层==\n\n   应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。\n\n   > 解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？\n   >\n   > `格式化数据`：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。（或者加包头）\n   >\n   > ==发送长度==：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。 （可能是最优方案了）\n   >\n   > 还有，定长发送，尾部标记序列（不好，难以设计，而且需要每次检测是否为标记）等~\n\n \n\nUDP则是面向消息传输的，是`有保护消息边界`的，接收方一次只接受一条独立的信息，所以不存在粘包问题。\n\n## 2.12. 如何用UDP实现可靠传输？\n\n- UDP要想可靠，就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，\n\n  > <u>==确认重传机制==</u>\n\n- 每个包有递增的序号，接收方发现中间丢了包就要发重传请求，\n\n  > <u>==序号机制==</u>\n\n- 当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。\n\n  > ==<u>窗口机制</u>==\n\n- 恭喜你， 你在`应用层`重新实现了TCP！\n\n# 3. 应用层\n\n## 3.1.   请你来说一说http协议\n\n### HTTP协议\n\n> HTTP协议是Hyper Text Transfer Protocol（超`（超越文本，不止文本）`文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。\n>\n> HTTP是一个`基于TCP/IP`通信协议来传递-数据（HTML 文件，图片文件，查询结果等）。\n>\n> HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n>\n\n### HTTP协议特点\n\n1. <u>==简单快速==</u>：\n- 客户向服务器请求服务时，<u>只需传送`请求方法`和`路径`。</u>请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n  \n2. <u>==灵活==</u>：\n   - <u>HTTP允许传输`任意类型`的数据对象</u>。正在传输的类型由Content-Type加以标记。\n3. <u>==无连接==</u>：\n- 无连接的含义是<u>限制每次连接只处理一个请求</u>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n  \n4. <u>==无状态==</u>：\n- HTTP协议是无状态协议。无状态是指协议<u>对于事务处理没有记忆能力</u>。\n  \n     > 缺少状态意味着如果后续处理需要前面的信息，则它`必须重传`，这样可能导致每次连接传送的数据量增大。\n     >\n     > 另一方面，在服务器不需要先前信息时它的`应答就较快`。\n\n5. 支持B/S（Browser/Server）及C/S（Client/Server）模式。\n\n6. 默认端口80\n\n7. 基于TCP协议\n\n### HTTP过程概述\n\nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。\n\nHTTP协议采用了`请求/响应模型`。\n\n> 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。\n>\n> 服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n#### HTTP 请求/响应的步骤\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/810603-20181003135126150-732067779.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n1. ==<u>客户端连接到Web服务器</u>==\n\n   一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）`建立一个TCP套接字连接`。\n\n2. `发送HTTP`请求\n\n   `通过TCP`套接字，客户端向Web服务器发送一个文本的`请求报文`，一个请求报文由`请求行、请求头部、空行和请求数据`4部分组成。\n\n3. 服务器接受请求并返回HTTP响应\n\n   Web服务器`解析请求`，`定位请求资源`。服务器将资源复本`写到TCP`套接字，`由客户端读取`。一个响应由`状态行、响应头部、空行和响应数据`4部分组成。\n\n4. 释放连接TCP连接\n\n   若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;\n\n   若connection 模式为keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n\n5. 客户端浏览器解析HTML内容\n\n   客户端浏览器首先`解析状态行`，查看表明请求`是否成功`的状态代码。然后`解析每一个响应头`，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器`读取响应数据HTML`，根据HTML的语法对其进行`格式化`，并在浏览器窗口中显示。\n\n## 3.2.   [HTTP 报文格式](https://www.cnblogs.com/huansky/p/14007810.html)\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220307170622062-814095231.png\" alt=\"img\" style=\"zoom: 25%;\" />\n\n### HTTP请求报文：\n\n一个HTTP请求报文由`请求行`（request line）、`请求头部`（header）、`空行`和`请求数据`4个部分组成，下图给出了请求报文的一般格式。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220307170825890-1826934569.png\" alt=\"img\" style=\"zoom: 25%;\" />\n\n```c++\n//www.baidu.com的请求报文\nGET / HTTP/1.1\nHost: www.baidu.com  //请求行  后面是请求头\n  \nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate, br   //允许的压缩编码格式\nConnection: keep-alive   //连接状态\nCookie: BAIDUID=6729CB682DADC2CF738F533E35162D98:FG=1; //本地缓存的用户信息\nBIDUPSID=6729CB682DADC2CFE015A8099199557E; PSTM=1614320692; BD_UPN=13314752;\nBDORZ=FFFB88E999055A3F8A630C64834BD6D0;\n__yjs_duid=1_d05d52b14af4a339210722080a668ec21614320694782; BD_HOME=1;\nH_PS_PSSID=33514_33257_33273_31660_33570_26350;\nBA_HECTOR=8h2001alag0lag85nk1g3hcm60q\nUpgrade-Insecure-Requests: 1\nCache-Control: max-age=0\n    \t\t\t\t\t//空行\n    正文\n```\n\n1. 请求行：请求行分为三个部分：`请求方法`、`请求地址`和`协议版本`。\n\n   > - 请求方法：HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。\n   >\n   >   ​\t最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。\n   >\n   > - 请求地址：URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。\n   >\n   >   ​\t组成：<协议>：//<主机>：<端口>/<路径>\n   >\n   >   ​\t端口和路径有时可以省略（HTTP默认端口号是80）\n   >\n   > - 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1\n\n2. 请求头部：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。\n\n   请求头部`通知服务器有关于客户端请求的信息`，典型的请求头有：\n\n   > User-Agent：产生请求的`浏览器类型`。\n   >\n   > Accept：客户端可识别的`内容类型列表`。\n   >\n   > Host：请求的`主机名`，允许多个域名同处一个IP地址，即虚拟主机。\n   >\n   > Connection：是否保持长连接\n   >\n   > Cookie：HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。\n   >\n   > Content-Length：请求的`内容长度`\n   >\n   > Range:实现`断点续传`\n\n3. 实体主体：实体主体即请求数据，不在GET方法中使用，而是在POST方法中使用。 （`例如账号密码`）\n\n   POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。\n\n### HTTP响应报文\n\nHTTP响应也由4个部分组成，分别是：`状态行`、`响应头部`、空行，`响应正文`（实体主体）。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220307170831822-466958194.png\" alt=\"img\" style=\"zoom: 25%;\" />\n\n```c++\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xf3c9743300024ee4\nCache-Control: private\nConnection: keep-alive\nContent-Encoding: gzip   //压缩编码格式\nContent-Type: text/html;charset=utf-8\nDate: Fri, 26 Feb 2021 08:44:35 GMT\nExpires: Fri, 26 Feb 2021 08:44:35 GMT\nServer: BWS/1.1\nSet-Cookie: BDSVRTM=13; path=/\nSet-Cookie: BD_HOME=1; path=/\nSet-Cookie: H_PS_PSSID=33514_33257_33273_31660_33570_26350; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nTraceid: 1614329075128412289017566699583927635684\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n    \t\t\t\t\t\t//空行\n    响应正文\n```\n\n\n\n其中，版本（HTTP-Version）表示服务器HTTP协议的版本；状态码（Status-Code）表示服务器发回的响应状态代码；短语（Reason-Phrase）表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。\n\n- #### [状态码对应的含义：](https://www.jianshu.com/p/b58025e61b2d)\n\n  > 1xx：指示信息--表示请求已接收，`请继续`处理。 \n  >\n  > 2xx：`成功`--表示请求已被成功接收、理解、接受。\n  >\n  > 3xx：`重定向`--要完成请求必须进行更进一步的操作。\n  >\n  > 4xx：`客户端错`误--请求有语法错误或请求无法实现。    ==404 Not Found==\n  >\n  > 5xx：`服务器端错`误--服务器未能实现合法的请求。\n\n响应头部与相应正文则与请求头部及请求数据向对应。\n\n \n\n## 3.3.   HTTP返回码\n\n| 状态码 | 类别                             | 含义                       |\n| :----- | :------------------------------- | :------------------------- |\n| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |\n| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |\n| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |\n| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |\n| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出           |\n\n##### [1xx 信息](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=1xx-信息)\n\n- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n##### [2xx 成功](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=2xx-成功)\n\n- **200 OK**    ==ok==\n- **204 No Content** ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 ==<u>（你没有请求数据，所有我的回复没有数据段）</u>==\n- **206 Partial Content** ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。<u>==（范围回复）==</u>\n\n##### [3xx 重定向](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=3xx-重定向)\n\n> URL 重定向，也称为 `URL 转发`，是一种当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects）来执行此类操作。\n>\n> 重定向可实现许多目标：\n>\n> - 站点维护或停机期间的临时重定向。\n> - 永久重定向将在更改站点的URL，上传文件时的进度页等之后保留现有的链接/书签。\n> - 上传文件时的表示进度的页面。\n\n- **301 Moved Permanently** ：永久性重定向\n- **302 Found** ：临时性重定向\n- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n##### [4xx 客户端错误](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=4xx-客户端错误)\n\n- **400 Bad Request** ：请求报文中存在语法错误。   ==我不理解==\n- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 ``\n- **403 Forbidden** ：请求被拒绝。  ==403 Forbidden==\n- **404 Not Found**           `==404` not found==\n- **405 Not Allowed**             ==达咩==\n- **406 无法接受**         ==无法接受==\n\n##### [5xx 服务器错误](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=5xx-服务器错误)\n\n- **500 Internal Server Error** ：服务器正在执行请求时发生错误。     ==Internet server error==\n- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n## 3.4.   http工作模式？？\n\n单工： 数据传输只允许在一个方向上的传输，只能一方来发送数据，另一方来接收数据并发送。例如：广播\n\n半双工：数据传输允许两个方向上的传输，但是同一时间内，只可以有一方发送或接受消息。例如：对讲机\n\n全双工：同时可进行双向传输。例如：websocket\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306213925564-430600494.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n> `http1.0：单工`。因为是短连接，客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接。\n>\n> `http1.1：半双工`。默认开启长连接keep-alive，开启一个连接可发送多个请求。\n>\n> `http2.0：全双工`，允许服务端主动向客户端发送数据。\n\n\n\n## 3.5.   HTTP1.0和1.1的区别\n\n1. HTTP 1.1支持`长连接`（PersistentConnection）和请求的`流水线`（Pipelining）处理   (==<u>长连接 半双工</u>==)\n\n   > HTTP 1.0规定浏览器与服务器只保持`短暂的连接`，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。\n   >\n   > HTTP 1.1则`支持持久连接`Persistent Connection, 并且默认使用persistent connection. <u>在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段)。</u>HTTP 1.1还<u>允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</u>，但服务器端必须按照接收到客户端请求的<u>先后顺序依次回送响应结果，</u>以保证客户端能够区分出每次请求的响应内容。\n\n2. 宽带和网络连接优化: `100(Continue) Status`   (==<u>1. range 2. 只发送header</u>==)\n\n   > - <u>http1.0中会存在一些性能浪费</u>,比如我们的只需要对象中的一部分,但是每次请求返回的却是`整个对象`,这无疑造成了性能的损害\n   >\n   >   http1.1则不然,它可以通过在请求头处`设置range头域`,就可以`返回请求资源的某一部分`,也就是返回码为206(Partial Content)的时候,这对于性能优化很有必要. 这里所谓的请求资源的一部分,也就是大家常说的断点续传\n   >\n   > - HTTP1.1支持`只发送header信息`（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了`节约了带宽`。\n\n3. `HOST`域\n\n   > 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。\n   >\n   > ==(ip地址下更细分)==\n\n4. `错误通知`的管理  （<u>==更多的错误通知==</u>）\n\n   > 在HTTP1.1中`新增`了24个`错误状态响应码`，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\n### 断点续传是怎么实现的  \n\n**可使用HTTP报文首部字段==Range==实现范围请求**\n\n- 对一份10000字节大小的资源，如果使用范围请求，可只请求5001~10000字节内的资源。\n\n- 执行范围请求时，会用到HTTP首部字段Range来指定资源的byte范围。形式如下：\n\n  5001~10000字节\n\n  > Range:bytes=5001-10000\n\n  从5001字节之后全部的\n\n  > Range:bytes=5001-\n\n  从1开始到3000字节和从5000开始到7000字节的多重范围\n\n  > Range:bytes=-3000,5000-7000\n\n- 针对范围请求，响应会返回状态码为<u>==206==</u> Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart/byteranges后返回响应报文。\n- <u>如果服务器无法响应范围请求</u>，则会返回状态码<u>==200 OK和完整的实体内容==</u>。\n\n因此，在进行断点续传时，只需使用范围请求，通过指定HTTP请求报文首部字段Range来请求尚未收到的资源。\n\n##  [HTTP采用keepalive模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？](https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html#!comments)\n\n1. 当使用普通模式，也就是http1.0没有keepalive模式时，HTTP协议中客户端发送一个小请求，服务器响应以所期望的信息（例如一个html文件或一副gif图像）。`服务器通常会在发送完请求的数据之后就关闭连接`。这样客户端读数据时会返回`EOF`（-1），就知道数据已经接收完全了\n\n2. ##### 使用消息首部字段Content-Length\n\n   故名思意，`Conent-Length表示实体内容长度`，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Content-Length呢？ （==<u>静态页面的请求</u>==）\n\n   ##### 使用消息首部字段Transfer-Encoding\n\n   当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用\"Transfer-Encoding: chunked\"这样的方式来代替Content-Length。\n\n   chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明**长度为0**的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（**十六进制的数字**）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用**回车换行(CRLF)**隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。\n\n## http协议请求类型有哪几种\n\n- <u>GET：向特定的资源发出请求。</u>\n\n- <u>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）</u>。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。\n\n- <u>PUT：向指定资源位置上传其最新内容。</u>\n\n- DELETE：请求服务器删除Request-URI所标识的资源。\n\n- TRACE：回显服务器收到的请求，主要用于测试或诊断。\n\n- OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*'的请求来测试服务器的功能性。\n\n- HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。\n\n- CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n## 请你来说一下GET和POST的区别\n\n1. ==功能==不同\n\n   > get是从服务器上`获取`数据。post是向服务器`传送`数据。\n\n2. ==请求方式==不同\n\n   > 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n   >\n   > 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）\n   >\n   > GET产生`一个`TCP数据包；POST产生`两个`TCP数据包。\n\n3. ==安全性==不同\n\n   > POST安全性相对较高。 \n   >\n   > <u>GET请求参数会被完整保留在浏览器历史记录里</u>，而POST中的`参数不会被保留`。  \n   >\n   > GET 是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。\n   >\n   > GET参数直接暴露在URL上\n   >\n   > <u>Ex: 如果使用get 提交用户名和密码 用户名和密码会暴露在url中 `很不安全</u>`\n\n4. 传送`数据量`不同\n\n   > get参数通过url传递，post放在request body中。\n   >\n   > get传送的`数据量`较小，不能大于2KB （这主要是因为受URL长度限制）。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 \n\n5. 获取`值`不同\n\n   > 对于get方式，服务器端用Request.QueryString获取变量的值。对于post方式，服务器端用Request.Form获取提交的数据\n\n6. 方式、类型不同\n\n   > GET请求只能进行`url编码`，而POST支持多种编码方式。\n   >\n   > 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\n\n## 3.6.   http1.x和2.0的区别\n\n1. ==<u>二进制</u>==分帧\n\n   > 在应用层(HTTP/2)和传输层(TCP or UDP)之间`增加一个二进制分帧层`。\n   >\n   > HTTP2使用的是`二进制传送`，HTTP1.X是`文本（字符串）传送`。二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示\n   >\n   > 在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。  **(基于文本则数据必须按顺序传送)**\n\n2. `多路复用`  （==<u>减少tcp</u>==）\n\n   > 在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。 `（多个tcp浪费资源）`\n   >\n   > HTTP2中同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。单个连接上可以并行交错的请求和响应，之间互不干扰。  `（tcp并行复用 节省资源）`         ==<u>TCP复用到底是1.1还是2.0新增的？</u>==\n   >\n   > TCP 慢启动原本就具有突发性和短时性的 HTTP 连接变的十分低效。  `（tcp比http慢很多 所以要少用tcp,进行tcp单连接复用）`\n   >\n   > HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。\n\n3. `首部压缩`   \n\n   > 在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接以纯文本传输。   `（http1压缩消息主体，但是不对状态行和头部进行压缩）`\n   >\n   > 头部压缩需要在支持 HTTP/2 的浏览器和服务端之间：\n   >\n   > 1. 维护一份相同的`静态字典`（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；\n   >\n   > 2. 维护一份相同的`动态字典`（Dynamic Table），可以动态的添加内容；\n   >\n   > 3. 支持基于静态哈夫曼码表的`哈夫曼编码`（Huffman Coding）；\n\n4. HTTP2支持`服务器推送`\n\n   > 服务端推送是一种在客户端请求之前发送数据的机制。当代网页使用了许多资源:HTML、样式表、脚本、图片等等。在HTTP/1.x中这些资源每一个都必须明确地请求。这可能是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，`网络经常是空闲的和未充分使用的`。\n   >\n   > 为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络。    `（为了充分利用网络空闲，主动推送附加资源）`\n\n## HTTP1.1协议中的持久连接和HTTP2.0协议中的多路复用有什么区别？\n\n> 相当于你们家跟你叔叔家打电话：\n>\n> 一个是你把跟你叔叔聊完后，不挂电话，你妈和你婶婶聊，你跟你堂兄弟姐妹聊。 （==<u>长连接 半双工 串行</u>==）\n>\n> 一个是你们家3口人和你叔叔家三口人同时一对一聊天。  （==<u>多路复用</u>==）\n\n- 所谓持久连接，就是重用下之前的连接，`明显连接一次只能一个请求/应答消息`。\n- 多路复用（multiple access），就是`多个http请求/应答使用一个链接`。\n\n## 3.7.   websocket\n\n## **HTTP 特性**\n\n### **HTTP（1.1） 的优点有哪些？**\n\n HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。\n\n1. 简单\n\n   HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。\n\n2. 灵活和易于扩展\n\n   HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。\n\n   同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**。\n\n   HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。\n\n3. 应用广泛和跨平台\n\n   互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。\n\n### **HTTP（1.1） 的缺点有哪些？**\n\nHTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。\n\n1. ==<u>无状态</u>==双刃剑\n\n   无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务\n\n   无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。\n\n   例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。\n\n   这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是**酸爽**！\n\n   对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。\n\n   `Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。\n\n   相当于，**在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**，\n\n2. ==<u>明文传输</u>==双刃剑\n\n   明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。\n\n   但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那**你号没了**。\n\n3. ==<u>不安全</u>==\n\n   HTTP 比较严重的缺点就是不安全：\n\n   - `通信使用明文`（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**\n   - `不验`证通信方的`身份`，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**\n   - 无法证明报文的`完整性`，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**\n\n### **HTTP/1.1 的性能如何？**\n\nHTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。\n\n1. ==<u>长连接</u>==\n\n   早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。\n\n   为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。\n\n   持久连接的特点是，<u>只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</u>。\n\n   当然，如果某个 HTTP 长<u>连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接</u>。\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-9661e23be694cfe3c0a4ffe94eb1b26d_r.jpg)\n\n2. ==<u>管道网络传输</u>==\n\n   HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。\n\n   即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**\n\n   举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图：\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-86c8867af6b3bd47a22a25951ae6d871_b.jpg)\n\n   但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。\n\n   注意，是<u>按照服务端收到的请求顺序响应</u>   （<u>==既然二进制了 是不是可以给请求按顺序编号？==</u>），并不管哪个请求是先发送的，假设客户端先发送 A 请求，后发送 B 请求，如果服务端先收到 B 请求，就先响应 B 请求，然后再响应 A 请求，但是假设处理 B 请求的时候，耗时比较长，那么请求 A 的响应就会被阻塞，这称为「队头堵塞」。\n\n   所以，**HTTP/1.1 管道解决了请求的队头阻塞？，但是没有解决响应的队头阻塞**\n\n3. <u>==队头阻塞==</u>\n\n   「请求 - 应答」的模式加剧了 HTTP 的性能问题。\n\n   因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-8f91790ce19f64d6b631a53f0a9be2db_b.jpg)\n\n   总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。\n\n## 3.8.   HTTP和HTTPS的区别，以及HTTPS有什么缺点？\n\n>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加`高效`，使`网络传输减少`。\n>\n>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。\n>\n>HTTPS协议的主要作用可以分为两种：一种是<u>建立一个`信息安全通道`，来保证数据传输的安全</u>；另一种就是<u>`确认网站的真实性`</u>。\n\n### [HTTPS](https://segmentfault.com/a/1190000021494676)：1. ssl握手 2. 证书\n\n> 应用tls协议 进行 ssl层握手     （==<u>信息安全通道</u>==）\n>\n> 根据证书 验证网站的安全合法存在  （==<u>确认网站的真实性</u>==）\n\n<u>**T**ransport **L**ayer **S**ecurity **传输层安全性协议**</u>\n\n<u>**S**ecure **S**ockets **L**ayer **安全套接层**</u>\n\n### HTTP协议和HTTPS协议`区别`如下：\n\n1. HTTP协议是以`明文`的方式在网络中传输数据，而HTTPS协议传输的数据则是经过`TLS加密`后的，==HTTPS具有更高的安全性==\n2. HTTPS在TCP三次握手阶段之后，还需要进行`SSL 的handshake`，协商加密使用的`对称加密密钥`\n3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根==证书==\n4. HTTP协议端口是80，HTTPS协议端口是443\n\n[HTTPS 之 SSL/TLS 握手协议（Handshake Protocol）全过程解析 - 简书 (jianshu.com)](https://www.jianshu.com/p/07a1e362e1ba)\n\n### HTTPS优点：\n\nHTTPS传输数据过程中`使用密钥进行加密，所以安全性更高`\n\nHTTPS协议可以`认证用户和服务器`，`确保数据发送到正确`的用户和服务器\n\n> 1. 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n> 2. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。\n> 3. HTTPS是`现行架构下最安全`的解决方案，虽然`不是绝对安全`，但它大幅`增加了中间人攻击的成本`。\n> 4. 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。\n\n### HTTPS缺点：\n\nHTTPS<u>==握手阶段延时较高==</u>：由于在进行HTTP会话之前还需要进行`SSL握手`，因此HTTPS协议握手阶段`延时增加`\n\nHTTPS<u>==部署成本高==</u>：一方面HTTPS协议需要使用`证书来验证`自身的安全性，所以需要`购买CA证书`；另一方面由于采用HTTPS协议需要进行加`解密`的计算，`占用CPU资源`较多，需要的服务器配置或数目高\n\n> 1. HTTPS协议握手阶段比较费时，会使页面的加载时间延长近`50%`，增加10%到20%的耗电；\n> 2. HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\n> 3. SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。\n> 4. SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。\n> 5. HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。\n\n \n\n数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。\n\n**CA**证书（可以防止中间人攻击）：\n\nCA证书是一种权威的电子文档,用于证明某一主体(如组织机构)的身份合法性,又称为网络的身份证。证书是由权威公正的第三方机构签发的，以确保网上传递信息的机密性、完整性，以及交易实体身份的真实性,信息的不可否认性,从而保障网络应用的可靠性。\n\n## **HTTP 与 HTTPS**\n\n### **HTTP 与 HTTPS 有哪些区别？**\n\n1. HTTP 是超文本传输协议，信息是`明文传输`，存在`安全风险`的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS `安全协议`，使得报文能够`加密传输`。\n2. HTTP 连接建立相对`简单`， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的`握手`过程，才可进入加密报文传输。\n3. HTTP 的`端口`号是 80，HTTPS 的端口号是 443。\n4. HTTPS 协议需要向 CA（证书权威机构）申请`数字证书`，来保证服务器的身份是可信的。\n\n### **HTTPS 解决了 HTTP 的哪些问题？**\n\nHTTP 由于是明文传输，所以安全上存在以下三个风险：\n\n- **窃听风险**，比如通信链路上可以获取`通信内容`，用户号容易没。   ==<u>（信息容易被窃取）</u>==\n- **篡改风险**，比如`强制植入`垃圾广告，视觉污染，用户眼容易瞎。  ==<u>（缺少数据的完整校验）</u>==\n- **冒充风险**，比如`冒充`淘宝网站，用户钱容易没。     ==<u>（缺少网站的真实校验）</u>==\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-ea7333e2c048671d11d41c5a013b1e57_r.jpg)\n\nHTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险：\n\n- **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。     ==<u>（混合加密）</u>==\n- **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。  <u>==（完整内容的唯一hash）==</u>\n- **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。     ==<u>（证书校验机制）</u>==\n\n可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。\n\n#### HTTPS 是如何解决上面的三个风险的？\n\n- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。\n- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。\n- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。\n\n## 加密算法\n\nHTTPS 解决数据传输安全问题的方案就是使用加密算法，具体来说是`混合加密算法`，也就是对称加密和非对称加密的混合使用，这里有必要先了解一下这两种加密算法的区别和优缺点。\n\n### 1. 对称加密\n\n对称加密，顾名思义就是`加密和解密都是使用同一个密钥`，常见的对称加密算法有 DES（Data Encryption Standard）、3DES 和 AES 等，其优缺点如下：\n\n- 优点：算法公开、计算量小、加密速度快、加密`效率高`，适合加密比较大的数据。\n- 缺点：\n  1. 交易双方需要使用相同的密钥，也就<u>无法避免密钥的传输</u>，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。  <u>==（密钥在传输中仍然可能被截获）==</u>\n  2. 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，[密钥管理](https://link.segmentfault.com/?enc=ue%2Bb8jIV3ClgNvpQRxREtg%3D%3D.NSuaakxo1dtKPyYdkpx5juKUSvvMwcH2CZvVVAAZeNMYgy0qPHjkz5y4H8HfsXFu)成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。<u>==（密钥唯一，变多 管理负担）==</u>\n\n不对具体的加密算法做详细介绍，可以参考 [对称加密算法详解](https://link.segmentfault.com/?enc=UyJybS0fpwfGVIDnSlCQXA%3D%3D.yJngp8X2cK4CK3Vn9uNYKamXIrv1FkUDqf2WyZmuap5koz0Ud0Pbm69K9P0en2b5nw3kxwKl3ChHqGU34enItQ%3D%3D)，\n\n![对称加密数据传输过程](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/3668516017-5e183a4c9cbfd_fix732)\n\n从图中可以看出，被加密的数据在传输过程中是无规则的乱码，即便被第三方截获，在没有密钥的情况下也无法解密数据，也就保证了数据的安全。但是有一个致命的问题，那就是既然双方要使用相同的密钥，那就必然要在传输数据之前先由一方把密钥传给另一方，那么在此过程中<u>==**密钥就很有可能被截获**==</u>，这样一来加密的数据也会被轻松解密。那如何确保密钥在传输过程中的安全呢？这就要用到`非对称加密`了。\n\n### 2. 非对称加密\n\n非对称加密，顾名思义，就是加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥对外公开；得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的私钥对加密后的信息进行解密。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。常用的非对称加密算法是 RSA 算法，想详细了解的同学点这里：[RSA 算法详解一](https://link.segmentfault.com/?enc=1N1DkxVrzw9slfAFvtB8zQ%3D%3D.DIMIymEV%2FnTMtRqgoXpxZx1L1Mq3zBRALGGEYcsquJb%2FxBjtSZrkcKf6TI7kbefS1TYJsTVP2KYTS9LxNxWMKo2hWw5bQRhFzam5GHMK6mo%3D)、[RSA 算法详解二](https://link.segmentfault.com/?enc=sIsYjXiPHcdxFzuLJ1Bj7Q%3D%3D.%2BUNw9hpET8m8mu7xFls6DPBFWlMsJ4ZjQXvwi3cCC57Buw6FV%2B4WEjSd17Ozv%2F5uviS2jE2KzNSIZucBEflIJ6LKnpSEHWJdG6q%2B6zKoKi0%3D)，其优缺点如下：\n\n- 优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，`安全性很高`。\n- 缺点：`计算量比较大`，加密和解密速度相比对称加密慢很多。\n\n由于非对称加密的强安全性，可以用它完美解决对称加密的密钥泄露问题，效果图如下：\n\n![客户端通过非对称加密把密钥 KEY 发送给服务器](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/959982414-5e11d6393cab7_fix732)\n\n在上述过程中，客户端在拿到服务器的公钥后，会生成一个随机码 (用 KEY 表示，这个 KEY 就是后续双方用于对称加密的密钥)，然后客户端使用公钥把 KEY 加密后再发送给服务器，服务器使用私钥将其解密，这样双方就有了同一个密钥 KEY，然后双方再使用 KEY 进行对称加密交互数据。在非对称加密传输 KEY 的过程中，即便第三方获取了公钥和加密后的 KEY，在没有私钥的情况下也无法破解 KEY (私钥存在服务器，泄露风险极小)，也就保证了接下来对称加密的数据安全。而上面这个流程图正是 HTTPS 的雏形，HTTPS 正好综合了这两种加密算法的优点，不仅保证了通信安全，还保证了数据传输效率。\n\n## 3.9.   SSL加密\n\nhttps使用的是对称加密和非对称加密的结合方式。我们的证书验证部分采用的是非对称加密，信息传输部分采用的是对称加密\n\n### **加密过程**\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2641864607-5e11d65c74244\" alt=\"img\" style=\"zoom: 50%;\" />\n\n1. 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式\n\n2. 服务端B接收到这些信息后确认加密方式（比如TLS 1.0版本）+自己的安全证书（包含自己的公钥，为了保证公钥的安全性，上级CA用自己的私钥对数字证书进行签名）+一个随机数发给A\n\n3. 客户端A确认数字证书有效性（内置CA证书），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。\n\n4. 服务端B使用自己的私钥解密这个随机数\n\n5. A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）\n\n### 安全性保证：\n\n1. 双方通信内容的安全性是靠<u>公钥加密、私钥解密</u>来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证。\n\n2. 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，**为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书**，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了。\n\n3. 数字证书是由上级 CA 签发给个人 / 组织的，**上级** **CA** **用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA** **证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。**那么安全性就是由上级 CA 证书的正确性保证的了。\n\n4. 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以<u>根证书就是这个信任链最重要的部分</u>。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了。\n\n5. 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。\n\n## 3.10. 为什么对称加密和非对称加密一起用？\n\n对称加密：\n\n- 首先：非对称加密的加解密效率是非常`低`的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的`效率是无法接受`的。\n\n- 另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。\n\n非对称加密：\n\n- 只有服务器可以用自己的私钥来解密客户端的随机数，生成对话用的对称密钥。确保对称密钥的安全性。\n\n> 1. `非对称加密的效率`低到无法接受，所以数据传输要使用对称加密\n>\n> 2. 非对称加密`更加安全` 所以必须使用\n\n## 3.11. 报文被篡改会怎么样？怎么解决？\n\n在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以`修改截获后的密文`修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。 <u>==**（虽然不知道你发的内容，但是可以做破坏）**==</u>\n\n**〖解决方法〗**\n\n- 在每次发送信息时，先==对信息的内容进行一个hash计算得出一个hash值==，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。\n\n## 3.12. HTTPS中间人攻击，劫持证书、改造证书怎么办\n\n### 为什么需要 CA 认证机构颁发证书？\n\n> <u>==**证书的一个重要作用就是验证公钥的合法性**==</u>\n\nHTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。\n\n首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的**“中间人攻击”**问题。\n“中间人攻击”的具体过程如下：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-7d13993d2f522f2d478f68d091129cc5_r.jpg\" alt=\"preview\" style=\"zoom:80%;\" />\n\n### 中间人攻击过程原理：\n\n1. 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器\n2. 中间人服务器返回中间人自己的证书\n3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输\n4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密\n5. 中间人以客户端的请求内容再向正规网站发起请求\n6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据\n7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密\n8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输\n9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密\n\n由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但<u>客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取</u>。\n\n### 浏览器是如何确保 CA 证书的合法性？\n\n#### 1. 证书包含什么信息？\n\n- 颁发机构信息\n- 公钥\n- 公司信息\n- 域名\n- 有效期\n- 指纹\n- 等\n\n#### 2. 证书的合法性依据是什么？\n\n首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，<u>只要是权威机构生成的证书，我们就认为是合法的</u>。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。\n\n#### 3. 浏览器如何验证证书的合法性？\n\n浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：\n\n> 1. `验证域名、有效期`等信息是否正确。证书上都有包含这些信息，比较容易完成验证；\n>\n> 2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成`来源验证`；\n>\n>    ![WX20191127-084216@2x.png](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102123017.webp)\n>\n> 3. `判断证书是否被篡改`。需要与 CA 服务器进行校验；\n>\n> 4. `判断证书是否已吊销`。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率\n\n以上任意一步都满足的情况下浏览器才认为证书是合法的。\n\n\n\n### `劫持证书、改造证书怎么办`\n\nSSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要<u>先将自己接入到客户端和目标网站之间</u>；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；\n\n数字证书就是申请人将一些必要信息（包括公钥、姓名、电子邮件、有效期）等提供给 CA，CA*（数字证书认证机构）*在通过各种手段确认申请人确实是他所声称的人之后，用自己的私钥对申请人所提供信息计算散列值进行加密，形成数字签名，附在证书最后，再将数字证书颁发给申请人，申请人就可以使用 CA 的证书向别人证明他自己的身份了。对方收到数字证书之后，只需要用 CA 的公钥解密证书最后的签名得到加密之前的散列值，再计算数字证书中信息的散列值，将两者进行对比，只要散列值一致，就证明这张数字证书是有效且未被篡改过的。\n\n对于客户端来说，如果中间人伪造了证书，`在校验证书过程中会提示证书错误`，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据\n\n## 3.13. DNS域名解析过程\n\nDNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。\n\n域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102157429.jpeg)\n\n根域名服务器： 知道所有的顶级域名服务器的域名和IP地址。\n\n顶级域名服务器： 负责管理自己下面注册的所有二级域名服务器\n\n权限域名服务器： 负责一个区的域名服务器\n\n本地域名服务器： 当一个主机发出DNS请求时，这个查询请求报文就是发送给了本地域名服务器\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102201792.jpeg)\n\n1. <u>浏览器</u>会`检查缓存`中有没有域名对应的ip地址，这个缓存是有过期时长的，一般是几分钟到几小时不等。\n\n2. 如果浏览器缓存没有，那么就`检查操作系统的host文件`，linux在/etc/hosts文件中配置。\n\n3. 如果本地也没有配置那么就会`根据向本机配置的本地区DNS域名服务器（LDNS）发起请求`，如果你是通过学校连接互联网的一般是你学校的DNS服务器，如果你是在小区连接互联网的一般是网络提供商比如电信，联通的DNS服务器，DNS服务器通常不会太远。如何查看本机的域名服务器，在Linux可以通过 cat /etc/resolv.conf查看。\n\n4. `如果LDNS也不能解析，那么就直接到根域名服务器请求解析`。\n\n5. 根域名服务器会给本地域名服务器LDNS一个所查询的`主域名服务器（gTLD）地址`，gTLD是国际顶级域名服务器，比如.com,.cn,.org等。\n\n6. 本地域名服务器LDNS再向上一步返回的`gLTD服务器发送请求`。\n\n7. gLTD服务器查询并返回域名对应的`Name Server域名服务器的地址`，通常是你注册的域名服务器，例如你在某个域名服务器提供商申请的域名，那么这个域名解析任务就由这个域名服务提供商来完成。\n\n8. Name Server域名服务器会查询存储的`域名和ip的映射关系表`，将ip连同一个TTL值返回给DNS Server域名服务器。\n\n9. LDNS拿到ip和TTL会缓存起来，缓存时间由TTL值控制。\n\n10. 把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。\n\n\n> （1）递归查询：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IPq地址告诉本机。\n>\n> （2）迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。\n>\n> 一般由DNS工作站提出的查询请求便属于递归查询。一般发生在客户端与服务器间，也有特殊情况是dns服务器与dns服务器之间。\n>\n> 根域名服务器总应该使用迭代查询，而不应该使用递归查询。一般的，每次指引都会更靠近根服务器（向上），查寻到根域名服务器后，则会再次根据提示向下查找。\n>\n\n# 4.    网络层、数据链路层\n\n## [网络层常见协议](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=78、网络层常见协议？可以说一下吗？)\n\n| 协议 | 名称                 | 作用                                                         |\n| :--- | :------------------- | :----------------------------------------------------------- |\n| IP   | 网际协议             | IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |\n| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |\n| RIP  | 路由信息协议         | 使用“跳数”(即metric)来衡量到达目标地址的路由距离             |\n| IGMP | Internet组管理协议   | 用于实现组播、广播等通信                                     |\n\n## 4.1.   [交换机、路由器的概念，并知道各自的用途](https://www.zhihu.com/search?q=交换机&type=content)\n\n### 4.1.1.  交换机\n\n- 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，<u>当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。</u>\n\n- 交换机工作于OSI参考模型的第二层，即==数据链路层==。交换机内部的CPU会在每个端口成功连接时，通过==ARP协议==学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。\n\n  ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102343874.jpeg)\n\n### 4.1.2.  路由器\n\n路由器（Router）是一种计算机网络设备，提供了`路由`与`转发`两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转送。路由工作在OSI模型的第三层——即<u>==**网络层**==</u>，例如==<u>**IP协议**</u>==。\n\n路由器的一个作用是`连通不同的网络`，另一个作用是`选择信息传送的线路`。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102346884.jpeg)\n\n### 路由器和交换机对比：\n\n**1、外形上**\n交换机通常端口比较多看起来比较笨重，而路由器的端口就少得多体积也小得多。\n**2、工作层次不同**\n普通的交换机一般工作在OSI七层模型的第二层·==数据链路层==，负责==局域网之间==的连接，而路由器工作在OSI的第三层·==网络层==，负责==广域网之间==的连接。\n**3、数据的转发对象不同**\n交换机都是<u>根据MAC地址转发数据帧</u>，而路由器是<u>基于路由表转发数据包</u>。\n**4、分工不同**\n交换机主要是负责`局域网`的搭建，而路由器在中小型网络架构中，负责的是`连接外网`，与公网通信。\n**5、冲突域和广播域**\n前文中讲过了，默认状态下，==交换机分割冲突域，共享同一广播域==。\n而路由器并不会转发广播数据，也就是说广播数据到达路由器，是会被丢弃的，从一定程度上来说，路由器本身就有一定的安全性。\n\n**总结：**\n\n**交换机是将不同IP地址的电脑连在一起，共享一根网线**；**路由器是将同一个IP给不同的电脑使用**，就像一条大路分成很多条小路。一句话，**路由器是接外网的，交换机是接内网的**。【 路由器可以给你的局域网自动分配IP，虚拟拨号，就像一个交通警察，指挥着你的电脑该往哪走，你自己不用操心那么多了，交换机只是用来分配网络数据的】\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102347687.jpeg)\n\n交换机利用我们熟知的MAC地址即每个设备唯一的物理地址来寻址，路由器则通过IP地址来寻址。说白了，`交换机寻找物理地址，路由器寻找软件地址`。\n\n**路由器具有防火墙的功能**，因为其不传送不支持路由协议的数据，可`防止广播风暴`，而交换机没有这个功能。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102347508.jpeg)\n\n路由器可以分割广播域，广播数据不会穿过路由器，交换机则无法分割，只能区分冲突域，会导致通信拥堵和安全漏洞。\n\n路由器产生在交换机之后，主要克服了交换机不能路由数据的不足。\n\n \n\n## 4.2.   TCP/IP数据链路层的交互过程\n\n网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就将目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器\n\n### **一、数据链路层的概述**\n\n#### **1.1 概述**\n\n数据链路层是TCP/IP协议栈的第二层！\n\n数据链路层的传输单元：帧（也就是传输单位）\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102353941.jpeg)\n\n#### **1.2 帧结构**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102353864.png)\n\n**帧结构分析如下：**\n\n**帧结构的构成**：MAC子层 + 上三层数据 + FCS\n\n**比喻：**一个帧我们可以理解为一辆**火车**，MAC子层是**火车头**，上三层数据为**乘客**，FCS为火车尾巴\n\n**MAC子层头部包含（也叫帧头）**：目标MAC地址（6字节） 源MAC地址（6字节） 类型（2字节）\n\n**MAC地址**：也称为物理地址，是被固化到网卡的全球唯一标识，如下图：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102353098.png)\n\n> 注释：\n> MAC地址=厂家标识+内部编号====实现了全球唯一！\n> 怎么查看自己的MAC地址？开始运行--cmd--ipconfig /all\n\n**类型字段的作用**：==区分上层协议==，0806代表上层协议是ARP协议，0800代表上层是IP协议\n\n**上三层数据：**也就是3层包头+4层包头+5层数据。其中一个帧是有最大承载能力限制的。也就是一个帧中的上三层数据就是乘客，而一辆火车中的乘客是又上限的，一个帧的最大承受能力叫MTU值，目前国际标准为1500字节\n\n**MTU**:（最大传输单元）1500字节\n\n**帧尾**：==FCS=帧校验==，长度4个字节，作用是校验整个帧在传输过程中是否发生传输错误。\n\n**帧结构最终效果图如下：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102354346.jpeg)\n\n> 经典问题：请描述一下帧结构\n> 答：帧是由帧头+上三层数据+帧尾，帧头包含目MAC，源MAC，类型，帧尾是FCS，MTU：1500\n\n### **二、本层的设备**\n\n工作在2层的设备：==交换机/网桥==\n\n### **三、交换机的工作原理**\n\n**交换机：**用来组建一个局域网！\n\n交换机的工作原理：交换机是如何工作的？从收到一个帧，到将该帧转发出去的过程！\n\n**经典问题：请描述一下交换机的工作原理**\n\n**答：**\n\n> 1）当收到一个`帧`，首先<u>学习帧中的MAC地址</u>来<u>`形成自己的MAC地址表`</u>！\n>\n> 2）然后检查帧中的目标MAC地址，并匹配MAC地址表\n>\n> - 如表中匹配成功，则单播转发！\n>\n> - 如表中无匹配项，则广播转发！\n>\n> 3）MAC地址表的老化时间是？300秒！\n\n**效果图如下：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203102355558.jpeg)\n\n## 4.3.   传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文\n\n根据上层协议tcp/udp 头部的端口标识，根据端口区分；\n\n看ip头中的协议标识字段，17是udp，6是tcp\n\n## 4.4. IP数据包的结构\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203110035597.gif\" alt=\"img\" style=\"zoom:150%;\" />\n\nIP数据包头长度：20-60字节（一般为20字节）可选项一般不用（IPSecVPN、TTL值、对首部字段加密时用到）\n\nIP数据包长度：mtu=1500（China）\n\n \n\n- `版本`（4）：0100（ipv4）、0110（ipv6）\n\n- `首部长度`（4）：0000~1111(0~15 x4字节 = 0~60字节)，IP包头的长度\n\n- 优先级与服务类型（8）：前4个bit代表优先级，中间3个bit代表服务类型，最后1个bit未启用（保留，运营商可能会用到）优先级最高为5，用于语音流量\n\n  > 优先级应用：大公司的专线，\n  >\n  > 服务类型：低延迟、多通道\n\n- `总长度`（16）: 3+4+5（<u>未分片时的长度</u>，不是IP数据包长度）   \n\n- `标识符`（16）：相当于id，是发送方随机生成的，`同一数据包的分片id相同`，不同数据包的分片标识符不同   （==<u>**标识同一组数组**</u>==）\n\n- `标志`（3）：第1个bit保留；第2个bit若为0代表数据包进行了分片，为1未分片；第3bit代表是否为最后一个分片（0是，1不是）\n\n- `段偏移量`（13）：0，1480,2960,···`1480`*n，`决定ip分片的先后顺序`，用于还原IP包   （<u>==**用于重组**==</u>）\n\n  > 泪滴攻击TearDrop：\n  >\n  > - 构造一个段偏移量不为1480*n的分片，<u>让受害者重组数据包失败,然后一直重组直到死机</u>，也`是ddos攻击的一种`。\n  >\n  > 防御方法：\n  >\n  > - `防火墙拦截`—>最有效的方法就是在服务器前端加防火墙，过滤不安全的包。比如我利用HillStone防火墙保护后端安全，在防火墙中开启TearDrop攻击防护。\n  >\n  > 检测方法：\n  >\n  > - 对接收到的分片数据包进行分析，计算数据包的片偏移量（Offset）是否有误。\n\n- ==<u>**TTL存活时间**</u>==（8）: Time To Live 0~255单位不是秒，是跳。`经过一个路由器-1`，默认255，主要用于`防环`。\n\n  > TTL应用：tracert跟踪，跳了多少跳。\n  >\n  > Ping 返回的TTL值是初始TTL值，处理的TTL值在可选项\n  >\n  > ping 回显的TTL值大于100一般是window，小于100一般是Liunx；\n\n- 协议号（8）：`表示上层所用的协议`，为上层提供服务TCP:6、UDP:17、ICMP:1、IGMP：88还有很多（网关选择协议，被路由器的hsrp技术替代了，vrrp）\n\n- <u>首部校验和（</u>16）：校验IP包头部\n\n## 4.5. IP协议切片\n\n#### 一、什么是IP分片？\n\n<u>IP协议在传输数据包时会将数据报文分成若干片进行传输，并在目标系统中进行重组。这一过程就成为分片</u>。\n\n#### 二、为什么要进行IP分片\n\n因为有`最大传输单元`（英語：Maximum Transmission Unit，缩写MTU）的限制。`1500个字节`\n\n如果IP数据报加上数据帧头部后大于MTU（最大传输单元1500字节），数据报文就会分成若干片进行传输。\n\n> 那么什么是MTU呢？\n>\n> 每一种物理网络都会规定链路层数据帧的最大长度，称为链路层MTU。在以太网的环境中可传输的最大IP报文为1500字节。\n>\n> 如果要传输的数据帧的大小超过1500字节，即IP数据报的长度大于1472(1500-20-8=1472，普通数据报)字节，需要分片之后进行传输。\n\n#### 三、IP分片是如何组装的？\n\n在IP头里面有`16bit的识别号`唯一记录了一个IP包的ID,<u>以确定这几个分片是否属于同一个包</u>，具有同一个ID的IP分片将会从新组装。`13bit的片偏移`记录了一个IP分片相对于整个包的位置。`3bit的标志位`记录了该分片后面是否还有新的分片。这三个分片组成了IP分片的所有的信息。\n\n> ==16bit的ip包识别号==\n>\n> ==13bit的片偏移==\n>\n> ==3bit的新分片标志位==\n\n#### IP分片原理及分析\n\n- 分片和重新组装的过程`对传输层是透明`的，其原因是当IP数据报进行分片之后，只有当它到达目的站时，才可进行重新组装，且它是由目的端的IP层来完成的。分片之后的数据报根据需要也可以再次进行分片\n\n  > 只有起始网络层可见 目的ip层组装\n\n- IP分片和完整IP报文差不多拥有相同的IP头，ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位`识别号唯一记录`了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位`片偏移`则记录了某IP片相对整个包的`位置`。 同时还有3bit的新分片标志位记录之后还有没有新的分片\n\n  > 识别号识别同一个ip 片偏移记录当前分片的位置 新分片标志位记录之后还有没有新的分片\n\n- 尽管IP分片过程看起来是透明的，但有一点让人不想使用它：<u>即使只丢失一片数据也要重传整个数据报</u>。因为IP层本身没有超时重传的机制——由更高层来负责超时和重传（TCP有超时和重传机制，但UDP没有。一些UDP应用程序本身也执行超时和重传）。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常需要避免分片。\n\n  > ==<u>**分片缺点：一个也不能丢失，不然整体重传**</u>==\n\n  \n\n## 4.6.   ARP/RARP协议\n\narp协议只适合本地同一网段的数据通信？\n\n### ARP协议概念\n\n- 地址解析协议，即ARP（Address Resolution Protocol），是<u>根据==IP地址==获取==物理地址==的一个TCP/IP协议</u>。主机发送信息时，将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入`本机ARP缓存`中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。  \n\n  > mac的那个自学习的表？\n\n- 地址解析协议是建立在网络中各个主机`互相信任`的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。\n\n- ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、Proxy-ARP。NDP用于在IPv6中代替地址解析协议。\n\n### ARP协议工作流程：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321130807068.png\" alt=\"image-20220321130807068\" style=\"zoom:67%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321130012417.png\" alt=\"image-20220321130012417\" style=\"zoom:67%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220321125611380.png\" alt=\"image-20220321125611380\" style=\"zoom:80%;\" />\n\n主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；\n\n主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；\n\n当主机A要与主机B通信时，==地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址==，以下为工作流程：\n\n1. 根据主机A上的[路由表](http://baike.baidu.com/view/149989.htm)内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。\n\n2. 如果主机A在ARP缓存中`没有找到映射`，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。\n\n3. 主机B确定ARP请求中的IP地址与自己的IP地址匹配`（不匹配则忽略，后续所有步骤停止）`，则将主机A的IP地址和MAC地址[映射](http://baike.baidu.com/view/21249.htm)添加到本地ARP缓存中。\n\n4. 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。\n\n5. 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有[生存期](http://baike.baidu.com/view/159877.htm)的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。\n\n### RARP协议的简单认识\n\n`反向地址转换协议`，即RARP（<u>Reverse</u> Address Resolution Protocol）。 反向地址转换协议（RARP）允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。网络管理员在局域网的网关路由器里创建一个表以映射物理地址（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向路由器上的 RARP 服务器请求相应的 IP 地址。假设在路由表中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。 RARP 可以使用于以太网、光纤分布式数据接口及令牌环 LAN等。\n\n### RARP协议工作流程/原理：\n\n==拿着自己的物理地址向上级查询自己的ip==\n\n（1）给主机发送一个本地的RARP广播?，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；\n\n（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；\n\n（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；\n\n（4）如果不存在，RARP服务器对此不做任何的响应；\n\n（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。\n\n答法2\n\n> 1. 网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从==网卡上读取MAC地址==，然后在网络上发送一个==RARP请求的广播数据包==，请求RARP服务器回复该主机的IP地址。\n>\n> 2. RARP服务器收到了RARP请求数据包，==为其分配IP地址==，并将RARP回应发送给主机。\n>\n> 3. PC1收到RARP回应后，就使用得到的IP地址进行通讯。\n\n## 4.7.   ICMP协议\n\n| 协议 | 名称                 | 作用                                                         |\n| :--- | :------------------- | :----------------------------------------------------------- |\n| ICMP | Internet控制报文协议 | ICMP就是一个“==错误侦测与回报机制”==，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议 |\n\n#### **ICMP**协议是一个网络层协议。\n\n一个新搭建好的网络，往往需要先`进行一个简单的测试，来验证网络是否畅通`；<u>但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。</u>\n\n所以我们就需要一种协议来完成这样的功能–ICMP协议。\n\n#### **ICMP**协议的功能\n\n> 1. `确认IP包是否成功到达目标地址`\n>\n> 2. `通知`在发送过程中IP包`被丢弃的原因`\n\n#### **ICMP**的报文格式\n\n==ICMP报文包含在IP数据报中==，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306213925428-808176996.png)\n\n##### 类型    \n\n- 占一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。\n- 第一类是取值为1~127的`差错`报文，第2类是取值128以上的`信息`报文\n\n##### 代码    \n\n- 占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的`详细类型`\n\n##### 校验和  \n\n- 这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的）\n\n \n\n## 4.8.   Ping用的什么协议\n\n### **ping**命令的功能\n\n1. 用来检测网络的连通情况和分析网络速度；\n\n2. 根据域名得到服务器IP； //dns哦\n\n3. 会统计响应时间和TTL(IP包中的Time To Live，生存周期)\n\n   > 根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。\n\n####  ==Ping 的原理是 ICMP 协议.==\n\n### **那么如何验证的呢？**\n\n（1）ping命令会先发送一个 `ICMP Echo Request`给对端   echo(回响 音：爱扣)\n\n（2）对端接收到之后, 会返回一个`ICMP Echo Reply`\n\n（3）若没有返回，就是超时了，会认为指定的网络地址不存在。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220315044319786.png\" alt=\"image-20220315044319786\" style=\"zoom:67%;\" />\n\n## 4.9.   IPv4和iPv6的区别\n\n###  IPV4和IPV6的区别：\n\n#### `扩展了路由和寻址的能力`\n\n- IPv6把IP地址由<u>32位增加到128位</u>，从而能够==<u>**支持更大的地址空间**</u>==，估计在地球表面每平米有4*10^18个IPv6地址，使IP地址在可预见的将来不会用完。\n\n- IPv6地址的编码采用类似于CIDR的`分层分级结构`，如同电话号码。<u>简化了路由，加快了路由速度</u>。\n\n- 在多点传播地址中增加了一个“范围”域，从而使多点传播不仅仅局限在子网内，可以横跨不同的子网，不同的局域网。\n\n#### `报头格式的简化`\n\nIPv4报头格式中一些冗余的域或被丢弃或被列为扩展报头，从而降低了包处理和报头带宽的开销。虽然IPv6的地址大小是IPv4地址的4倍。但报头只有它的2倍大。\n\n#### 对`可选项`更大的支持\n\nIPv6的<u>可选项不放入报头，而是放在一个个独立的扩展头部</u>。如果不指定路由器不会打开处理扩展头部.这大大改变了路由性能。IPv6放宽了对可选项长度的严格要求(IPv4的可选项总长最多为40字节)，并可根据需要随时引入新选项。IPV6的很多新的特点就是由选项来提供的，如对IP层安全(IPSEC)的支持，对巨报(jumbogram)的支持以及对IP层漫游(Mobile-IP)的支持等。\n\n#### QoS的功能\n\n> ##### 什么是服务质量？\n>\n> 服务质量 (QoS) 是`对流量的操纵`，使得路由器或交换机等网络设备采取与生成该流量的应用程序所需行为一致的方式转发流量。换言之，QoS 使网络设备能够区分流量，然后向流量应用不同的行为。\n>\n> ##### QoS 解决的问题\n>\n> 过去，使用独立的物理网络来分别承载语音和数据流量。每个网络承载特定类型的流量，并提供该流量所需的内在质量水平。如今，这些相同的应用程序在基于数据包的融合网络上运行，流量在此共享通用基础架构和网络资源。这些基于数据包的网络旨在尽最大努力提供流量，它们没有固有的 QoS。\n>\n> 然而，语音和视频服务用户要求这些服务始终达到可接受的质量水平。基于数据包的网络将大量流量从 A 点传递到 B 点，并遵循生成该流量的所有应用程序的服务合同和性能需求，QoS 正是实现此目的的途径。\n>\n> ##### QoS 有何作用？\n>\n> QoS 对于管理当今基于数据包的网络中的流量至关重要，其包括以下功能：\n>\n> - 根据协议、地址和端口号区分流量优先顺序。\n> - 过滤入口和出口流量。\n> - 控制允许在设备上传输或接收的带宽。\n> - 在数据包标头中读写 QoS 行为要求。\n> - 控制拥塞，以便设备基于计划程序优先级发送优先级最高的流量。\n> - 使用随机早期检测 (RED) 算法控制丢包，以便设备知道要丢弃或处理的数据包。\n\n因特网不仅可以提供各种信息，缩短人们的距离.还可以进行网上娱乐。网上VOD现正被商家炒得热火朝天，而大多还只是准VOD的水平，且只能在局域网上实现，因特网上的VOD都很不理想.问题在于IPv4的报头虽然有服务类型的字段，实际上现在的路由器实现中都忽略了这一字段。在IPv6的头部，有两个相应的优先权和流标识字段，允许把数据报指定为某一信息流的组成部分，并可对这些数据报进行流量控制。如对于实时通信即使所有分组都丢失也要保持恒速，所以优先权最高，而一个新闻分组延迟几秒钟也没什么感觉，所以其优先权较低。IPv6指定这两字段是每一IPv6节点都必须实现的。\n\n#### 安全\n\n> ##### 身份验证和保密\n>\n> - `在IPv6中加入了关于身份验证、数据一致性和保密性的内容`。\n>\n> ##### `安全机制`IPSec是必选的\n>\n> - IPv4的是可选的或者是需要付费支持的。\n\n#### 加强了对`移动设备的支持`\n\n- IPv6在设计之初有有着支持移动设备的思想，允许移动终端在切换接入点时保留相同的IP地址。\n\n#### 支持`无状态自动地址`配置\n\n> 无状态地址自动配置会自动执行某些网络管理员的任务。\n>\n> 无状态地址自动配置是 IPv6 节点（主机或路由器）用于为接口自动配置 IPv6 地址的过程。节点通过将地址前缀与节点的 MAC 地址派生的标识或用户指定的接口标识组合来构建各种 IPv6 地址。这些前缀包括本地链路前缀（fe80::/10）和本地 IPv6 路由器（如果存在）所通告的长度为 64 的前缀。\n>\n> 将地址分配给某个接口之前，节点执行重复地址检测以验证其唯一性。节点对新地址发送邻居请求查询并等待响应。如果节点没有接收到响应，那么假设该地址是唯一的。如果节点接收到一个邻居广告格式的响应，那么该地址已在使用。如果节点确定其尝试的 IPv6 地址不是唯一的，那么自动配置将停止并要求手工配置该接口。\n\n### 简化了`地址配置`过程\n\n无需DNS服务器也可完成地址的配置，路由广播地址前缀，各主机根据自己MAC地址和收到的地址前缀生成可聚合全球单播地址。这也方便了某一区域内的主机同时更换IP地址前缀。\n\n> 理解 无需rarp协议 自己进行ip的配置\n>\n> 使用无状态自动配置，无需手动干预就能够改变网络中所有主机的IP地址。例如，当企业更换了联入Internet的ISP时，将从新ISP处得到一个新的可聚集全局地址前缀。ISP把这个地址前缀从它的路由器上传送到企业路由器上。由于企业路由器将周期性地向本地链接中的所有主机多点广播路由器公告，因此企业网络中所有主机都将通过路由器公告收到新的地址前缀，此后，它们就会自动产生新的IP地址并覆盖旧的IP地址。\n\n# 5.    应用\n\n## [53、应用层常见协议知道多少？了解几个？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=53、应用层常见协议知道多少？了解几个？)\n\n| 协议   | 名称                       | 默认端口       | 底层协议                                                  |\n| :----- | :------------------------- | :------------- | :-------------------------------------------------------- |\n| HTTP   | 超文本传输协议             | 80             | TCP                                                       |\n| HTTPS  | 超文本传输安全协议         | 443            | TCP                                                       |\n| Telnet | 远程登录服务的标准协议     | 23             | TCP                                                       |\n| FTP    | 文件传输协议               | 20传输和21连接 | TCP                                                       |\n| `TFTP` | 简单文件传输协议           | 69             | UDP                                                       |\n| SMTP   | 简单邮件传输协议（发送用） | 25             | TCP                                                       |\n| POP    | 邮局协议（接收用）         | 110            | TCP                                                       |\n| `DNS`  | 域名解析服务               | 53             | 服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP |\n\n## 5.1.   Cookie和session有什么区别 他们的作用又是什么\n\n### 5.1.1.  Cookie\n\n#### [Cookie是什么？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=24、cookie是什么？)\n\n> cookie就是便利贴，每当你访问一个网站，该网站的服务器就会给你发一张便利贴。当他需要记一些和你相关的事情的时候（比如你的姓名，浏览记录等），就会写在你的便利贴上。同时，记在这张便利贴上的东西不能太重要，因为你可能会弄丢，也可能会主动撕掉它。服务器也不会心疼，再给你发一张就是了\n\nHTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息。\n\nCookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。\n\nCookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。\n\n新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。\n\n==cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。==\n\n抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。\n\n\n\n#### [Cookie有什么用途？用途](https://zhuanlan.zhihu.com/p/131256002)\n\n- `会话状态`管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）==(清除cookie需要重新登录)==\n- `个性化设置`（如用户自定义设置、主题等）\n- `浏览器行为跟踪`（如跟踪分析用户行为等）  ==（行为喜好 个性化推送）==\n\n### 5.1.2.  session\n\n#### session是什么\n\n除了可以将用户信息通过 Cookie 存储在用户浏览器中，也<u>可以利用 Session 存储在==服务器==端，存储在服务器端的信息==更加安全==。</u>\n\nSession 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。\n\n#### [使用 Session 的过程是怎样的？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=41、使用-session-的过程是怎样的？)\n\n过程如下：\n\n- 用户进行登录时，`用户提交包含用户名和密码的表单`，放入 HTTP 请求报文中；\n- 服务器`验证`该用户名和密码，如果正确则把用户信息`存储到 Redis` 中，它在 Redis 中的 `Key 称为 Session ID`；\n- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 `Session ID`，客户端收到响应报文之后将该 Cookie 值存入浏览器中；\n- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 `Session ID`，从 Redis 中取出用户信息，继续之前的业务操作。\n\n> **注意**：\n>\n> Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。\n>\n> 此外，还需要<u>经常重新生成 Session ID</u>。在对安全性要求极高的场景下，例如`转账`等操作，除了使用 Session 管理用户状态之外，还需要对用户进行`重新验证`，比如重新输入密码，或者使用短信验证码等方式。\n\n#### [Session 的工作原理是什么？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=27、session-的工作原理是什么？)\n\nsession 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。\n\n#### Session应用\n\nSession 的主要作用就是通过服务端记录用户的状态。 典型的场景是==购物车==。\n\n### 5.1.3.  cookie和session的区别\n\n1. session保存在<u>`服务器`</u>，客户端不知道其中的信息；cookie保存在`客户端`，服务器能够知道其中的信息。  ==<u>保存位置</u>==\n2. 都是key-value，session中保存的是`对象object`，cookie中保存的是`字符串`。  ==<u>数据类型</u>==\n3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）    ==<u>联系 禁用</u>==\n4. <u>session在用户会话结束后就会关闭了，但cookie因为保存在客户端，可以长期保存</u>   ==<u>长期保存</u>==\n5. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，`考虑到安全应当使用session`。 ==<u>安全</u>==\n6.  session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，`考虑到减轻服务器性能方面，应当使用COOKIE`。    （<u>==性能==</u>）\n7. 单个cookie保存的数据不能超过`4K`，很多浏览器都限制一个站点最多保存20个cookie。session：理论上受当前内存的限制  ==<u>大小限制</u>==\n\n### 5.1.4 session 和 cookie 的联系　　\n\n　　当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。**保存这个session id的方式可以采用cookie**，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。\n\n　　**cookie可以被人为的禁止，同时 session 可能会失效**，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做**URL重写，就是把session id直接附加在URL路径的后面**。还有一种技术叫做**表单隐藏字段**。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器\n\n## 5.2.   keepalive和session的区别\n\n1. 这里的keep-alive是短时间内多个http请求可复用同一个tcp连接\n2. session是储存在服务端用于标识客户端请求用户的，两者并无矛盾\n\n#### tcp的keepalive和http的keep-alive不一样。\n\n### Tcp的keepalive\n\nkeepalive是指tcp自动断开失效连接。\n\n<u>如果在一段时间（保活时间：tcp_ keepalive_time）内此连接都不活跃，开启保活功能的一端会向对端发送一个==保活探测报文==。</u>\n\n若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可。\n\n若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定**探测时间间隔（tcp_keepalive_intvl）后，将继续发送保活探测报文。==直到收到对端的响应==，或者达到配置的==探测循环次数上限==（tcp_keepalive_probes）**==都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。==\n\n### http的keepalive\n\n我们知道HTTP协议采用“请求-应答”模式*\n\n- 当使用`普通模式`，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；\n- 当使用`Keep-Alive模式`（又称持久连接、`连接重用`）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。\n\n![image-20220412111656856](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220412111656856.png)\n\n<u>http 1.0中默认是关闭的</u>，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；<u>http 1.1中默认启用Keep-Alive</u>，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n\n## 5.3.   [Web页面的请求历程](https://www.cxyxiaowu.com/17476.html)\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220315050156919.png\" alt=\"image-20220315050156919\" style=\"zoom:67%;\" />\n\n#### [在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=16、在浏览器地址栏输入一个url后回车，背后会进行哪些技术步骤？)\n\n1. 查浏览器缓存，看看有没有已经缓存好的`域名IP映射`，如果没有\n\n2. 检查本机host文件\n\n   > - Hosts是一个没有扩展名的系统文件，<u>其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”。</u>\n   > - hosts文件能<u>加快域名解析</u>，对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，提高域名解析速度。\n   > - hosts文件可以方便局域网用户在很多单位的局域网中，可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。\n   > - hosts文件可以<u>屏蔽一些网站</u>，对于自己想屏蔽的一些网站我们可以利用Hosts把该网站的域名映射到一个错误的IP或本地计算机的IP，这样就不用访问了。\n\n3. 调用API，Linux下Scoket函数 gethostbyname\n\n   > `如果`gethostbyname`没有这个域名的缓存记录，也没有在`hosts` 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。\n\n4. 向DNS服务器发送DNS请求，查询`本地DNS服务器`，这其中用的是UDP的协议 ==（用udp发送dns请求）==\n\n5. 如果在一个`子网内`采用ARP地址解析协议进行`ARP查询`，如果`不在一个子网`那就需要`对默认网关进行DNS查询`，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）\n\n6. 这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，<u>首先尝试`http`然后调用Socket建立`TCP`连接</u>，\n\n7. 经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，\n\n8. 如果不是http协议，服务器会返回一个`5开头的的重定向消息`，告诉我们用的是`https`，那就是说IP没变，但是端口号从80变成443了，好了，再四次`挥手`，完事，\n\n9. 再来一遍，这次除了上述的端口号从80变成443之外，还会采用`SSL的加密技术`来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的， \n\n10. 这次依然是三次握手，沟通好双方使用的`认证算法，加密和检验算法`，在此过程中也会检验对方的CA安全证书。 ==SSL handshake==\n\n11. 确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页\n\n\n\n\n\nhttps://blog.csdn.net/wenyun_kang/article/details/81290904\n\n1. 为主机申请IP：DHCP动态主机配置协议\n\n   > 1）主机生成一个DHCP请求报文（应用层）\n   >\n   > 2）放入UDP报文段（传输层），UDP报文段主要包含\n   >\n   > ​\t源端口68（DHCP客户端的固定端口）\n   >\n   > ​\t目的端口67（DHCP服务器的固定端口）\n   >\n   > 3）网络层添加头部封装成IP数据报，主要包含\n   >\n   > ​\t源IP：0.0.0.0\n   >\n   > ​\t目的IP：255.255.255.255（广播IP）\n   >\n   > 4）数据链路层添加头部封装成以太网帧\n   >\n   > 5）以太网帧被发送到交换机\n   >\n   > 6）与交换机相连的默认网关路由器接收到了这个广播帧，进行解析，提取出IP数据报，发现目的IP是广播IP，就交给传输层，传输层又提取出 DHCP 请求交给应用层， DHCP 服务器就收到了该 DHCP 请求。\n   >\n   > 7）DHCP 服务器为此生成一个 DHCP ACK 报文，主要包含：\n   >\n   > ​\tl 分配给DHCP请求的IP\n   >\n   > ​\tl DNS服务器的IP\n   >\n   > ​\tl 默认网关路由器的IP\n   >\n   > ​\tl 子网掩码\n   >\n   > 8）DHCP ACK以太网帧由默认网关路由器发送给交换机，交换机根据转发表转发回给我的主机\n   >\n   > 9）主机收到该帧之后再从链路层到应用层，层层提取，最后得到自己的IP、DNS服务器IP、默认网关路由器IP\n\n2. 查找默认网关路由器的MAC地址：ARP地址转换协议\n\n   通过默认网关路由器ip找局域网默认网关路由器的MAC地址。\n\n   这就用到了ARP地址转换协议。\n\n   > - 主机生成一个 ARP 查询报文，目的 IP 是默认网关路由器，这个报文最终被封装成以太网帧，帧的目的MAC是 FF:FF:FF:FF:FF:FF（广播地址），然后把帧发给交换机，交换机看到是广播地址就给广播出去\n   >\n   > - 默认网关路由器接收到了这个帧，经过层层提取得到 ARP 报文，发现其中的目的 IP 跟他自己某个接口的 IP 匹配，就发送回去一个 ARP 应答报文给主机，这里包含他自己的 MAC\n\n3. 查找目的域名的IP：DNS域名系统\n\n   <u>拿到了默认网关路由器的MAC之后，离开局域网去DNS服务器查目的域名的IP</u>。\n\n   路由表中已经配置了可以从路由器到达 DNS 服务器的路由表项。\n\n4. 解析出 IP地址后，`根据该 IP地址和默认端口80`，和服务器建立TCP连接；\n\n5. 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为 TCP三次握手的第三个报文的数据发送给服务器；\n\n6. 服务器对浏览器请求作出响应，并把对应的 html文本发送给浏览器；\n\n   > 如果不是http 重定向5开头的响应序号， 然后重新建立https 的socket连接 还有ssl的`handshake`。互相检验ca证书\n\n7. 释放 TCP连接；\n\n8. 浏览器将该 html文本并显示内容；\n\n \n\n==DNS + HTTP + TCP + IP + ARP==\n\n \n\n## 5.4.   web页面请求时各层工作\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220315050156919.png\" alt=\"image-20220315050156919\" style=\"zoom:67%;\" />\n\n### 总感觉写的有点问题\n\n1. **应用层：**客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。\n\n   > DHCP DNS \n\n2. 运输层：在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层（网络层）的IP地址查找目的端。\n\n   > tcp？\n\n3. 网络层：客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。\n\n   > ARP\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306213925507-1155884218.png)\n\n4. 链路层：客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。\n\n## 5.5.   结合7层模型讲讲输入url之后发生了什么\n\n 用户输入网址后到收到网页，客户端需要发送三次数据。\n1、DNS域名解析\n2、建立TCP/IP连接\n3、发送请求网页信息\n建立TCP/IP连接与请求网页信息放在一起\n\n\n1、DNS域名解析：首先，客户端的`应用层`会封装数据到达`传输层`，在<u>传输层标识源端口号与目的端口号</u>（源端口号为大于1023随机，目的端口号为UDP53端口）及应用层服务（这里因该是请求DNS查询服务吧）。传输层封装数据产生数据段传给网络层，在网络层标识源IP地址及目的IP地址（源IP地址为客户端IP，目的IP地址为DNS服务器IP地址），网络层将数据段封装为数据包传给数据链路层，在数据链路层将会在数据包里加入源MAC地址及目的MAC地址（源MAC地址为客户端网卡MAC地址，目的MAC地址为DNS服务器MAC地址），这里应该查询MAC缓存。数据链路层根据客户端与DNS服务器之间的链路，将数据包封装成帧，传给物理层。物理层会将数据帧转化为电信号放到物理介质上。\n电信号到达DNS服务器后会从物理层到达应用层（这里和客户端发送数据差不多，只不过这个过程变成了解封装），DNS服务器做完域名解析后再将数据传给客户端，传输过程同客户端发送数据。\n\n2、建立TCP/IP连接：客户端知道WEB服务器IP地址之后，在网络层产生建立TCP/IP三次握手的数据包（TCP/IP三次握手：客户端向服务器端发送SYN信息，服务器端收到SYN信息后回复给客户端SYN+ACK确认信息，客户端收到确认信息后再向服务器发送ACK信息建立连接），应用层标识HTTP服务将数据发送到传输层，传输层将数据+源端口号（大于1023）、目的端口号（80）+上层服务WWW封装为数据段传给网路层。网络层将数据段+源ip与目的ip（WWW服务器的ip地址）封装为数据包发送到数据链路层。数据链路层参照ARP缓存表确定源MAC地址（本机MAC地址）及目的MAC地址（客户端与路由B相连端口的MAC地址）将数据包封装成数据帧。这里还需要CRC校验。。。。。。数据帧到达物理层后变成电信号发送到介质上（这里还需要访问控制方法DSMA/CD）\n路由B收到电信号后传给路由器的数据链路层，这里还需要CRC,FCS校验。。。。。。确定数据帧没有损坏后查看目的MAC地址与路由器端口地址是否相同，如果相同将解封装，将数据包发送到路由器B的物理层，路由器查看路由表确定数据包的转发端口，路由器B确定与路由A之间的链路，创建帧。\n路由B与路由A可以看成是点对点，即路由B将创建PPP帧。路由A收到电信号后，确定帧的完整性，如果完整即将数据帧解封装发送到网络层，路由A查询路由表将数据包转发到与WEB相连的路由端口。\n路由A的数据链路层将查询ARP缓存表确定WWW服务器的MAC地址，路由A将创建源MAC地址（路由A）及目的MAC地址（WEB服务器MAC地址）的数据帧。WEB服务器收到数据帧后比较MAC地址，确定数据帧是发给WEB服务器的，传给WEB服务器的网络层，查看目的IP地址是否与WEB服务器IP地址是否相同，相同即发送到传输层，查看为TCP协议及80端口号。应用层收到数据即向客户端响应WWW服务请求。\n发送网页与请求网页数据发送相同\n\n## 5.6.   如何保证浏览器发出的数据到路由器这一段是安全的？\n\nICMP协议？\n\n数据链路层保证可靠传输，数据帧会通过一些手段对数据进行`校验`，来发现数据帧是否错误，如果错误，可以检错重发，向前纠错，反馈校验，检错丢弃等手段来保证两个节点之间传输的数据帧向上层提供的数据是无差错的。\n\n## 5.7.   如何应对大量访问，泛洪攻击\n\nSYN洪泛攻击发生在三次握手建立TCP连接的过程中。\n\n1. 具体过程\n   - SYN攻击就是Client在短时间内<u>伪造大量不存在的IP地址</u>，并向Server<u>不断地发送SYN包</u>，Server则回复确认包，并等待Client确认，由<u>于源地址不存在，因此Server需要不断重发直至超时</u>，这些伪造的SYN包将长时间占用未连接队列，<u>导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</u>。SYN 攻击是一种典型的 DoS/DDoS 攻击。\n   - 攻击者如果发送非常大量的这种TCP连接，由于每一个都无法完成三次握手，所以服务器上这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务。\n\n2. 解决方法（==SYN cookie==）\n\n   >- 缩短超时（SYN Timeout）时间\n   >\n   >- 增加最大半连接数\n   >\n   >- 过滤网关防护\n   >\n   >  > 这里，过滤网关首要指明防火墙，当然路由器也能成为过滤网关。[防火墙](http://www.5636.com/netbar/network/489.html)摆设在分歧网络之间，防备外来不合法进击和避免保护秘密信息外泄，它处于客户端和服务器之间，应用它来防护SYN攻击能起到很好的结果。过滤网关防护首要包罗超时设置，SYN网关和SYN署理三种。\n   >  > 　　·网关超时设置：\n   >  > 　　防火墙设置SYN转发超时参数(形态检测的防火墙可在形态内外面设置)，该参数远小于服务器的timeout工夫。当<u>客户端发送完SYN包</u>，<u>效劳端发送确认包后(SYN+ACK)</u>，防火墙假如在`计数器到期`时还未收到客户端确实认包(ACK)，则往服务器发送`RST包`，以使服务器从队列中删去该半衔接。值得留意的是，网关超时参数设置不宜过小也不宜过大，超时参数设置过小会影响正常的通信，设置太大，又会影响防备SYN攻击的结果，必需依据所在的网络使用情况来设置此参数。\n   >  > 　　·SYN网关：\n   >  > 　　SYN网关收到客户端的SYN包时，直接转发给服务器；SYN网关收到服务器的SYN/ACK包后，将该包转发给客户端，还以客户端的名义给服务器发ACK确认包。此时服务器由半衔接形态进入衔接形态。当客户端确认包抵达时，假如稀有数据转发，不然丢掉。现实上，服务器除了维持半衔接队列外，还要有一个衔接队列，假如发作SYN攻击时，将使衔接队列数量添加，但普通服务器所能接受的衔接数目比半衔接数目大得多，所以这种办法能有用地减轻对服务器的进击。\n   >  > 　　·SYN署理：\n   >  > 　　当客户端SYN包抵达过滤网关时，SYN署理并不转发SYN包，而是以服务器的名义自动答复SYN/ACK包给客户，假如收到客户的ACK包，标明这是正常的拜访，此时防火墙向[服务器](http://www.5636.com/netbar/wupan/503.html)发送ACK包并完成三次握手。SYN署理现实上替代了服务器行止理SYN攻击，此时要求过滤网关本身具有很强的防备SYN进击才能。\n   >\n   >- SYN cookies技术\n   - 检测 SYN 攻击非常的方便，当你在服务器上`看到大量的半连接状态时，特别是源IP地址是随机的`，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 `netstats` 命令来检测 SYN 攻击。\n\n   ==SYN cookies技术==\n\n   - 当服务器接收到一个SYN报文段时，其并不知道该报文段来自一个合法用户还是要进行SYN洪泛攻击的攻击者，因此服务器不会为该报文段生成一个半开的连接 ，相反服务器会生成一个初始序列号（ack），该序列号是一个复杂函数（散列函数，由SYN报文段的源IP地址和目的IP地址，源端口号和目的端口号以及仅有服务器知道的秘密数构成），这个初始序列号被称为cookie。服务器会发送这种具有特殊初始序列号的SYNACK报文段，==且服务器并不记录该cookie以及其他任何关于SYN的状态信息==。 \n   \n     > (<u>不建立`半连接` 而是加密(`随机的seqNumber?`)发回去,你发回来我检查一下</u>)\n   \n   - 如果客户是合法的，则它将返回一个ACK报文段，当服务器收到ACK报文段后，需要验证ACK是否与前面发送的某个SYN相对应。由于服务器没有记录SYN报文段的相关信息，所以其会使用SYNACK报文段的源IP地址和目的IP地址，==源端口号和目的端口号以及仅有服务器知道的秘密数生成一个散列函数==。如果这个函数的结果（cookie值）加1和客户ACK报文段中的确认值相同，那么服务器会认为该ACK对应于较早的SYN报文段，则其合法，因此服务器会生成一个套接字的全开连接。\n   \n   - 如果客户没有返回一个ACK报文段，则说明之前的SYN报文段属于要进行SYN洪泛攻击的攻击者，但其并没有对服务器造成任何危害，因为服务器没有为它分配任何资源。\n\n \n\n## 5.8.   `CSRF`()攻击以及如何防御\n\n#### [CSRF攻击？你知道吗？](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=96、csrf攻击？你知道吗？)\n\n==<u>Cross-site request forgery</u>==`跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作`。可以这么理解CSRF攻击：<u>攻击者`盗用你的身份`，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份`发邮件`，发`短信`，进行`交易转账`，甚至`盗取账号信息`。</u>\n\n#### [如何防范CSRF`攻击`](https://interviewguide.cn/#/Doc/Knowledge/计算机网络/计算机网络?id=97、如何防范csrf攻击)\n\n1. **安全框架**，例如Spring Security。\n\n2. **token机制**。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。 \n\n   > 用mac地址或者sessioonid作为token 类似浏览器session的使用 客户端每次通信附带token 服务器进行验证\n\n3. **验证码**。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，<u>出于`用户体验`考虑，验证码只能作为一种辅助手段</u>，而不是最主要的解决方案。\n\n4. **referer识别**。在HTTP Header中有一个`字段Referer`，<u>它记录了HTTP请求的来源地址</u>。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，`服务器并非都能取到Referer`。很多用户出于`隐私保护`的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。\n\n   > - 使用==<u>安全框架</u>==\n   >- 在请求地址添加 ==`token`== 并验证。\n   > - 关键操作添加==<u>验证码</u>==； \n   >- 验证请求来源地址 ==<u>referer</u>==；\n\n## 5.9.   DNS劫持\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-2addab8448622b23dc169f44a7def2bc_r.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-47e0b34eaf313c9ef4e5c37a0e762c85_r.jpg\" style=\"zoom:80%;\" />\n\n==解析域名的时候，DNS服务器返回了一个错误的地址==\n\n### DNS劫持分类\n\n我们按照`客户端侧--递归DNS服务器--权威DNS服务器`的路径，将DNS劫持做如下分类：\n\n##### 【一、本地DNS劫持】 \n\n> 主要是`修改本地dns配置`达到欺骗效果\n\n客户端侧发生的DNS劫持统称为本地DNS劫持。本地DNS劫持可能是：\n\n1. 黑客通过木马病毒或者恶意程序`入侵PC`，<u>篡改DNS配置</u>(hosts文件，DNS服务器地址，DNS缓存等)。\n2. 黑客利用`路由器`漏洞或者破击路由器管理账号入侵路由器并且<u>篡改DNS配置</u>。\n3. 一些`企业代理设备`（如Cisco Umbrella intelligent proxy）针对企业内部场景对一些特定的域名做DNS劫持解析为指定的结果。\n\n##### 【二、DNS解析路径劫持】\n\n> ==<u>转发</u>== <u>==复制==</u> 和 ==<u>代答</u>==\n\nDNS解析过程中发生在客户端和DNS服务器网络通信时的DNS劫持统一归类为DNS解析路径劫持。通过对DNS解析报文在查询阶段的劫持路径进行划分，又可以将DNS解析路径劫持划分为如下三类：\n\n###### • DNS`请求转发`\n\n通过技术手段(中间盒子，软件等)将DNS流量==`重定向`==到其他DNS服务器\n\n###### • DNS`请求复制`\n\n利用分光等设备将`DNS查询复制到网络设备，并先于正常应答返回DNS劫持的结果`。\n\n案例：一个DNS查询抓包返回两个不同的应答。\n\n###### • DNS`请求代答`\n\n网络设备或者软件直接代替DNS服务器对DNS查询进行应答。\n\n案例：一些DNS服务器实现了SERVFAIL重写和NXDOMAIN重写的功能。\n\n##### 【三、篡改DNS权威记录】\n\n> ==<u>黑掉你要查询的 dns服务器</u>==\n\n篡改DNS权威记录 我们这里指的黑客`非法入侵DNS权威记录管理账号`，直接修改DNS记录的行为。 （==<u>暴力</u>==）\n\n案例：黑客黑入域名的管理账户，`篡改DNS权威记录指向自己的恶意服务器以实现DNS劫持`。\n\n- `DDOS攻击`：在知道攻击目标的IP地址后，攻击者以这个地址为源地址去向DNS服务器发送请求，然后==攻击目标就会收到很多DNS返回的请求==\n\n- 缓存污染：攻击者使用DNS请求，`将数据放入一个具有漏洞的DNS服务器的缓存当中`。这些缓存信息会在客户进行DNS访问时返回给用户，从而把用户客户对正常域名的访问引导到入侵者所设置挂马、钓鱼等页面上，或者通过伪造的邮件和其他的server服务获取用户口令信息，导致客户遭遇进一步的侵害。\n\n- 中间人攻击：通过截获主机与DNS服务器之间的通信，`伪装成DNS服务器`向主机返回错误的ip。\n\n- 如何防止DNS劫持\n\n  > 1、互联网公司准备两个以上的域名，一旦黑客进行DNS攻击，用户还可以访问另一个域名。\n  >\n  > 2、手动修改DNS：\n  >\n  > ##### DNS劫持防范\n  >\n  > > • 安装杀毒软件，防御木马病毒和恶意软件；定期修改路由器管理账号密码和更新固件。\n  > > • 选择安全技术实力过硬的域名注册商，并且给自己的域名权威数据上锁，防止域名权威数据被篡改。\n  > > • 选择支持DNSSEC的域名解析服务商，并且给自己的域名实施DNSSEC。DNSSEC能够保证递归DNS服务器和权威DNS服 \t务器之间的通信不被篡改。阿里云DNS作为一家专业的DNS解析服务厂商，一直在不断完善打磨产品功能，DNSSEC功能已经在开发中，不日就会上线发布。\n  > > • 在客户端和递归DNS服务器通信的最后一英里使用DNS加密技术，如DNS-over-TLS，DNS-over-HTTPS等。\n\n## 5.10. 为什么直播要用UDP而视频网站一般用TCP\n\n因为<u>视频网站对画面质量有要求，且允许缓冲等待</u>；而微信视频聊天一般用udp，因为`不希望画面卡顿`，可以接受画面不太清晰\n\n## 5.11. 游戏用tcp还是udp\n\n1. 在实时性方面，tcp协议的网络抗性欠佳，对MOBA类或其他`实时性要求较高的游戏`，一般是不建议使用tcp作为协议载体。事实上，王者荣耀的PVP通信协议也确实是基于`udp`封装的；同样，最近大家喜闻乐见的《绝地求生》，也是基于udp的。\n\n2. 一般游戏中TCP和UDP会同时用的，如果对于数据传输速度要求非常高的场景，比如FPS，MOBA等游戏过程中，用户对战时候的数据肯定是要用UDP来传输的，并且在程序层面保证传输的可靠性，包括自己做校验等；但其它模块，比如大厅里啊，买东西啊，创建房间啊等等，都是可以TCP实现的。==（操作时udp，抽奖时tcp）==\n\n3. 如果客户端和服务器都可以独立发包，但是偶尔发生延迟可以容忍（比如：在线的纸牌游戏，许多MMO类的游戏），那么使用TCP长连接吧。\n4. 如果客户端和服务器都可以独立发包，而且无法忍受延迟（比如：大多数的多人动作类游戏，一些MMO类游戏），那么使用UDP吧。\n\n## 5.12. [为什么QQ用的是UDP协议而不是TCP协议？](https://www.jianshu.com/p/d9a5a954c161)\n\n### QQ既有UDP也有TCP！\n\n不管UDP还是TCP，最终登陆成功之后，<u>QQ都会有一个`TCP连接`来保持在线状态</u>。这个TCP连接的远程端口一般是80，采用UDP方式登陆的时候，端口是8000。\n\nUDP协议是无连接方式的协议，它的效率高，速度快，占资源少，但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。由于QQ的服务器设计容量是`海量级的应用`，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。 ==（UDP保证海量级，大规模服务）==\n\nQQ客户端之间的消息传送也采用了UDP模式，因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此QQ选择了UDP作为客户之间的主要通信协议。  ==（UDP穿透复杂的代理服务器）==\n\n采用UDP协议，通过服务器中转方式。因此，现在的IP侦探在你仅仅跟对方发送聊天消息的时候是无法获取到IP的。大家都知道，UDP 协议是不可靠协议，它只管发送，不管对方是否收到的，但它的传输很高效。但是，作为聊天软件，怎么可以采用这样的不可靠方式来传输消息呢？于是，`腾讯采用了上层协议来保证可靠传输`：如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输。之所以会发生在客户端明明看到“消息发送失败”但对方又收到了这个消息的情况，就是因为客户端发出的消息服务器已经收到并转发成功，但客户端由于网络原因没有收到服务器的应答包引起的。  ==（使用UDP做了确认应答）==\n\n\n\n### 分情况应用tcp和udp\n\n登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说：\n\n1. <u>登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个`TCP连接来保持在线状态`。</u>\n\n2. `和好友发消息，客户端client采用UDP协议`，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。\n\n3. 如果是在`内网`里面的两个客户端传文件，QQ采用的是`P2P`技术，<u>不需要服务器中转</u>\n\n\n\n\n\n\n\n首先,QQ并不是完全基于UDP实现。比如在使用QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证。\n\nUPD包比TCP包要少12字节（UDP8,TCP20）\n使用UDP进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。\n\n腾讯采用了上层协议来保证可靠传输：如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输。\n\n \n\n## 5.15. 在网络弱的情况下开发者如何改进APP和服务器，提高请求和响应的准确率\n\n \n\n## 5.16. 手机时间乱了，如何实现设置中的同步网络标准时间\n\n### NTP服务器\n\n【Network Time Protocol（NTP）】是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。时间按NTP服务器的等级传播。按照离外部UTC源的远近把所有服务器归入不同的Stratum（层）中。\n\n### 解决方案\n\n根据不同的情况，如下三种解决方案：\n\n- 修改系统时间。\n  优点：程序启动时执行一次即可，一劳永逸。\n  缺点：只能在原生系统中使用，非原生系统无法安装。(具体后面会解释)。\n\n- 获取NTP服务器时间代替系统时间。\n  优点：无需Root，适用于任何手机及系统。\n  缺点：需要可以访问外部网络，内网环境下则需要一台自己的NTP服务器。\n\n  > 可以开启一个线程，做`定时任务`，不断更新该时间，以到达时间时间同步的效果\n\n- 获取网页时间代替系统时间。\n  优点：无需Root，适用于任何手机及系统，适用于任何网络环境。\n  缺点：需要一条额外的线程，去维护时间准确，容易造成误差。\n\n# 6.    [socket](##Tcp代码实现)\n\n## IP地址作用，以及MAC地址作用\n\n- MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。\n\n- P地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n\n> IP地址决定了网络中数据包如何通过路由器的转发到达目的地，而MAC地址则唯一标识了接受这个数据包的主机。\n>\n> ”IP地址是快递地址，MAC是收件人“\n\n> ==<u>IP 如何转发</u>==\n>\n> ==<u>MAC 目的地</u>==\n\n## socket编程中服务器端和客户端主要用到哪些函数\n\n### 基于TCP的socket：\n\n1. 服务器端程序：\n\n   > - 创建一个socket，用函数socket()\n   >\n   > - 绑定IP地址、端口等信息到socket上，用函数bind()\n   >\n   > - 设置允许的最大连接数，用函数listen()\n   >\n   > - 接收客户端上来的连接，用函数accept()\n   >\n   > - 收发数据，用函数send()和recv()，或者read()和write()\n   >\n   > - 关闭网络连接\n\n2. 客户端程序：\n\n   > - 创建一个socket，用函数socket()\n   >\n   > - 设置要连接的对方的IP地址和端口等属性\n   >\n   > - 连接服务器，用函数connect()\n   >\n   > - 收发数据，用函数send()和recv()，或read()和write()\n   >\n   > - 关闭网络连接\n\n   ![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220306213925515-1565537758.png)\n\n### 基于UDP的socket：\n\n1. 服务器端流程\n\n   > - 建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。\n   >\n   > - 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。\n   >\n   > - 绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。\n   >\n   > - 接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。\n   >\n   > - 向客户端发送数据，使用sendto()函数向服务器主机发送数据。\n   >\n   > - 关闭套接字，使用close()函数释放资源。UDP协议的客户端流程\n\n2. 客户端流程\n\n   > - 建立套接字文件描述符，socket()。\n   >\n   > - 设置服务器地址和端口，struct sockaddr。\n   >\n   > - 向服务器发送数据，sendto()。\n   >\n   > - 接收服务器的数据，recvfrom()。\n   >\n   > - 关闭套接字，close()。\n\n![在这里插入图片描述](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/20190703204323583.png)\n\n \n\n \n\n## Socket编程的send() recv() accept() socket()函数？\n\nsend函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。\n\nrecv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。\n accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。\n\n \n\n## 介绍一下udp的connect函数\n\n除非套接字已连接，否则异步错误是不会返回到UDP套接字的。我们确实可以给UDP套接字调用connect，然而这样做的结果却与TCP连接不同的是没有三路握手过程。内核只是检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回调用进程。\n\n对于已连接UDP套接字，与默认的未连接UDP套接字相比，发生了三个变化。\n\n其实一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。\n\n1、我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.\n\n2、不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。\n\n3、由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。\n\n来自任何其他IP地址或断开的数据报不投递给这个已连接套接字，因为它们要么源IP地址要么源UDP端口不与该套接字connect到的协议地址相匹配。\n\nUDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。\n\n## 6.6.   server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？\n\n这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态\n\n \n\n## 6.7.   socket的五元组是啥\n\n五元组格式（`协议`，`本地IP`，`本地端口`，`远方IP`，`远方端口`）\n\n服务器一般都有两个功能：监听 和 处理\n\n- 在监听的时候，协议/本地IP/本地端口（监听端口）都是确定的，当收到客户端的报文时，远方IP就是报文的源IP地址，远方端口就是报文的源端口，这样一来五元组就确定了。\n\n- 客户端的话正好相反，在发送请求时采用随机的本地端口，而接受响应时采用服务器的源端口作为远方端口。\n\n> getpeername得到远方端口号及地址\n> getsockname 得到本地端口号及地址\n\n \n\n \n\n#  项目实战\n\n [项目实战.pdf](..\\牛客学习资料\\第五章项目代码PPT\\第五章项目代码+PPT\\项目实战.pdf) \n\n\n\n## 阻塞/非阻塞 同步/异步（网络io)\n\n> 典型的一次IO的两个阶段是什么？`数据就绪` 和 `数据读写`\n\n数据就绪：根据系统IO操作的就绪状态\n\n- 阻塞\n\n- 非阻塞\n\n数据读写：根据应用程序和内核的交互方式\n\n- 同步\n\n- 异步\n\n陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，`只有使用了特殊的 API 才是异步 IO`。\n\n![image-20220408163945604](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408163945604.png)\n\n> 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。\n>\n> 同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），<u>数据的读写都是由请求方A`自己`来完成的</u>（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理`结果`。(意思是我给你处里好了 告诉你一声)\n\n- 同步阻塞\n\n- 同步非阻塞\n\n- 异步阻塞\n\n- 异步非阻塞\n\n## Unix/Linux上的五种IO模型\n\n### 阻塞 blocking\n\n调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必\n\n须等这个函数返回才能进行下一步动作。\n\n![image-20220408164252667](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164252667.png)\n\n### 非阻塞 non-blocking（NIO）\n\n非阻塞等待，<u>每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事</u>。非阻塞I/O执行系统调用<u>总是立即返回</u>，不管事件是否已经发生，<u>若事件没有发生，则返回-1</u>，此时可以`根据 errno` 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。\n\n![image-20220408164418629](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164418629.png)\n\n### IO复用（IO multiplexing）\n\nLinux 用 `select/poll/epoll` 函数实现 IO 复用模型，这些函数<u>也会使进程阻塞</u>，但是和阻塞IO所不同的是这些函数<u>可以同时阻塞多个IO操作</u>。而且<u>可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</u>。\n\n![image-20220408164556972](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164556972.png)\n\n### 信号驱动（signal-driven）\n\nLinux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。\n\n![image-20220408164637471](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164637471.png)\n\n内核在`第一个阶段是异步`，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，<u>不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率</u>。 \n\n### 异步（asynchronous）\n\nLinux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。\n\n![image-20220408164817634](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164817634.png)\n\n## Web Server（网页服务器）\n\n一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是<u>通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。</u>\n\n![image-20220408164930096](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408164930096.png)\n\n通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则\n\n1. 先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，\n2. 然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。\n\n## HTTP协议(应用层的协议) [看之前的](#3. 应用层)\n\n## 服务器编程基本框架\n\n虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。\n\n![image-20220408165839919](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408165839919.png)\n\n- I/O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I/O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。\n\n- 一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。\n\n- 网络存储单元可以是数据库、缓存和文件，但不是必须的。\n\n- 请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。\n\n## 两种高效的事件处理模式\n\n服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor和 Proactor，`同步 I/O 模型通常用于实现 Reactor 模式`，`异步 I/O 模型通常用于实现 Proactor 模式`。\n\n### `Reactor模式` （核反应堆）\n\n要求`主线程（I/O处理单元）只负责监听`文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。<u>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成</u>。\n\n使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：\n\n1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。\n2. 主线程调用 epoll_wait 等待 socket 上有数据可读。\n3. 当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。\n4. 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll\n\n内核事件表中注册该 socket 上的写就绪事件。\n\n5. 当主线程调用 epoll_wait 等待 socket 可写。\n6. 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。\n7. 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。\n\n#### Reactor 模式的工作流程：\n\n![image-20220408170831020](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408170831020.png)\n\n### Proactor模式\n\nProactor 模式将所有 I/O 操作都交给主线程和内核来处理（进行读、写），`工作线程仅仅负责业务逻辑`。使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：\n\n1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。\n2. 主线程继续处理其他逻辑。\n3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。\n4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。\n5. 主线程继续处理其他逻辑。\n6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。\n7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。\n\n#### Proactor 模式的工作流程：\n\n![image-20220408185245794](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220408185245794.png)\n\n### 模拟Proactor模式\n\n使用同步 I/O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向\n\n工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下\n\n来要做的只是对读写的结果进行逻辑处理。\n\n使用同步 I/O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：\n\n1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。\n2. 主线程调用 epoll_wait 等待 socket 上有数据可读。\n3. 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。\n4. 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。\n5. 主线程调用 epoll_wait 等待 socket 可写。\n6. 当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。\n\n#### 同步 I/O 模拟 Proactor 模式的工作流程：\n\n![image-20220409233342836](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220409233342836.png)\n\n## 线程池\n\n线程池是由`服务器预先创建的一组子线程`，线程池中的<u>线程数量应该和 CPU 数量差不多</u>。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：\n\n- 主线程使用某种算法来主动选择子线程。最简单、最常用的算法是`随机算法`和 `Round Robin（轮流选取）算法`，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。\n\n- 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。\n\n线程池的一般模型为：\n\n![image-20220410001141862](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220410001141862.png)\n\n> 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。\n\n- `空间换时间`，浪费服务器的硬件资源，换取运行效率。\n\n- 池是一组资源的集合，<u>这组资源在服务器启动之初就被完全创建好并初始化，这称为`静态`资源</u>。\n\n- 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。\n\n- 当服务器处理完一个客户连接后，可以把相关的资源放回池中，<u>无需执行系统调用释放资源</u>。\n\n## 有限状态机\n\n逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。\n\n有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以<u>根据它来编写相应的处理逻辑</u>。如下是一种状态独立的有限状态机：\n\n```c++\nSTATE_MACHINE( Package _pack ) { \n    PackageType _type = _pack.GetType(); \n    switch( _type ) { \n        case type_A: \n            process_package_A( _pack ); \n            break; \n        case type_B: \n            process_package_B( _pack ); \n            break; \n    } \n}\n```\n\n这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。\n\n状态之间的转移是需要状态机内部驱动，如下代码：\n\n```c++\nSTATE_MACHINE() { \n    State cur_State = type_A;\n    while( cur_State != type_C ) { \n        Package _pack = getNewPackage(); \n        switch( cur_State ) { \n            case type_A: \n                process_package_state_A( _pack ); \n                cur_State = type_B; \n                break; \n            case type_B: \n                process_package_state_B( _pack ); \n                cur_State = type_C; \n                break; \n        } \n    } \n}\n```\n\n该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。\n\n## EPOLLONESHOT事件\n\n- 即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。<u>比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。</u>`一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现`。\n\n- 对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。\n\n## **服务器压力测试**\n\n`Webbench` 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发。\n\n> - 测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。\n>\n> - 展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量。\n\n基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的结果通过pipe 告诉父进程，父进程做最终的统计结果。\n\n测试示例\n\n```\nwebbench -c 1000 -t 30 http://192.168.110.129:10000/index.html \n参数：\n-c 表示客户端数 \n-t 表示时间\n```\n\n\n\n ","tags":["面试"],"categories":["基础知识"]},{"title":"c++面试","url":"/2022/03/16/c-ba-gu/","content":"\n# 1.   语言\n\n## C++和C的区别\n\n**设计思想上：**\n\nC++是`面向对象`的语言，而C是`面向过程`的结构化编程语言\n\n**语法上：**\n\nC++具有`封装、继承和多态`三种特性\n\nC++相比C，增加多许多类型`安全`的功能，比如强制s类型转换\n\nC++支持`范式编程`，比如模板类、函数模板等\n\n \n\n**c++更安全**\n\n（1）操作符`new`返回的指针类型严格与对象匹配，而不是void；\n\n（2）C中很多以void为参数的函数可以改写为C++模板函数，而`模板是支持类型检查`的；\n\n（3）引入`const关键字`代替#define constants，它是有**类型、有作用域**的，而#define constants只是简单的`文本替换`；\n\n（4）一些`#define宏可被改写为inline函数`，结合函数的`重载`，可在`类型安全`的前提下`支持多种类型`，当然改写为模板也能保证类型安全\n\n（5）C++提供了`dynamic_cast关键字，使得转换过程更加安全`，因为dynamic_cast比static_cast涉及更多具体的类型检查。\n\n## 面向过程和面向对象的区别\n\n<u>==**面向过程**==</u>\n\n优点：`性能比面向对象高`，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n\n缺点：`没有`面向对象`易维护、易复用、易扩展`\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811279-1163623030.png)\n\n<u>==**面向对象**==</u>\n\n优点：`易维护、易复用、易扩展`，由于面向对象有封装、继承、多态性的特性，可以设计出`低耦合`的系统，使`系统 更加灵活、更加易于维护`\n\n缺点：`性能`比面向过程`低`\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811278-1076991646.png)\n\n## 面向对象的六大原则\n\n1.`单一职责`原则：`就一个类而言，应该仅有一个引起它发生变化的原因`\n\n如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱这个或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，这种高耦合会导致意想不到的变化\n\n \n\n2.`开放封闭`原则:软件实体(类，模块，函数等等)应该`可以扩展`，`但是不能修改`\n\n面对需求的时候，对程序的改动是通过增加新的代码来完成的，而不是通过对原代码的改变来完成，对于原代码的改变很麻烦，可能会导致意想不到的错误\n\n`开放封闭原则是面向对象设计的核心所在`，遵循这个原则，实现了可维护，可扩展，可复用，灵活性好，开发人员应该进队程序中呈现出频繁变化的那些部分作出抽象，但是也不能可以地对每一个部分进行抽象，拒绝不成熟的抽象一样很重要\n\n个人理解：简单工厂模式并不是属于23中设计模式之一，主要就是因为简单工厂模式不符合开放封闭的原则，在类里面增加switch...case语句，当有新的功能或者是类的时候，就要修改该工厂类，代码的可维护性减低了\n\n \n\n3.`里氏代换`原则：`子类型必须能够替换掉他们的父类型`\n\n只有当子类可以替换到父类，软件单位的功能不受到影响的时候，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为\n\n如果没有里氏代换原则，我们在开发的时候如果改变了子类的行为，同时对父类产生了影响，这样你要修改子类，也就必须要修改父类了。\n\n \n\n4.`依赖倒转`原则：也叫依赖倒置原则，其内容如下：\n\nA：高层模块不应该依赖底层模块，`两个都应该抽象`\n\nB：抽象不应该依赖细节，`细节应该依赖抽象`\n\n倒转，假如用户的需求需要改变，软件开发的时候你用的是db2数据库，但是最后要改为mysql数据库，由于高层的模块依赖的是底层的模块，这就使得底层模块也要做修改。但是如果高层模块依赖的是接口或者是抽象类的话，因为接口和抽象类是不变的，所以如果你要更改数据库的话，就不怕出现混乱，A和B两个说的都是这样的意思。因为依赖的是抽象类或者接口，有里氏代换规则可以知道，子类的变化对于父类造不成影响。\n\n针对上面的例子，我们可以做一个抽象的数据库的类，让db2继承这个抽象类，加入现在要换为mysql数据库，只要让mysql去继承这个类就可以，不管用哪个数据库，我们都建立的是抽象数据类的引用，用它去指向你要访问的类就ok了\n\n \n\n5.`迪米特`法则：如果两个类之间不必发生彼此直接通信，那么这两个类就不应当发生直接的相互引用。如果其中一个类需要调用另一个类的某个方法的话，可以`通过第三者转发这个调用`\n\n对于这个原则，我是这样理解的，两个类之间相互知道了解，就是将一个类直接暴露给了另外一个类，这样子违反了信息的隐藏。如果多个类之间需要两两发生调用的话，那么就需要调用者知道被调用这的全部信息，这是我们可以通过一个中介来转发需要通信的两个类之间的请求，所有的类，只需要将自己暴露给中介就可以了，不需要给被调用者，这样做简化了代码，这也就是设计模式中的中介者模式\n\n这样`降低了类与类之间的耦合性`，符合我们提倡的低耦合的观点，耦合性越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及\n\n \n\n6、`接口隔离`原则\n\n表明客户端不应该被强迫实现一些他们不会使用的接口，应该把接口中方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是`使用多个专门的接口比使用单个接口好很多`。\n\n该原则观点如下：\n1）一个类对另外一个类的依赖性应当是建立在最小的接口上\n\n2）客户端程序不应该依赖它不需要的接口方法。\n\n## C++中，为什么可以函数重载，实现原理\n\n`c++函数重载的原理:`\n\n编译器在编译.cpp文件中当前使用的作用域里的同名函数时，根据函数形参的类型和顺序会对函数进行重命名（不同的编译器在编译时对函数的重命名标准不一样）但是总的来说，他们都把文件中的同一个函数名进行了重命名；\n\n**在vs编译器中：**\n\n根据返回值类型（不起决定性作用）+形参类型和顺序（起决定性作用）的规则重命名并记录在map文件中。\n\n在**linux g++** **编译器中：**\n\n根据`函数名字的字符数`+`形参类型和顺序`的规则重命名记录在符号表中；从而产生不同的函数名，当外面的函数被调用时，便是根据这个记录的结果去寻找符合要求的函数名,进行调用；\n\n**为什么c语言不能实现函数重载**\n\n**编译器在编译**.c文件时，`只会给函数进行简单的重命名`；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错；\n\n \n\n## C++11有哪些新特性？\n\nC++11 最常用的新特性如下：\n\n`lambda表达式`：\n\n`auto关键字`：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导\n\n`nullptr关键字`：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。\n\n`智能指针`：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。\n\n`初始化列表`：使用初始化列表来对类进行初始化\n\n`右值引用`：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率\n\natomic原子操作用于多线程资源互斥操作\n\n新增STL容器array以及tuple\n\n## NULL和nullptr的区别\n\n在C语言中，NULL通常被定义为：#define NULL ((void *)0)\n\nC++是强类型语言，void*是不能隐式转换成其他类型的指针的\n\n在C++中，NULL实际上是0. 因为C++中不能把void*类型的指针隐式转换成其他类型的指针，所以为了解决空指针的表示问题，C++引入了nullptr来表示空指针。\n\n为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了nullptr这一新的关键字来代指空指针，从上面的例子中我们可以看到，使用nullptr作为实参，确实选择了正确的以void*作为形参的函数版本\n\n\n\n### [void*是怎样的存在？](https://zhuanlan.zhihu.com/p/98061960)\n\n#### **指针类型的含义**\n\n在说明`void*`之前，先了解一下普通指针类型的含义。\n\n```c\n//main.c\n#include <stdio.h>\nint main(void)\n{\n    int a[] = {0x01020304,2019};\n    int *b = a;\n    char *c = (char*)&a[0];\n    printf(\"b+1:%d\\n\",*(b+1));\n    printf(\"c+1:%d\\n\",*(c+1));\n    return 0;\n}\n```\n\n上面的输出结果为：\n\n```text\nb+1:2019\nc+1:3\n```\n\n一个是指向整型的指针，一个是指向char型的指针，当它们执行算术运算时，`它们的步长就是对应类型占用空间大小`。\n\n即\n\n```text\nb + 1 //移动sizeof(int)字节  4\nc + 1 //移动sizeof(char)字节 2\n```\n\n#### **结论**\n\n各种类型之间没有本质区别，只是解释内存中的数据方式不同。例如，对于int型指针b，解引用时，会解析4字节，算术运算时，也是以该类型占用空间大小为单位，所以b+1，移动4字节，解引用，处理4字节内容，得到2019。对于char型指针c，解引用时，会解析1个字节，算术运算时，也是以sizeof(char)为单位，所以c+1，移动一字节，解引用，处理1字节，得到03。所以像下面这样的操作：\n\n```text\nchar a[] = {01,02,03,04};\nint *b = (int*)(a+2);\n```\n\n如果你试图解引用b，即*b，就可能遇到无法预料的问题，因为将会访问非法内存位置。a+2，移动sizeof(char)字节，指向03，此时按照int类型指针解引用，由于int类型解引用会处理4字节内存，但是后面已经没有属于数组a的合法内容了，因此可能出错。\n\n#### **void**\n\n说回void*，前面说了，指针的类型不过是解释数据的方式不同罢了，这样的道理也可用于很多场合的强制类型转换，例如将int类型指针转换为char型指针，并不会改变内存的实际内容，只是修改了解释方式而已。而void * 是一种无类型指针，任何类型指针都可以转为`void*`，它无条件接受各种类型。而既然是无类型指针，那么就**<u>不要尝试</u>**做下面的事情：\n\n- 解引用\n- 算术运算\n\n由于不知道其解引用操作的内存大小，以及算术运算操作的大小，因此它的结果是未知的。\n\n```c\n#include <stdio.h>\nint main(void)\n{\n    int a = 10;\n    int *b = &a;\n    void *c = b; \n    *c;    //warning: dereferencing ‘void *’ pointer\n    return 0;\n}\n```\n\n#### **如何使用**\n\n既然如此，那么void* 有什么用呢？实际上我们在很多接口中都会发现它们的参数类型都是void*,例如:\n\n```text\nssize_t read(int fd, void *buf, size_t count);\nvoid *memcpy(void *dest, const void *src, size_t n);\n```\n\n为何要如此设计？因为对于这种通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void* 。void*  能包容地接受各种类型的指针。也就是说，如果你期望接口能够接受任何类型的参数，你可以使用void* 类型。但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是int* ，那么你在使用的时候就应该按照int* 使用。\n\n#### **注意**\n\n使用void*需要特别注意的是，你必须清楚原始传入的是什么类型，然后转换成对应类型。例如，你准备使用库函数qsort进行排序：\n\n```text\nvoid qsort(void *base,size_t nmemb,size_t size , int(*compar)(const void *,const void *));\n```\n\n它的第三个参数就是比较函数，它接受的参数都是const void*，如果你的比较对象是一个结构体类型，那么你自己在实现compar函数的时候，也必须是转换为该结构体类型使用。举个例子，你要实现学生信息按照成绩比较：\n\n```c\ntypedef struct student_tag\n{\n    char name[STU_NAME_LEN];  //学生姓名\n    unsigned int id;          //学生学号\n    int score;                //学生成绩\n}student_t;\n\nint studentCompare(const void *stu1,const void *stu2)\n{\n　　/*强转成需要比较的数据结构*/\n    student_t *value1 = (student_t*)stu1;\n    student_t *value2 = (student_t*)stu2;\n    return value1->score-value2->score;\n}\n```\n\n在将其传入`studentCompare`函数后，必须转换为其对应的类型进行处理。\n\n#### **总结**\n\nvoid* 很强大，但是一定要在合适的时候使用；同时强转很逆天，但是一定要注意前后的类型是否真的能正确转换。通俗地说void*：\n\n- <u>**这里有一片内存数据，我也不知道什么类型，给你了，你自己想怎么用怎么用吧，不过要用对奥！**</u>\n- <u>**我这里什么类型都能处理，你给我一片内存数据就可以了**</u>\n\n## [使用初始化列表的好处](https://www.cnblogs.com/wuyepeng/p/9863763.html)\n\n[C++ 初始化列表](https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)\n\n1.类成员中存在`常量`，如`const` int a,只能用初始化不能复制\n\n2.类成员中存在`引用`，同样只能使用初始化不能赋值。\n\n3.提高效率\n\n```c++\ntemplate < class  T>\nclass  NamedPtr {\npublic  :\n    NamedPtr( const string& initName, T *initPtr);\n    ...\nprivate:\n  const string& name;  // 必须通过成员初始化列表\n              // 进行初始化\n  T * const ptr;  // 必须通过成员初始化列表\n          // 进行初始化\n};\n\nstruct Test1\n{\n    Test1() // 无参构造函数\n    { \n        cout << \"Construct Test1\" << endl ;\n    }\n\n    Test1(const Test1& t1) // 拷贝构造函数\n    {\n        cout << \"Copy constructor for Test1\" << endl ;\n        this->a = t1.a ;\n    }\n\n    Test1& operator = (const Test1& t1) // 赋值运算符\n    {\n        cout << \"assignment for Test1\" << endl ;\n        this->a = t1.a ;\n        return *this;\n    }\n\n    int a ;\n};\n\nstruct Test2\n{\n    Test1 test1 ;\n    Test2(Test1 &t1)\n    {\n        test1 = t1 ;\n    }\n    \n    //如果是初始化列表 就可以省去计算阶段\n     Test2(Test1 &t1)\n    {\n        test1 = t1 ;\n    }\n};\n```\n\n- **构造函数的两个执行阶段**\n  1. `初始化阶段`：所有类类型（class type）的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。\n  2. `计算阶段`：如果类成员，初始化列表只用调用类的拷贝构造函数，不使用初始化列表则需先调用默认构造函数构造对象，再给对象赋值，赋值的阶段即为计算阶段，`初始化列表可以省去计算阶段`从而优化性能\n\n## 1.8.  auto 和 [decltype](https://www.cnblogs.com/QG-whz/p/4952980.html)区别和联系\n\nauto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 `auto 定义的变量必须有初始值`。\n\n当引用被用作初始值的时候，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型。\n\nauto一般会忽略掉顶层const，但底层const会被保留下来，比如当初始值是一个指向常量的指针时：\n\n```c++\nconst int ci = i, &cr = ci;\nauto b = ci; //b是一个整数（ci的顶层const特性被忽略掉了)\nauto c = cr; //c是一个整数（Cr是ci的别名，ci本身是一个顶层const)\nauto d = &i; //d是一个整型指针（整数的地址就是指向整数的指针）\nauto e = &ci; //e是一个指向整形常量的指针（对常量对象取地址是一种底层const)\n```\n\n[decltype](https://www.cnblogs.com/QG-whz/p/4952980.html)的作用是`选择并返回操作数的数据类型`。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。(主要用在泛型编程中结合auto，用于追踪函数的返回值类型)\n\n```c++\ntemplate <typename _Tx, typename _Ty>\nauto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty){\n    return x*y;\n}\n```\n\ndecltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内).\n\n如果decltype得到引用则必须初始化。\n\n注意:decltype((variable))（注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当 variable本身就是一个引用时才是引用。\n\n> 使用：顶堆的自定义排序  [顶堆 | qianxunslimgのblog](https://qianxunslimg.github.io/2022/04/20/ding-dui/)\n>\n> ```c++\n> auto cmp = [](const pair<int, int> a, const pair<int, int> b)->bool{\n>   \treturn a.first + a.second > b.first + b.second;\n> };\n> priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n> ```\n\n## 1.9.  [C++11右值引用](https://zhuanlan.zhihu.com/p/85668787)\n\n右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：\n\n1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。\n\n2. 能够更简洁明确地定义泛型函数。\n\n \n\n#### 左值和右值的概念：\n\n左值：`能对表达式取地址`、或具名对象/变量。一般指表达式结束后依然存在的`持久对象`。\n\n右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的`临时对象`。\n\nC++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：\n\nT && a=ReturnRvale();\n\n假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。\n\n \n\n可以使用move将对左值进行右值引用\n\n int k = 4;\n\n  int&& s = move(k);\n\n此时s和k地址一样。\n\n### 1.9.1. 移动构造\n\n基于右值引用可以实现转移语义和完美转发新特性。\n\n移动语义：\n\n- 对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。\n\n- 但是如下列代码所示：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass HasPtrMem{\npublic:\n  HasPtrMem() : d(new int(0)){\n    cout<<\"Construct:\"<<++n_cstr<<endl;\n  }\n  HasPtrMem(const HasPtrMem &h) : d(new (int(*h.d))){\n    cout<<\"Copy construct:\"<<++n_cptr<<endl;\n\t}\n  ~HasPtrMem(){\n    cout<<\"Destruct:\"<<++n_dstr<<endl;\n\t}\n  int *d;\n  static int n_cstr;\n  static int n_dstr;\n  static int n_cptr;\n};\n\nint HasPtrMem::n_cstr == 0;\nint HasPtrMem::n_dstr == 0;\nint HasPtrMem::n_cptr == 0;\n\nHasPtrMem GetTemp(){retrun HasPtrMem();}\n\nint main(){\n  HasPtrMem a = GetTemp();\n}\n\nHasPtrMem(HasPtrMem && h) : d(h.d){ //移动构造函数\n  h.d = nullptr;\t\t\t\t\t\t\t\t\t\t//将移动值的指针成员置空\n  cout<<\"Move construct:\"<<++n_mvtr<<endl;\n}\n```\n\n- 当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。\n\n- 而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。\n\n- 如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。\n\n- 使用右值引用直接使用h里面的h.d。\n\n  否则将会用h.d构造d，因为拷贝构造不能浅拷贝指针，所以不能直接赋值。\n\n```c++\nHasPtrMem(HasPtrMem && h) : d(h.d){ //移动构造函数\n  h.d = nullptr;\t\t\t\t\t\t\t\t\t\t//将移动值的指针成员置空\n  cout<<\"Move construct:\"<<++n_mvtr<<endl;\n}\n```\n\n- 其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811301-2120007528.png)\n\n### 1.9.2. [完美转发](https://blog.csdn.net/xiangbaohui/article/details/103673177)\n\nstd::forward被称为完美转发，它的作用是保持原来的值属性不变。啥意思呢？通俗的讲就是，如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。\n\n完美转发是指\n\n- 只有在需要的时候，才调用复制构造函数\n- 左值被转发为左值，右值被转发为右值\n\n##### 参数转发\n\n```cpp\nvoid foo(myVector& v) {}\n\n// 参数转发\ntemplate<typename T>\nvoid relay(T arg) {\n    foo(arg);\n}\n\nint main() {\n  myVector reusable= reateMyVector();\n  \n  // 拷贝构造函数\n  relay(reusable); \n\n  // 移动构造函数\n  relay(createMyVector()); \n}\n```\n\n这个实现有个问题，假如定义了两个版本的 foo\n\n```cpp\nvoid foo(myVector& v) {}\nvoid foo(myVector&& v) {}\n```\n\n永远只有 foo(myVector& v) 会被调用 (右值引用`myVector&& v`是个左值，这里的v是有名字的)\n\n所以，我们需要改写上文的 relay 函数，借助 std::forward\n\n```cpp\ntemplate<typename T>\nvoid relay(T&& arg) {\n    foo(std::forward<T>(arg));\n}\n```\n\n于是就有\n\n- relay(reusable) 调用 foo(myVector&)\n- relay(createMyVector()) 调用 foo(myVector&&)\n\n要解释完美转发的原理，首先引入 C++11 的引用折叠原则\n\n- T& & => T&\n- T& && => T&\n- T&& & => T&\n- T&& && => T&&\n\n所以，在 relay 函数中\n\n- relay(9); => T = int&& => T&& = int&& && = int&&\n- relay(x); => T = int& => T&& = int& && = int &\n\n因此，在这种情况下，T&& 被称作 universal reference，即满足\n\n- T 是模板类型\n- T 是被推导出来的，适用引用折叠，即 T 是一个函数模板类型，而不是类模板类型\n\n然后，C++11 定义了 remove_reference，用于返回引用指向的类型\n\n```cpp\ntemplate<class T>\nstruct remove_reference; \n\nremove_reference<int&>::type == int\nremove_reference<int>::type  == int\n```\n\n于是，std::forword 的实现如下\n\n```cpp\ntemplate<class T>\nT&& forward(\ntypename remove_reference<T>::type& arg\n) {\n  return static_cast<T&&>(arg);\n}\n```\n\n等于是把右值引用(右值引用本身是个左值)转成了右值，左值保持不变\n\n\n\n## 1.10. push_back()和emplace_back()区别\n\n如果传入类，push_back()先构造对象，再将对象放到末尾（如果是右值就进行移动构造），emplace_back()直接在末尾构造。\n\n#### **1. `push_back()` 方法**\n\n首先分析较为简单直观的 `push_back()` 方法。对于 `push_back()` 而言，最开始只有 `void push_back( const T& value );` 这个函数声明，后来从 `C++11` ，新加了`void push_back( T&& value )` 函数，以下为 `C++` 中的源码实现：\n\n```c++\n/**\n *  以下程序来自STL源码 bits/stl_vector.h\n *\n *  @brief  Add data to the end of the %vector.\n *  @param  __x  Data to be added.\n *\n *  This is a typical stack operation.  The function creates an\n *  element at the end of the %vector and assigns the given data\n *  to it.  Due to the nature of a %vector this operation can be\n *  done in constant time if the %vector has preallocated space\n *  available.\n */\nvoid push_back(const value_type &__x) {\n    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {\n        // 首先判断容器满没满，如果没满那么就构造新的元素，然后插入新的元素\n        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n                                 __x);\n        ++this->_M_impl._M_finish; // 更新当前容器内元素数量\n    } else\n        // 如果满了，那么就重新申请空间，然后拷贝数据，接着插入新数据 __x\n        _M_realloc_insert(end(), __x);\n}\n\n// 如果 C++ 版本为 C++11 及以上（也就是从 C++11 开始新加了这个方法），使用 emplace_back() 代替\n#if __cplusplus >= 201103L\nvoid push_back(value_type &&__x) {\n    emplace_back(std::move(__x));\n}\n#endif\n```\n\n在 `C++20` 之后，对这两个重载方法进行了修改，变成了 `constexpr void push_back( const T& value );` 以及 `constexpr void push_back( T&& value );` 。详情参考 `http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf` **[版本修改计划](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1004r2.pdf)**。\n\n#### **2. `emplace_back()` 方法**\n\n`emplace_back()` 是从 `C++11` 起新增到 `vector` 中的方法，最初的函数声明为：\n\n```c++\ntemplate< class... Args >\nvoid emplace_back( Args&&... args );\n```\n\n之后在 `C++14` 之后，将无返回值 `void` 改为了返回对插入元素的引用：\n\n```c++\ntemplate< class... Args >\nreference emplace_back( Args&&... args );\n```\n\n在 `STL` 源码中，可以看到 `emplace_back()` 的实现是这样的：\n\n```c++\n/**\n *  以下程序来自STL源码 bits/vector.tcc\n */\ntemplate<typename _Tp, typename _Alloc>\ntemplate<typename... _Args>\n#if __cplusplus > 201402L\ntypename vector<_Tp, _Alloc>::reference\n#else\nvoid\n#endif\nvector<_Tp, _Alloc>::emplace_back(_Args &&... __args) {\n    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {\n        // 同样判断容器是否满了，没满的话，执行构造函数，对元素进行构造，并执行类型转换\n        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n                                 std::forward<_Args>(__args)...);\n        ++this->_M_impl._M_finish; // 更新当前容器大小\n    } else\n        // 满了的话重新申请内存空间，将新的元素继续构造进来，并且进行类型转换\n        _M_realloc_insert(end(), std::forward<_Args>(__args)...);\n#if __cplusplus > 201402L\n    return back(); // 在 C++14版本之后，添加返回值，返回最后一个元素的引用\n#endif\n}\n\n#endif\n```\n\n将 `emplace_back()` 和 `push_back()` 中区别最大的程序拎出来看：\n\n```c++\n_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n                                 std::forward<_Args>(__args)...); // emplace_back()\n_Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,\n                                 __x);                            // push_back()\n```\n\n对于 `std::forward()` 函数而言，本质上是一个类型转换函数，它的声明函数如下所示：\n\n```c++\n/**\n *  以下程序来自STL源码 bits/move.h\n *  @brief  Forward an lvalue.\n *  @return The parameter cast to the specified type.\n *\n *  This function is used to implement \"perfect forwarding\".\n */\ntemplate<typename _Tp>\nconstexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept {\n    return static_cast<_Tp &&>(__t);\n}\n```\n\n**在强制类型转换中，将参数 `__t` 传递给对应类 `_Tp` 的构造函数，然后调用了该类的构造函数从而完成对象创建过程。**\n\n因此，在 `emplace_back()` 函数中，是支持直接将构造函数所需的参数传递过去，然后构建一个新的对象出来，然后填充到容器尾部的。\n\n## 1.11. C++11 Lambda表达式\n\nLambda表达式定义一个匿名函数，并且可以捕获一定范围内的变量，其定义如下：\n\n[capture] (params)mutable->return-type{statement}\n\n其中，\n\n- [capture]：捕获列表，捕获上下变量以供lambda使用。编译器根据符号[]判断接下来代码是否是lambda函数。\n\n- (Params)：参数列表，与普通函数的参数列表一致，如果不需要传递参数，则可以连通括号一起省略。\n- mutable是修饰符，默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。\n- ->return-type:返回类型是返回值类型\n- {statement}:函数体，内容与普通函数一样，除了可以使用参数之外，还可以使用所捕获的变量。\n\nLambda表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。其形式如下:\n\n> - [ ] [var]表示值传递方式捕捉变量var\n>\n> - [ ] [=]表示值传递方式捕捉所有父作用域的变量（包括this)\n> - [ ] [&var]表示引用传递捕捉变量var\n> - [ ] [&]表示引用传递捕捉所有父作用域的变量（包括this）\n> - [ ] [this]表示值传递方式捕捉当前的this指针\n\nLambda的类型被定义为“闭包”的类，其通常用于STL库中，在某些场景下可用于`简化仿函数`的使用，同时`Lambda作为局部函数，也会提高复杂代码的开发加速，轻松在函数内重用代码，无须费心设计接口`。\n\n## 1.12. [头文件循环引用](https://blog.csdn.net/qq_22488067/article/details/73195621)\n\n```c++\nA.h\n#include \"B.h\"\nclass A{\npublic:\n　　B* m_b;\n}\n\nB.h\n#include \"A.h\"\nclass B{\npublic:\n　　A* m_a;\n}\n```\n\n上面这样是编译不过的，把A.h中的\n\n\\#include \"B.h\"\n\n去掉，改为\n\nclass B;\n\n1. 两个类不能互相include对方的头文件，两者也不能都是实体对象，必须其中一个为指针。 因为两个类相互引用，不管哪个类在前面，都会出现有一个类未定义的情况，所以可以`提前声明一个类`，而类的声明就是提前告诉编译器，所要引用的是个类，但此时后面的那个类还没有定义，因此无法给对象分配确定的内存空间，因此`只能使用类指针`。如果非得互相引用实体，那应该是错误的设计。 \n2. 用指针的原因是：假设两个类分别为A和B，在B中用指针调用A，那么在A需要知道B占空间大小的时候，就会去找到B的定义文件，虽然B的定义文件中并没有导入A的头文件，不知道A的占空间大小，但是由于在B中调用A的时候用的指针形式，B只知道指针占4个字节就可以，不需要知道A真正占空间大小，也就是说，A也是知道B的占空间大小的。 \n\n# 2.   重载、模板\n\n## 2.1.  运算符重载\n\n### 2.1.1. 算术运算符\n\n```c++\ncomplex complex::operator+(const complex &A) const{\n\tcomplex B;\n\tB.m_real = this->m_real + A.m_real;\n\tB.m_imag = this->m_imag + A.m_imag;\n\treturn B;\n}\n//以全局函数的形式重载\nComplex operator+(const Complex &c1, const Complex &c2){\n\tComplex c;\n\tc.m_real = c1.m_real + c2.m_real;\n\tc.m_imag = c1.m_imag + c2.m_imag;\n\treturn c;\n}\n```\n\n### 2.1.2. []\n\n```c++\nint& Array::operator[](int i){\n\treturn m_p[i];\n}\n```\n\n### 2.1.3. <<,>>\n\n```c++\nistream & operator>>(istream &in, complex &A){\n\tin >> A.m_real >> A.m_imag;\n  return in;\n}\n\nostream & operator<<(ostream &out, complex &A){\n\tout << A.m_real <<\" + \"<< A.m_imag <<\" i \";\n\treturn out;\n}\n```\n\n### 2.1.4. ++i和i++的实现\n\n1. ++i 实现：\n\n```c++\nint& int::operator++ (){\n\t*this +=1；\n\treturn *this；\n}\n```\n\n2. i++ 实现：\n\n````c++\nconst int  int::operator++ (int){\n\tint oldValue = *this；\n\t++（*this）；\n\treturn oldValue；\n}\n````\n\n### 2.1.5. 函数调用运算符()\n\n```c++\nclass Complex {\n  double real, imag;\n\npublic:\n  Complex(double r = 0, double i = 0) : real(r), imag(i){};\n  operator double() { return real; } //重载强制类型转换运算符 double\n};\n\nint main() {\n  Complex c(1.2, 3.4);\n  cout << (double)c << endl; //输出 1.2  !!!!!!!!!!\n  double n = 2 + c;          //等价于 double n = 2 + c. operator double()\n  cout << n;                 //输出 3.2\n}\n```\n\n举个简单的例子，下面这个名为absInt的struct含有一个调用运算符，该运算符负责返回其参数的绝对值：\n\n```c++\nstruct absInt {\n  int operator()(int val) const{\n    return val<0?-val:val;\n  }\n};\n\nint main(){\n  int i = -42;\n\tabsInt absObj;\t\t\t//含有函数调用运算符的对象\n\tint ui = ansObi(i); //将i传递给absObj.operator(); \n}\n\n```\n\n### 2.1.6. 成员访问运算符* ->\n\n```c++\nclass ObjContainer {\n  vector<Obj *> a;\n\npublic:\n  void add(Obj *obj) {\n    a.push_back(obj); // 调用向量的标准方法\n  }\n  friend class SmartPointer;\n};\n\nclass SmartPointer {\n  ObjContainer oc;\n  Obj *operator->() const {\n    if (!oc.a[index]) {\n      cout << \"Zero value\";\n      return (Obj *)0;\n    }\n    return oc.a[index];\n  }\n};\n```\n\nA* ca;  \t调用ca->相当于调用ca->oc.a[index]->;\n\n## 2.2.  类模板\n\nC++ 中类模板的写法如下：\n\n```c++\ntemplate <类型参数表>\nclass 类模板名{\n   成员函数和成员变量\n};\n```\n\n## 2.3.  C++11中的可变参数模板\n\nC++11的可变参数模板，`对参数进行了高度泛化`，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上`省略号`”。\n\n例如：\n\n```c++\nTemplate<class ... T>\nvoid func(T ... args){\n\tcout<<”num is”<<sizeof ...(args)<<endl;\n}\n```\n\nfunc();//args不含任何参数\n\nfunc(1);//args包含一个int类型的实参\n\nfunc(1,2.0);//args包含一个int一个double类型的实参\n\n其中T叫做模板参数包，args叫做函数参数包\n\n省略号作用如下：\n\n1）声明一个包含0到任意个模板参数的参数包\n\n2）在模板定义得右边，可以将参数包展成一个个独立的参数\n\nC++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：\n\n```c++\n#include<iostream>\nusing namespace std;\n// 最终递归函数\nvoid print(){\n  cout << \"empty\" << endl;\n}\n\n// 展开函数\ntemplate <class T, class ...Args>\nvoid print(T head, Args... args){\n  cout << \"parameter \" << head << endl;\n  print(args...);\n}\n\nint main(){\n  print(1, 2, 3, 4); return 0;\n}\n```\n\n参数包Args ...在展开的过程中递归调用自己，没调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程\n\n![image-20220417154116203](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220417154116203.png)\n\n# 3.   类\n\n## 3.1.  空类占多大内存，为什么\n\n`1字节`，\n\n`类中static数据不占空间。`\n\n`虚函数表占4字节，函数不占内存`。\n\n编译器往往会给一个`空类隐含的加一个字节（char）`，这样空类在实例化后在内存得到了`独一无二的地址`。\n\n## 3.2.  this指针理解\n\n1. 定义\n\n- 在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。`this 指针是所有成员函数的隐含参数`。因此，在成员函数内部，`它可以用来指向调用对象`。\n\n2. `this只能在成员函数中使用`\n\n   成员函数默认第一个参数为T* const register this。\n\n   `（友元函数，全局函数不是成员函数）`\n\n3. this指针不能再静态函数中使用\n\n- 静态函数如同静态变量一样，他不属于具体的哪一个对象，`静态函数表示了整个类范围意义上的信息`，而`this指针却实实在在的对应一个对象`，所以this指针不能被静态函数使用。\n\n4. `this指针的创建`\n\n- this指针在成员函数的开始执行前构造的，在成员的执行结束后清除。\n\n5. this指针只有在`成员函数`中才有定义\n\n- 创建一个对象后，不能通过对象使用this指针。也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以`&this`获得)，也可以直接使用的。\n- this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。\n-  this 作为隐式形参，`本质上是成员函数的局部变量`，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。\n\n## 3.3.  C++中类成员的访问权限\n\n1. public修饰的成员变量\n   \n- 能被类成员函数、子类函数、友元访问，也能被类的对象访问，`不需要通过成员函数就可以由类的实例直接访问`\n  \n2. private修饰的成员变量\n   \n-  只能被类成员函数及友元访问，不能被其他任何访问，本身的类对象也不行，`类的实例要通过成员函数才可以访问`，这个可以起到`信息隐藏`\n   \n3. protected是受保护变量\n   \n   - `只能被类成员函数、子类函数及友元访问，不能被其他任何访问，本身的类对象也不行`，也就是说，`基类中有protected成员，子类继承于基类，那么也可以访问基类的protected成员，要是基类是private成员，则对于子类也是隐藏的，不可访问`\n   \n     > 可以理解为可以继承的private?\n\n## 3.4.  C++中struct和class的区别\n\n在C++中，可以用struct和class定义类，都可以继承。区别在于：\n\n1. `默认的继承访问权`。class默认的是private,strcut默认的是public。\n2. `默认访问权限`：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。\n3. “class”这个关键字还用于`定义模板参数`，就像“typename”。但关建字“struct”不用于定义模板参数\n4. class和struct在使用大括号`{ }`上的区别\n   - **关于使用大括号初始化**\n     1. class和struct如果定义了构造函数的话，都不能用大括号进行初始化\n     2. 如果没有定义构造函数，struct可以用大括号初始化。\n     3. 如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化\n\n## 3.5.  C++类内可以定义引用数据成员吗？\n\n`可以，必须通过成员函数初始化列表初始化。` （必须使用初始化列表的情况：const 和引用, 初始化列表还有一个好处是省去计算阶段）\n\n````c++\nclass A{\npublic:\n  A(int &b):a(b){}\n  int &a;\n};\n\nint main(){\n  int b = 10;\n  A a(b);\n  cout << a.a <<endl;\n  return 0;\n}\n````\n\n## 3.6.  一个空类都有什么默认函数\n\n三个构造，一个赋值一个寻址\n\n1. 无参的构造函数\n\n```c\nEmpty(){}\n```\n\n2. 拷贝构造函数\n\n```c++\nEmpty(const Empty& copy){}\n```\n\n3. 赋值运算符\n\n```c++\nEmpty& operator = (const Empty& copy){}\n```\n\n4. 析构函数（非虚）\n\n```c++\n~Empty(){}\n```\n\n5. 寻址函数\n\n```c++\nEmpty* operator&(){}//取址运算符\n```\n\n## 3.7.  Struct 和union的区别\n\n1. **结构体struct**\n\n- 各成员`各自拥有自己的内存`，各自使用互不干涉，同时存在的，`遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。`\n\n2. **联合体union**\n\n- 各成员`共用一块内存空间`，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，`联合体比结构体更节约内存`。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。`不允许对联合体变量名U2直接赋值或其他操作`。\n\n## 3.8.  [C++如何阻止一个类被实例化](https://www.cnblogs.com/Stephen-Qin/p/11514588.html)\n\n1. 定义一个无用的抽象函数，使得类成为`抽象类`。\n2. 将构造函数定义为private.\n3. 使用 构造函数=delete\n\n## [3.9 说一说你理解的内存对齐以及原因](https://zhuanlan.zhihu.com/p/30007037)\n\n### 为什么要进行内存对齐\n\n> `因为大多数处理器有内存存取粒度的限制，比如说32位系统是4字节的存取粒度，只能从地址为4的倍数的内存开始读取数据，所以需要内存对齐，数据在内存的存放没有规则的话，会给数据的读取增添很大的工作量，所以需要按照对齐规则存放数据，进行内存对齐`\n>\n> <u>==需要考虑成员变量定义的先后顺序，可以优化数据存储大小==</u>\n\n- 尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为<u>==内存存取粒度.==</u>\n\n- 现在考虑4字节存取粒度的处理器取int类型变量（32位系统），<u>==该处理器只能从地址为4的倍数的内存开始读取数据==</u>。\n\n- 假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-3f40af513a94901b36ceb5387982277e_r.jpg)\n\n- 现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-361e2d16876ce8383c9e6ea2dca34474_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 内存对齐规则\n\n每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。\n\n> #pragma pack(n) 设定最大对齐值\n\n有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫**对齐单位**。\n\n了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：\n\n1. 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。\n\n2.  **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。\n\n```c++\n//32位系统 4字节内存存取粒度\n//32位系统\n#include<stdio.h>\nstruct{\n    int i;    \n    char c1;  \n    char c2;  \n}x1;\n\nstruct{\n    char c1;  \n    int i;    \n    char c2;  \n}x2;\n\nstruct{\n    char c1;  \n    char c2; \n    int i;    \n}x3;\n\nint main(){\n    printf(\"%d\\n\",sizeof(x1));  // 输出8\n    printf(\"%d\\n\",sizeof(x2));  // 输出12\n    printf(\"%d\\n\",sizeof(x3));  // 输出8\n    return 0;\n}\n```\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-86c644ce29b1e2d3858380aaa631cc1d_r.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n添加了#pragma pack(n)后规则就变成了下面这样：\n\n1. 偏移量要是n和当前变量大小中较小值的整数倍\n\n2. 整体大小要是n和最大变量大小中较小值的整数倍\n\n3. n值必须为1,2,4,8…，为其他值时就按照默认的分配规则\n\n例如，对于上个例子的三个结构体，如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-672ebe0ccc1430adbda00dfd7abc0375_r.jpg\" alt=\"img\" style=\"zoom:80%;\" />\n\n如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-1c35bc20c76d85d07855901964488637_r.jpg\" alt=\"img\" style=\"zoom:80%;\" />\n\n# 4. 指针和引用\n\n## 4.1.  C/C++ 中指针和引用的区别？\n\n1. 指针有自己的一块`空间`，而引用只是一个`别名`；\n\n2. 使用`sizeof看一个指针的大小是4`，而`引用则是被引用对象的大小`<u>==；大小==</u>\n\n3. 指针可以被初始化为`NULL`，而引用必须被`初始化`且必须是一个已有`对象`的引用；<u>==初始化==</u>\n\n4. 作为参数传递时，`指针需要被解引用`才可以对对象进行操作，而`直接对引用的修改都会改变引用所指向的对象`；\n\n5. 可以有`const指针`，但是没有const引用；\n\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；<u>==指向是否可改==</u>\n\n7. 指针可以有`多级指针`（**p），而引用至于`一级`； <u>==多级==</u>\n\n8. 指针和引用使用`++`运算符的意义不一样； 指针++移动地址，引用++正常++\n\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露？\n\n   [在函数内new一个对象，如果作为引用返回，是不是就可以不用delete了？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/33971459)\n\n## 4.2.  野指针是什么？\n\n野指针就是指向      `一个已删除的对象`或者`未申请访问权限内存区域`       的指针\n\n指针变量未初始化\n\n任何[指针变量](https://baike.baidu.com/item/指针变量)刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。指针释放后之后未置空\n\n有时[指针](https://baike.baidu.com/item/指针)在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。\n\n指针操作超越变量作用域\n\n数组越界\n\n不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。\n\n## 4.3.  c++四个智能指针：[shared_ptr](http://c.biancheng.net/view/7898.html),unique_ptr,weak_ptr,auto_ptr\n\nC++里面的四个智能指针: auto_ptr, `shared_ptr`, `weak_ptr`, `unique_ptr` 其中后三个是c++11支持，并且第一个已经被11弃用。\n\n`为什么要使用智能指针`：\n\n智能指针的作用是管理一个指针，因为存在以下这种情况：\n\n> 申请的空间在函数结束时`忘记释放，造成内存泄漏`。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个<u>==类==</u>，当超出了类的作用域是，类会自动调用<u>==析构函数==</u>，析构函数会自动释放资源。所以`智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。`\n\n1. auto_ptr（c++98的方案，cpp11已经抛弃）\n\n- 采用`所有权模式`。\n\n```c++\nauto_ptr<string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n\n- 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！\n\n2. unique_ptr（替换auto_ptr）\n\n- unique_ptr实现`独占式拥有`或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n- 采用`所有权`模式，还是上面那个例子\n\n````c++\nunique_ptr<string> p3 (new string  (\"auto\")); \nunique_ptr<string> p4；   \np4 = p3;//此时会报错！！\n````\n\n- 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。\n\n- 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个`临时右值`，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                   // #1 not allowed\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));  // #2 allowed\n```\n\n- 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。\n\n- 注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数`std::move()`，让你能够将一个unique_ptr赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1); //(ps1不在指向原来对象)\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n```\n\n3. <u>[==shared_ptr==](https://www.cnblogs.com/diysoul/p/5930361.html)</u>\n\n- shared_ptr实现`共享式拥有`概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“`最后一个引用被销毁`”时候`释放`。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。<u>==引用计数==</u>\n\n- shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n- 成员函数：\n  1. use_count 返回引用计数的个数\n  2. unique 返回是否是独占所有权( use_count 为 1)\n  3. swap 交换两个 shared_ptr 对象(即交换所拥有的对象)\n  4. reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少\n  5. get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的\n  \n  ```c++\n  #include <iostream>\n  #include <memory>\n  using namespace std;\n  int main()\n  {\n      //构建 2 个智能指针\n      std::shared_ptr<int> p1(new int(10));\n      std::shared_ptr<int> p2(p1);\n      //输出 p2 指向的数据\n      cout << *p2 << endl;   //输出10\n      p1.reset();//引用计数减 1,p1为空指针\n      if (p1) {\n          cout << \"p1 不为空\" << endl;\n      }\n      else {\n          cout << \"p1 为空\" << endl;  //输出\n      }\n      //以上操作，并不会影响 p2\n      cout << *p2 << endl;    //输出10\n      //判断当前和 p2 同指向的智能指针有多少个\n      cout << p2.use_count() << endl;  //输出 1\n      return 0;\n  }\n  ```\n\n4. weak_ptr  ( `shared_ptr 指针的一种辅助工具`)\n\n- weak_ptr 是一种`不控制对象生命周期`的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, `它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放`。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。\n\n  ````c++\n  class B;\n  class A{\n  public:\n  \tshared_ptr<B> pb_;\n  \t~A(){\n      cout<<\"A delete\\n\";\n    }\n  };\n  \n  class B{\n  public:\n    shared_ptr<A> pa_;\n  \t~B(){\n      cout<<\"B delete\\n\";\n    }\n  };\n  \n  void fun(){\n    shared_ptr<B> pb(new B());\n    shared_ptr<A> pa(new A());\n    pb->pa_ = pa;\n    pa->pb_ = pb;\n    cout<<pb.use_count()<<endl; //2\n    cout<<pa.use_count()<<endl; //2\n  }\n  \n  int main(){\n    fun();\n    return 0;\n  }\n  ````\n\n- 可以看到fun函数中pa ，pb之间`互相引用`，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（pa_，pb_未释放，因为AB是在堆上申请的内存），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。\n\n- 注意的是`我们不能通过weak_ptr直接访问对象的方法`，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 因为pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：\n\n  ````c++\n  shared_ptr p = pa->pb_.lock();  //将weak_ptr转换为shared_ptr\n  p->print();\n  ````\n\n## 4.4.  智能指针的线程安全问题\n\n- 智能指针shared_ptr本身（底层实现原理是引用计数）是线程安全的但对象的读写则不是，因为shared_ptr有两个数据成员，一个是指向的对象的指针，还有一个就是我们上面看到的引用计数管理对象。\n\n- 当智能指针发生拷贝的时候，标准库的实现是先拷贝智能指针，再拷贝引用计数对象（拷贝引用计数对象的时候，会使use_count加一），这两个操作并不是原子操作。\n\n- 如果线程1拷贝对象后线程2将该对象销毁，然后线程1再将引用计数加1，就会产生悬空指针。\n  1. 同一个shared_ptr被多个线程读，是线程安全的；\n  2. 同一个shared_ptr被多个线程写，不是线程安全的；\n  3. 共享引用计数的不同的shared_ptr被多个线程写，是线程安全的。\n\n- 线程不安全例子：\n\n```c++\nshared_ptr<Foo> g(new Foo); // 线程之间共享的 shared_ptr\nshared_ptr<Foo> x; // 线程 A 的局部变量\nshared_ptr<Foo> n(new Foo); // 线程 B 的局部变量\n```\n\n- 1. 线程 A 执行x = g;（即 read g），以下完成了步骤 1，还没来及执行步骤 2。这时切换到了 B 线程。\n  2. 同时线程 B 执行 g = n; （即 write G），两个步骤一起完成了。\n  3. 这时 Foo1对象已经销毁，x.ptr 成了空悬指针！ \n-  `我刚读完他 你就把他写没了`\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811237-1324544888.png)\n\nweak_ptr不会增加引用计数，不能直接操作对象的内存（需要先调用[lock](https://links.jianshu.com/go?to=https://en.cppreference.com/w/cpp/memory/weak_ptr/lock)接口），需要和shared_ptr配套使用。\n\n同时，通过weak_ptr获得的shared_ptr可以安全使用，因为其[lock](https://links.jianshu.com/go?to=https://en.cppreference.com/w/cpp/memory/weak_ptr/lock)接口是原子性的，那么`lock返回的是一个新的shared_ptr`，不存在同一个shared_ptr的读写操作。\n\n## 4.5.  为什么不能在STL容器中存储auto_ptr\n\n- <u>==一个STL对象是可以“拷贝构造”和“赋值”==</u>，而且当一个源对象复制到目标对象后 ，`源对象的状态通常是不会改变`的。\n\n- 但是，这不适用于auto_ptr（智能指针）。因为一个auto_ptr对象拷贝或赋值到另一个对象时会使源对象产生预期变动之外的变化。引发这个问题的原因是`auto_ptr指针的唯一性`，即一个对象只能有一个auto_ptr指针所指向它。因此，当auto_ptr以传值方式被复制给另外一个对象时，源对象就放弃了对象的拥有权，把它转移到目标对象上。\n\n## 4.6.  [智能指针的实现](https://www.cnblogs.com/wxquare/p/4759020.html)\n\nhttps://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\n\n- 智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。\n  1. 每次<u>创建类的新对象</u>时，初始化指针并将<u>引用计数置为1</u>；\n  2. 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；\n  3. 对一个对象进行赋值时，赋值操作符`减少左操作数所指对象的引用计数`（如果引用计数为减至0，则删除对象），并`增加右操作数所指对象的引用计数`；\n  4. 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象。\n\n- 智能指针就是模拟指针动作的类。\n\n- 所有的智能指针都会重载 `->` 和 `*` 操作符。\n\n- 智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。\n\n```c++\n#include <iostream>\n#include <memory>\n\ntemplate <typename T> \nclass SmartPointer {\nprivate:\n  T *_ptr;\n  size_t *_count;\n\npublic:\n  SmartPointer(T *ptr = nullptr) : _ptr(ptr) {\n    if (_ptr) {\n      _count = new size_t(1);  //初始化非空 设置count为1\n    } else {\n      _count = new size_t(0);\t//初始化为空 count设为0\n    }\n  }\n\n  SmartPointer(const SmartPointer &ptr) {\n    if (this != &ptr) {\n      this->_ptr = ptr._ptr;\n      this->_count = ptr._count;\n      (*this->_count)++;  //拷贝构造 count++\n    }\n  }\n\n  SmartPointer &operator=(const SmartPointer &ptr) {\n    if (this->_ptr == ptr._ptr) {\n      return *this;\n    }\n    if (this->_ptr) {\n      (*this->_count)--;   //本身存在实例化对象，更换指向 因此count--\n      if (this->_count == 0) {\n        delete this->_ptr;\n        delete this->_count;\n      }\n    }\n    this->_ptr = ptr._ptr;  //更改指向\n    this->_count = ptr._count;\n    (*this->_count)++;  //count++\n    return *this;\n  }\n\n  T &operator*() {\n    assert(this->_ptr == nullptr);\n    return *(this->_ptr);  //* 返回指针的解引用 实例化的对象\n  }\n\n  T *operator->() {\n    assert(this->_ptr == nullptr);\n    return this->_ptr;  //->返回的是个指针\n  }\n\n  ~SmartPointer() {   //RAII机制, 对象离开作用域即调用析构函数\n    (*this->_count)--;   //对象析构count--\n    if (*this->_count == 0) { //引用计数为0，析构释放空间\n      delete this->_ptr;\n      delete this->_count;\n    }\n  }\n\n  size_t use_count() { return *this->_count; }  //返回指向ptr堆空间的智能指针\n};\n\nint main() {\n  {\n    SmartPointer<int> sp(new int(10));\n    SmartPointer<int> sp2(sp);\n    SmartPointer<int> sp3(new int(20));\n    sp2 = sp3;\n    std::cout << sp.use_count() << std::endl;\n    std::cout << sp3.use_count() << std::endl;\n  }\n  // delete operator\n}\n```\n\n## 4.7.  [函数指针](https://www.runoob.com/cprogramming/c-fun-pointer-callback.html)\n\n1. 定义\n   - <u>函数指针是指向函数的指针变量。</u>\n   - `函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数`。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。\n   - C<u>在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</u>。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途：\n   \n- **<u>==调用函数和做函数的参数，比如回调函数。==</u>**\n3. 示例：\n\n   ```c++\n   char * fun(char * p)  {…}    // 函数fun\n   char * (*pf)(char * p);       // 函数指针pf\n   pf = fun;            // 函数指针pf指向函数fun\n   pf(p);            // 通过函数指针pf调用函数fun\n   ```\n\n## 4.8.  函数内可以返回一个局部变量的引用吗？\n\n不可以。\n\n```c++\nint *get10(){\n  int a = 10;\n  int *b = &a;\n  return b;\n}//错误\n```\n\n解决：\n\n1. 加static\n\n2. 加传入参数\n\n3. 分配在堆上\n\n# 5. 构造、析构函数\n\n## 5.1.  C++中析构函数的作用\n\n- 析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n- 析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n- 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n- 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n- 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n## 5.2.  C++中拷贝赋值函数的形参能否进行值传递？\n\n```c++\nA& operator=(A other) // 进行值传递而非引用传递（拷贝构造时也有赋值过程）？\nA a;\nA b(a);\nA b=a;  都是拷贝构造函数来创建对象b\n```\n\n强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！\n\n`赋值函数如果为值传递，仅仅是多了一次拷贝构造，并不会无限递归`\n\n**<u>==拷贝构造如果为值传递，才会引起无限递归==</u>**\n\n ````c++\n Example(Example& ex)    //拷贝构造函数（引用传递参数）\n {\n   //aa = ex.aa;       //如果构造函数是成员函数赋值则可以，默认使用参数列表初始化\n   *this = ex;        //如果是类拷贝则不行\n   cout << \"调用构造函数\" << endl;\n }\n ````\n\n## 5.3.  [构造函数可以定义为虚函数吗](https://blog.csdn.net/qq_28584889/article/details/88749862)\n\n**`构造函数不能是虚函数`**\n\n1. 从vptr角度解释\n   - 虚函数的调用是通过虚函数表来查找的，而虚函数表由`类的实例化对象`的vptr指针(vptr可以参考[C++的虚函数表指针vptr](https://blog.csdn.net/qq_28584889/article/details/88748923))指向，该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，但此时vptr还没有初始化！**<u>==（用虚函数构造我 但是使用虚函数需要我）==</u>**\n\n2.  从多态角度解释\n   - 虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而`构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义`。\n   - 在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。\n\n\n\n## 5.4.  为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数\n\n1. - 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n   - 如果不是虚函数的话，子类的构析函数不会被调用，子类申请的内存不会被释放。\n\n2. - C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会`浪费内存`。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n````c++\nclass Father {\npublic:\n  virtual ~Father() {\n    cout << \"class Father destroyed\" << endl;\n  }\n};\n\nclass Son : public Father {\npublic:\n  ~Son() {\n    cout << \"class Son destroyed\" << endl;\n  }\n};\n\nint main() {\n  Father* p = new Son;\n  delete p;   //如果不是虚函数 则不调用子类的析构函数\n  return 0;\n}\n````\n\n- 如果父类的析构函数是虚函数，则`子类的析构函数一定是虚函数`（即使是子类的析构函数不加virtual,这是C++的语法规则），`在父类指针或引用指向一个子类时，触发动态绑定（多态）`，析构实例化对象时，若是子类则会执行子类的析构函数，同时，编译器会在子类的析构函数中插入父类的析构函数，最终实现了先调用子类析构函数再调用父类析构函数。\n\n```c++\n//Rectangle Triangle继承自Shape\n//area()为Shape的virtual方法\nint main( ){\n   Shape *shape;\n   Rectangle rec(10,7);\n   Triangle  tri(10,5);\n   // 存储矩形的地址\n   shape = &rec;\n   // 调用矩形的求面积函数 area\n   shape->area(); \n   // 存储三角形的地址\n   shape = &tri;\n   // 调用三角形的求面积函数 area\n   shape->area(); \n   return 0;\n}\n```\n\n# 6.   关键字、函数\n\n## 6.1.  const 作用和应用场景\n\n### 6.1.1. [const修饰指针](https://blog.csdn.net/oguro/article/details/52694295)\n\n~~**const修饰指针有三种情况：**`离谁近谁不可修改` 说法是**<u>==反==</u>**过来的？~~\n\n1. ~~const修饰指针——指向常量的指针( const int *p = &a )~~\n\n   ~~指针的指向可以修改，但是指针指向的值不可以修改.~~\n\n2. ~~const修饰常量——指针常量( int * const p = &a )~~\n\n   ~~指针的指向不可以修改，但是指针指向的值可以修改.~~\n\n3. ~~const既修饰指针，又修饰常量(const int * const p = &a )~~\n\n   ~~指针的指向不可以修改，指针指向的值也不可以修改.~~\n\n前面理解不大对，正确的理解应该是 \n\nint* p = new int(10); \n\n此时`*p是值`， `p是指针`\n\n- int * const p; `const限定的是p` 是指针，所以`指向不可更改`\n\n- const int* p 或者 int const* p; `const限定的都是*p 是值`， 所以`指向的值不可更改`\n\n### 6.1.2. [const修饰成员函数](https://blog.csdn.net/lihao21/article/details/8634876)\n\n- 常函数：成员函数`后加const`后我们称为这个函数为常函数\n\n  1. `常函数内不可以修改成员属性`\n\n  ````c++\n  class Screen {\n  public:\n      int ok() const {return _cursor; }  //合法\n      int error(intival) const { _cursor = ival; } //非法\n  };\n  ````\n\n  2. 常函数内修改成员属性的两种方法：\n     - 成员属性声明时加关键字mutable后，在常函数中依然可以修改\n     - 将成员变量以引用的方式传入函数\n     - 值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。例如，\n\n  ````c++\n  class Name {\n  public:\n      void setName(const string &s) const;\n  private:\n      char *m_sName;\n  };\n   \n  void setName(const string &s) const {\n      m_sName = s.c_str();      // 错误！不能修改m_sName;\n   \n      for (int i = 0; i < s.size(); ++i) \n          m_sName[i] = s[i];    // 不好的风格，但不是错误的\n  }\n  ````\n\n- 常对象\n  1. 声明对象前加const称该对象为常对象\n  2. `常对象只能调用常函数`，普通对象既可以调用普通成员函数，也可以调用常函数\n\n### 6.1.3. const修饰的函数可以重载么\n\n**const修饰的函数同时也`能`实现函数的重载。**\n\n1. 要想调用`const修饰的重载函数`，需要用`const对象`去调用。\n2. 如果一个函数用const修饰了，但是这个函数没有实现重载，那么非const对象和const对象都能调用这个函数。\n   - 如下代码：若没有fun只有const fun， 则t1也会调用const fun\n\n````c++\n#include<iostream>  \nusing namespace std;  \n   \nclass Test  \n{  \nprotected:  \n    int x;  \npublic:  \n    Test (int i):x(i) {}  \n    void fun() const  {  \n        cout << \"fun() const called \" << endl;  \n    }  \n    void fun()  {  \n        cout << \"fun() called \" << endl;  \n    }  \n};  \n   \nint main()  \n{  \n    Test t1 (10);  \n    const Test t2 (20);  \n    t1.fun();  //fun() called\n    t2.fun();  //fun() const called\n    return 0;  \n}\n````\n\n### 6.1.4. 常量引用\n\nconst int & ref = 10// 正确，加上const之后,编译器将代码修改为 int temp = 10; const int & ref = temp;\n\n### 6.1.5. 顶层const(const指针)和底层const(const常量)\n\n1. 指向`常量`的指针，`底层const`。声明时const可以放在类型名前后都可，拿int类型来说，声明时：const int和int const 是等价的，\n\n````c++\nint num_a = 1;\nint const *p_a = &num_a; //底层const\n//*p_a = 2; //错误，指向“常量”的指针不能改变所指的对象\n````\n\n2. 指针常量，顶层const\n\n   > 记忆 *（指针）const（常量）   **<u>==指针常量==</u>** \t\n   >\n   > 记忆  const（常量） int *（指针）  **<u>==常量指针==</u>**\t\t\n\n````c++\nint num_b = 2;\nint *const p_b = &num_b; //顶层const\n//p_b = &num_a; //错误，指针常量不能改变存储的地址值\n````\n\n- 当执行对象的拷贝过程中（赋值操作，函数的值传递）时，如果被拷贝对象拥有底层const资格，则拷贝对象必须拥有相同的底层const资格。或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。\n\n````c++\nint k = 2;\nint *const a = &k;\nint *b = a;//可以\nint const* a = &k;\nint *b = a;//不行\n````\n\n- 使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。\n\n`````c++\nint k = 4;\nint *const a = &k;\nint* b = const_cast<int*>(a);\na = b;//错误，顶层const不能改变\n`````\n\n\n\n#### [25、C++的顶层const和底层const](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=25、c的顶层const和底层const)\n\n**概念区分**\n\n- **顶层**const：指的是const修饰的变量**本身**是一个常量，无法修改，指的是指针，就是 * 号的右边\n- **底层**const：指的是const修饰的变量**所指向的对象**是一个常量，指的是所指变量，就是 * 号的左边\n\n**举个例子**\n\n```cpp\nint a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量\nconst int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量\nconst int b3 = 20;            //顶层const，b3是常量不可变\nconst int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变\nconst int& b5 = a;           //用于声明引用变量，都是底层const\n```\n\n**区分作用**\n\n- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const\n- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const\n\n```cpp\nconst int a;int const a;const int *a;int *const a;Copy to clipboardErrorCopied\n```\n\n- int const a和const int a均表示定义常量类型a。\n- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)\n- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)\n\n## 6.2.  static关键字的作用\n\n1. 全局静态变量\n   - 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.\n   - 内存中的位置：静态存储区（数据段），在整个程序运行期间一直存在。\n   - 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n   - 作用域：全局静态变量在声明他的`文件之外`是`不可见`的，准确地说是从定义之处开始，到文件结尾。\n\n2. 局部静态变量\n   - 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。\n   - 内存中的位置：静态存储区\n   - 初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n   - 作用域：作用域仍为`局部作用域`，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并`没有销毁`，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数<u>再次被调用</u>，并且`值不变`；\n\n3. 静态函数 （**<u>==限定在局部==</u>**）\n   - 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n   - 函数的`实现`使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n   - warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；\n\n4. 类的静态成员\n   - 在类中，`静态成员可以实现多个对象之间的数据共享`，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。<u>对多个对象来说，静态数据成员只存储一处，供所有对象共用。不存在对象内存里。</u>\n\n5. 类的静态函数\n   - 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n   - 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n## 6.3.  extern\n\n1. extern关键字可以置于变量或者函数前，以<u>标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时`在其他模块中寻找其定义`。这里起到的是声明作用范围的用处。</u>\n\n2. extern “C”\n   - c和c++对同一个函数经过编译后生成的函数名是不同的，由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在c++中调用一个使用c语言编写的模块中的某个函数，那么c++是根据c++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误。\n\n## 6.4.  inline\n\n- inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为`内联函数`。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline`必须与函数定义放在一起`才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。\n\n- **inline和宏的区别**\n  1.  内联函数在`编译时`展开，而宏在预编译时展开\n  2. 在编译的时候，内联函数直接被`嵌入到目标代码`中去，而宏只是一个简单的文本替换。\n  3. 内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。\n  4. 宏不是函数，而inline是`函数`\n  5. 宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现`二义性`。而内联函数不会出现二义性。\n  6. inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。\n\n- 在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个[表达式](https://baike.baidu.com/item/表达式)涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this[指针](https://baike.baidu.com/item/指针)放在合适的位置）。\n\n## 6.5.  c++中四种cast转换\n\nC++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast\n\n1. const_cast\n   - 用于将const变量转为非const\n   - 只能去掉`底层`const  （`靠左`的const：const int* p = &a (修饰指针，指向可改，值不可改)）\n\n2. **<u>==static_cast==</u>**\n\n   - 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态`向上`转化，如果向下转能成功但是不安全，结果未知；\n   - 首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。\n   - 任何具有明确意义的类型转换，只要不包含底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成douuble类型就能使表达式执行浮点数除法；\n\n   ```c++\n   //进行强制类型转换以便执行浮点数除法\n   double slope = static_cast<double>(j)/i;\n   ```\n\n   - 当需要把一个`较大的算数类型赋值给较小的类型`时，static_cast非常有用。此时强制转换类型告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型并且试图赋值给较小的类型时，就会给出警告信息，但是当我们执行了显式的类型转换后，警告信息就会被关闭了。\n   - static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以时用static_cast找回存在与void*的指针中的值:\n\n   ````c++\n   void* p = &d; //正确，任何非常量对象的地址都能存入void*\n   //正确：将void*转换回初始的指针类型\n   double *dp = static_cast<double*>(P);\n   ````\n\n   - 当我们把指针存放在void*中，并且使用static_cast将其强制转换为原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与其原始的地址相等，因此我们必须确保转换后的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。\n\n3. dynamic_cast\n\n   - 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。\n   - 向上转换：指的是子类向基类的转换\n   - 向下转换：指的是基类向子类的转换\n   - 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。\n   - `dynamic_cast`只用于对象的指针和引用。当用于多态类型时，它允许任意的隐式类型转换以及相反过程。不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程），dynamic_cast会检查操作是否有效。也就是说，它会检查转换是否会返回一个被请求的有效的完整对象。检测在运行时进行。（用于将**<u>==父类指向子类的指针==</u>**转换为**<u>==子类指针==</u>**， 前提是本身自己是子类）\n   - 如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL.\n   - 代码：\n\n   `````c++\n   class Base { virtual void dummy() {} };\n   class Derived : public Base {};\n   \n   Base* b1 = new Derived;\n   Base* b2 = new Base;\n   \n   Derived* d1 = dynamic_cast<Derived *>(b1);     // succeeds\n   Derived* d2 = dynamic_cast<Derived *>(b2);     // fails: d2 is 'NULL'\n   `````\n\n   - 如果一个引用类型执行了类型转换并且这个转换是不可能的，一个bad_cast的异常类型被抛出： \n   - 代码:\n\n   ````c++\n   class Base { virtual void dummy() {} };\n   class Derived : public Base {};\n   \n   Base* b1 = new Derived;\n   Base* b2 = new Base;\n   \n   Derived d1 = dynamic_cast<Derived &*>(b1);     // succeeds\n   Derived d2 = dynamic_cast<Derived &*>(b2);     // fails: exception Thrown\n   ````\n\n   - 被转换对象obj的类型T1必须是多态类型，即T1必须公有继承自其它类，或者T1拥有虚函数（继承或自定义）。若T1为非多态类型，使用dynamic_cast会报编译错误\n\n   > 理解：他这个转换是不是类似于 void* 转 int* double* 啥的 只是读取的方式不一样 内存还是在那 转来转去 还是那块内存\n   >\n   > 比如说， `子类转基类 再转子类 是不会有任何信息的丢失的`\n   >\n   > ```c++\n   > class Base {\n   >   virtual void dummy() {}\n   >   \tint a = 0;\n   > };\n   > class Derived : public Base {\n   >   \tint b = 1;\n   > };\n   > int main() {\n   >   \tDerived *p1 = new Derived;\n   >   \tBase *d1 = static_cast<Derived *>(p1);\n   >   \tDerived *p2 = dynamic_cast<Derived *>(d1);\n   >   \treturn 0;\n   > }\n   > ```\n\n4. reinterpret_cast\n\n   - 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；\n   - reinterpret_cast通常为运算对象的`位模式`提供较低层次上的重新解释。举个例子，加入有如下的转换\n\n   `````c++\n   int *ip;\n   char *pc = reinterpret_cast<char*>(ip);\n   `````\n\n   - 我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。例如：\n\n   ````c++\n   string str(pc);\n   ````\n\n5. 为什么不使用C的强制转换？\n   \n   - C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。\n\n## 6.6.  volatile关键字的作用\n\n- volatile关键字是<u>防止在共享的空间发生读取的错误。只保证其可见性，不保证原子性；使用volatile指每次从内存中读取数据，而不是从编译器优化后的缓存中读取数据</u>，简单来讲就是防止编译器优化。\n\n- 在单任务环境中，如果在两次读取变量之间不改变变量的值，编译器就会发生优化，会将RAM中的值赋值到寄存器中；由于访问寄存器的效率要高于RAM，所以在需要读取变量时，直接寄存器中获取变量的值，而不是从RAM中。\n\n- 在多任务环境中，虽然在两次读取变量之间不改变变量的值，在一些情况下变量的值还是会发生改变，比如在发生中断程序或者有其他的线程。这时候如果编译器优化，依旧从寄存器中获取变量的值，修改的值就得不到及时的响应（在RAM还未将新的值赋值给寄存器，就已经获取到寄存器的值）。\n\n- 要想`防止编译器优化`，就需要在声明变量时加volatile关键字，加关键字后，就在RAM中读取变量的值，而不是直接在寄存器中取值。\n\n## 6.7.  override关键字作用：\n\n- 如果派生类在虚函数声明时使用了override描述符，那么该函数==**<u>必须重载其基类中的同名函数</u>**==，否则代码将无法通过编译\n\n- 例如如下代码\n\n  ```c++\n  // This program has a subtle error in the virtual functions.\n  #include <iostream>\n  #include <memory>\n  using namespace std;\n  \n  class Base\n  {\n      public:\n          virtual void functionA(int arg) const{cout << \"This is Base::functionA\" << endl; }\n  };\n  \n  class Derived : public Base\n  {\n      public:\n          virtual void functionA(long arg) const{ cout << \"This is Derived::functionA\" << endl; }\n  };\n  int main()\n  {\n      // Base pointer b points to a Derived class object.\n      shared_ptr<Base>b = make_shared<Derived>();\n      // Call virtual functionA through Base pointer.\n      b->functionA(99);   //最终的输出结果为\"This is Base::functionA\"\n      return 0;\n  }\n  ```\n\n  > 在该程序中，Base 类[指针](http://c.biancheng.net/c/80/) b 指向 Derived 类对象。因为 functionA 是一个虚函数，所以一般可以认为 b 对 functionA 的调用将选择 Derived 类的版本。\n  >\n  > 但是，从程序的输出结果来看，实际情况并非如此。其原因是这两个函数有不同的形参类型，所以 Derived 类中的 functionA 不能覆盖 Base 类中的 functionA。基类中的函数釆用的是 int 类型的参数，而派生类中的函数釆用的则是 long 类型的参数，因此，Derived 类中的 functionA 只不过是重载 Base 类中的 functionA 函数。\n\n- 要确认派生类中的成员函数覆盖基类中的虚成员函数，可以在派生类的函数原型（如果函数以内联方式写入，则在函数头）后面加上 override 关键字。override 关键字告诉编译器，该函数应覆盖基类中的函数。如果该函数实际上没有覆盖任何函数，则会导致编译器错误。\n\n  ```c++\n  //This program demonstrates the use of the override keyword.\n  #include <iostream>\n  #include <memory>\n  using namespace std;\n  \n  class Base\n  {\n      public:\n          virtual void functionA(int arg) const { cout << \"This is Base::functionA\" << endl;}\n  };\n  class Derived : public Base\n  {\n      public:\n          virtual void functionA(int arg) const override{ cout << \"This is Derived::functionA\" << endl; }\n  };\n  int main()\n  {\n      // Base pointer b points to a Derived class object.\n      shared_ptr<Base>b = make_shared<Derived>();\n      // Call virtual functionA through Base pointer.\n      b->functionA(99);   //This is Derived::functionA\n      return 0;\n  }\n  ```\n\n## 6.8.  final关键字作用\n\n1. `类 禁用继承`\n\n   - C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。\n   - 实例如下：\n\n   ````c++\n   class Super final{\n    //......\n   };\n   ````\n\n2. `方法 禁用重写`\n\n   - C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下\n\n   ````c++\n   class Super{\n   public:\n     Supe();\n     virtual void SomeMethod() final;\n   };\n   ````\n\n## 6.9. strcpy和strlen\n\n### strcpy\n\n```c++\n// Function to implement `strcpy()` function\nchar* strcpy(char* destination, const char* source){\n    if (destination == NULL) {\n        return NULL;\n    }\n\n    char *ptr = destination;\n    while (*source != '\\0'){\n        *destination = *source;\n        destination++;\n        source++;\n    }\n    *destination = '\\0';\n    return ptr;\n}\n \n// Implement `strcpy()` function in C\nint main(void)\n{\n    char source[] = \"Techie Delight\";\n    char destination[25];\n \n    printf(\"%s\\n\", strcpy(destination, source));\n \n    return 0;\n}\n```\n\n\n\n### [strlen和sizeof区别？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=16、strlen和sizeof区别？)\n\n- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。\n- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\\0'的字符串。\n- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。\n\n```cpp\n  int main(int argc, char const *argv[]){\n      const char* str = \"name\";\n      sizeof(str); // 取的是指针str的长度，是8  在64位的编译环境下的\n      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \\0。大小是4\n      return 0;\n  }\n```\n\n#### strcpy是字符串拷贝函数，原型：\n\n````c++\nchar *strcpy(char* dest, const char *src);\n````\n\n- 从src逐字节拷贝到dest，直到遇到'\\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,`安全版本是strncpy函数`。\n\n````c++\nchar *mystrncpy(char *dest, const char *src, size_t count) {\n  char *tmp = dest;\n  while (count) {\n    if ((*tmp = *src) != 0)\n      src++;\n    tmp++;\n    count--;\n  }\n  return dest;\n}\n````\n\n```c++\n  char str[16] = {\"hello,world!\\n\"};\n  strncpy(str, \"ipc\", strlen(\"ipc\"));  //ipclo,world!\n  printf(\"%s\\n\", str);\n  strncpy(str, \"ipc\\n\", strlen(\"ipc\")); ////ipclo,world!\n  printf(\"%s\\n\", str);\n  strncpy(str, \"ipc\", strlen(\"ipc\") + 1); //ipc  此时ipc<给定大小 str补%0\n  printf(\"%s\\n\", str);\n```\n\n![image-20220510164752313](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220510164752313.png)\n\n#### strncpy实现\n\n#### strlen函数\n\n​\t是计算字符串长度的函数，返回从开始到'\\0'之间的字符个数。\n\n`sizeof计算字符串长度会加1`，自动添加'\\0'\n\n```c++\nint main(){ \n  const char c[] = \"12\";\n\tcout << sizeof(c) << endl;//输出3\n\tcout << strlen(c);       //输出2\n  \n  char arr[10]={'1','2','3'};\n  printf(\" strlen(arr)=%d   sizeof(arr)=%d\\n\",strlen(arr),sizeof(arr)); //输出strlen 3， sizeof 10\n  return 0;\n}\n```\n\n## 6.10. memmove 和 memcpy的区别\n\n1. memcpy和memmove都是C语言中的库函数，在头文件string.h中，作用是拷贝一定长度的内存的内容，原型分别如下：\n\n   ```c++\n    void *memcpy(void *dst, const void *src, size_t count);\n    void *memmove(void *dst, const void *src, size_t count); \n   ```\n\n   - 他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，`memmove保证拷贝的结果是正确的`，memcpy不保证拷贝的结果的正确。\n\n   ````c++\n   void *memmove(void *dest, const void *src, size_t count){\n     assert(dest != NULL || src != NULL)\n       if (dst < src){//（memcpy没有if判断）\n         char *p = (char *)dest;\n         char *q = (char *)src;\n         while (count--){\n           *p++ = *q++;\n         }\n       }\n     else{\n       char *p = (char *)dest + count;\n       char *q = (char *)src + count;\n       while (count--){\n         *--p = *--q;\n       }\n     }\n     return dest;\n   }\n   ````\n\n# 7.   多态、虚函数\n\n## 7.1.  虚函数和多态\n\n多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。\n\n- 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。虚函数表存放在代码段的只读数据段。\n\n- 当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。\n\n- 子类重写父类虚函数后，父类虚函数仍然可以通过子类调用。\n\n- 不同子类继承同一父类时虚函数表不同。同一子类创建不同对象时虚函数表相同。\n\n- 继承了多个父类会有多个虚函数表指针，如果父类有2张虚函数表，子类也会继承2张虚函数表。子类自己的虚函数表加在第一张虚函数表之后。\n\n虚函数存储在对象开头，占4字节（32位）\n\n同一个类，创造的不同对象，其虚指针的值是一样的，全都是指向该类的虚函数表。\n\n## 7.2.  [虚继承](https://codeantenna.com/a/xMPwa2Aj7L)\n\n`虚继承`主要用于`菱形`形式的继承形式，是为了在多继承的时候避免引发歧义，避免重复拷贝。重要概念是 **虚基类指针(vbptr)** 和 **虚基类表(vftable)**。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220316214523810.png\" alt=\"image-20220316214523810\" style=\"zoom:67%;\" />\n\n- `菱形继承`带来的问题： 从成员模型可以看出来，菱形继承有**数据冗余**和**数据二义性**的问题。在最下面的一层D类中，对象会有**2份**最上层对象A类里面的成员\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220316214710539.png\" alt=\"image-20220316214710539\" style=\"zoom:67%;\" />\n\n- 再来看一个例子，来看菱形继承所带来的问题\n\n```c++\nclass Person{\npublic:\n\tstring name;\n};\nclass Student : public Person{\npublic:\n \tstring No;\n};\nclass Teacher: public Person{\npublic:\n\tstring id;\n};\nclass Course : public Student, public Teacher{\npublic:\n\tstring course;\n};\nint main (){\n\t//这样就会有二义性无法明确知道访问的是哪一个\n\tCourse c;\n\tc.name = \"tom\";\n\t// 这样就可以解决二义性的问题， 但是数据冗余问题无法解决\n\tc.Student::name = \"wang\";\n\tc.Teacher::name = \"lili\";\n}\n```\n\n`菱形虚拟继承`\n\n- **菱形虚拟继承的概念**：\n  菱形虚拟继承就是在多个类同时继承一个类的时候加上virtual关键字，使得父类的变量在全局只有一份，多个继承父类的类可以同时找到它并修改它\n  作用就是： A类是父类， B,C类继承父类， D类继承B,C类。 那么A类的成员变量就在B和C类中，但是D类继承B,C类，A类的成员变量就在D类中有两份。菱形虚拟继承的作用是：**使得A类的成员变量在对象中只有一份**。\n  **菱形虚拟继承的做法**：\n  **在多个类同时需要继承同一个父类的时候，在继承方式前加上virtual关键字**。\n\n```c++\nclass Person{\npublic:\n\tstring name;\n};\nclass Student :  virtual public Person   //学生类需要继承人这个类     加上virtual关键字，虚拟继承{\npublic:\n \tstring No;\n};\nclass Teacher: virtual public Person    //老师类也需要继承人这个类     加上virtual关键字，虚拟继承{\npublic:\n\tstring id;\n};\nclass Course : public Student, public Teacher{\npublic:\n\tstring course;\n};\nint main (){\n\tCourse c;\n\tc.name = \"tom\"; //把name改为tom,所有类里面的name全都该为tom\n}\n\n```\n\n- 总结：这样子，**就不会产生数据二义性了，和数据冗余了**，因为是继承，所有所有类里面都含有基类变量name。但是菱形虚拟继承做的是在所有类里面的name变量都是同一个。所有你Course类里面的name改变，所有类成员里面的name变量都是\"tom\"\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220226100811258-2132271296.png)\n\n- 内存顺序：A的虚函数指针，A中Base偏移，A的数据，B的虚函数指针，B中Base偏移，B的数据，Base虚函数指针，Base数据。\n\n## 7.3.  静态函数和虚函数的区别\n\n- 静态函数在`编译的时候就已经确定运行时机`，虚函数在`运行的时候动态绑定`。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销\n\n## 7.4.  虚函数表具体是怎样实现运行时多态的?\n\n- 子类若重写父类虚函数，`虚函数表中，该函数的地址会被替换`，对于存在虚函数的类的对象，在VS中，`对象的对象模型的头部存放指向虚函数表的指针`，通过该机制实现多态。\n\n## 7.5.  [纯虚函数](https://www.runoob.com/w3cnote/cpp-virtual-functions.html)\n\n- 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类`都要`定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:\n\n  ````c++\n  virtual void funtion1()=0\n  ````\n\n- 编译器要求在派生类中`必须予以重写`以实现多态性。同时含有纯虚拟函数的类称为`抽象类`，它`不能生成对象`。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。\n\n## 7.6.  抽象类\n\n1. **抽象类的定义**： 称带有纯虚函数的类为抽象类。\n\n2. **抽象类的作用**： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来`为派生类提供一个公共的根`，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。\n\n3. **使用抽象类时注意：**\n\n   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。`如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类`。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。\n\n## 7.7.  重载、覆盖（重写）、隐藏（重定义）\n\n1. **重载：**\n\n   两个函数名相同，但是`参数列表`不同（个数，类型），返回值类型没有要求，在同一作用域中。\n\n2. **重写：**\n   - `子类继承了父类`，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。这样的函数地址是在运行期间绑定。需要函数返回值也相同。\n   - （如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译）\n\n3. **隐藏：**（重定义）\n   - 如果派生类的函数与基类的函数同名，但参数不同，则无论有无virtual关键字，`基类的函数都被隐藏`。不存在子类和父类的同名函数重载。**<u>==（子和父的函数有不同的地方，那么肯定隐藏父的）==</u>**\n   - 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时基类的函数被隐藏。**<u>==（子和父的函数完全相同，基类没有virtual，则父中虚函数被隐藏）==</u>**\n\n## 7.8.  重写override的函数中包含有默认参数的情况，会发生动态绑定吗？\n\n因为默认参数的值要在`编译时确定`，所以是`early binding`，不会发生动态绑定。？？\n\n（子类的默认参数值不会用上）\n\n```c++\nclass Base{\npublic:\n  virtual void f(int k) {}\n};\n\nclass Derived:public Base{\npublic:\n  void f(int k=1) {}    \n};\n\nint main(){\n  Base *p = new Derived();\n  p->f();//报错\n}\n//////////////////////////////////////////////////////////////\n \n//如果基类也有默认参数，则可以运行子类函数（但是参数为父类默认参数）\nclass Base{\npublic:\n  virtual void f(int k=2) {\n    cout << k;\n  }\n};\n\nclass Derived:public Base{\npublic:\n  void f(int k=1) {   \n    cout << k;\n    cout << \"666\";\n  } \n};\n\nint main(){\n  Base *p = new Derived();\n  p->f();//输出2 666\n}\n//////////////////////////////////////////////////////////////////\n\nclass Base{\npublic:\n  virtual void f(int k) {\n    cout << k;\n  }\n};\n\nclass Derived:public Base{\npublic:\n  void f(int k=1) {   \n    cout << k << endl;;\n    cout << \"666\";\n  } \n};\n\nint main(){\n  Base *p = new Derived();\n  p->f(2);//输出2 666\n}\n```\n\n## 7.9.  [多继承情况下的内存布局？](https://m.nowcoder.com/answer/764869?tagId=&pos=1&type=0&onlyWrong=false&source=home)为什么会有自适应偏移？\n\n对于多继承情况\n\n考虑示例代码\n\n```cpp\nstruct Base1 {...};\nstruct Base2 {...};\nstruct Derived : Base1, Base2 {...};\n```\n\n### 有如下内存布局\n\n![image-20220311153833294](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203111538412.png)\n\n首先出现的是<u>`派生类Derived类的虚表指针vptr`</u>\n\n> （这里插入一个提醒：\n>\n> 一直以来vptr都被国人翻译为虚函数表指针\n>\n> 但是vtbl英文原文是virtual table并非virtual function table\n>\n> 为什么呢\n>\n> 因为这个表不只是为了虚函数而准备的\n>\n> 一切虚拟化技术都会用这个表 包括 虚继承 RTTI等\n>\n> 所以当类本身与其直接间接基类内都未定义任何虚函数时也是有可能有虚表的\n>\n> 典型就是当前类继承了一个虚基类..提醒结束）\n\n其次是<u>`第一直接基类的数据成员`</u>\n\n然后是<u>`第二直接基类的虚表指针vptr`</u>\n\n再次是<u>`第二直接基类的数据成员`</u>\n\n如果还有后继直接基类 那么依此类推\n\n### 解释\n\n- 为何偏移0处是Derived类的vptr，而不是Base1的vptr\n\n  > `因为非虚继承第一直接基类Base1与派生类Derived的基地址是一致的`\n  >\n  > **<u>==`Derived`的内存结构正是从Base1开始==</u>**\n  >\n  > 而对于\t\n  >\n  > ```c++\n  > Base1 *pb1 = new Derived;\n  > pb1->polymorphicFunction();\n  > ```\n  >\n  > 这样的多态引用\n  >\n  > 事实上我们也是用的Derived的虚表vtbl\n  >\n  > 因为Derived的vtbl和Base1的vtbl已经**<u>==融为一体==</u>**了\n  >\n  > 也就是说从Derived的vtbl中完全可以查到从Base1继承下来的虚函数\n  >\n  > 以及覆盖Base1的虚函数\n\n- 对于Base2来说\n\n  > 事实上图中所示的Base2::vptr并不是指向Base2类的vtbl\n  >\n  > 而是指向Derived类的vtbl中的一个thunk地址\n  >\n  > 这个所谓的thunk地址又指向一段汇编码\n  >\n  > 这段thunk汇编码负责做两件事：\n  >\n  > 1. 跳转到vtbl中正确的虚函数(也就是Derived的虚函数)地址所在的内存单元\n  >\n  > 2. 修改this指针使其指向Derived对象，并传入上一步检索到的虚函数中\n  >\n  >    \n  >\n  > `通过这个thunk策略`\n  >\n  > `编译器实现了C++的多态性`\n  >\n  > 举个例子\n  >\n  > ```cpp\n  > Base2 *pb2 = new Derived;\n  > delete pb2;\n  > ```\n  >\n  > 此时使用pb2调用虚析构函数时\n  >\n  > 通过Base2::vptr跳转到了thunk汇编代码\n  >\n  > 执行thunk后跳转到vtbl中Derived::~Derived()所在的槽位\n  >\n  > 然后把当前指向Base2子对象部分的的this指针\n  >\n  > 添加适当偏移使其指向Derived对象的内存首地址\n  >\n  > 然后传入并调用Derived::~Derived()\n  >\n  > 从而实现了Base2 *pb2和事实对象类Derived的动态绑定\n\n\n\n<u>父类1的虚函数表-父类1成员-父类2的虚函数表-父类2成员。。。</u>\n\n<u>（派生类自己的虚函数记录在第一张虚函数表末尾，如果父类有2张虚函数表，则子类会继承2张虚函数表）</u>\n\n### [C++ 虚函数表图解](https://blog.51cto.com/u_15295315/2999213)\n\n###  虚表布局设计思想：\n\n1. 表结构保护了Base1和Base2这些直接基类的vtbl结构，这样就能保持执行多态操作时的一致性，按照相应基类中虚函数的声明顺序完成固定偏移就能寻址到想要的虚函数\n\n2. 将派生类覆盖了的虚函数叠加到第一直接基类Base1上面，符合Derived和Base1内存空间偏移一致的设计惯例。同时也`使得Base1中不需要thunk来完成跳转`\n\n3. 非第一直接基类的vtbl区域里被覆盖的虚函数都需要`thunk来处理`跳转以及this指针的重定位\n\n### c++多重继承的子类为何要使用多个虚函数表？\n\n如果基类的虚函数表是`分开`2个的话，那上面的将父类指针指向子类对象的操作，`编译器只需要做一些指针偏移`，就可以得到正确的结果。把基类对象在子类对象的内存布局中完全分开可以更高效地实现父子类之间的转换。\n\n## 7.10. 同时定义了两个函数，一个带const，一个不带，会有问题吗？\n\n不会，这**<u>==相当于函数的重载==</u>**。\n\n````c++\nclass A { \n void fun() const {}\n void fun() {} \n};\n````\n\n（这里的两个函数指的是一个类中两个成员函数，带const，const是放在函数后面的，也就是对this指针做const限定。所以说是重载）\n\n## 7.11. 动态绑定\n\n### [C++中的静态绑定和动态绑定](https://www.cnblogs.com/lizhenghn/p/3657717.html)\n\n- 找到`函数名对应的地址`，然后将`函数调用处用该地址替换`，这称为函数绑定，或符号决议。\n\n- 一般情况下，在`编译期间（包括链接期间）就能完成符号决议`，不用等到程序执行时再进行额外的操作，这称为静态绑定。如果编译期间不能完成符号决议，就必须在`程序执行期间完成`，这称为动态绑定。\n\n> - 静态类型：对象在声明时采用的类型，在编译期既已确定；\n> - 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；\n> - 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；\n> - 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；\n\n从上面的定义也可以看出，`非虚函数一般都是静态绑定`，而**<u>==虚函数都是动态绑定==</u>**（如此才可实现多态性）。\n先看代码和运行结果：\n\n```c++\nclass A{\npublic:\n    /*virtual*/ void func(){ std::cout << \"A::func()\\n\"; }\n};\nclass B : public A{\npublic:\n    void func(){ std::cout << \"B::func()\\n\"; }\n};\nclass C : public A{\npublic:\n    void func(){ std::cout << \"C::func()\\n\"; }\n};\n```\n\n<u>**==动态类型可以更改 静态类型不可修改==**</u>\n\n``````c++\nC* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；\nB* pb = new B(); //pb的静态类型和动态类型也都是B*；\nA* pa = pc;      //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；\npa = pb;         //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；\nC *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；\n\npa->func();      //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；\npc->func();      //C::func() pc的动、静态类型都是C*，因此调用C::func()；\npnull->func();   //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；\n``````\n\n 如果注释掉类C中的func函数定义，其他不变，即\n\n```c++\nclass C : public A\n{\n};\n\npa->func();      //A::func() 理由同上；\npc->func();      //A::func() pc在类C中找不到func的定义，因此到其基类中寻找；\npnull->func();   //A::func() 原因也解释过了；\n```\n\n如果为A中的void func()函数添加virtual特性，其他不变，即\n\n```c++\nclass A{\npublic:\n    virtual void func(){ std::cout << \"A::func()\\n\"; }\n};\n\npa->func();      //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；\npc->func();      //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；\npnull->func();   //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；\n```\n\n### 静态绑定和动态绑定的区别：\n\n> 1. 静态绑定发生在编译期，动态绑定发生在运行期；\n> 2.  对象的动态类型可以更改，但是静态类型无法更改；\n> 3. 要想实现动态，必须使用动态绑定；\n> 4. 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；\n\n```c++\nclass E{\npublic:\n    virtual void func(int i = 0)\n    {\n        std::cout << \"E::func()\\t\"<< i <<\"\\n\";\n    }\n};\nclass F : public E{\npublic:\n    virtual void func(int i = 1)\n    {\n        std::cout << \"F::func()\\t\" << i <<\"\\n\";\n    }\n};\n\nvoid test2(){\n    F* pf = new F();\n    E* pe = pf;\n    pf->func(); //F::func() 1  正常，就该如此；\n    pe->func(); //F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！\n}\n```\n\n#### 出现这个现象的原因\n\n绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为`缺省参数值都是静态绑定（为了执行效率）`，而`virtual函数却是动态绑定`。\n\n\n\n\n\n\n\n# 8.   函数调用、程序运行、栈\n\n## 8.1. [ 在main执行之前和之后执行的代码可能是什么？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=1、-在main执行之前和之后执行的代码可能是什么？)\n\n**main函数执行之前**，主要就是初始化系统相关资源：\n\n- 设置栈指针\n- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容\n- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容\n- <u>全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码</u>\n- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数\n- `__attribute__((constructor))`\n\n**main函数执行之后**：\n\n- 全局对象的析构函数会在main函数之后执行；\n\n- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;\n\n- `__attribute__((destructor))`\n\n  \n\n### 写个函数在main函数执行前先运行\n\n```c++\nclass TestClas{\npublic:\n  TestClass();\n};\n\nTestClass::TestClass(){\ncout << \"TestClass\" << endl;\n}\n\nTestClass Ts;//定义个全局变量，让类里面的代码在main之前执行\n\nint main(){}\n```\n\n## 8.2.  C语言参数压栈顺序？\n\n<u>==从右到左==</u>   **压栈顺序主要考虑出栈读取**\n\nprintf函数的原型是：printf（const char* format,…）\n\n它是一个不定参函数，那么我们在实际使用中是怎么样知道它的参数个数呢？这就要靠format了，编译器通过format中的%占位符的个数来确定参数的个数。\n\n现在我们假设参数的压栈顺序是从左到右的，这时，函数调用的时候，format最先进栈，之后是各个参数进栈，最后pc进栈，此时，由于format先进栈了，上面压着未知个数的参数，想要知道参数的个数，必须找到format，而要找到format，必须要知道参数的个数，这样就陷入了一个无法求解的死循环了！！\n\n## 8.3.  函数的默认参数为什么必须放在最后\n\n1. 结构上：参数从右到左压栈，调用函数时参数从左到右赋值。\n2. 应用上：把设定默认值的形参放在最右边可以让函数少传参还能正常执行\n\n## 8.4.  [函数栈帧内存的分布](https://segmentfault.com/a/1190000017151354)\n\n编程语言离不开函数，函数是对一段代码的封装，往往实现了某个特定的功能，在程序中可以多次调用这个函数。稍有编程经验的同学都知道，函数是由栈实现的，调用对应入栈，退出对应出栈。在写递归函数的时候，如果递归层次太深会出现栈溢出（StackOverFlow）的错误。\n\n\"函数栈\"包含了对函数调用的基本理解，但是从细节来看，还有很多疑问，例如：\n\n- 函数的栈是如何开辟的？\n- 如何传入参数？\n- 返回值是如何得到的？\n\n本文以 C 语言为例，从内存布局、汇编代码的角度来分析函数栈的实现原理。\n\n### Linux 进程内存布局\n\n当程序被执行的时候，Linux 会为其在内存中分配相应的空间以支撑程序的运行，如下图所示。\n\n![linux-memory.png](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bVbj7AB)\n\n在虚拟内存中，内存空间被分为多个区域。代码指令保存在文本段，已初始化的全局变量 `global` 保存在数据段，程序运行中动态申请的内存`malloc(10 * char())`放在堆中，而函数执行的时候则在栈中开辟空间运行。例如`main`函数便占有一个函数栈，其中的变量`i`和`ip`都保存在`main`的栈空间中。\n\n<u>函数的栈空间有个名字叫做 `栈帧`，</u>下面就具体了解一下栈帧。\n\n### 栈帧\n\n下图是栈的结构。图中右侧是栈空间，其中有多个栈帧。从上往下由较早的栈帧到较新的栈帧，由于栈是从高地址往低地址生长的，所以最新的栈永远在最下面，即栈顶。\n\n![stack-frame.png](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bVbj7B9)\n\n图中有两个画出了具体结构的栈帧，分别是函数 A 和函数 B。函数 A 的栈帧最上面有一块省略号标识的区域，其中保存的是上一个栈帧的寄存器值以及函数 A 自己内部创建的局部变量。下面的参数 n 到参数 1 则是函数 A 要传给函数 B 的调用参数。那么函数 B 如何获取？答案是用寄存器。\n\nCPU 计算时会把很多变量放在寄存器中，根据硬件体系的不同，寄存器数量和作用也不同。<u>一般在 x86 32位中，寄存器 `%esp` 保存了栈指针的值，也就是栈顶，而 `%ebp` 作为当前栈帧的帧指针，也就是当前栈帧的底部，所以通过 `%esp` 和 `%ebp` 就可以知道当前栈帧的头跟尾。除了这两个寄存器，还有其它一些通用寄存器（`%eax`、`%edx`等），用于保存程序执行的临时值。</u>\n\n了解了寄存器的基本知识后，下面我们就可以知道函数 B 如何获取到函数 A 传给它的参数了。参数 1 的地址是 `%ebp + 8`，参数 2 的地址是 `%ebp + 12`，参数 n 的地址是 `%ebp + 4 + 4 * n`。相信大家已经看明白，通过帧指针往上找就可以取得这些参数，而这些参数之所以在这里当然是函数 A 预先准备好的，关于这一点下文会有例子。\n\n另外在所有参数的最下面保存着 `返回地址`，这个是在函数 B 返回之后接下来要执行的指令的地址。\n\n看了函数 A 之后，再看看函数 B。在函数 B 的栈帧最上面是 `被保存的 %ebp`，这个指的是函数 A 的帧指针，毕竟 `%ebp` 这个寄存器就一个，所以新的函数入栈的时候要先把老的保存起来，等函数出栈再恢复。在这个老的帧指针下面则是其它需要保存的寄存器变量以及函数 B 自己内部用到的局部变量。再往下是 `参数构造区域`，也就是函数 B 即将调用另一个函数，在这里先把参数准备好。可以看出，函数 B 与函数 A 的栈帧结构是类似的。\n\n了解了栈帧的理论之后，大家可能会觉得很抽象，下面结合具体实例来看栈帧从产生到消亡的过程。\n\n### 函数调用实例\n\n下面图是函数 `caller` 的具体执行过程，左边是 C 代码，中间是汇编码，右边是对应的栈帧。\n\n![caller-frame.png](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bVbj7LZ)\n\n我们一行一行的来分析，看中间汇编码，上面三行绿色的：\n\n```perl\npushl %ebp // 保存旧的 %ebp\nmovl %esp, %ebp // 将 %ebp 设置为 %esp\nsubl $24, %esp // 将 %esp 减 24 开辟栈空间\n```\n\n这三行其实是为栈帧做准备工作。第一行保存旧的 `%ebp`，此时新的栈空间还没有创建，但保存旧的 `%ebp` 的这一行空间将作为新栈帧的栈底，也就是帧指针，因此第二行将栈指针 `%esp`（永远指向栈顶）的值设置到 `%ebp` 上。 第三行将 `%esp` 下移 24 个字节，这一行其实就是为函数 `caller` 开辟栈空间了。从图中可以看出，下面的空间用于保存 `caller` 中的变量以及传给下个函数的参数。有部分空间未使用，这个是为了地址对齐，不影响我们的分析，可以忽略。\n\n在开辟了栈帧之后，就开始执行 `caller` 内部的逻辑了，`caller` 首先创建了两个局部变量（`arg1`和`arg2`）。对应的汇编代码为 `movl $534, -4(%ebp); movl $1057, -8(%ebp)`，其中 `-4(%ebp)` 表示 `%ebp - 4` 的位置，也就是图中 `arg1` 所在的位置， `arg2` 的位置则是 `%ebp - 8` 的位置。这两行是把 `534` 和 `1057` 保存到传送到这两个位置上。\n\n继续往下是这几行：\n\n```perl\nleal -8(%ebp), %eax // 把 %ebp - 8 这个地址保存到 %eax \nmovl %eax, 4(%esp)  // 把 %eax 的值保存到 %esp + 4 这个位置上\nleal -4(%ebp), %eax  // 把 %ebp - 4 这个地址保存到 %eax \nmovl %eax, ($esp)  // 把 %eax 的值保存到 %esp 这个位置上\n```\n\n第一行把 `%ebp - 8` 这个地址保存到 `%eax` 中，而 `%ebp - 8` 是 `arg2` 的地址，下一行把这个地址放到 `%esp + 4` 这个位置上，也就是图中 `&arg2` 的那个区域块。其实这一行是在为函数 `swap_add` 准备参数 `&arg2`，而下面两行则是准备参数 `&arg1`。\n\n再下面一行是 `call swap_add`。这一行就是调用函数 `swap_add` 了，不过在这之前还需要把返回地址压到栈上，这里的返回地址是函数 `swap_add` 返回后要接着执行的代码的地址，也就是 `int diff = arg1 - arg2` 地址。\n\n在调用 `swap_add` 后用到了其返回值 `sum` 继续进行计算，我们还不知道返回值是怎么拿到的。在这之前，我们先进入 `swap_add` 函数，下面是对应的代码执行图：\n\n![swap_add-frame.png](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bVbj7TT)\n\n`swap_add` 对应的汇编代码的前三行与 `caller` 类似，同样是保存旧的帧指针，但是因为 `swap_add` 不需要保存额外的变量，只需要多用一个寄存器 `%ebx`，所以这里保存了这个寄存器的旧值，但是没有将 `%esp` 直接下移一段长度的操作。\n\n接下来绿色的两行就是关键了：\n\n```perl\nmovl 8(%ebp), %edx // 从 %ebp + 8 取值保存到 %edx\nmovl 12(%ebp), %ecx // 从 %ebp + 12 取值保存到 %ecx\n```\n\n这两行分别是从 `caller` 中保存参数 `&arg1` 和 `&arg2` 的地方取得地址值，并根据地址取得 `arg1`和`arg2` 的实际数值。\n\n接下来的 4 行是交换操作，这里就不具体看每一行的逻辑了。\n\n再下面一行 `addl %ebx, %eax` 是将返回值保存到寄存器 `%eax` 中，这里非常关键，**函数 `swap_add` 的返回值保存在 `%eax` 中**，一会儿 `caller` 就是从这个寄存器获取的。\n\n`swap_add` 的最后几行是出栈操作，将 `%ebx` 和 `%ebp` 分别恢复为 `caller` 中的值。最后执行 `ret` 返回到 `caller` 中。\n\n下面我们继续回到 `caller` 中，刚才执行到 `call swap_add`，下面几行是执行 `int diff = arg1 - arg2`，结果保存在 `%edx` 中。\n\n最后一行是计算 `sum * diff`，对应的汇编代码为 `imull %edx, %eax`。这里是把 `%edx` 和 `%eax` 的值相乘并且把结果保存到 `%eax` 中。在上面的分析中，我们知道 `%eax` 保存着 `swap_add` 的返回值，这里还是从 `%eax` 中取出返回值进行计算，并且把结果继续保存到 `%eax` 中，而这个值又是 `caller` 的返回值，这样调用 `caller` 的函数也可以从这个寄存器中获取返回值了。\n\n`caller` 函数的最后一行汇编代码是 `ret`，这会销毁 `caller` 的栈帧并且恢复相应寄存器的旧值。到此，`caller` 和 `swap_add` 这个函数的调用过程就全部分析完了。\n\n\n\n寄存器ebp和esp来保存栈底地址和栈顶地址\n\neip专门记录下一条指令的寄存器\n\n每当执行一条指令，eip寄存器加上相应指令的长度，这样每一条指令执行完成后，eip都执向下一条指令的地址。只要能够保存函数调用前，下一句代码的地址，这样在函数执行完成后将这个地址赋值给eip寄存器，就能够回到调用者的位置，这是函数实现的基本依据。\n\n![IMG_256](file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image037.jpg)\n\n \n\n\\1. 首先从右至左将被调用函数的参数压入栈中\n\n\\2. 然后调用call指令保存eip寄存器的值，然后跳转到函数代码\n\n ![IMG_256](file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image039.gif)\n\n\\3. 将上一个函数的栈底地址ebp的值压入栈中\n\n\\4. 将此时esp的值保存到ebp中，作为该函数的函数栈的栈底地址\n\n![IMG_256](file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image041.gif)\n\n\\5. 根据函数中局部变量的个数抬高esp的值并初始化这段栈空间\n\n\\6. 将其余寄存器的值压栈\n\n![IMG_256](file:///C:/Users/QIANXU~1/AppData/Local/Temp/msohtmlclip1/01/clip_image043.gif)\n\n\\7. 执行函数代码\n\n\\8. 通过eax或者内存拷贝的方式保存返回值\n\n\\9. 将上面保存的寄存器的值出栈\n\n\\10. 执行esp = ebp，时esp指向函数栈的栈底\n\n\\11. pop ebp 还原之前保存的值，使ebp指向调用者的函数栈栈底\n\n\\12. ret 返回或者ret n(n为整数)指令返回到调用者的下一句代码\n\n## 8.5.  C语言是怎么进行函数调用的？\n\n每一个函数调用都会分配函数栈，在栈内进行函数执行过程。\n\n1. 将被调用函数的参数按照`从右到左的顺序压入栈`中,**<u>==再把返回地址压栈==</u>**\n\n2. 调用call指令保存eip寄存器的值，然后跳转到函数代码\n\n3. 然后把当前函数的esp指针压栈。\n\n4. 将调用者的 %ebp 压入栈\n\n5. 将 %esp 的值赋给 %ebp。\n\n6. 根据函数中局部变量的个数抬高esp的值并初始化这段栈空间\n\n7. 将其余寄存器的值压栈\n\n \n\n## 8.6.  C++如何处理返回值？\n\n[写的很好的一个博客](https://blog.csdn.net/m0_37836661/article/details/106490987)\n\n执行某个函数时，如果有参数，则在**栈上**为形式参数分配空间（如果是引用类型的参数则类外），继续进入到函数体内部，如果遇到变量，则按情况为变量在不同的存储区域分配空间（如果是static类型的变量，则是在进行编译的过程中已经就分配了空间），函数内的语句执行完后，如果函数没有返回值，则直接返回调用该函数的地方（即执行远点），如果存在返回值，则**先将返回值进行拷贝传回**，再返回执行远点，函数全部执行完毕后，进行退栈操作，将刚才函数内部在栈上申请的内存空间释放掉。\n\n<u>函数的返回值用于**初始化在调用函数时创建的临时对象**(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。</u>\n\n> - char（8bit）：寄存器a1\n> - short（16bit）：寄存器ax\n> - int（32bit）：寄存器eax     如果是64位，那么就是存放在eax和edx中了，高位在edx，低位在eax。\n> - double（64bit）：协处理器堆栈\n> - 指针、引用：寄存器eax\n> - 类的对象且体积超过64bit：主调函数会在函数栈上创建临时对象存放\n\n## 8.7.  C++函数栈空间的最大值\n\n默认是1M，不过可以调整\n\n \n\n## 8.8.  [C++中的RTTI机制 - 简书](https://www.jianshu.com/p/3b4a80adffa7)\n\nRTTI(Run Time Type Identification)即**<u>==通过运行时类型识别==</u>**，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。\n\nRTTI提供了两个非常有用的操作符：typeid和dynamic_cast。\n\n> typeid操作符，**<u>==返回指针和引用所指的实际类型==</u>**；\n>\n> ```c++\n> #include <iostream>\n> #include <typeinfo>\n> using namespace std;\n> \n> class A{\n> public:\n>      void Print() { cout<<\"This is class A.\"<<endl; }\n> };\n> \n> class B : public A{\n> public:\n>      void Print() { cout<<\"This is class B.\"<<endl; }\n> };\n> \n> struct C{\n>      void Print() { cout<<\"This is struct C.\"<<endl; }\n> };\n> int main()\n> {\n>      short s = 2;\n>      unsigned ui = 10;\n>      int i = 10;\n>      char ch = 'a';\n>      wchar_t wch = L'b';\n>      float f = 1.0f;\n>      double d = 2;\n> \n>      cout<<typeid(s).name()<<endl; // short\n>      cout<<typeid(ui).name()<<endl; // unsigned int\n>      cout<<typeid(i).name()<<endl; // int\n>      cout<<typeid(ch).name()<<endl; // char\n>      cout<<typeid(wch).name()<<endl; // wchar_t\n>      cout<<typeid(f).name()<<endl; // float\n>      cout<<typeid(d).name()<<endl; // double\n>     \n>      A *pA1 = new A();\n>      A a2;\n> \n>      cout<<typeid(pA1).name()<<endl; // class A *\n>      cout<<typeid(a2).name()<<endl; // class A\n> \n>      B *pB1 = new B();\n>      cout<<typeid(pB1).name()<<endl; // class B *\n> \n>      C *pC1 = new C();\n>      C c2;\n> \n>      cout<<typeid(pC1).name()<<endl; // struct C *\n>      cout<<typeid(c2).name()<<endl; // struct C\n>     \n>      return 0;\n> }\n> ```\n>\n> dynamic_cast操作符，**<u>==将基类类型的指针或引用安全地转换为其派生类类型的指针或引用==</u>**。\n>\n> ```c++\n> #include <iostream>\n> #include <typeinfo>\n> using namespace std;\n> \n> class A\n> {\n> public:\n>      virtual void Print() { cout<<\"This is class A.\"<<endl; }\n> };\n> \n> class B\n> {\n> public:\n>      virtual void Print() { cout<<\"This is class B.\"<<endl; }\n> };\n> \n> class C : public A, public B\n> {\n> public:\n>      void Print() { cout<<\"This is C.\"<<endl; }\n>      void Printt() { cout << \"This is Cc.\" << endl; }\n> };\n> \n> int main()\n> {\n>      A *pA = new C;\n>      //C *pC = pA; // Wrong 编译器会提示错误\n>      C *pC = dynamic_cast<C *>(pA);\n>      if (pC != NULL)\n>      {\n>           pC->Print();  // This is C.\n>           pC->Printt(); // Tiis is Cc.\n>      }\n>      delete pA;\n> }\n> ```\n\n \n\n运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。\n\n在执行dynamic_cast时，两个type_info会被交给runtime library函数，比较之后告诉我们是否吻合。如果吻合，返回转换后的指针；否则返回nullptr。\n\n在 type_info 类中，拷贝构造函数和赋值运算符重载都被删除（C++11），同时也没有默认的构造函数（一个类只有一个type信息）<u>。==**typeid使用友元返回type_info引用**==</u>\n\n程序中创建type_info对象的唯一方法是使用typeid操作符（由此可见，如果把typeid看作函数的话，其应该是type_info的友元）\n\n如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。\n\n## 8.9.  在什么情况下你应该使用dynamic_cast替代虚函数?\n\n如果我们需要在派生类中增加新的成员函数f，但又无法取得基类的源代码，因而无法在基类中增加相应的虚函数，这时，可以在派生类中增加非虚成员函数。但这样一来，就无法用基类指针调用函数f。如果在程序中需要通过基类指针(如使用该继承层次的某个类中所包含的指向基类对象的指针数据成员p)来调用f，则必须使用dynamic_cast将p转换为指向派生类的指针，才能调用f。也就是说，如果无法为基类增加虚函数，就可以使用dynamic_cast 代替虚函数。\n\n> **<u>==由于种种原因（父类不可修改或不可获得）需要使用父类指针调用子类中的非虚函数时==</u>**\n\n## 8.10. include头文件的顺序以及双引号””和尖括号<>的区别？\n\n- Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。\n\n- 双引号和尖括号的区别：编译器预处理阶段`查找头文件的路径`不一样。**<u>==双引号先对当前文件目录进行查找==</u>**\n\n  1. 对于使用双引号包含的头文件，查找头文件路径的顺序为：\n\n     `当前头文件目录`-><u>编译器设置的头文件路径</u>（编译器可使用-I显式指定搜索路径）-><u>系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</u>\n\n  2. 对于使用尖括号包含的头文件，查找头文件的路径顺序为：\n\n     编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）->`系统变量`<u>CPLUS_INCLUDE_PATH</u>/C_INCLUDE_PATH指定的头文件路径\n\n## 8.11. 源码到可执行文件的过程\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322130321959.png\" alt=\"image-20220322130321959\" style=\"zoom:67%;\" />\n\n- 预编译(.i)\n\n  主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下\n\n  1. 删除所有的#define，展开所有的宏定义。\n  2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。\n  3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。\n  4. 删除所有的注释，“//”和“/**/”。\n  5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。\n  6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号。\n\n- 编译(.s)\n\n  把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。\n\n  1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。\n  2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。\n  3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。\n  4. 优化：源代码级别的一个优化过程。\n  5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。\n  6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。\n\n- 汇编(.o)\n\n  将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。\n\n- 链接(.exe .out)\n\n  将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：\n\n  1. **<u>==静态链接==</u>**：<u>（拿空间和更新难度 换 运行速度）</u>\n\n     函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中`复制这些函数和数据`并把它们和应用程序的其它模块`组合`起来创建最终的可执行文件。\n\n     > `空间浪费`：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； （`内存中的空间浪费`）\n     >\n     > `更新困难`：<u>每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序</u>。\n     >\n     > `运行速度快`：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。\n\n  2. **<u>==动态链接==</u>**：<u>（拿运行速度 换 空间和更新难度）</u>\n\n     动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在<u>程序运行时才将它们链接在一起形成一个完整的程序</u>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。\n\n     > `共享库`：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；\n     >\n     > `更新方便`：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。\n     >\n     > `性能损耗`：<u>因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</u>\n\n### 库相关\n\n#### 库的好处\n\n1. 代码保密\n2. 方便部署和分发\n\n#### 静态库(.a)的制作和使用 \n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322130441816.png\" alt=\"image-20220322130441816\" style=\"zoom:67%;\" />\n\n![image-20220322111045785](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322111045785.png)\n\n> 1. 汇编不进行链接 生成目标代码\n>\n>    ```c++\n>     gcc -c add.c sub.c div.c mult.c \n>    ```\n>\n> 2. 使用ar工具（archive）  c表示创建 s表示索引\n>\n>    ```C\n>    ar rcs libcalc.a add.o sub.o mult.o div.o\n>    ```\n>\n> 3. 使用静态库 (-I指定include路径 -l指定静态库名称 -L指定静态库路径)\n>\n>    ```c++\n>    gcc main.c -o app -I ./include/ -l calc -L ./lib\n>    ```\n\n#### 动态库(.so)的制作和使用\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322130501075.png\" alt=\"image-20220322130501075\" style=\"zoom:67%;\" />\n\n> 1. 使用gcc得到<u>与位置无关的代码</u> -fpic\n>\n>    ```c++\n>    gcc -c –fpic add.c sub.c div.c mult.c \n>    ```\n>\n> 2. gcc 得到动态库\n>\n>    ```c++\n>    gcc -shared add.o sub.o mult.o div.o -o libcalc.so\n>    ```\n>\n> 3. 添加到环境变量\n>\n>    ```c++\n>    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/qianxunslimg/Desktop/c++code/1.4/library/lib\n>    ```\n>\n> 4. 使用动态库\n>\n>    ```c++\n>    gcc main.c -o main -I include/ -L lib/ -l calc\n>    ```\n\n#### 工作原理\n\n◼ 静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中\n\n◼ 动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中\n\n◼ 程序启动之后，动态库会被动态加载到内存中，通过 ldd （list dynamic \n\ndependencies）命令检查动态库依赖关系\n\n◼ 如何定位共享库文件呢？ (`Linux`)\n\n> 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 **DT_RPATH段** ——> **环境变量LD_LIBRARY_PATH** ——> **/etc/ld.so.cache**文件列表 ——> **/lib/**，**/usr/lib**\n>\n> 目录找到库文件后将其载入内存\n\n#### 优缺点\n\n##### 静态库的优缺点\n\n◼ 优点：\n\n​\t<u>◆ 静态库被打包到应用程序中加载速度快</u>\n\n​\t<u>◆ 发布程序无需提供静态库，移植方便</u>\n\n◼ 缺点：\n\n​\t◆ 消耗系统资源，浪费内存\n\n​\t◆ 更新、部署、发布麻烦\n\n##### 动态库的优缺点\n\n◼ 优点：\n\n​\t◆ 可以实现进程间资源共享（`共享库`）\n\n​\t◆ 更新、部署、发布`简单`\n\n​\t◆ 可以控制何时加载动态库 （`使用到的时候才动态加载`）\n\n◼ 缺点：\n\n​\t◆ 加载速度比静态库`慢` （<u>其实相差不多 只是稍慢</u>）\n\n​\t◆ 发布程序时需要提供`依赖`的动态库\n\n# 9.   内存\n\n## 9.1.  new/delete与malloc/free的区别是什么\n\n1. new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数 \n\n   > 语言不同\n\n2. malloc/free为函数只是开辟空间并释放，new/delete则不仅会开辟空间，并调用构造函数和析构函数进行初始化和清理\n\n   > new/delete 还可以进行构造和析构\n\n3. new/delete底层是基于malloc/free来实现的，而malloc/free不能基于new/delete实现；\n\n   > 实现层次的上下关系\n\n4. malloc开辟空间类型大小需手动计算，new是由编译器自己计算；\n\n   > 是否需要手动计算 空间大小\n\n5. malloc返回类型为void*,必须强制类型转换对应类型指针，new则直接返回对应类型指针；\n\n   > 指针返回类型不同\n\n6. malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；\n\n   > 是否需要手动检查开辟是否成功\n\n7. 无论释放几个空间大小，free只传递指针，多个对象时delete需加[]\n\n   > 对于内置类型若new[]但用delete释放时，没有影响，但若是自定义类型如类时，若释放使用 delete时，这时则会只调用一次析构函数，只析构了一个对象，剩下的对象都没有被清理。\n\n8. 因为new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；\n\n   > 是否可以被重载\n\n9. 对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；\n\n   > malloc分配的空间可以再次调整 relloc\n\n10. `对于new/delete若内存分配失败，用户可以指定处理函数或重新制定分配器（new_handler(可以在此处进行扩展)），malloc/free用户是不可以处理的。`\n\n## [new和delete是如何实现的？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=9、new和delete是如何实现的？)\n\n- new的实现过程是：首先调用名为**operator new**的标准库函数，`分配`足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个`构造`函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的`指针`\n- delete的实现过程：对`指针指向`的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存\n\n## 9.2.  free是怎么知道它要free的空间有多大\n\nmalloc返回的内存地址<u>前面有一段空间存储了该块内存的长度</u>，一般这段空间是16个字节，<u>在free时，解析传入内存地址的前一段内存空间，就可以得到具体的长度。</u>\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203111827845.jpeg)\n\n##  9.3.  allocator\n\n标准库 allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。\n\n\n\n## 9.4.  malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？\n\n更详细：https://blog.csdn.net/z_ryan/article/details/79950737\n\n**内存池**\n\n<u>为了减少内存碎片和系统调用的开销</u>，malloc其采用内存池的方式，`先申请大块内存`作为堆区，然后将堆区`分为多个内存块`，以`块`作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。\n\n当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；\n\n当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。\n\n \n\n### 内存布局\n\n介绍ptmalloc之前，我们先了解一下内存布局，以x86的32位系统为例：\n\n![image-20220406000333060](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220406000333060.png)\n　　从上图可以看到，栈至顶向下扩展，堆至底向上扩展， mmap 映射区域至顶向下扩展。 mmap 映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于 C 运行时库使用 mmap 映射区域和堆进行内存分配。\n\n### brk（sbrk）和mmap函数\n\n首先，linux系统向用户提供申请的内存有brk(sbrk)和mmap函数。下面我们先来了解一下这几个函数。\n\n#### brk() 和 sbrk()\n\n```c++\n#include <unistd.h>\nint brk( const void *addr )\nvoid* sbrk ( intptr_t incr );\n```\n\n> 两者的作用是扩展heap的上界brk\n> Brk（）的参数设置为新的brk上界地址，成功返回1，失败返回0；\n> Sbrk（）的参数为申请内存的大小，返回heap新的上界brk的地址\n\n#### mmap()\n\n```c++\n#include <sys/mman.h>\nvoid *mmap(void *addr, size\\_t length, int prot, int flags, int fd, off\\_t offset);\nint munmap(void *addr, size_t length);\n```\n\n> mmap的第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。\n> malloc使用的是mmap的第二种用法（匿名映射）。\n> munmap函数用于释放内存。\n\n### **申请内存**\n\nMalloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。\n\n当申请内存小于128K时，会使用系统函数brk在堆区中分配；\n\n当申请内存大于128K时，会使用系统函数mmap在映射区分配。\n\n栈、`映射区内存至顶向下扩展`，堆至低向上扩展。\n\n### **释放内存**\n\n当用户使用free函数释放掉的内存，ptmalloc并不会马上交还给操作系统，而是被ptmalloc本身的空闲链表bins管理起来了，这样当下次进程需要malloc一块内存的时候，ptmalloc就会从空闲的bins上寻找一块合适大小的内存块分配给用户使用。这样的好处可以避免频繁的系统调用，降低内存分配的开销。\n\n当释放mmaped chunk上的内存的时候会直接交还给操作系统。\n\n \n\n**chunk** **内存块的基本组织单元**\n\n在 ptmalloc 的实现源码中定义结构体 malloc_chunk 来描述这些块。malloc_chunk 定义如下：\n\n1.struct malloc_chunk { \n\n\\2. INTERNAL_SIZE_T   prev_size;  /* Size of previous chunk (if free). */ \n\n\\3. INTERNAL_SIZE_T   size;     /* Size in bytes, including overhead. */ \n\n\\4. \n\n\\5. struct malloc_chunk* fd;      /* double links -- used only if free. */ \n\n\\6. struct malloc_chunk* bk; \n\n\\7. \n\n\\8. /* Only used for large blocks: pointer to next larger size. */ \n\n\\9. struct malloc_chunk* fd_nextsize;   /* double links -- used only if free. */ \n\n\\10. struct malloc_chunk* bk_nextsize; \n\n11.}; \n\n \n\n**主分配区和非主分配区**\n\nAllocate的内存分配器中，为了解决多线程锁争夺问题，分为主分配区main_area和非主分配区no_main_area。\n\n　1. 主分配区和非主分配区形成一个环形链表进行管理。\n\n　2. 每一个分配区利用互斥锁使线程对于该分配区的访问互斥。\n\n　3. 每个进程只有一个主分配区，也可以允许有多个非主分配区。\n\n　4. ptmalloc根据系统对分配区的争用动态增加分配区的大小，分配区的数量一旦增加，则不会减少。\n\n　5. 主分配区可以使用brk和mmap来分配，而非主分配区只能使用mmap来映射内存块\n\n　6. 申请小内存时会产生很多内存碎片，ptmalloc在整理时也需要对分配区做加锁操作。\n\n \n\n当一个线程需要使用malloc分配内存的时候，会先查看该线程的私有变量中是否已经存在一个分配区。若是存在。会尝试对其进行加锁操作。若是加锁成功，就在使用该分配区分配内存，若是失败，就会遍历循环链表中获取一个未加锁的分配区。若是整个链表中都没有未加锁的分配区，则malloc会开辟一个新的分配区，将其加入全局的循环链表并加锁，然后使用该分配区进行内存分配。当释放这块内存时，同样会先获取待释放内存块所在的分配区的锁。若是有其他线程正在使用该分配区，则必须等待其他线程释放该分配区互斥锁之后才能进行释放内存的操作。\n\n## 9.5.  [C++的内存管理是怎样的](https://interviewguide.cn/#/Doc/Knowledge/C++/内存管理/内存管理?id=类的对象存储空间)\n\n#### [1、类的对象存储空间？](https://interviewguide.cn/#/Doc/Knowledge/C++/内存管理/内存管理?id=1、类的对象存储空间？)\n\n- `非静态`成员的数据类型大小之和。\n\n- 编译器加入的额外成员变量（如指向`虚函数表的指针`）。\n\n- 为了`边缘对齐`优化加入的padding。  \n\n  空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0.\n\n#### [2、简要说明C++的内存分区](https://interviewguide.cn/#/Doc/Knowledge/C++/内存管理/内存管理?id=2、简要说明c的内存分区)\n\nC++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。如下图所示\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220319163028599.png\" alt=\"image-20220319163028599\" style=\"zoom:67%;\" />\n\n- **栈**：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限 \n\n  > （由高地址向低地址增长，和堆的增长方式相对，对不同的OS来说，栈的初始大小有规定，可以修改，目前`默认一般为2M`，由编译器自动分配释放）\n\n- ?共享库文件/映射区？（调用的库文件，位于堆和栈之间）从上向下生长；存储动态链接库以及调用mmap函数进行的文件映射\n\n- **堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收\n\n  > （由低地址向高地址增长，一般new和malloc分配，由程序员分配释放）\n\n- **自由存储区**：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的`抽象概念`。需要注意的是，自由存储区和堆比较像，但不等价。\n\n- **全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0\n\n- **常量存储区**：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改\n\n- **代码区**：存放函数体的二进制代码\n\n###  [13、请说一下以下几种情况下，下面几个类的大小各是多少？](https://interviewguide.cn/#/Doc/Knowledge/C++/内存管理/内存管理?id=13、请说一下以下几种情况下，下面几个类的大小各是多少？)\n\n```cpp\nclass A {};\nint main(){\n  cout<<sizeof(A)<<endl;// 输出 1;\n  A a; \n  cout<<sizeof(a)<<endl;// 输出 1;\n  return 0;\n}Copy to clipboardErrorCopied\n```\n\n`空类的大小是1`， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，<u>编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址</u>。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。\n\n空类的实例大小就是类的大小，所以sizeof(a)=1字节,`如果a是指针，则sizeof(a)就是指针的大小，即4字节`。\n\n```cpp\nclass A { virtual Fun(){} };\nint main(){\n  cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器);\n  A a; \n  cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器);\n  return 0;\n}Copy to clipboardErrorCopied\n```\n\n如果 有虚函数 类对象中都有一个<u>`虚函数表指针`</u> __vptr，其大小是4字节\n\n```cpp\nclass A { static int a; };\nint main(){\n  cout<<sizeof(A)<<endl;// 输出 1;\n  A a; \n  cout<<sizeof(a)<<endl;// 输出 1;\n  return 0;\n}Copy to clipboardErrorCopied\n```\n\n静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小\n\n```cpp\nclass A { int a; };\nint main(){\n  cout<<sizeof(A)<<endl;// 输出 4;\n  A a; \n  cout<<sizeof(a)<<endl;// 输出 4;\n  return 0;\n}Copy to clipboardErrorCopied\nclass A { static int a; int b; };;\nint main(){\n  cout<<sizeof(A)<<endl;// 输出 4;\n  A a; \n  cout<<sizeof(a)<<endl;// 输出 4;\n  return 0;\n}Copy to clipboardErrorCopied\n```\n\n静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节\n\n## 9.6.  栈和堆比较\n\n#### [1. 堆和栈的区别](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=5、堆和栈的区别)\n\n- 申请方式不同。\n  - 栈由系统自动分配。\n  - 堆是自己申请和释放的。\n- 申请大小限制不同。\n  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。\n  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。\n- 申请效率不同。\n  - 栈由系统分配，速度快，不会有碎片。\n  - 堆由程序员分配，速度慢，且会有碎片。\n\n**<u>==栈空间默认是4M, 堆区一般是 1G - 4G==</u>**\n\n|                  | 堆                                                           | 栈                                                           |\n| ---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |\n| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |\n| **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |\n| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |\n| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |\n| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |\n| **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。    | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |\n\n**形象的比喻**\n\n栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。\n\n堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。\n\n\n\n#### [2. 你觉得堆快一点还是栈快一点？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=6、你觉得堆快一点还是栈快一点？)\n\n毫无疑问是**<u>==栈快==</u>**一点。\n\n因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。\n\n而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要`一定的算法寻找合适大小的内存`。<u>并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</u>\n\n## 9.7.  为什么堆栈增长方向不一样\n\n为了最大程度利用地址空间。\n\n## 9.8.  什么时候会发生段错误\n\nhttps://blog.csdn.net/qq_35703848/article/details/90670581\n\n段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：\n\n1. 使用`未经初始化及或已经释放的指针地址`，使用野指针:\n\nstrcpy(s,\"abcd\");\n\n2. 试图修改字符串常量的内容（`写入只读的内存地址`）\n\n   ```c++\n   char *str = \"samson\";\n   *str = \"cool\";\n   ```\n\n3. 数组越界\n\n4. 堆栈溢出\n\n1. 错误的访问类型引起\n\n   ```c++\n   #include<stdio.h>\n   #include<stdlib.h>\n   \n   int main(){\n       char *c = \"hello world\";\n       c[1] = 'H';\n   }\n   ```\n\n   - 上述程序编译没有问题，但是运行时弹出SIGSEGV。此例中，”hello world”作为一个常量字符串，在编译后会被放在.rodata节（GCC），最后链接生成目标程序时.rodata节会被合并到text segment与代码段放在一起，故其所处内存区域是只读的。这就是错误的访问类型引起的SIGSEGV。\n\n2. 访问了不属于进程地址空间的内存\n\n   ```c++\n   #include <stdio.h> \n   #include <stdlib.h>\n   \n   int main(){ \n       int* p = (int*)0xC0000fff; \n       *p = 10; \n   }　\n   ```\n\n   还有一种可能，往受到系统保护的内存地址写数据，最常见的就是给一个指针以0地址；\n\n   ```c++\n   int  i=0; \n   scanf (\"%d\", i);  /* should have used &i */ \n   printf (\"%d\\n\", i);\n   return 0;\n   ```\n\n3. 访问了不存在的内存\n    最常见的情况不外乎解引用空指针了，如：\n\n  ```c++\n  int *p = null;\n  *p = 1;\n  ```\n\n  - 在实际情况中，此例中的空指针可能指向用户态地址空间，但其所指向的页面实际不存在。\n\n4. 内存越界，数组越界，变量类型不一致等\n\n   ```c++\n   include <stdio.h>\n       \n   int main(){ \n   \tchar test[1]; \n   \tprintf(\"%c\", test[10]); \n   \treturn 0; \n   }　\n   ```\n\n   - 这就是明显的数组越界了，或者这个地址根本不存在。\n\n5. 试图把一个整数按照字符串的方式输出\n\n   ```c++\n   int  main() { \n       int b = 10; \n       printf(\"%s\\n\", b);\n       return 0; \n   }　\n   ```\n\n## 9.9.  内存溢出原因\n\n指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误\n\n内存溢出原因：\n\n1. 内存中`加载的数据量过于庞大`，如一次从数据库取出过多数据  (new读取几个g的文件)\n\n2. **<u>==递归==</u>**调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。\n\n3. `集合类中有对对象的引用，使用完后未清空，使得不能回收`\n\n4. 代码中存在<u>==死循环或循环==</u>产生过多重复的对象实体\n\n## 9.10. 什么是memory leak，也就是内存泄漏\n\n内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，`由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费`。\n\n### 内存泄漏的分类：\n\n1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.\n\n2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。\n\n3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。\n\n## 9.11. 如何判断内存泄漏？\n\n内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是`缺少了对应的free/delete`。\n\n#### **Linux:**\n\n我们一方面可以使用linux环境下的内存泄漏检查工具**<u>==Valgrind==</u>**,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。\n\nValgrind：\n\n编译：g++ -g -o test test.cpp\n\n使用：valgrind --tool=memcheck ./test\n\n可以检测如下问题：\n\n使用未初始化的内存（全局/静态变量初始化为0，局部变量/动态申请初始化为随机值）；\n\n内存读写越界；\n\n内存覆盖（strcpy/strcat/memcpy）；\n\n动态内存管理（申请释放方式不同，忘记释放等）；\n\n内存泄露（动态内存用完后没有释放，又无法被其他程序使用）。\n\n#### **Windows(vs)**\n\n_CrtDumpMemoryLeaks()就是检测从程序开始到执行该函数进程的堆使用情况，通过使用 _CrtDumpMemoryLeaks()我们可以进行简单的内存泄露检测。\n\n```c++\n#define CRTDBG_MAP_ALLOC //放在程序最前\n#include <iostream>\n#include <stdlib.h>  \n#include <crtdbg.h> \nusing namespace std;\nint main(){\n    int *a = new int [10];\n    int *p = new int[1000];\n    _CrtDumpMemoryLeaks(); //放在程序最后  //会输出在第几行 泄露了多少\n    system(\"pause\");\n    return 0;\n}\n\n```\n\n## 9.12. C++如何处理内存泄漏？\n\n**`Linux使用varglind检测`**\n\n**`Windows使用CRT`**\n\n###  **内存泄露**\n\n一般我们常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了\n\n### **避免内存泄露的几种方式**\n\n- 计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露\n\n  `智能指针思想`\n\n- 一定要将基类的析构函数声明为**虚函数**    `（不然子类无法析构）`\n\n- 对象数组的释放一定要用**delete []**                     `（只有默认的常量类型可以用delete删除指针数组）`\n\n- 有new就有delete，有malloc就有free，保证它们一定成对出现\n\n### **检测工具**\n\n- Linux下可以使用**Valgrind工具**\n- Windows下可以使用**CRT库**\n\n## 9.13. C++里是怎么定义常量的？常量存放在内存的哪个位置？\n\n常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。对于字面值常量，常量存放在常量存储区(代码段)。\n\n## 9.14. const char * arr = \"123\"; char * brr = \"123\"; const char crr[] = \"123\"; char drr[] = \"123\"的区别是什么;\n\nconst char * arr = \"123\";\n\n> //字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，`所以加不加const效果都一样`\n>\n\nchar * brr = \"123\";（vs下不加const报错）\n\n> //字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改\"123\"的值\n>\n\nconst char crr[] = \"123\";\n\n> //这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区\n>\n\nchar drr[] = \"123\";     `//保存在栈区 只有这个可以修改`\n\n> //字符串123保存在栈区，可以通过drr去修改\n>\n\n \n\n## 9.15. c++中的RAII机制\n\nRAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。\n\n由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。**如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。**\n\n#### 例子：智能指针，lock_guard()\n\n\n\n### 1  RAII介绍\n\nRAII全称是Resource Acquisition Is Initialization，翻译过来是资源获取即初始化，RAII机制用于管理资源的申请和释放。对于资源，我们通常经历三个过程，申请，使用，释放，这里的资源不仅仅是内存，也可以是文件、socket、锁等等。但是我们往往只关注资源的申请和使用，而忘了释放，这不仅会导致内存泄漏，可能还会导致业务逻辑的错误，RAII就用来解决此类问题。\n\n### 2 C++中的RAII使用\n\n我们看以下例子。\n\n```javascript\nstd::mutex m;\nvoid fn() {\n    m.lock();                 \n    使用资源\n    m.unlock();                \n}\n```\n\n上面的代码是对互斥变量的使用，我们看到加锁和解锁是成对出现的。如果我们忘了unlock那么别的线程再也无法枷锁成功，而且还会导致一直阻塞。我们看C++怎么解决这个问题。\n\n```javascript\nstd::mutex m;\nvoid fn(){    \n    std::lock_guard<std::mutex> guard(m); \n    do_something();                            \n    // 指向完函数后，guard会被析构，从而mutex也会被释放\n}\n```\n\n我们看到上面的代码中，我们只需要加锁，操作资源，不需要手动解锁。那么RAII是怎么做的呢？我们看看`lock_guard的实现`。\n\n```javascript\ntemplate <class Mutex> \nclass lock_guard {\n    private:\n        Mutex& mutex_;\n\n    public:\n        lock_guard(Mutex& mutex) : mutex_(mutex) { mutex_.lock(); }\n        ~lock_guard() { mutex_.unlock(); }\n        // 禁止复制和赋值\n        lock_guard(lock_guard const&) = delete;\n        lock_guard& operator=(lock_guard const&) = delete;\n};\n```\n\n我们看到实现很简单，在创建一个lock_guard对象的时候，lock_guard会初始化内部字段，并且执行加锁操作。当lock_guard析构的时候，会指向解锁操作，所以借助这个类，我们就不需要关注解锁的操作了，`具体的原理是利用了C++对象离开作用域后会自定执行析构函数`。\n\n\n\n[`智能指针的实现就是RAII的使用`](https://cloud.tencent.com/developer/article/1855285)","tags":["面试"],"categories":["基础知识"]},{"title":"操作系统面试","url":"/2022/03/16/cao-zuo-xi-tong-ba-gu/","content":"\n# 1. 操作系统有哪些模块\n\n1. `处理器`管理\n- 处理器管理最基本的功能是`处理中断事件`，配置了操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是处理器`调度`，针对不同情况采取不同的调度策略。\n  \n2. `存储器`管理\n- 存储器管理主要是指针对内存储器的管理。主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。\n  \n3. `设备`管理\n- 设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用。\n\n4. `文件`管理\n   - 文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的存储、检索和修改等操作以及文件的保护功能。\n\n5. `作业`管理\n   - 每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。\n\n\n\n# 2. 进程和线程\n\n## 2.1.  进程与线程的概念，以及为什么要有进程线程\n\n基本概念：\n\n- <u>`进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发`；</u>\n\n- 1. 线程是进程的子任务，是==CPU调度和分派的基本单位==，用于保证程序的实时性，实现进程内部的并发；\n  2. 线程是操作系统可识别的==最小执行和调度单位==。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是==共享==同一`地址空间`（也就是同样的动态内存，映射文件，目标代码等等），打开的`文件队列`和其他`内核资源`。\n\n- 线程产生的原因：\n\n  1. 进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：\n     - 进程在同一时间只能干一件事（`一次一件事`）；\n     - 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（`阻塞挂起整个`）。\n\n  2. （`为了减小并发的时空开销`）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：\n\n     - （相同的地址空间，所以`节省资源`）从资源上来讲，线程是一种非常\"节俭\"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种\"昂贵\"的多任务工作方式。 \n\n     - （相同的地址空间，所以`切换快`）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。\n\n     - 相同的地址空间，所以`通信快捷方便`）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。\n\n     - 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：\n\n       1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。\n\n       2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。\n\n\n\n## 2.2.  线程与进程的区别\n\n1. （`从属关系`）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程`依赖`于进程而存在。\n\n2. （`资源区别`）进程有独立的系统资源，而同一进程内的线程共享进程的大部分系统资源,包括堆、代码段、数据段，每个线程只拥有一些在运行中必不可少的私有属性，比如tcb,线程Id,栈、寄存器。\n\n3. （`单位`）进程是资源分配的最小单位，线程是CPU调度的最小单位；\n\n4. `系统开销`： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。\n\n   类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。\n\n5. `通信`：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预\n\n6. （`调试难度可靠性`）进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。\n\n7. （`相互影响`）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉\n\n\n\n## 2.3.  协程\n\n1. 概念：\n\n   协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。\n\n   协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。\n\n   例如：\n\n   ```c++\n   def A() :\n   print '1'\n   print '2'\n   print '3'\n   def B() :\n   print 'x'\n   print 'y'\n   print 'z'\n   ```\n\n   由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。\n\n2. 协程和线程区别\n\n   那和多线程比，协程最大的优势就是协程`极高的执行效率`。因为子程序切换不是线程切换，而是由程序自身控制（用户态），因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。\n\n   第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。\n\n   在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，协程常使用异步IO。\n\n\n\n## 2.4.  有了进程，为什么还要有线程？\n\n线程产生的原因：\n\n1. 进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：\n   - 进程在同一时间只能干一件事（`一次一件事`）；\n   - 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行（`阻塞挂起整个`）。\n\n2. （`为了减小并发的时空开销`）因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：\n\n   - （相同的地址空间，所以`节省资源`）从资源上来讲，线程是一种非常\"节俭\"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种\"昂贵\"的多任务工作方式。 \n\n   - （相同的地址空间，所以`切换快`）从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。\n\n   - 相同的地址空间，所以`通信快捷方便`）从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。\n\n   - 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：\n\n     1、使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，<u>不同的线程运行于不同的CPU上</u>。\n\n     2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。\n\n\n\n## 2.5.  说一下多线程和多进程的不同\n\n进程是资源分配的最小单位，而线程是CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单（？？？），适用于多核、多机分布。\n\n| 维度                                                         |                            多进程                            |                 多线程                 |   总结   |\n| ------------------------------------------------------------ | :----------------------------------------------------------: | :------------------------------------: | :------: |\n| 数据共享、同步                                               |          数据是分开的:共享复杂，需要用IPC;同步简单           | 多线程共享进程数据：共享简单；同步复杂 | 各有优势 |\n| 内存、[CPU](https://so.csdn.net/so/search?q=CPU&spm=1001.2101.3001.7020) |              占用内存多，切换复杂，CPU利用率低               |   占用内存少，切换简单，CPU利用率高    | 线程占优 |\n| 创建销毁、切换                                               |                  创建销毁、切换复杂，速度慢                  |       创建销毁、切换简单，速度快       | 线程占优 |\n| 编程调试                                                     |                      编程简单，调试简单                      |           编程复杂，调试复杂           | 进程占优 |\n| 可靠性                                                       |                      进程间不会相互影响                      |     一个线程挂掉将导致整个进程挂掉     | 进程占优 |\n| 分布式                                                       | 适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单 |             适应于多核分布             | 进程占优 |\n\n\n\n## 2.6.  多进程和多线程的使用场景\n\n多进程模型的优势是CPU\n\n1. 多线程模型主要优势为线程间切换代价较小，因此适用于==I/O密集型==（`读写文件`）的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线程模型也适用于单机多核分布式场景。\n\n2. 多进程模型，适用于==CPU密集型==（`大量计算`）。同时，多进程模型也适用于多机分布式场景中，易于多机扩展。\n\n**[一分钟明白IO密集型与CPU密集型的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7027610930431131685)**\n\n- CPU密集型也叫`计算密集型`，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作CPU读写IO(硬盘/内存)时，IO可以在很短的时间内完成，而CPU还有许多运算要处理，因此，CPU负载很高。\n- IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等IO (硬盘/内存) 的`读写`操作，因此，CPU负载并不高。\n- 一个计算为主的应用程序（CPU密集型程序），多线程或多进程跑的时候，可以充分利用起所有的 CPU 核心数，比如说16核的CPU ，开16个线程的时候，可以同时跑16个线程的运算任务，此时是最大效率。但是如果线程数/进程数远远超出 CPU 核心数量，反而会使得任务效率下降，因为**频繁的切换线程或进程**也是要消耗时间的。因此对于 CPU 密集型的任务来说，线程数/进程数等于 CPU 数是最好的了。\n- 如果是一个磁盘或网络为主的应用程序（IO密集型程序），一个线程处在 IO 等待的时候，另一个线程还可以在 CPU 里面跑，有时候 CPU 闲着没事干，所有的线程都在等着 IO，这时候他们就是同时的了，而单线程的话，此时还是在一个一个等待的。我们都知道IO的速度比起 CPU 来是很慢的。此时线程数可以是CPU核心数的数倍（视情况而定）\n\n\n\n## 2.7.  线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的\n\n线程在切换的过程中需要保存`当前线程Id`、`线程状态`、`堆栈`、`寄存器状态`等信息。其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：\n\n- SP:**堆栈指针**，指向当前栈的栈顶地址 （`存地址`）\n- PC:**程序计数器，存储下一条将要执行的指令**（`存下一条指令`）\n- EAX:累加寄存器，用于加法乘法的缺省寄存器 `？`\n\n\n\n## 2.8.  进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞\n\n1. 进程的五种基本状态：\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220301002354909-1638079864.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n   - `创建`状态：进程正在被创建\n\n   - `就绪`状态：进程被加入到就绪队列中等待CPU调度运行\n\n   - `执行`状态：进程正在被运行\n\n   - 等待`阻塞`状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。\n\n   - `终止`状态：进程运行完毕\n\n     （2-4为基本状态）\n\n2. `交换技术`\n\n   - 当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理就会空闲，I/0速度比处理速度慢得多，可能`出现全部进程阻塞等待I/O`。\n\n   - 针对以上问题，提出了两种解决方法：\n\n     1）`交换技术`：<u>换出一部分进程到外存，腾出内存空间。</u>\n\n     - 在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。\n\n     - 从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。\n\n     2）`虚拟存储技术`：每个进程只能装入一部分程序和数据。\n\n3. 活动阻塞，静止阻塞，活动就绪，静止就绪\n\n   1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。\n\n   2）静止阻塞：进程在外存，同时被某种原因阻塞了。\n\n   3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。\n\n   4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。\n\n   从而出现了：\n\n   活动就绪 ——  静止就绪    （内存不够，调到外存）\n\n   活动阻塞 ——  静止阻塞    （内存不够，调到外存）\n\n   执行   ——  静止就绪     （时间片用完）\n\n\n\n## 2.9.  进程调度算法\n\n### 2.9.1. 先来先去服务\n\n先来先去服务调度算法是一种最简单的调度算法，也称为`先进先出`或`严格排队`方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，<u>选择在就绪队列中存在时间最长的进程运行</u>。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。\n\n### 2.9.2. 最短进程优先\n\n最短进程优先是一个非抢占策略，他的原则是`下一次选择预计处理时间最短的进程`，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是<u>他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。</u>\n\n### 2.9.3. 最短剩余时间优先 \n\n（==估计时间最短就不排队了 直接抢==）最短剩余时间是针对最短进程优先`增加了抢占机制`的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。\n\n### 2.9.4. ==时间片==轮转法\n\n（`被抢占之前起码运行一段时间`）轮转法是基于适中的抢占策略的，以一个周期性间隔产生时钟中断，当中断发生后，当前正在运行的进程被置于就绪队列中，然后基于==先来先去==服务策略选择下一个就绪作业的运行。这种技术也称为时间片，因为每个进程再被抢占之前都给定一片时间。\n\n### 2.9.5. 优先权调度算法\n\n此算法常被用于批处理系统中，作为作业调度算法，也作为多种[**操作系统**](http://www.wypblog.com/archives/category/操作系统)中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。\n\n1) 非抢占式优先权算法\n\n在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该`进程便一直执行下去，直至完成`；或因发生某事件使`该进程放弃处理机`时（==完成或自己放弃==），系统方可再将处理机重新分配给另一优先权`最高`的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。\n\n2) 抢占式优先权调度算法\n\n在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就`立即停止`当前进程(原优先权最高的进程)的执行，`重新将处理机分配`给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。\n\n### 2.9.6. 最高响应比优先\n\n（`照顾长时间进程`）根据比率：R=(w+s)/s （R为响应比，w为<u>等待处理的时间</u>，s为<u>预计的服务时间</u>）\n\n如果该进程被立即调用，则R值等于归一化周转时间（周转时间和服务时间的比率）。R最小值为1.0，只有第一个进入系统的进程才能达到该值。调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。\n\n和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。\n\n### 2.9.7. ==多级反馈队列调度算法==\n\n前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则`不必事先知道各种进程所需的执行时间`，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种`较好`的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。\n\n`优先级越高 越靠前 时间越短 没完成扔到第二队列最后 时间边长 等待`\n\n(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。\n\n(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。\n\n(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。\n\n## 单核CPU是如何实现多进程的?\n\n单核cpu之所以能够实现多进程,主要是依靠于`操作系统的进程的调度算法`  ==<u>操作系统的并发</u>==\n\n　　如时间片轮转算法,在早期,举例说明:有5个正在运行的程序(即5个进程) :  QQ  微信  有道词典   网易云音乐  chrome浏览器, 操作系统会让单核cpu轮流来运行这些进程,一个进程只运行2ms,这样看起起来就像多个进程同时在运行,从而实现多进程\n\n## Unix、Linux与Windows进程调度策略的比较\n\n无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。 \n\n**进程调度的实质是资源的分配**，如何使系统能够保持较短的响应时间和较高的吞吐量，如何在**多个可运行的进程**中选取一个**最值得运行的进程投入运行**是调度器的主要任务。进程调度包括两个方面的内容：何时分配CPU 时间（调度时机）即调度器什么时候启动；如何选择进程（调度算法）即调度器该怎么做。进程调度主要可以分为**非剥夺**方式与**剥夺**方式两种。\n\n非剥夺方式：调度程序一旦把处理机分配给某进程后便让它**一直运行下去**，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。 \n\n剥夺方式：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。**剥夺原则有：优先权原则、短进程优先原则、时间片原则**。\n\nLinux 从整体上区分实时进程和普通进程，因为实时进程和普通进程度调度是不同的，它们两者之间，实时进程应该先于普通进程而运行，然后，对于同一类型的不同进程，采用不同的标准来选择进程。对**普通进程**的调度策略是**动态优先调度**，对于**实时进程**采用了两种调度策略，**FIFO(先来先服务调度)和RR（时间片轮转调度）**。\n\nUNIX系统是**单纯的分时系统**，所以没有设置作业调度。UNIX系统的进程调度采用的算法是，**多级反馈队列调度法**。其核心思想是先从最高休先级就绪队列中取出排在队列最前面的进程，当进程执行完一个时间片仍未完成则剥夺它的执行，将它放入到相应的队列中，取出下一个就绪进程投入运行，对于同一个队列中的各个进程，按照时间片轮转法调度。多级反馈队列调度算法即能使高优先级的作业得到响应又能使短作业（进程）迅速完成。但是它还是存在某些方面的不足，当**不断有新进程到来时，则长进程可能饥饿**。\n\nWindows 系统其调度方式比较复杂，它的处理器调度的**调度单位是线程而不是进程**，是基于**优先级的抢占式多处理器调度**，依据优先级和分配时间片来调度。而且Windows 2000/XP在单处理器系统和多处理器系统中的线程调度是不同的线程调度机制，Windows操作系统的调度系统总是**运行优先级最高的就绪线程**。在**同一优先级的各线程按时间片轮转算法进行调度**。如果一个高优先级的线程进入就绪状态，**当前运行的线程可能在用完它的时间片之前就被抢占处理机。**\n\n多任务、有线程优先级、多种中断级别这是现代操作系统的共同特点。实时操作系统（Real-time operating system, RTOS）最大的特点是**对响应时间有严格的要求**，linux尚且不能称为完全的实时操作系统，USA的宇宙飞船常用的操作系统是VxWorks，这才是闻名于世的RTOS。\n\n## 2.10. 常用线程模型\n\n1. Future模型  （==QFuture 和 run==）\n\n   - 该模型通常在使用的时候需要结合Callable接口配合使用。\n   - Future是`把结果放在将来获取`，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。\n   - 使用Future模式便可以`省去全局变量`的使用，直接从线程中获取子线程处理结果\n\n2. fork&join模型  （==Qt::Concurrent map那一堆==）\n\n   - 该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以`进行拆分的大任务`。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。\n\n   - 这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。\n\n     <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-884ed47503dcaa900d72066f3eb8c10d_r.jpg\" alt=\"img\" style=\"zoom: 67%;\" />\n\n3. 生产者消费者模型   （新建线程任务放在==队列==就不管了）\n\n   - 生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。`开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。`这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。\n\n4. master-worker模型\n\n   - master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。\n\n\n\n## 2.11. [reactor模型组成](https://jishuin.proginn.com/p/763bfbd58a63)\n\n### 线程模型1：传统阻塞 I/O 服务模型\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/7f1dd376f2ab0eaf7415844713efac4f.webp\" alt=\"img\" style=\"zoom: 80%;\" />\n\n特点：\n\n- 1）采用阻塞式 I/O 模型获取输入数据；\n- 2）每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。\n\n\n存在问题：\n\n- 1）当并发数较大时，需要创建大量线程来处理连接，`系统资源占用较大`；\n- 2）连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成`线程资源浪费`。\n\n### `线程模型2：Reactor 模式`\n\n针对传统阻塞 I/O 服务模型的 2 个缺点，比较常见的有如下解决方案： \n\n- 1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；\n- 2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。\n\n`I/O 复用结合线程池`，这就是 Reactor 模式基本设计思想，如下图：\n\n\n![高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_2.jpeg](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bd40e7f36c71aaa1710e68303122a899.webp)\t \n\nReactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的`事件驱动处理模式`。 \n\n服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 `Dispatcher` 模式。\n\n即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。\n\nReactor 模式中有 2 个关键组成：\n\n- 1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；\t==接线员==\n\n- 2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。    ==事件处理程序==\n\n  \n\nreactor模型要求`主线程只负责监听文件描述上是否有事件发生`，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220301002354841-2074717704.png)\n\n1. Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。\n\n2. Synchronous Event Demultiplexer（`同步事件复用器`）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。\n\n   >Select 是I/O 复用模型的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求\n\n3. Initiation Dispatcher：用于`管理Event Handler`，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。\n\n4. Event Handler：定义`事件处理方法`：handle_event()，以供InitiationDispatcher回调使用。\n\n5. Concrete Event Handler：事件EventHandler接口，实现`特定事件处理逻辑`。\n\n\n\n\n\n## 2.13. 怎样确定当前线程是繁忙还是阻塞？\n\n==使用ps命令查看==\n\n  `ps`命令是Process Status的缩写，用来列出系统中当前运行的进程。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。ps命令所列出的进行是当前进程的快照，也就是并不是动态的，而是执行该命令时那一时刻进行的状态。而经常和ps一起结合使用的杀死进程的是`kill`命令。\n  在我们的学习中我们知道，Linux的进程状态一般分为几种：\n\n\t>`R`(TASK_RUNNING，可执行状态)，这个进程是可运行的——要么它正在运行，要么在运行队列中等待运行；\n\t>\n\t>`S`(TASK_INTERRUPTIBLE，中断状态)，这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量等）而被挂起，然后当这些事件发生或完成后，对应的等待队列中的一个或多个进程将被唤醒。\n\t>\n\t>`D`(TASK_UNINTERRUPTIBLE，不可中断状态)，在进程接收到信号时，不会被唤醒变成可运行的。除了这一点，该状态和TASK_INTERRUPTIBLE其他部分完全一样，这个状态通常用于进程必须不间断等待或者事件发生的频率很快，并且无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。\n\t>\n\t>`T`(TASK_STOPPED或TASK_TRACED，暂停状态或跟踪状态)，该状态表示该进程已经停止执行，并且不具有再次执行的条件。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。而当进程正在被跟踪时，它处于TASK_TRACED状态。\n\t>\n\t>`Z`(TASK_DEAD或EXIT_ZOMBIE，退出状态)，进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在，这也就是所谓的\"僵尸\"进程。\n\t>\n\t>`X`(TASK_DEAD - EXIT_DEAD，退出状态)，进程即将被销毁。EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。\n\n\n\n## 2.14. 就绪状态的进程在等待什么？\n\n==被调度使用cpu的运行权==\n\n \n\n## 2.15. fork,wait,exec函数\n\n父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1\n\n \n\n## 2.16. fork和vfork的区别\n\n### fork\n\n- fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用：\n\n```c++\n#include <unistd.h>  \n#include <stdio.h>\nint main(){   \n    pid_t fpid; //fpid表示fork函数返回的值  \n    int count=0;  \n    fpid=fork();   \n    if (fpid < 0)   \n        printf(\"error in fork!\");   \n    else if (fpid == 0) {  \n        printf(\"i am the child process, my process id is %d/n\",getpid());   \n        printf(\"我是爹的儿子/n\");//对某些人来说中文看着更直白。  \n        count++;  \n    }  \n    else {  \n        printf(\"i am the parent process, my process id is %d/n\",getpid());   \n        printf(\"我是孩子他爹/n\");  \n        count++;  \n    }  \n    printf(\"统计结果是: %d/n\",count);  \n    return 0;  \n}  \n```\n\n- 成功调用fork()会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork()返回子进程的pid。如果出现错误，fork()返回一个负值。\n- `最常见的fork()用法是创建一个新的进程，然后使用exec()载入二进制映像，替换当前进程的映像`。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“`派生加执行`”的方式是很常见的。\n- ==写时拷贝==：当任意一个进程试图修改共享空间中的数据，操作系统就会将需要修改的数据所在的页直接拷一份出来。 \n- 内核只为新生成的子进程创建虚拟空间结构，它们复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应的段的行为发生时，再为子进程相应的段分配物理空间。\n\n### fork失败的主要原因：\n\n1. 当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN  ==（进程数上限）==\n2. 系统内存不足，这时errno的值被设置为ENOMEM  ==（内存不足）==\n\n### vfork\n\n- 在实现写时复制之前，Unix的设计者们就一直很关注`在fork后立刻执行exec所造成的地址空间的浪费`。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。\n\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n\npid_t vfork(void);\n```\n\n- 除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程`直到子进程终止或者运行了一个新的可执行文件的映像`。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。\n- ==意思是 vfork的唯一好处就是避免了父进程映像的拷贝，要想使用仍然需要调用exec();==\n\n### fork和vfork的区别：\n\n1.  fork( )的子进程拷贝父进程的`数据段和代码段`；vfork( )的子进程与父进程共享`数据段`\n\n2. fork( )的父子进程的`执行次序不确定`；vfork( )保证`子进程先运行`，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。\n3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。\n4. 当需要改变共享数据段中变量的值，则拷贝父进程。\n\n## 2.17. 手写一下fork调用示例\n\n1. 概念：\n\n   Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：\n\n   成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。\n\n   最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。\n\n2. fork实例\n\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n\n    int num = 10;\n\n    // 创建子进程\n    pid_t pid = fork();\n\n    // 判断是父进程还是子进程\n    if(pid > 0) {\n        // printf(\"pid : %d\\n\", pid);\n        // 如果大于0，返回的是创建的子进程的进程号，当前是父进程\n        printf(\"i am parent process, pid : %d, ppid : %d\\n\", getpid(), getppid());\n\n        printf(\"parent num : %d\\n\", num);\n        num += 10;\n        printf(\"parent num += 10 : %d\\n\", num);\n\n\n    } else if(pid == 0) {\n        // 当前是子进程\n        printf(\"i am child process, pid : %d, ppid : %d\\n\", getpid(),getppid());\n       \n        printf(\"child num : %d\\n\", num);\n        num += 100;\n        printf(\"child num += 100 : %d\\n\", num);\n    }\n\n    // for循环    //无pid判断 父子进程都执行\n    for(int i = 0; i < 3; i++) {\n        printf(\"i : %d , pid : %d\\n\", i , getpid());\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n\n## GDB多线程调试\n\n- 使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。\n- 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child]\n- 设置调试模式：set detach-on-fork [on | off]   默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。\n\n- 查看调试的进程：info inferiors\n- 切换当前调试的进程：inferior id\n- 使进程脱离 GDB 调试：detach inferiors id\n\n\n\n## exec函数族\n\n### exec 函数族介绍\n\n-  exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来`取代调用进程的内容`，换句话说，就是在<u>调用进程内部执行一个可执行文件</u>。\n\n- exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。\n\n```c++\n// hello.c  -> hello.out\n#include <stdio.h>\nint main() {    \n    printf(\"hello, world\\n\");\n    return 0;\n}\n\n// execl.c\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    // 创建一个子进程，在子进程中执行exec函数族中的函数\n    pid_t pid = fork();\n\n    if(pid > 0) {\n        // 父进程\n        printf(\"i am parent process, pid : %d\\n\",getpid());\n        sleep(1);\n    }else if(pid == 0) {\n        // 子进程\n        // execl(\"hello\",\"hello\",NULL);  //执行hello.out程序， 输出hello, world\n\n        execl(\"/bin/ps\", \"ps\", \"aux\", NULL);  //执行操作系统的 ps命令\n      \texeclp(\"ps\", \"ps\", \"aux\", NULL); //execlp可以从环境变量中查找 不需要指定路径\n        // perror(\"execl\");  //execl路径错误会输出错误信息\n        printf(\"i am child process, pid : %d\\n\", getpid());\n    }\n    for(int i = 0; i < 3; i++) {\n        printf(\"i = %d, pid = %d\\n\", i, getpid());\n    }\n    return 0;\n}\n```\n\n## 进程控制\n\n### 1. 进程退出\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220303183615766-727338168.png)\n\n```c++\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"hello\\n\");\n    printf(\"world\");\n    // exit(0);   // 打印 hello world 最后刷新io缓冲输出的world\n    _exit(0);    //打印hello  因为printf的\\n有刷新缓冲区的作用 输出hello\n    return 0;\n}\n```\n\n### 2. 孤儿进程\n\n- 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。\n- 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。\n-  因此`孤儿进程并不会有什么危害`。\n\n### 3. 僵尸进程\n\n- 每个进程结束之后, 都会释放自己地址空间中的用户区数据，<u>==内核区的 PCB 没有办法自己释放掉，需要父进程去释放==</u>。\n- 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。\n- <u>==僵尸进程不能被 kill -9 杀死==</u>，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的`进程号是有限的`，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的`危害`，应当避免。\n\n### 4. 进程回收\n\n- 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。\n\n- 父进程可以通过调用`wait`或`waitpid`得到它的退出状态同时彻底清除掉这个进程。\n\n- wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。\n\n- 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 <u>==（一次一个）==</u>\n\n- <u>==主进程wait阻塞等待子进程被kill掉 清楚pcb 主进程继续==</u>\n\n  > `线程中也存在子线程资源的回收`:\n  >\n  > join函数（类似多进程中的wait和waitpid），不同于多进程，任何线程都可以对其他线程的资源进行回收\n\n## 僵尸进程和孤儿进程\n\n- 正常进程\n\n  1. 正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。`子进程的结束和父进程的运行是一个异步过程`，即`父进程永远无法预测子进程到底什么时候结束`。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。\n\n  2. unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：\n\n     >1`进程号`the process ID\n     >\n     >2`退出状态`the termination status of the process\n     >\n     >3`运行时间`the amount of CPU time taken by the process等\n\n\n\n- ==孤儿==进程\n\n  一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。`孤儿进程将被init进程(进程号为1)所收养`，并由init进程对它们完成状态收集工作。\n\n- ==僵尸==进程\n\n  1. 一个进程使用fork创建子进程，<u>如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程</u>。\n  2. 僵尸进程是一个进程==必然==会经过的过程：这是每个子进程在结束时都要经过的阶段。\n  3. 如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。\n  4. 如果父进程在子进程结束之前退出，则子进程将由`init`接管。init将会以父进程的身份对僵尸状态的子进程进行处理。\n\n  - 危害：\n\n    <u>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</u>\n\n  - `外部消灭`：\n\n    通过kill发送sig_term或者sig_kill信号消灭产生僵尸进程的父进程，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源 （==杀死僵尸的爹，让它变成孤儿==）\n\n  - `内部解决`：\n\n    1. 子进程退出时向父进程发送sig_child信号，<u>父进程处理sig_child信号</u>。在信号处理函数中调用wait进行处理僵尸进程。\n\n       （==告诉你一声我要结束了，来处理我==）\n\n    2. fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 \n\n       （==创建时fork两次，然后退出第一个子进程，孙子就变成了孤儿==\n\n## 守护进程\n\n###  守护进程\n\n- 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是`Linux 中的后台服务进程`。它是一个生存期较长的进程，<u>通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件</u>。一般采用以 d 结尾的名字。\n- 守护进程具备下列特征：\n  - `生命周期很长`，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。\n  - 它`在后台运行并且不拥有控制终端`。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。\n\n- Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。\n\n###  守护进程的创建步骤\n\n1. 执行一个 fork()，之后父进程退出，子进程继续执行。\n2. 子进程调用 setsid() 开启一个新会话。\n3. 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。\n4. 修改进程的当前工作目录，通常会改为根目录（/）。\n5. 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。\n6. 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null 并使用dup2() 使所有这些描述符指向这个设备。\n7.  核心业务逻辑\n\n> 守护进程 是linux下的后台服务进程\n>\n> 例如：写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。\n\n# 3. 进程间通信方式 必考\n\n### 3.1 进程间通讯概念\n\n◼ 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。\n\n◼ 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。 \n\n◼ 进程间通信的目的：\n\n- 数据传输：一个进程需要将它的数据发送给另一个进程。\n- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。\n- 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。\n- 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制\n- 进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变\n\n### **3.2 进程间通信的方式：**\n\n进程间通信主要包括`管道`、`内存映射` 系统IPC（包括`消息队列`、`信号量`、`信号`、`共享内存`等）、以及套接字socket。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322163513852.png\" alt=\"image-20220322163513852\" style=\"zoom:50%;\" />\n\n#### 管道：\n\n- 管道主要包括无名管道和命名管道:\n\n  > 管道可用于具有亲缘关系的父子进程间的通信，\n  >\n  > 有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信\n\n##### 管道的特点\n\n- 管道其实是一个在`内核内存`中维护的`缓冲器`，这个缓冲器的存储`能力是有限`的，不同的操作系统大小不一定相同。\n\n- 管道拥有文件的特质：`读`操作、`写`操作，<u>匿名管道没有文件实体</u>，<u>有名管道有文件实体</u>，但不存储数据。可以按照操作文件的方式对管道进行操作。\n\n- 一个管道是一个`字节流`，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。\n\n- 通过管道传递的`数据是顺序`的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。\n\n- 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，具有`固定的读端和写端`，管道是`半双工`的。\n\n- 从管道读数据是`一次性操作`，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。\n\n- 匿名管道只能在`有亲缘关系的进程之间`（父进程与子进程，或者两个兄弟进程，具有亲缘）    <u>==（父亲或兄弟）==</u>\n\n  关系）之间使用。\n\n  \n\n##### 普通(匿名)管道PIPE：\n\n###### 特点\n\n1. 它是`半双工`的（即数据只能在一个方向上流动），具有`固定的读端和写端`    ==（指定方向的queue）==\n2. 它只能用于具`有亲缘关系的进程之间`的通信（也是父子进程或者兄弟进程之间） ==（父亲或兄弟）==\n3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且`只存在于内存，没有文件实体`中。   ==（特殊的，存在于内存中的文件）==\n\n###### 相关接口：\n\n- int pipe(int fd[2]);\n  - fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322170304928.png\" alt=\"image-20220322170304928\" style=\"zoom:50%;\" />\n\n`上图可以看出亲缘关系 两个文件实现 数据的队列传输`\n\n```c++\nint main(){\n    int fd[2]; // 定义文件描述符   0为读 1为写\n    pid_t pid;\n    char str[1024] = \"hello\\n\";\n    char buf[1024];\n    if (pipe(fd) < 0) // 创建管道，成功返回0，失败返回-1\n    {\n        perror(\"pipe\");\n        exit(1);\n    }\n    pid = fork(); // 创建一个子进程\n    // 功能：父写子读\n    if (pid > 0) // 父进程\n    {\n        close(fd[0]); // 父进程关闭读端\n        sleep(2);\n        write(fd[1], str, strlen(str)); // 向管道里写数据\n        wait(NULL); // 回收子进程\n    }\n    else if (pid == 0) // 子进程\n    {\n        close(fd[1]); // 子进程关闭写端\n        int len = read(fd[0], buf, sizeof(buf)); // 从管道里读数据\n        write(STDOUT_FILENO, buf, len); // 把读到的数据写到标准输出\n    }\n    else // 创建子进程失败\n    {\n        perror(\"fork\");\n        exit(1);\n    }\n    return 0;\n}\n```\n\n##### 命名管道FIFO： ==（仍然为 单向 半双工）==\n\n###### 有名管道特点：\n\n- 有名管道是FIFO文件，`存在于文件系统中`，可以通过文件路径名来指出。\n- 有名管道`可以在不具有亲缘`关系的进程间进行通信。\n\n###### 相关接口：\n\n- int mkfifo(const char *pathname, mode_t mode);\n  - pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。\n  - mode：和open()中的参数相同。\n\n```c++\n//write\n    int fd;  \n    int ret;      \n    ret = mkfifo(\"my_fifo\", 0666); // 创建命名管道  ret!=0创建成功\n    fd = open(\"my_fifo\", O_WRONLY); // 写  >0 open success\n    char send[100] = \"Hello World\";  \n    write(fd, send, strlen(send));  // 写数据  \n    printf(\"write to my_fifo buf=%s\\n\",send);  \n    while(1); // 阻塞，保证读写进程保持着通信过程\n    close(fd);\n\n//read\n    int fd;  \n    int ret;      \n    ret = mkfifo(\"my_fifo\", 0666); // 创建命名管道  \n    fd = open(\"my_fifo\", O_RDONLY); // 等着只写  \n    while(1) {  \n        char recv[100] = {0};\n        read(fd, recv, sizeof(recv)); // 读数据  \n        printf(\"read from my_fifo buf=[%s]\\n\", recv);  \n        sleep(1);  \n    }\n    close(fd);\n```\n\n#### 内存映射\n\n内存映射(mapped memory)：内存映射允许`任何多个进程间`通信，每一个使用该机制的进程通过`把一个共享的文件`映射到自己的`进程地址空间`来实现它，用户通过修改内存就能修改磁盘文件  （==<u>映射到`虚拟地址空间`, 可以是实现没有关系的进程间的通信</u>==） \n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220324110803612.png\" alt=\"image-20220324110803612\" style=\"zoom: 67%;\" />\n\n```c++\n/*\n    #include <sys/mman.h>\n    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);\n        - 功能：将一个文件或者设备的数据映射到内存中\n        - 参数：\n            - void *addr: NULL, 由内核指定\n            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。\n                    获取文件的长度：stat lseek\n            - prot : 对申请的内存映射区的操作权限\n                -PROT_EXEC ：可执行的权限\n                -PROT_READ ：读权限\n                -PROT_WRITE ：写权限\n                -PROT_NONE ：没有权限\n                要操作映射内存，必须要有读的权限。\n                PROT_READ、PROT_READ|PROT_WRITE\n            - flags :\n                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项\n                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）\n            - fd: 需要映射的那个文件的文件描述符\n                - 通过open得到，open的是一个磁盘文件\n                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。\n                    prot: PROT_READ                open:只读/读写 \n                    prot: PROT_READ | PROT_WRITE   open:读写\n            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不便宜。\n        - 返回值：返回创建的内存的首地址\n            失败返回MAP_FAILED，(void *) -1\n\n    int munmap(void *addr, size_t length);\n        - 功能：释放内存映射\n        - 参数：\n            - addr : 要释放的内存的首地址\n            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。\n*/\n\n/*\n    使用内存映射实现进程间通信：\n    1.有关系的进程（父子进程）\n        - 还没有子进程的时候\n            - 通过唯一的父进程，先创建内存映射区\n        - 有了内存映射区以后，创建子进程\n        - 父子进程共享创建的内存映射区\n    \n    2.没有关系的进程间通信\n        - 准备一个大小不是0的磁盘文件\n        - 进程1 通过磁盘文件创建内存映射区\n            - 得到一个操作这块内存的指针\n        - 进程2 通过磁盘文件创建内存映射区\n            - 得到一个操作这块内存的指针\n        - 使用内存映射区通信\n\n    注意：内存映射区通信，是非阻塞。\n*/\n\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <wait.h>\n\n// 作业:使用内存映射实现没有关系的进程间的通信。\nint main() {\n\n    // 1.打开一个文件\n    int fd = open(\"test.txt\", O_RDWR);\n    int size = lseek(fd, 0, SEEK_END);  // 获取文件的大小\n\n    // 2.创建内存映射区\n    void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(0);\n    }\n\n    // 3.创建子进程\n    pid_t pid = fork();\n    if(pid > 0) {\n        wait(NULL);\n        // 父进程\n        char buf[64];\n        strcpy(buf, (char *)ptr);\n        printf(\"read data : %s\\n\", buf);\n       \n    }else if(pid == 0){\n        // 子进程\n        strcpy((char *)ptr, \"nihao a, son!!!\");\n    }\n\n    // 关闭内存映射区\n    munmap(ptr, size);\n    return 0;\n}\n```\n\n\n\n#### 消息队列\n\n- 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列`克服了信号传递信息少`，`管道只能承载无格式字节流`以及`缓冲区大小受限`等特点) 具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；\n\n  特点：\n\n  1. 消息队列是面向记录的，其中的消息具有特定的`格式`以及特定的`优先级`。\n  2. 消息队列独立于发送与接收进程。进程`终止`时，消息队列及其内容并`不会被删除`。\n  3. 消息队列可以实现消息的`随机查询`,<u>消息不一定要以先进先出的次序读取,也可以按消息的类型读取</u>。\n\n#### 信号量semaphore   \n\n####   ==(控制而非通信)==\n\n- 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个`计数器`，可以用来`控制多个进程对共享资源的访问`。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。\n\n  特点：\n\n  1. 信号量用于进程间`同步`，若要在进程间传递数据需要结合共享内存。\n  2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。\n  3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。\n  4. 支持信号量组。\n\n#### 信号 (<u>kill</u>)\n\n- 信号是 Linux 进程间通信的`最古老的方式之一`，是事件发生时对进程的通知机制，有时也称之为`软件中断`，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。\n\n- 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：\n  - 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。\n  - 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。\n  - 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者该进程的某个子进程退出。\n  - 运行 kill 命令或调用 kill 函数。\n\n- 使用信号的两个主要目的是：\n\n  - 让进程知道已经发生了一个特定的事情。\n\n  - 强迫进程执行它自己代码中的信号处理程序。\n\n- 信号的特点： \n  - 简单 \n  - 不能携带大量信息\n  - 满足某个特定条件才发送\n  - 优先级比较高\n\n- 查看系统定义的信号列表：kill –l \n- 前 31 个信号为常规信号，其余为实时信号。\n\n##### 信号相关的几个函数\n\n##### `信号发生`\n\n```c++\n/*  #include <sys/types.h>\n    #include <signal.h>\n\n    int kill(pid_t pid, int sig);\n        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig\n        - 参数：\n            - pid ：\n                > 0 : 将信号发送给指定的进程\n                = 0 : 将信号发送给当前的进程组\n                = -1 : 将信号发送给每一个有权限接收这个信号的进程\n                < -1 : 这个pid=某个进程组的ID取反 （-12345）\n            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号\n\n        kill(getppid(), 9);\n        kill(getpid(), 9);\n        \n    int raise(int sig);\n        - 功能：给当前进程发送信号\n        - 参数：\n            - sig : 要发送的信号\n        - 返回值：\n            - 成功 0\n            - 失败 非0\n        kill(getpid(), sig);   \n\n    void abort(void);\n        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程\n        kill(getpid(), SIGABRT); \n        \n   \tunsigned int alarm(unsigned int seconds);\n        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，\n                函数会给当前的进程发送一个信号：SIGALARM\n        - 参数：\n            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。\n                    取消一个定时器，通过alarm(0)。\n        - 返回值：\n            - 之前没有定时器，返回0\n            - 之前有定时器，返回之前的定时器剩余的时间\n\n    \t- SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。\n        \talarm(10);  -> 返回0\n        \t过了1秒\n            alarm(5);   -> 返回9\n            alarm(100) -> 该函数是不阻塞的            \n    \n    int setitimer(int which, const struct itimerval *new_value,\n                        struct itimerval *old_value);\n    \n        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时\n        - 参数：\n            - which : 定时器以什么时间计时\n              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用\n              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM\n              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF\n\n            - new_value: 设置定时器的属性\n            \n                struct itimerval {      // 定时器的结构体\n                struct timeval it_interval;  // 每个阶段的时间，间隔时间\n                struct timeval it_value;     // 延迟多长时间执行定时器\n                };\n\n                struct timeval {        // 时间的结构体\n                    time_t      tv_sec;     //  秒数     \n                    suseconds_t tv_usec;    //  微秒    \n                };\n\n            过10秒后，每个2秒定时一次\n           \n            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL\n        \n        - 返回值：\n            成功 0\n            失败 -1 并设置错误号\n*/\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <unistd.h>\n\nint main() {\n\n    pid_t pid = fork();\n\n    if(pid == 0) {\n        // 子进程\n        int i = 0;\n        for(i = 0; i < 5; i++) {\n            printf(\"child process\\n\");\n            sleep(1);\n        }\n\n    } else if(pid > 0) {\n        // 父进程\n        printf(\"parent process\\n\");\n        sleep(2);\n        printf(\"kill child process now\\n\");\n        kill(pid, SIGINT);\n    }\n\n    return 0;\n}\n\n```\n\n##### `信号捕捉`\n\n```c++\n/*\n    #include <signal.h>\n    typedef void (*sighandler_t)(int);\n    sighandler_t signal(int signum, sighandler_t handler);\n        - 功能：设置某个信号的捕捉行为\n        - 参数：\n            - signum: 要捕捉的信号\n            - handler: 捕捉到信号要如何处理\n                - SIG_IGN ： 忽略信号\n                - SIG_DFL ： 使用信号默认的行为\n                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。\n                回调函数：\n                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义\n                    - 不是程序员调用，而是当信号产生，由内核调用\n                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。\n\n        - 返回值：\n            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL\n            失败，返回SIG_ERR，设置错误号\n            \n    SIGKILL SIGSTOP不能被捕捉，不能被忽略。\n*/\n\n#include <sys/time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n\nvoid myalarm(int num) {\n    printf(\"捕捉到了信号的编号是：%d\\n\", num);\n    printf(\"xxxxxxx\\n\");\n}\n\n// 过3秒以后，每隔2秒钟定时一次\nint main() {\n\n    // 注册信号捕捉\n    // signal(SIGALRM, SIG_IGN);\n    // signal(SIGALRM, SIG_DFL);\n    // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。\n    signal(SIGALRM, myalarm);\n\n    struct itimerval new_value;\n\n    // 设置间隔的时间\n    new_value.it_interval.tv_sec = 2;\n    new_value.it_interval.tv_usec = 0;\n\n    // 设置延迟的时间,3秒之后开始第一次定时\n    new_value.it_value.tv_sec = 3;\n    new_value.it_value.tv_usec = 0;\n\n    int ret = setitimer(ITIMER_REAL, &new_value, NULL); // 非阻塞的\n    printf(\"定时器开始了...\\n\");\n\n    if(ret == -1) {\n        perror(\"setitimer\");\n        exit(0);\n    }\n\n    getchar();\n\n    return 0;\n}\n```\n\n##### `SIGCHLD信号`\n\n**产生条件：**\n\n1. 子进程结束\n2. 子进程暂停了\n3. 子进程继续运行\n\n<u>都会给父进程发送该信号，父进程默认忽略该信号。</u>\n\n使用SIGCHLD信号`解决僵尸进程`的问题。\n\n```c++\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <sys/wait.h>\n\nvoid myFun(int num) {\n    printf(\"捕捉到的信号 ：%d\\n\", num);\n    // 回收子进程PCB的资源\n    // while(1) {\n    //     wait(NULL); \n    // }\n    while(1) {\n       int ret = waitpid(-1, NULL, WNOHANG);  //设置非阻塞\n       if(ret > 0) {\n           printf(\"child die , pid = %d\\n\", ret);\n       } else if(ret == 0) {\n           // 说明还有子进程或者\n           break;\n       } else if(ret == -1) {\n           // 没有子进程\n           break;\n       }\n    }\n}\n\nint main() {\n    // 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉\n    sigset_t set;\n    sigemptyset(&set);\n    sigaddset(&set, SIGCHLD);\n    sigprocmask(SIG_BLOCK, &set, NULL);\n\n    // 创建一些子进程\n    pid_t pid;\n    for(int i = 0; i < 20; i++) {\n        pid = fork();\n        if(pid == 0) {\n            break;  //子进程就不要再for循环 创建进程了\n        }\n    }\n\n    if(pid > 0) {\n        // 捕捉子进程死亡时发送的SIGCHLD信号\n        struct sigaction act;\n        act.sa_flags = 0;\n        act.sa_handler = myFun;\n        sigemptyset(&act.sa_mask);\n        sigaction(SIGCHLD, &act, NULL);\n\n        // 注册完信号捕捉以后，解除阻塞\n        sigprocmask(SIG_UNBLOCK, &set, NULL);\n\n        while(1) {\n            printf(\"parent process pid : %d\\n\", getpid());\n            sleep(2);\n        }\n    } else if( pid == 0) {\n        // 子进程\n        printf(\"child process pid : %d\\n\", getpid());\n    }\n\n    return 0;\n}\n```\n\n#### 共享内存\n\n##### **01 /** 共享内存概念\n\n- 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制`无需内核介入`。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用 是`最快的ipc`。\n- 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。   `（直接操作内存 与内核内存无关 管道什么的必须拷贝到内核内存）`\n\n##### **02 /** 共享内存使用步骤\n\n- 调用 shmget() `创建`一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。\n- 使用 shmat() 来`附上`共享内存段，即使该段成为调用进程的虚拟内存的一部分。 `（共享内存与进程关联）`\n- 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟`地址`空间中该共享内存段的起点的指针。\n- 调用 shmdt() 来`分离`共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。\n- 调用 shmctl() 来`删除`共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步\n\n##### 03 / 共享内存补充（Shared Memory）  （`不是`内存映射）\n\n- 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如`互斥锁和信号量`等\n\n  特点：\n\n  1. 共享内存是`最快`的一种IPC，因为进程是直接对内存进行存取\n  2. 因为多个进程可以同时操作，所以需要进行同步\n  3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问\n\nread_shm.c\n\n```c++\n#include <stdio.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <string.h>\n\nint main() {    \n\n    // 1.获取一个共享内存\n    int shmid = shmget(100, 0, IPC_CREAT);\n    printf(\"shmid : %d\\n\", shmid);\n\n    // 2.和当前进程进行关联\n    void * ptr = shmat(shmid, NULL, 0);\n\n    // 3.读数据\n    printf(\"%s\\n\", (char *)ptr);\n    \n    printf(\"按任意键继续\\n\");\n    getchar();\n\n    // 4.解除关联\n    shmdt(ptr);\n\n    // 5.删除共享内存\n    shmctl(shmid, IPC_RMID, NULL);\n\n    return 0;\n}\n```\n\nwrite_shm.c\n\n```c++\n#include <stdio.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <string.h>\n\nint main() {    \n\n    // 1.创建一个共享内存\n    int shmid = shmget(100, 4096, IPC_CREAT|0664);\n    printf(\"shmid : %d\\n\", shmid);\n    \n    // 2.和当前进程进行关联\n    void * ptr = shmat(shmid, NULL, 0);\n\n    char * str = \"helloworld\";\n\n    // 3.写数据\n    memcpy(ptr, str, strlen(str) + 1);\n\n    printf(\"按任意键继续\\n\");\n    getchar();\n\n    // 4.解除关联\n    shmdt(ptr);\n\n    // 5.删除共享内存\n    shmctl(shmid, IPC_RMID, NULL);\n\n    return 0;\n}\n```\n\n### 套接字SOCKET：\n\n- socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于==不同主机之间的进程==通信。\n\n \n\n# 4. 多线程、线程同步、通信实现\n\n## 线程的使用\n\n- int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start_routine) (void *), void *arg);\n- pthread_t pthread_self(void);\n- int pthread_equal(pthread_t t1, pthread_t t2);\n- void pthread_exit(void *retval);\n- int pthread_join(pthread_t thread, void **retval);\n- int pthread_detach(pthread_t thread);\n- int pthread_cancel(pthread_t thread);\n\n### 线程的创建 pthread_create\n\n#### 代码演示\n\n```c++\n/*\n    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程\n    称之为子线程。\n    程序中默认只有一个进程，fork()函数调用，2进程\n    程序中默认只有一个线程，pthread_create()函数调用，2个线程。\n\n    #include <pthread.h>\n    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, \n    void *(*start_routine) (void *), void *arg);\n\n        - 功能：创建一个子线程\n        - 参数：\n            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。\n            - attr : 设置线程的属性，一般使用默认值，NULL\n            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码\n            - arg : 给第三个参数使用，传参\n        - 返回值：\n            成功：0\n            失败：返回错误号。这个错误号和之前errno不太一样。\n            获取错误号的信息：  char * strerror(int errnum);\n\n*/\n#include <stdio.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid * callback(void * arg) {\n    printf(\"child thread...\\n\");\n    printf(\"arg value: %d\\n\", *(int *)arg);\n    return NULL;\n}\n\nint main() {\n    pthread_t tid;\n    int num = 10;\n    \n    // 创建一个子线程\n    int ret = pthread_create(&tid, NULL, callback, (void *)&num);\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error : %s\\n\", errstr);\n    } \n    \n    for(int i = 0; i < 5; i++) {\n        printf(\"%d\\n\", i);\n    }\n    sleep(1);\n    return 0;   // exit(0);\n}\n```\n\n### 线程终止 pthread_exit\n\n#### 代码演示\n\n```c++\n/*\n\n    #include <pthread.h>\n    void pthread_exit(void *retval);\n        功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程\n        参数：\n            retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。\n\n    pthread_t pthread_self(void);\n        功能：获取当前的线程的线程ID\n\n    int pthread_equal(pthread_t t1, pthread_t t2);\n        功能：比较两个线程ID是否相等\n        不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的\n        是使用结构体去实现的。\n*/\n#include <stdio.h>\n#include <pthread.h>\n#include <string.h>\n\nvoid * callback(void * arg) {\n    printf(\"child thread id : %ld\\n\", pthread_self());\n    return NULL;    // pthread_exit(NULL); 同一个含义\n} \n\nint main() {\n    // 创建一个子线程\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, callback, NULL);\n\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error : %s\\n\", errstr);\n    }\n\n    // 主线程\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d\\n\", i);\n    }\n\n    printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self());\n\n    // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。\n    pthread_exit(NULL);\n\n    printf(\"main thread exit\\n\");  //不输出\n\n    return 0;   // exit(0);\n}\n```\n\n### 线程回收\n\n线程中也存在子线程资源的回收:\n\n`join函数`（类似多进程中的wait和waitpid），不同于多进程，`任何线程都可以对其他线程的资源进行回收`\n\n#### 代码演示\n\n```c++\n/*\n    #include <pthread.h>\n    int pthread_join(pthread_t thread, void **retval);\n        - 功能：和一个已经终止的线程进行连接\n                回收子线程的资源\n                这个函数是阻塞函数，调用一次只能回收一个子线程\n                一般在主线程中使用\n        - 参数：\n            - thread：需要回收的子线程的ID\n            - retval: 接收子线程退出时的返回值\n        - 返回值：\n            0 : 成功\n            非0 : 失败，返回的错误号\n*/\n\n#include <stdio.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n\nint value = 10;\n\nvoid * callback(void * arg) {\n    printf(\"child thread id : %ld\\n\", pthread_self());\n    // sleep(3);\n    // return NULL; \n    // int value = 10; // 局部变量\n    pthread_exit((void *)&value);   // return (void *)&value;\n} \n\nint main() {\n\n    // 创建一个子线程\n    pthread_t tid;\n    int ret = pthread_create(&tid, NULL, callback, NULL);\n\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error : %s\\n\", errstr);\n    }\n\n    // 主线程\n    for(int i = 0; i < 5; i++) {\n        printf(\"%d\\n\", i);\n    }\n\n    printf(\"tid : %ld, main thread id : %ld\\n\", tid ,pthread_self());\n\n    // 主线程调用pthread_join()回收子线程的资源\n    int * thread_retval;\n    ret = pthread_join(tid, (void **)&thread_retval);\n\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error : %s\\n\", errstr);\n    }\n\n    //注意不要返回局部变量\n    printf(\"exit data : %d\\n\", *thread_retval);  \n\n    printf(\"回收子线程资源成功！\\n\");\n\n    // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。\n    pthread_exit(NULL);\n\n    return 0; \n}\n\n```\n\n### 线程的分离\n\nint pthread_detach(pthread_t thread);\n\n功能：分离一个线程。被分离的线程在终止的时候，会`自动释放资源`返回给系统。\n\n1. <u>不能多次分离</u>，会产生不可预料的行为\n\n2. <u>不能去连接一个已经分离的线程</u>，会报错\n\n#### 代码演示\n\n```c++\n/*\n    #include <pthread.h>\n    int pthread_detach(pthread_t thread);\n        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。\n          1.不能多次分离，会产生不可预料的行为。\n          2.不能去连接一个已经分离的线程，会报错。\n        - 参数：需要分离的线程的ID\n        - 返回值：\n            成功：0\n            失败：返回错误号\n*/\n#include <stdio.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid * callback(void * arg) {\n    printf(\"chid thread id : %ld\\n\", pthread_self());\n    return NULL;\n}\n\nint main() {\n\n    // 创建一个子线程\n    pthread_t tid;\n\n    int ret = pthread_create(&tid, NULL, callback, NULL);\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error1 : %s\\n\", errstr);\n    }\n\n    // 输出主线程和子线程的id\n    printf(\"tid : %ld, main thread id : %ld\\n\", tid, pthread_self());\n\n    // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放\n    ret = pthread_detach(tid);\n    if(ret != 0) {\n        char * errstr = strerror(ret);\n        printf(\"error2 : %s\\n\", errstr);\n    }\n\n    // 设置分离后，对分离的子线程进行连接 pthread_join()\n    // ret = pthread_join(tid, NULL);\n    // if(ret != 0) {\n    //     char * errstr = strerror(ret);\n    //     printf(\"error3 : %s\\n\", errstr);\n    // }\n\n    pthread_exit(NULL);\n\n    return 0;\n}\n```\n\n## 多线程，线程同步的几种方式\n\n临界区（线程通信方式）：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；\n\n`互斥量`Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问\n\n`信号量`Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。\n\n`条件变量`（事件）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作\n\n1. <u>==互斥锁==</u>\n\n   互斥锁是最常见的线程同步方式，它是一种特殊的变量，它有 ***lock*** 和 ***unlock*** 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取在使用同一个资源前加锁，使用后解锁，即可实现线程同步，需要注意的是，如果加锁后不解锁，会造成死锁\n\n   - **优点：**\n\n     使用简单；\n\n   - **缺点：**\n\n     1. 重复锁定和解锁，`每次都会检查共享数据结构，浪费时间和资源`；   ==（频繁检查共享数据（锁），浪费时间和资源）==\n     2. 繁忙查询的效率非常低；   ==（效率低）==\n\n2. <u>==条件变量==</u>\n\n   条件变量的方法是，当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁，实现高效。\n\n   条件变量允许线程阻塞并等待另一个线程发送信号，`一般和互斥锁一起使用`。\n\n   <u>条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。</u>    ==（一些锁 用条件变量替换）==\n\n3. <u>==信号量==</u>\n\n   **信号量** 和互斥锁的区别在于：`互斥锁只允许一个线程进入临界区，信号量允许多个线程同时进入临界区`\n\n   可以这样理解，互斥锁使用对同一个资源的互斥的方式达到线程同步的目的，信号量可以同步多个资源以达到线程同步\n\n   - 为什么要使用信号量？？?\n\n     为了防止多个进程在访问共享资源为引发的问题。信号量可以协调进程对共享资源的访问，也就是用来`保护临界资源`的。任一时刻只能有一个执行线程进入临界区。  ==（生产消费）==\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220301220958085-739618204.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n## 线程同步实现\n\n### 线程之间共享和非共享资源\n\n◼ 共享资源\n\n- 进程 ID 和父进程 ID\n\n- 进程组 ID 和会话 ID\n- 用户 ID 和 用户组 ID\n- 文件描述符表\n- 信号处置\n- 文件系统的相关信息：文件权限掩码（umask）、当前工作目录\n- 虚拟地址空间（除栈、.text） \n\n◼ 非共享资源\n\n- 线程 ID\n\n- 信号`掩码`\n\n  > 信号屏蔽字，它规定了当前要屏蔽或要阻塞递送到该进程的信号集 （==<u>屏蔽一些信号</u>==）\n  >\n  > 例如 当一个程序正在运行时，在键盘上按下Ctrl+C，内核就会向相应的进程发出一个SIGINT信号（终端中断符），对这个信号的默认操作就是通过do_exit()结束该进程的运行。但是，有些应用程序可能对Ctrl+C有自己的处理，所以就要为SIGINT另行设置一个处理程序，使它指向应用程序中的一个函数，在那个函数中对Ctrl+C这个事件做出响应。\n\n- 线程特有数据\n\n- error 变量\n\n- 实时调度策略和优先级\n\n- `栈`，本地变量和函数的调用链接信息\n\n### 线程同步介绍\n\n1. 线程的主要优势在于，`能够通过全局变量来共享信息`。不过，这种便捷的共享是`有代价`的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。\n\n2. `临界区是指`访问某一共享资源的`代码片段`，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。\n\n   > <u>原子操作是指不会被[线程调度](https://baike.baidu.com/item/线程调度/10226112)机制打断的操作</u>；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch（切换到另一个线程）。\n\n3. 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。\n\n### 互斥锁\n\n- 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。\n\n- 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。\n\n- 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问\n\n  同一资源时将采用如下协议：\n\n  > ⚫ 针对共享资源锁定互斥量\n  >\n  > ⚫ 访问共享资源\n  >\n  > ⚫ 对互斥量解锁\n\n- 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：\n\n![image-20220326121820000](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220326121820000.png)\n\n#### 代码演示\n\n```c++\n/*\n    互斥量的类型 pthread_mutex_t\n    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);\n        - 初始化互斥量\n        - 参数 ：\n            - mutex ： 需要初始化的互斥量变量\n            - attr ： 互斥量相关的属性，NULL\n        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。\n            pthread_mutex_t *restrict mutex = xxx;\n            pthread_mutex_t * mutex1 = mutex;\n\n    int pthread_mutex_destroy(pthread_mutex_t *mutex);\n        - 释放互斥量的资源\n\n    int pthread_mutex_lock(pthread_mutex_t *mutex);\n        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待\n\n    int pthread_mutex_trylock(pthread_mutex_t *mutex);\n        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。\n\n    int pthread_mutex_unlock(pthread_mutex_t *mutex);\n        - 解锁\n*/\n#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\n// 全局变量，所有的线程都共享这一份资源。\nint tickets = 1000;\n\n// 创建一个互斥量\npthread_mutex_t mutex;\n\nvoid * sellticket(void * arg) {\n    // 卖票\n    while(1) {\n        // 加锁\n        pthread_mutex_lock(&mutex);\n        if(tickets > 0) {\n            usleep(6000);\n            printf(\"%ld 正在卖第 %d 张门票\\n\", pthread_self(), tickets);\n            tickets--;\n        }else {\n            // 解锁\n            pthread_mutex_unlock(&mutex);\n            break;\n        }\n        // 解锁\n        pthread_mutex_unlock(&mutex);\n    }\n    return NULL;\n}\n\nint main() {\n    // 初始化互斥量\n    pthread_mutex_init(&mutex, NULL);\n    // 创建3个子线程\n    pthread_t tid1, tid2, tid3;\n    pthread_create(&tid1, NULL, sellticket, NULL);\n    pthread_create(&tid2, NULL, sellticket, NULL);\n    pthread_create(&tid3, NULL, sellticket, NULL)\n    // 回收子线程的资源,阻塞\n    pthread_join(tid1, NULL);\n    pthread_join(tid2, NULL);\n    pthread_join(tid3, NULL);\n    pthread_exit(NULL); // 退出主线程\n    // 释放互斥量资源\n    pthread_mutex_destroy(&mutex);\n\n    return 0;\n}\n```\n\n### 死锁\n\n- 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。\n\n- 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。\n\n-  死锁的几种场景：\n\n  > 忘记释放\n  >\n  > 重复加锁\n  >\n  > 多线程多锁，抢占锁资源\n\n![image-20220326123641573](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220326123641573.png)\n\n\n\n### 读写锁\n\n- 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。<u>但是考虑一种情形，当前持有互斥锁的线程只是要`读访问`共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是`实际上多个线程同时读访问共享资源并不会导致问题`。</u>\n\n- 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。\n\n- 读写锁的特点：\n\n  > 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。  `(读锁允许其他的读 不允许写)`\n  >\n  > 如果有其它线程写数据，则其它线程都不允许读、写操作。\t\t\t\t`（写锁不允许其他的读，也不允许其他的写）`\n  >\n  > 写是独占的，写的优先级高。\n\n\n\n#### 代码\n\n```c++\n/*\n    读写锁的类型 pthread_rwlock_t\n    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);\n    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n\n    案例：8个线程操作同一个全局变量。\n    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量\n*/\n\n#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\n// 创建一个共享数据\nint num = 1;\n// pthread_mutex_t mutex;\npthread_rwlock_t rwlock;\n\nvoid * writeNum(void * arg) {\n\n    while(1) {\n        pthread_rwlock_wrlock(&rwlock);\n        num++;\n        printf(\"++write, tid : %ld, num : %d\\n\", pthread_self(), num);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(100);\n    }\n\n    return NULL;\n}\n\nvoid * readNum(void * arg) {\n\n    while(1) {\n        pthread_rwlock_rdlock(&rwlock);\n        printf(\"===read, tid : %ld, num : %d\\n\", pthread_self(), num);\n        pthread_rwlock_unlock(&rwlock);\n        usleep(100);\n    }\n\n    return NULL;\n}\n\nint main() {\n\n   pthread_rwlock_init(&rwlock, NULL);\n\n    // 创建3个写线程，5个读线程\n    pthread_t wtids[3], rtids[5];\n    for(int i = 0; i < 3; i++) {\n        pthread_create(&wtids[i], NULL, writeNum, NULL);\n    }\n\n    for(int i = 0; i < 5; i++) {\n        pthread_create(&rtids[i], NULL, readNum, NULL);\n    }\n\n    // 设置线程分离\n    for(int i = 0; i < 3; i++) {\n       pthread_detach(wtids[i]);\n    }\n\n    for(int i = 0; i < 5; i++) {\n         pthread_detach(rtids[i]);\n    }\n\n    pthread_exit(NULL);\n\n    pthread_rwlock_destroy(&rwlock);\n\n    return 0;\n}\n```\n\n### 生产者消费者模型&条件变量\n\n店家生产包子 放到桌子上 客人吃包子\n\n三个对象：生产者 消费者 容器 \n\n生产者和消费者需要交流：有包子了通知客人吃，客人吃完了通知店家做\n\n<u>需要使用条件变量或者信号量实现同步 不能无限制的做包子或者无限制的等待（while(1)）吃包子</u>\n\n#### 简单实现：\n\n```c++\n/*\n    条件变量的类型 pthread_cond_t\n    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);\n    int pthread_cond_destroy(pthread_cond_t *cond);\n    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);\n        - 等待，调用了该函数，线程会阻塞。\n    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);\n        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。\n    int pthread_cond_signal(pthread_cond_t *cond);\n        - 唤醒一个或者多个等待的线程\n    int pthread_cond_broadcast(pthread_cond_t *cond);\n        - 唤醒所有的等待的线程\n*/\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n// 创建一个互斥量\npthread_mutex_t mutex;\n// 创建条件变量\npthread_cond_t cond;\n\nstruct Node{\n    int num;\n    struct Node *next;\n};\n\n// 头结点\nstruct Node * head = NULL;\n\nvoid * producer(void * arg) {\n    // 不断的创建新的节点，添加到链表中\n    while(1) {\n        pthread_mutex_lock(&mutex);\n        struct Node * newNode = (struct Node *)malloc(sizeof(struct Node));\n        newNode->next = head;\n        head = newNode;\n        newNode->num = rand() % 1000;\n        printf(\"add node, num : %d, tid : %ld\\n\", newNode->num, pthread_self());\n        \n        // 只要生产了一个，就通知消费者消费\n        pthread_cond_signal(&cond);\n\n        pthread_mutex_unlock(&mutex);\n        usleep(100);\n    }\n\n    return NULL;\n}\n\nvoid * customer(void * arg) {\n    while(1) {\n        pthread_mutex_lock(&mutex);\n        // 保存头结点的指针\n        struct Node * tmp = head;\n        // 判断是否有数据\n        if(head != NULL) {\n            // 有数据\n            head = head->next;\n            printf(\"del node, num : %d, tid : %ld\\n\", tmp->num, pthread_self());\n            free(tmp);\n            pthread_mutex_unlock(&mutex);\n            usleep(100);\n        } else {\n            // 没有数据，需要等待\n            // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。\n            pthread_cond_wait(&cond, &mutex);\n            pthread_mutex_unlock(&mutex);  //没有条件变量 会一致解锁 浪费资源\n        }\n    }\n    return  NULL;\n}\n\nint main() {\n    pthread_mutex_init(&mutex, NULL);\n    pthread_cond_init(&cond, NULL);\n\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5], ctids[5];\n\n    for(int i = 0; i < 5; i++) {\n        pthread_create(&ptids[i], NULL, producer, NULL);\n        pthread_create(&ctids[i], NULL, customer, NULL);\n    }\n\n    for(int i = 0; i < 5; i++) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    while(1) {\n        sleep(10);\n    }\n\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond);\n\n    pthread_exit(NULL);\n\n    return 0;\n}\n\n```\n\n### 信号量\n\n```c++\n/*\n    信号量的类型 sem_t\n    int sem_init(sem_t *sem, int pshared, unsigned int value);\n        - 初始化信号量\n        - 参数：\n            - sem : 信号量变量的地址\n            - pshared : 0 用在线程间 ，非0 用在进程间\n            - value : 信号量中的值\n\n    int sem_destroy(sem_t *sem);\n        - 释放资源\n\n    int sem_wait(sem_t *sem);\n        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞\n\n    int sem_trywait(sem_t *sem);\n\n    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);\n    int sem_post(sem_t *sem);\n        - 对信号量解锁，调用一次对信号量的值+1\n\n    int sem_getvalue(sem_t *sem, int *sval);\n\n    sem_t psem;\n    sem_t csem;\n    init(psem, 0, 8);\n    init(csem, 0, 0);\n\n    producer() {\n        sem_wait(&psem);\n        sem_post(&csem)\n    }\n\n    customer() {\n        sem_wait(&csem);\n        sem_post(&psem)\n    }\n\n*/\n\n#include <stdio.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <semaphore.h>\n\n// 创建一个互斥量\npthread_mutex_t mutex;\n// 创建两个信号量\nsem_t psem;\nsem_t csem;\n\nstruct Node{\n    int num;\n    struct Node *next;\n};\n\n// 头结点\nstruct Node * head = NULL;\n\nvoid * producer(void * arg) {\n\n    // 不断的创建新的节点，添加到链表中\n    while(1) {\n        sem_wait(&psem); // 8 - 1 - 1 - 1.... \n        pthread_mutex_lock(&mutex);\n        struct Node * newNode = (struct Node *)malloc(sizeof(struct Node));\n        newNode->next = head;\n        head = newNode;\n        newNode->num = rand() % 1000;\n        printf(\"add node, num : %d, tid : %ld\\n\", newNode->num, pthread_self());\n        pthread_mutex_unlock(&mutex);\n        sem_post(&csem); // 0 + 1 + 1 + 1.....\n    }\n\n    return NULL;\n}\n\nvoid * customer(void * arg) {\n\n    while(1) {\n        sem_wait(&csem);  //不为0 说明有包子 进行后续代码 进行消费 - 1 - 1 -1...\n        pthread_mutex_lock(&mutex);\n        // 保存头结点的指针\n        struct Node * tmp = head;\n        head = head->next;\n        printf(\"del node, num : %d, tid : %ld\\n\", tmp->num, pthread_self());\n        free(tmp);\n        pthread_mutex_unlock(&mutex);\n        sem_post(&psem); //消费完成 通知生产则生产 + 1 + 1 + 1....\n       \n    }\n    return  NULL;\n}\n\nint main() {\n\n    pthread_mutex_init(&mutex, NULL);\n    sem_init(&psem, 0, 8);  //初始为8\n    sem_init(&csem, 0, 0);\n\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5], ctids[5];\n\n    for(int i = 0; i < 5; i++) {\n        pthread_create(&ptids[i], NULL, producer, NULL);\n        pthread_create(&ctids[i], NULL, customer, NULL);\n    }\n\n    for(int i = 0; i < 5; i++) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    while(1) {\n        sleep(10);\n    }\n\n    pthread_mutex_destroy(&mutex);\n\n    pthread_exit(NULL);\n\n    return 0;\n}\n\n```\n\n\n\n## 线程间的同步方式，最好说出具体的系统调用\n\n==信号量==\n\n信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：\n\nP(SV):如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。 ==消费==线程 \n\n> 假设sv = 1, sv大于0表示有苹果 可以吃  --， 然后sv = 0还想吃 则挂起\n\nV(SV)：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。 ==生产==线程\n\n其系统调用为：\n\n`sem_wait`（sem_t *sem）：以原子操作的方式将信号量减1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。\n\n`sem_post`（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。\n\n \n\n==互斥量==\n\n互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：\n\n`pthread_mutex_init`:初始化互斥锁\n\n`pthread_mutex_destroy`：销毁互斥锁\n\n`pthread_mutex_lock`：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。\n\n`pthread_mutex_unlock`:以一个原子操作的方式给一个互斥锁解锁。\n\n \n\n==条件变量==\n\n条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：\n\n`pthread_cond_init`:初始化条件变量\n\n`pthread_cond_destroy`：销毁条件变量\n\n`pthread_cond_signal`：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。\n\n`pthread_cond_wait`：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线d对共享资源正确访问。\n\n \n\n## 互斥锁和条件变量的区别\n\n- 条件变量：可以自己决定什么时候唤醒别的线程，达到唤醒条件之后再==唤醒==某个线程。选择唤醒单个线程   \n\n  ==（主要是唤醒特定线程）==\n\n- 互斥锁强调的是资源的访问互斥：解锁时自动唤醒阻塞线程\n\n###  1. 互斥锁（mutual exclusive lock variable / mutex ）\n\n- 互斥量(mutex)从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥锁加锁的线程将会阻塞直到当前线程释放该互斥锁。**如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。**\n\n### 2. 条件变量\n\n- 条件变量(cond)是在多线程程序中用来实现\"等待--》唤醒\"逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待\"条件变量的条件成立\"而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。\n\n### [3. 那为什么有互斥锁，还需要条件变量](https://www.jianshu.com/p/01ad36b91d39)\n\n- 因为：**互斥锁和条件变量所解决的，是不同的问题，不同的场景。**\n\n- 互斥锁解决的是在 shared memory space 模型下，多个线程对同一个全局变量的访问的竞争问题。由于写操作的非原子性（从内存中读进寄存器，修改，如果其他线程完成了对这个变量的修改，则旧的修改就被覆盖，等等问题），必须保证同一时间只有一个线程在进行写操作。这就涉及到了互斥锁，将临界区的**操作**锁起来，保证只有一个线程在进行操作。多个线程在等待同一把锁的时候，按照 FIFO 组织队列，当锁被释放时，队头线程获得锁（由操作系统管理，具体不表）。**没有获得锁的线程继续被 block，换言之，它们是因为没有获得锁而被 block**。\n\n- 假如我们没有“条件变量”这个概念，如果一个线程要等待某个“自定义的条件”满足而继续执行，而这个条件只能由另一个线程来满足，比如 T1不断给一个全局变量 x +1， T2检测到x 大于100时，将x 置0，如果我们没有条件变量，则只通过互斥锁则可以有如下实现:\n\n  ```c++\n  /* \n   * Assume we have global variables:\n   * int iCount == 0;\n   * pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n   */\n  \n  //thread 1:\n  while(true){\n      pthread_mutex_lock(&mutex);\n      iCount++;\n      pthread_mutex_unlock(&mutex);\n  }\n  \n  //thread 2:\n  while(true){\n      pthread_mutex_lock(&mutex);\n      if(iCount >= 100){\n          iCount = 0;\n      }\n      pthread_mutex_unlock(&mutex);\n  }\n  ```\n\n- 这种实现下，就算 lock 空闲，thread2需要不断重复<加锁，判断，解锁>这个流程，会给系统带来不必要的开销。有没有一种办法让 thread2先被 block，等条件满足的时候再唤醒 thread2？这样 thread2 就不用不断进行重复的加解锁操作了？这就要用到条件变量了：\n\n  ````c++\n  //thread1 :\n  while(true){\n      pthread_mutex_lock(&mutex);\n      iCount++;\n      pthread_mutex_unlock(&mutex);\n  \n      pthread_mutex_lock(&mutex);\n      if(iCount >= 100){\n          pthread_cond_signal(&cond);\n      }\n      pthread_mutex_unlock(&mutex);\n  }\n  \n  //thread2:    啥玩意 没看懂\n  while(1){\n      pthread_mutex_lock(&mutex);\n      while(iCount < 100)\n      {\n          pthread_cond_wait(&cond, &mutex);\n      }\n      printf(\"iCount >= 100\\r\\n\");\n      iCount = 0;\n      pthread_mutex_unlock(&mutex);\n  }\n  ````\n\n  - 需要注意的是，条件变量需要配合互斥锁来使用：\n    为什么要与pthread_mutex 一起使用呢？ 这是为了应对 线程1在调用pthread_cond_wait()但线程1还没有进入wait cond的状态的时候，此时线程2调用了 cond_singal 的情况。 如果不用mutex锁的话，这个cond_singal就丢失了。加了锁的情况是，线程2必须等到 mutex 被释放（也就是 pthread_cod_wait() 释放锁并进入wait_cond状态 ，此时线程2上锁） 的时候才能调用cond_singal.\n\n  - 简而言之就是，在thread 1 call pthread_cond_wait() 的时刻到 thread 1真正进入 wait 状态时，是存在着时间差的。如果在这段时间差内 thread2 调用了 pthread_cond_signal() 那这个 signal 信号就丢失了。给 wait 加锁可以防止同时有另一个线程在 signal。\n\n## 互斥锁/互斥量\n\n1. 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。\n\n2. 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。\n\n3.  一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问\n\n4. 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域\n\n5. 同一资源时将采用如下协议：\n\n   > ⚫ 针对共享资源锁定互斥量\n   >\n   > ⚫ 访问共享资源\n   >\n   > ⚫ 对互斥量解锁\n\n````c++\n#include <mutex>\n\nmutex mut;\nmut.lock();\nval++;\nmut.unlock();\n// lock_guard自动解锁\nvoid proc2(int a) {\n  lock_guard<mutex> g2(m); //自动锁定\n  cout << \"proc2函数正在改写a\" << endl;\n} //自动解锁\n\n// unique_lock自动解锁，且可在中途解锁\n\nvoid proc1(int a) {\n  unique_lock<mutex> g1(m, defer_lock); //始化了一个没有加锁的mutex\n  g1.lock(); //手动加锁，注意，不是m.lock();注意，不是m.lock(),m已经被g1接管了;\n  cout << \"proc1函数正在改写a\" << endl;\n  g1.unlock(); //临时解锁\n  cout << \"xxxxx\" << endl;\n  g1.lock();\n  cout << \"xxxxxx\" << endl;\n} //自动解锁\n\nvoid proc2(int a) {\n  unique_lock<mutex> g2(\n      m,\n      try_to_lock); //尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作。\n  if (g2.owns_lock) { //锁成功\n    cout << \"proc2函数正在改写a\" << endl;\n    cout << \"原始a为\" << a << endl;\n    cout << \"现在a为\" << a + 1 << endl;\n  } else { //锁失败则执行这段语句\n    cout << \"\" << endl;\n  }\n} //自动解锁\n````\n\n## 条件变量\n\n条件变量一般和互斥锁搭配使用，互斥锁用于上锁，条件变量用于在多线程环境中等待特定事件发生。\n\n```c++\n#include <condition_variable>\ncondition_variable cv;\nint k = 0;\n\n//线程1\nk = 1; \ncv.notify_all(); // 通知其他所有在等待唤醒队列中的线程\n\n\n//线程2\ncv.wait(lock, [this](){ return k == 1; }); \n// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行\n\nk = 2;\ncv.notify_one();  // 随机通知一个（unspecified）在等待唤醒队列中的线程\n```\n\n\n\n## 信号量\n\n信号量是用来实现对共享资源的同步访问的机制，其使用方法和条件变量类似，都是通过`主动等待和主动唤醒`来实现的。\n\n````c++\n#include <semaphore.h>\nsem_init(&sem_1, 0, 0);\nvoid first(function<void()> printFirst) {\n  printFirst();\n  sem_post(&sem_1);\n}\n\nvoid second(function<void()> printSecond) {\n  sem_wait(&sem_1);\n  printSecond();\n}\n````\n\n## 异步操作\n\n刚实例化的future是没有储存值的，但在调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future\n\n````c++\n#include<future>\nfuture<double> fu = async(t1, a, b);//创建异步线程，并将线程的执行结果用fu占位；\ncout << \"正在进行计算\" << endl;\ncout << \"计算结果马上就准备好，请您耐心等待\" << endl;\ncout << \"计算结果：\" << fu.get() << endl;//阻塞主线程，直至异步线程return\n````\n\n## 原子操作\n\n每次操作这个对象时，就不用lock与unlock，这个对象自身就具有原子性（==相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了==\n\n```c++\nstd::atomic<bool> b(true);\nb=false;\n```\n\n## 4.7. 生产者消费者模型\n\n\n\n# 5. IO操作/线程池\n\n## 5.1.  [介绍一下5种IO模型](https://www.jianshu.com/p/486b0965c296)\n\n1. `阻塞IO`:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作  ==<u>（等待 的准备好了才能继续）</u>==\n2. `非阻塞IO`:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就<u>==可以做其他事==</u>。\n3. `信号驱动IO`:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。 <u>==（不是我去循环检查你好没好，而是你好了告诉我）==</u>\n4. `IO复用/多路`转接IO:linux用<u>==select/poll==</u>函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数 <u>==（批处理）==</u>\n5. `异步IO`:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。   <u>==（告知你我要什么，你自己给我送过来 然后再通知我）==</u>\n\n\n\n## 5.3.  死循环+来连接时新建线程的方法效率有点低，怎么改进？\n\n\n\n==<u>改进死循环</u>==：使用`select epoll`这样的技术\n\n==<u>新建线程效率低</u>==：提前创建好一个线程池，用`生产者消费者模型`，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。\n\n## 5.4.  线程池\n\n`因为创建线程关闭线程花销是比较大的，大过了线程空转的花销`,创建和销毁线程开销大，可能需要上千个时钟周期，避免cpu花费不必要的时间在这上面。  （==创建销毁 > 空转==）\n\n### 5.4.1. 原理\n\n**为了减少创建与销毁线程所带来的时间消耗与资源消耗，因此采用线程池的策略：**\n\n1. 程序启动后，`预先创建一定数量的线程放入空闲队列`中，这些线程都是处于阻塞状态，基本不消耗CPU，只占用较小的内存空间。\n\n2. 接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。\n3. 任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。\n\n**线程池所解决的问题：**\n\n1. 需要频繁创建与销毁大量线程的情况下，由于线程预先就创建好了，接到任务就能马上从线程池中调用线程来处理任务，`减少了创建与销毁线程带来的时间开销和CPU资源占用`。\n2.  需要并发的任务很多时候，无法为每个任务指定一个线程（`线程不够分`），使用线程池可以将提交的任务挂在任务队列上，等到池中有空闲线程时就可以为该任务指定线程。\n\n### 5.4.2. ==怎么实现线程池==\n\n1. <u>设置一个生产者消费者队列</u>，作为临界资源\n2. 初始化n个线程，并让其运行起来，加锁去队列取任务运行\n3. 当任务队列为空的时候，所有线程阻塞\n4. 当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程\n\n### 5.4.3. 线程池参数设置\n\n线程池的线程数量设置`过多`会导致线程`竞争激烈`\n\n如果线程数量设置`过少`的话，还会导致系统`无法充分利`用计算机`资源`\n\n- CPU 密集型任务\n\n  这种任务消耗的主要是 CPU 资源，可以将线程数设置为 `N（CPU 核心数）+1`，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\n\n- I/O 密集型任务\n\n  这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 `2N`。\n\n \n\n## 5.5.  [select，poll，epoll的区别，原理，性能，限制都说一说](https://www.zhihu.com/collection/786678607)\n\n### 5.5.1. IO多路复用\n\nIO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。\n\n这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。\n\n \n\nIO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。\n\n<u>当用户进程调用了select，那么`整个进程会被block`，而同时，kernel会“`监视`”所有select负责的socket，当任何一个socket中的`数据准备好了`，select就会`返回`。这个时候用户进程再调用`read操作`，`将数据从kernel拷贝到用户进程`。</u>\n\n所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。\n\nI/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。\n\n所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）\n\n在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。\n\n\n\n### select poll epoll大体介绍及对比\n\n**(1)、select==>时间复杂度O(n)**\n\n- 它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以**select具有O(n)的无差别轮询复杂度**，同时处理的流越多，无差别轮询时间就越长。\n\n  ==（知道有io事件了 再遍历所有）==\n\n**(2)、poll==>时间复杂度O(n)**\n\n- poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， **但是它没有最大连接数的限制**，原因是它是基于链表来存储的.  ==(链表存储 没有大小限制)==\n\n**(3)、epoll==>时间复杂度O(1)**\n\n- **epoll可以理解为event poll**，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是**事件驱动（==每个事件关联上fd==）**的，此时我们对这些流的操作都是有意义的。==**（复杂度降低到了O(1)）**==、\n\n  \n\n- select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。**但select，poll，epoll本质上`都是同步I/O`，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\n- epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现\n\n### select\n\nselect本质上是通过设置或者检查存放fd标志位的数据结构(`检查描述符集`)来进行下一步处理。这样所带来的缺点是：\n\n1. 单个进程可监视的fd数量被限制，即能监听端口的大小有限。默认是1024  ==（数量受限）==\n\n   一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.\n\n2. 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低： ==（效率低）==\n\n   当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能`给套接字注册某个回调函数`，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。\n\n3. 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大  ==（维护的数据结构开销大）==\n\n   **每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大**\n\n4. 每次调用select 都要重新初始化fd集合\n\n### poll\n\npoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。\n\n**它没有最大连接数的限制**，原因是它是基于链表来存储的，但是同样有一个缺点：   ==(链表存储 数量不限)==\n\n1. 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。 （大量数据复制）\n\n2. poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。 \n\n### **epoll:**\n\n- epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。\n- LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作  ==（没读完数据可以重复提醒）==\n- 在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。==（====我只说一次）==\n- 所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。\n- 还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的`回调机制`来激活该fd，epoll_wait便可以收到通知。\n\n### **epoll为什么要有EPOLLET触发模式？**\n\n- 如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！==**这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符**==\n\n### **epoll的优点：**\n\n1. **没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）**；==（数量大）==\n\n2. 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 ==（效率高）==\n\n3.  内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap`减少复制开销`。  ==（开销小）==\n\n   \n\n### **select、poll、epoll 区别总结**\n\n**1、支持一个进程所能打开的最大连接数**\n\n> select\t单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32* 32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。\n>\n> poll\tpoll本质上和select没有区别，但是它`没有`最大连接数的`限制`，原因是它是基于链表来存储的\n>\n> epoll\t虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接  ==(1G10W)==\n\n**2、FD剧增后带来的IO效率问题**\n\n> select\t因为每次调用时都会对连接进行`线性遍历`，所以随着FD的增加会造成遍历速度慢的“`线性下降性能问题`”。\n>\n> poll\t同上\n>\n> epoll\t因为epoll内核中实现是根据每个fd上的`callback函数`来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。\n\n**3、 消息传递方式**\n\n> select \t内核需要将消息传递到用户空间，都需要`内核拷贝`动作\n>\n> poll\t同上\n>\n> epoll\tepoll通过内核和用户空间`共享一块内存`来实现的。\n\n==**总结：**==\n\n> **综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。**\n>\n> **1、表面上看epoll的性能最好，但是在`连接数少并且连接都十分活跃`的情况下，`select和poll的性能可能比epoll好`，毕竟epoll的通知机制需要很多函数回调。**\n>\n> **2、select低效是因为每次它都需要轮询。但`低效也是相对`的，视情况而定，也可通过良好的`设计`改善**\n\n## epoll水平触发与边沿触发\n\n1.  LT模式\n\n    - LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。\n\n    - 比如说我们采用epoll水平触发模式监听一个文件描述符的可读，当这个文件可读就绪时，epoll会触发一个通知，然后我们执行一次读取操作，但这次操作我们并没有把该文件描述符的数据全部读取完。当下一次调用epoll监听该文件描述符时，epoll还会再次触发通知，直到该事件被处理完。这就意味着，当epoll触发通知后，我们可以不立即处理该事件，当下次调用epoll监听时，然后会再次向应用程序通告此事件，此时我们再处理也不晚。\n\n2.  ET模式\n    - ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)\n    - ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n    - 当文件描述符收到I/O事件通知时，通常我们并不知道要处理多少I/O（例如有多少字节可读）。如果程序采用循环来对文件描述符执行尽可能多的I/O，而文件描述符又被设置为可阻塞的，那么最终当没有更多的I/O可执行时，I/O系统调用就会阻塞。\n\n3.  LT模式与ET模式的区别如下：\n    - LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。\n    - ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。\n\n# 6. 锁\n\n## 6.1.  Linux的4种锁机制：\n\n### 四种锁介绍\n\n1. ==互斥锁：mutex==，用于保证在任何时刻，都只能有一个线程访问该对象。<u>当获取锁操作失败时，线程会进入`睡眠`，等待锁释放时被唤醒</u>\n\n2. 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许`多个线程同时获得读操作`。但是同一时刻只能有`一个线程可以获得写锁`。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。   ==(多个读 一个写)==\n\n3. 自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，`不会进入睡眠`，而是会在`原地自旋`，直到锁被释放。这样<u>节省了线程从睡眠状态到被唤醒期间的消耗</u>，==在加锁时间短暂的环境下会极大的提高效率==。但如果加锁时间过长，则会非常浪费CPU资源。\n\n   > 自旋锁尽可能的减少线程的阻塞，这`对于锁的竞争不激烈`，且`占用锁时间非常短`的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！\n   >\n   > 但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。\n\n4. RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。==在有大量读操作，少量写操作的情况下效率非常高。==\n\n### 互斥锁和读写锁的区别：\n\n1. 读写锁`区分读者和写者`，而互斥锁不区分\n\n2. 互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许`多个读者`同时读对象。\n\n## 6.2.  乐观锁和悲观锁\n\n### 比较\n\n前面提到的==互斥锁、自旋锁、读写锁==，都是属于悲观锁。\n\n- 悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。\n- 乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。可见，<u>乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现乐观锁全程并没有加锁，所以它也叫`无锁编程`。</u>\n\n### 乐观锁\n\n总是假设==最好==的情况，<u>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是`在更新的时候会判断一下在此期间别人有没有去更新这个数据`，</u>可以使用==<u>版本号机制</u>==和==<u>CAS算法</u>==实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。\n\n#### **1. 版本号机制**\n\n一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。\n\n**举一个简单的例子：**\n假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。\n\n1. 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $ 50 ($ 100-$ 50 ）。\n2. 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。\n3. 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。\n4. 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。\n\n这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。\n\n#### **2. CAS算法**\n\n即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。**CAS算法**涉及到三个操作数\n\n- 需要读写的内存值 V\n- 进行比较的值 A\n- 拟写入的新值 B\n\n当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。\n\n\n\n### **乐观锁的缺点**\n\n> ABA 问题是乐观锁一个常见的问题\n\n**1 ABA 问题**\n\n如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **\"ABA\"问题。**\n\nJDK 1.5 以后的 `AtomicStampedReference 类`就提供了此种能力，其中的 `compareAndSet 方法`就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n\n**2 循环时间长开销大**\n\n**自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。** 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。\n\n**3 只能保证一个共享变量的原子操作**\n\nCAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了`AtomicReference类`来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference类`把多个共享变量合并成一个共享变量来操作。\n\n#### **CAS与synchronized的使用情景**\n\n> **简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）**\n\n1. 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。\n2. 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。\n\n## 6.3.  递归锁和非递归锁\n\n Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。\n     二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。   ==(递归锁指不能连续上锁 连续解锁)==\n     Windows下的Mutex和Critical Section是可递归的。Linux下的pthread_mutex_t锁默认是非递归的。可以显示的设置PTHREAD_MUTEX_RECURSIVE属性，将pthread_mutex_t设为递归锁。\n\n## 6.4.  两个进程访问临界区资源，会不会出现都获得自旋锁的情况？\n\n`单核cpu，并且开了抢占可以造成这种情况。`\n\n \n\n## 6.5.  互斥锁（mutex）机制，以及互斥锁和读写锁的区别\n\n互斥锁和读写锁区别：\n\n互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。\n\n读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。\n\n互斥锁和读写锁的区别：\n\n1. 读写锁区分`读者`和`写者`，而互斥锁不区分\n\n2. 互斥锁同一时间`只允许一个`线程访问该对象，无论读写；\n\n   读写锁同一时间内`只允许一个写者`，但是`允许多个读者`同时读对象。\n\n \n\n \n\n## 6.6.  死锁发生的条件以及如何解决死锁\n\n死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待的现象。\n\n### 死锁发生的四个必要条件\n\n- `互斥条件`：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；\n\n  > （`互斥指的是资源的互斥 只能一个进程访问`）\n\n- `请求和保持条件`：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源\n\n  > （`我阻塞 但我不放手自己的资源`）\n\n- `不可抢占条件`：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放\n\n  > （`资源只能我自己释放`）\n\n- `循环等待条件`：进程发生死锁后，必然存在一个进程-资源之间的环形链\n\n  > （`我需要你的 你需要他 他需要我...`）\n\n\n\n### 解决死锁的方法\n\n即破坏上述四个条件之一，主要方法如下：\n\n1. 资源一次性分配，从而剥夺`请求和保持条件`\n\n2. 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏`不可剥夺的条件`\n\n3. 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件\n\n   \n\n### 处理死锁的基本方法\n\n1. 预防死锁: 属于事前预防的策略，通过<u>设置某些限制条件</u>，去破坏产生死锁的四个必要条件或其中的几个条件。预防死锁比较容易实现，所以被泛使用，但是由于施加的限制条件过于严格可能会导致系统资源利用率和系统吞吐量降低。\n\n2. 避免死锁: 属于事前预防的策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是<u>在资源的动态分配过程中，用某种方法去防止系统进入不安全状态</u>，从而避免死锁的产生。但实现有一定的难度。目前较完善的系统中`常用此法`来避免死锁。\n3. 检测死锁: 这种方法不需要事前采取任何限制措施，也不用检查是否进入不安全状态，而是`允许`系统在运行的过程中`发生死锁`。但是通过系统所设置的检测机构.及时的检测出死锁的发生，并精确的测出与死锁有关的进程和资源，然后，采取适当的措施，从系统中将已发生的死锁清楚掉。 (`及时定位给死锁并清除`)\n4. 解除死锁: 这是与检测死锁相配套的一套措施。当检测到系统已经产生死锁时，须将进程从死锁中解放出来。通常用到的实施方法是撤销或挂起些进程，以便收回一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源和吞吐量，但在现实上难度也最大。\n\n### 预防死锁和避免死锁的区别:\n\n- 预防死锁和避免死锁实质上都是通过施加某种相知条件的方法，来预防发生死锁。两者的主要区别:为了预防死锁所施加的限制条件较为严格，这往往会影响到进程的并发执行，而避免死锁所施加的限制条件则较为宽松，有利于进程的并发执行。 \n\n  ==（预防比较严格 避免比较宽松）==\n\n \n\n## 6.7.  `银行家算法`（避免死锁）\n\n- 银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中`允许进程动态地申请资源`，但系统在进行资源分配之前，应`先计算此次分配资源的安全性`，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。要解释银行家算法，必须先解释操作系统安全状态和不安全状态。\n\n- 安全序列是指一个进程序列{P1，…，Pn}是安全的，即对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j < i )当前占有资源量之和。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220303234601290-1516095814.png)\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220303234601275-2072986485.png)\n\n## 6.8.  单核机器上写多线程程序，是否需要考虑加锁，为什么？\n\n- 在单核机器上写多线程程序，`仍然需要`线程锁。因为线程锁通常用来实现线程的`同步和通信`。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。<u>如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</u>\n\n# 7. 并行并发\n\n## 7.1.  并发(concurrency)和并行(parallelism)\n\n- 并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。\n\n  `（其实是交替运行）`\n\n- 并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。\n\n  `（真正的同时运行）`\n\n\n\n## 7.2.  如何采用单线程的方式处理高并发\n\n（这里指主线程为单线程）\n\n在单线程模型中，可以采用`I/O复用`来提高单线程处理多个请求的能力\n\n- 采用事件驱动模型`（epoll?）`，基于异步回调来处理事件，当遇到非常耗时的IO操作时，采用非阻塞的方式，继续执行后面的代码，并且进入事件循环，当IO操作完成时，程序会被通知IO操作已经完成。\n\n- 协程的休眠和唤醒都是发生在用户态的，也就是说应用程序开发者要自己负责协程的休眠和唤醒。即，在向客户端发送请求以后（sendResult(0)），就会主动休眠(park)，一直到客户端把数据返回到服务端，再把协程唤醒(unpark)。\n\n- 这个程序的基础仍然是`I/O复用`，也就是说我们只在socket上有数据的时候，才会去把协程唤醒，让协程去读取数据。\n\n# 8.    内存\n\n## [Linux虚拟地址空间](https://zhuanlan.zhihu.com/p/96098896)\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322144514836.png\" alt=\"image-20220322144514836\" style=\"zoom:50%;\" />\n\n`为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏`，<u>也为了让物理内存扩充成更大的逻辑内存</u>，从而`让程序获得更多的可用内存`，<u>采用了虚拟内存</u>。\n\n>直接使用物理内存会产生一些问题\n>\n>1. 内存空间利用率的问题（内存==碎片==化）\n>2. 读写内存的安全性问题（访问==权限==问题）\n>3. 进程间的==安全==问题\n>4. 内存读写的==效率==问题\n\n- 虚拟内存技术使得不同进程在运行过程中，<u>它所看到的是自己独自占有了当前系统的4G内存</u>。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间`映射并存储`到物理内存上。\n-  <u>事实上，在每个进程创建加载时，内核`只是为进程“创建”了虚拟内存的布局`，具体就是`初始化`进程控制表中内存相关的`链表`，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的`映射`就好（叫做存储器映射）</u>，等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，`要动态分配内存`，比如malloc时，也`只是分配了虚拟内存`，即为这块虚拟内存对应的页表项做相应设置，`当进程真正访问到此数据时，才引发缺页异常`。\n\n- 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。\n\n  \n\n### **虚拟内存的好处：**\n\n1. `扩大`地址空间；\n\n   > 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。\n   >\n   > 从上面的描述中可以看出，<u>虚拟内存允许`程序不用将地址空间中的每一页都映射`到物理内</u>存，<u>也就是说一个`程序不需要全部调入内存`就可以运行</u>，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序\n\n2. 内存`保护`：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。 （==<u>互不干扰，防止进程互相恶意篡改</u>==）\n\n3. `公平`内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。  \n\n4. 当进程`通信`时，可采用`虚存共享`的方式实现。  （==<u>实现共享内存</u>==）\n\n5. 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，`节省内存`\n\n6. 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。<u>在内存中可以保留多个进程</u>，系统`并发度提高`\n\n7. 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以`利用碎片`\n\n    \n\n### **虚拟内存的代价：**\n\n1. 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的`内存`\n\n2. 虚拟地址到物理地址的转换，增加了指令的`执行时间`。\n\n3. 页面的换入换出需要`磁盘I/O`，这是很`耗时`的\n\n4. <u>如果一页中只有一部分数据，会浪费内存。</u>\n\n\n\n## 分页机制\n\n### 分页存储管理方式：\n\n将用户程序（进程）的 `逻辑地址` 空间分成若干个 `页` （4KB）并编号，同时将内存的 `物理地址` 也分成若干个 `块或页框` （4KB）并编号\n\n#### 目的：\n\n将进程的各个页`离散`地存储在内存的任一物理块中，使得从进程的角度看，认为它有一段`连续的内存`，进程总是从0号单元开始编址\n\n![image-20220418191706925](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418191706925.png)\n\n因此需要建立一个由页到页框的一一映射的关系，这就是`页表`\n\n![image-20220418191729182](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418191729182.png)\n\n系统会`为每一个进程建立一张页表`，进程执行时，通过查找进程自己的页表，找到每页在内存中的物理块号，从而保证每个进程都能正确运行\n\n由于页表实现了逻辑地址到物理地址的变换，执行的频率非常高，因此页表大多`驻留在内存中` ，且需要采用硬件实现。在系统中设置一个`页表寄存器（PTR）` ，在其中存放页表在内存中的`起始地址`和页表的`长度`，<u>平时页表始址和长度存放在各进程的`PCB`中</u>，当调度到某进程时，才将这两个数据装入页表寄存器中。\n\n#### 页表项结构：\n\n![image-20220418191754260](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418191754260.png)\n\n- 前20位即为块号，指示`物理内存中的块（也称页框）`\n- P - `存在（Present）标志`，用于指明表项对地址转换是否有效。P=1表示有效；P=0表示无效。在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。\n- R/W - `读/写（Read/Write）标志`。如果等于1，表示页面可以被读、写或执行。如果为0，表示页面只读或可执行。\n\n#### `理解`\n\n> 1. 逻辑地址分页 每页4KB 物理地址分块 每块4KB\n> 2. 需要实现逻辑地址到物理地址的映射关系，也就是页表 驻存在进程头部\n> 3. 页表中包含很多页表项，实现逻辑页->物理块的映射\n> 4. 通过页表寄存器PTR 存储当前进程页表的起始地址和长度，实现页表的快速定位\n\n#### 地址变换过程：\n\n1. 进程访问某个`逻辑地址`的数据\n2. 由逻辑地址的`页面号`3，以及`页表寄存器中的始址`，找到页表并找到对应的`页表项(3)`\n3. 由页表项上的==<u>块号</u>==，找到==<u>物理内存中的块号</u>==\n4. 由块号，加上逻辑地址的页内地址（==<u>偏移量</u>==），实现了对物理地址数据的定位\n5. 进程访问该逻辑地址对应的物理地址的数据\n\n![image-20220418194256850](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418194256850.png)\n\n由上可知，每存取一个数据，需`两次访问内存`，第一次访问内存中的页表，第二次访问内存中的数据，效率较低\n\n#### **改进**：\n\n增设一个具有并行查寻能力的`特殊高速缓冲寄存器`，称为“联想寄存器”或“快表”，IBM中称为TLB，用于存放当前访问的那些页表项\n\n==<u>（多了一个缓存）</u>==\n\n#### 改进后的地址变换过程：\n\n1. 进程访问某个逻辑地址的数据\n2. 由逻辑地址的页号(3)，先与高速缓冲寄存器中的所有页号比较，若匹配则直接读出块号，若不匹配则再由上面的2、3步骤执行\n3. 找到页表项后，将此页表项存入快表中，若快表已满，则系统找出一个认为不再需要的页表项将其换出\n4. 4，5步骤相同\n\n![image-20220418195948645](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418195948645.png)\n\n### 分级页表\n\n#### 原因：\n\nIA-32体系结构中，处理器为32位，可寻址=4GB的虚拟地址空间，若每页大小为4KB，则共分为4GB/4KB=220=1048576页，因此页表中应有1048576项，每个页表项为4B，则一个页表需要`4MB`的连续的物理内存，每个进程都需要自身的页表占4MB，将导致大量内存用于保存进程的页表\n\n> 1. 32条地址线 ，程序可以访问2^32^*1Byte=4GByte的虚拟地址空间，虚拟地址是按页分的，每页4KByte(2^12^), 所以需要页表项数为 ： 4GB/4KB页   (2^20^)\n> 2. 一个页表有很多的页表项 一个页表项大小4Byte\n> 3. 所以页表大小 = 页表项大小 * 所需要页表项数\n\nPS:80386处理器为32位，可寻址**4GB**逻辑地址，而当时物理内存只有**4MB**，采用单级页表明显不行\n\n**采用两级页表**：每页中存2^10^项，共分为2^10^页，并新增一个`页目录表`来记录这2^10^页表的地址与信息，因此页目录表大小为2^10^*4B=4KB放在内存中，需要具体的表再由此读入\n\n#### 解决方法：\n\n1、采用离散分配方式代替原来页表需要的连续物理内存\n\n2、将当前需要的部分页表项调入内存，其余页表项仍驻留在磁盘上，需要时再调入\n\n#### 两级页表：\n\n指向原页表项**逻辑地址**结构\n\n![image-20220418200252800](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200252800.png)\n\nPS：位移量W也称为页内地址 页大小4k 所以页内地址需要12位（2^12^=4k）\n\nVS\n\n指向两级页表项**逻辑地址**结构\n\n![image-20220418200305512](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200305512.png)\n\nPS:外层页号也称页目录表(**Directory**)，外层页内地址也称页表地址(**Table**)\n\n![image-20220418200357965](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200357965.png)\n\n与页表寄存器(PTR)相同，增设一个外层页表寄存器(CR3)，用于存放外层页表的地址\n\n#### 页目录项结构\n\n![image-20220418200412718](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200412718.png)\n\n与页表项结构类似。\n\n#### 分级后的地址变换过程：\n\n1、进程访问某个逻辑地址的数据\n\n2、由逻辑地址中的外层页号(Directory)，以及外层页表寄存器(CR3)中的外层页表始址，找到二级页表的始址\n\n3、由二级页表的始址，加上逻辑地址中的外层页内地址(Table)，找到对应的二级页表中的页表项\n\n4、由页表项中的物理块号，加上逻辑地址中的页内地址(偏移量)，实现了对物理地址数据的定位\n\n5、进程访问该逻辑地址对应的物理地址的数据\n\n![image-20220418200434286](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200434286.png)\n\n![image-20220418200453246](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220418200453246.png)\n\n以上分级解决了原来页表需要连续物理内存空间的问题，接下来解决用较少的内存空间去存放大页表的问题\n\n#### 解决方法：\n\n仅把当前需要的一批页表项调入内存，以后再根据需要陆续调入。因此**页目录表**常驻内存（大小为**4KB**，地址存在CR3寄存器中），而 **进程的页表**存于磁盘中，对于页表只需调入一页或几页。由页目录项中的P标记该页表是否在内存中，若不在则产生缺页异常，产生异常中断，请求系统将该页表调入内存\n\n## 分页系统地址映射\n\n内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。\n\n一个虚拟地址分成两个部分，一部分存储`页面号`，一部分存储`偏移量`。\n\n下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是`存储页面号` 2（0010），读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。\n\n![image-20220419105449130](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419105449130.png)\n\n由上可知，每存取一个数据，需`两次访问内存`，第一次访问内存中的页表，第二次访问内存中的数据，效率较低\n\n#### **改进**：\n\n增设一个具有并行查寻能力的`特殊高速缓冲寄存器`，称为“联想寄存器”或“快表”，IBM中称为TLB，用于存放当前访问的那些页表项\n\n==<u>（多了一个缓存）</u>==\n\n#### 改进后的地址变换过程：\n\n1. 进程访问某个逻辑地址的数据\n2. 由逻辑地址的页，先与高速缓冲寄存器中的所有页号比较，若匹配则直接读出块号，若不匹配则再由上面的之前步骤执行\n3. 找到页表项后，将此页表项存入快表中，若快表已满，则系统找出一个认为不再需要的页表项将其换出\n4. 后续步骤相同\n\n## 请你说一说操作系统中的`页表寻址`\n\n页式内存管理，内存分成固定长度的一个个页片。<u>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫`页表`，</u>页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。\n\n\n\n### Linux最初的两级页表机制：\n\n两级分页机制`将32位的虚拟空间分成三段`，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。 10 22  ->  10 10 12 \n\n- PGD(Page Global Directory): 最高10位，全局页目录表索引\n\n- PTE(Page Table Entry)：中间10位，页表入口索引\n\n1. 当在进行地址转换时，结合在CR3寄存器中存放的页目录(page directory, PGD)的这一页的物理地址，再加上从虚拟地址中抽出高10位叫做页目录表项(内核也称这为pgd)的部分作为偏移, 即定位到可以描述该地址的pgd；\n2. 从该pgd中可以获取可以描述该地址的页表的物理地址，再加上从虚拟地址中抽取中间10位作为偏移, 即定位到可以描述该地址的pte；\n3. 在这个pte中即可获取该地址对应的页的物理地址, 加上从虚拟地址中抽取的最后12位，即形成该页的页内偏移, 即可最终完成从虚拟地址到物理地址的转换。\n\n从上述过程中，可以看出，对虚拟地址的分级解析过程，实际上就是<u>不断深入页表层次</u>，<u>逐渐定位到最终地址的过程</u>，所以这一过程被叫做page talbe walk。\n\n\n\n### Linux的三级页表机制：\n\n当X86引入物理地址扩展(Pisycal Addrress Extension, PAE)后，可以支持大于4G的物理内存(36位），但虚拟地址依然是32位，原先的页表项不适用，它实际多4 bytes被扩充到8 bytes，这意味着，每一页现在能存放的pte数目从1024变成512了(4k/8)。相应地，页表层级发生了变化，Linus新增加了一个层级，叫做页中间目录(page middle directory, PMD), 变成：\n\n字段      描述            位数\n\ncr3      指向一个PDPT      crs寄存器存储\n\nPGD    指向PDPT中4个项中的一个  位31~30\n\nPMD    指向页目录中512项中的一个  位29~21\n\nPTE      指向页表中512项中的一个  位20~12\n\npage offset  4KB页中的偏移      位11~0\n\n\n\n\n\n2 - 9 - 9 - 12\n\n现在就同时存在2级页表和3级页表，在代码管理上肯定不方便。巧妙的是，Linux采取了一种抽象方法：所有架构全部使用3级页表: 即PGD -> PMD -> PTE。那只使用2级页表(如非PAE的X86)怎么办？\n\n办法是针对使用2级页表的架构，把PMD抽象掉，即虚设一个PMD表项。这样在page table walk过程中，PGD本直接指向PTE的，现在不了，指向一个虚拟的PMD，然后再由PMD指向PTE。这种抽象保持了代码结构的统一。\n\n\n\n### Linux的四级页表机制：\n\n硬件在发展，3级页表很快又捉襟见肘了，原因是64位CPU出现了, 比如X86_64， 它的硬件是实实在在支持4级页表的。它支持48位的虚拟地址空间1。如下：\n\n字段      描述            位数\n\nPML4    指向一个PDPT      位47~39\n\nPGD    指向PDPT中4个项中的一个  位38~30\n\nPMD    指向页目录中512项中的一个  位29~21\n\nPTE      指向页表中512项中的一个  位20~12\n\npage offset  4KB页中的偏移      位11~0\n\n\n\nLinux内核针为使用原来的3级列表(PGD->PMD->PTE)，做了折衷。即采用一个唯一的，共享的顶级层次，叫PML4。这个PML4没有编码在地址中，这样就能套用原来的3级列表方案了。不过代价就是，由于只有唯一的PML4, 寻址空间被局限在(239=)512G, 而本来PML4段有9位, 可以支持512个PML4表项的。现在为了使用3级列表方案，只能限制使用一个， 512G的空间很快就又不够用了，解决方案呼之欲出。\n\n在2004年10月，当时的X86_64架构代码的维护者Andi Kleen提交了一个叫做4level page tables for Linux的PATCH系列，为Linux内核带来了4级页表的支持。在他的解决方案中，不出意料地，按照X86_64规范，新增了一个PML4的层级, 在这种解决方案中，X86_64拥一个有512条目的PML4, 512条目的PGD, 512条目的PMD, 512条目的PTE。对于仍使用3级目录的架构来说，它们依然拥有一个虚拟的PML4,相关的代码会在编译时被优化掉。 这样，就把Linux内核的3级列表扩充为4级列表。这系列PATCH工作得不错，不久被纳入Andrew Morton的-mm树接受测试。不出意外的话，它将在v2.6.11版本中释出。但是，另一个知名开发者Nick Piggin提出了一些看法，他认为Andi的Patch很不错，不过他认为最好还是把PGD作为第一级目录，把新增加的层次放在中间，并给出了他自己的Patch:alternate 4-level page tables patches。Andi更想保持自己的PATCH, 他认为Nick不过是玩了改名的游戏，而且他的PATCH经过测试很稳定，快被合并到主线了，不宜再折腾。不过Linus却表达了对Nick Piggin的支持，理由是Nick的做法conceptually least intrusive。毕竟作为Linux的扛把子，稳定对于Linus来说意义重大。最终，不意外地，最后Nick Piggin的PATCH在v2.6.11版本中被合并入主线。在这种方案中，4级页表分别是：PGD -> PUD -> PMD -> PTE。\n\n## 分段\n\n虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。\n\n下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。\n\n![image-20220419112236355](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419112236355.png)\n\n\n\n分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。\n\n![image-20220419112249178](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419112249178.png)\n\n\n\n## 段页式\n\n程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。\n\n## 分页与分段的比较\n\n- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。\n- 地址空间的维度：分页是一维地址空间，分段是二维的。\n- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。\n- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。\n\n## 操作系统中的程序的`内存结构`\n\n\n![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)\n\n#### 一个程序本质上（没有调入内存）时都是由`BSS段`、`data段`、`text段`三个组成的。\n\n> - `代码段 text`：存放程序执行代码的一块内存区域。<u>这部分区域的大小在程序运行前就已经确定</u>，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量 `（包括文本区和只读数据区）`\n> - `数据段 data`：存放程序中==<u>已初始化</u>==的`全局变量`的一块内存区域。<u>数据段属于`静态内存`分配</u>\n> - `未初始化数据区 bss`：通常用来存放程序中`未初始化的全局变量和静态变量`的一块内存区域。BSS段属于`静态分配`，<u>程序结束后静态变量资源由系统自动释放。</u>\n>\n\ntext段和data段在编译时已经分配了空间，而`BSS段并不占用可执行文件的大小`，它是由`链接器来获取内存`的。\n\nbss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有`正文段`和`初始化数据段`。  \n\ndata段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。\n\n数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存<u>进入程序的地址空间后全部清零</u>。包含数据段和BSS段的整个区段此时通常称为==<u>数据区</u>==。\n\n#### <u>可执行程序在运行时又多出两个区域</u>：<u>==栈区==和==堆区==</u>。\n\n==栈区==：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块`连续`的内存区域，最大容量是由系统`预先定义`好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。\n\n==堆区==：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。`堆是从低地址位向高地址位增长，采用链式存储结构`。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的`效率`比栈要`低`的多。\n\n \n\n## [为什么堆栈生长方向不一样](https://blog.csdn.net/unix21/article/details/8531875)\n\n### **历史原因**\n\n- 在没有内存管理单元MMU的时代，`为了最大的利用内存空间`，堆和栈被设计为从`两端相向生长`。那么哪一个向上，哪一个向下呢？\n  1. 人们对数据访问是习惯于向上的，比如你在堆中new一个数组，是习惯于把低元素放到低地址，把高位放到高地址，所以`堆向上生长比较符合习惯`\n  2. `栈则对方向不敏感`，一般对栈的操作只有PUSH和POP，无所谓向上向下，所以就把堆放在了低端，把栈放在了高端。MMU出来后就无所谓了，只不过也没必要改了。\n\n### 内存管理单元 MMU\n\n**内存管理单元**（英语：**memory management unit**，缩写为**MMU**），有时称作**分页内存管理单元**（英语：**paged memory management unit**，缩写为**PMMU**）。它是一种负责处理[中央处理器](https://zh.m.wikipedia.org/wiki/中央处理器)（CPU）的[内存](https://zh.m.wikipedia.org/wiki/内存)访问请求的[计算机硬件](https://zh.m.wikipedia.org/wiki/计算机硬件)。它的功能包括[虚拟地址](https://zh.m.wikipedia.org/wiki/虚拟地址)到[物理地址](https://zh.m.wikipedia.org/wiki/物理地址)的转换（即[虚拟内存](https://zh.m.wikipedia.org/wiki/虚拟内存)管理）[[1\\]](https://zh.m.wikipedia.org/zh-hans/内存管理单元#cite_note-1)、[内存保护](https://zh.m.wikipedia.org/wiki/内存保护)、中央处理器[高速缓存](https://zh.m.wikipedia.org/wiki/高速缓存)的控制，在较为简单的计算机体系结构中，负责[总线](https://zh.m.wikipedia.org/wiki/总线)的[仲裁](https://zh.m.wikipedia.org/w/index.php?title=仲裁_(电子器件)&action=edit&redlink=1)以及[存储体切换](https://zh.m.wikipedia.org/w/index.php?title=存储体切换&action=edit&redlink=1)（bank switching，尤其是在[8位](https://zh.m.wikipedia.org/wiki/8位)的系统上）\n\n> 实现虚拟地址到物理地址的页表寻址过程，实现虚拟内存映射\n\n## 文件描述符\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220322145240288.png\" alt=\"image-20220322145240288\" style=\"zoom: 50%;\" />\n\n- 每一个`进程控制块pcb中包含一个 默认大小为1024的文件描述符表`（前三个指向设备终端的默认文件），所以每一个进程默认最多打开1024个文件 \n- 同一个文件可以重复打开 则在文件描述符表中 占多个位置 直到调用fclose释放\n\n## A* a = new A; a->i = 10;在内核中的内存分配上发生了什么？\n\nA* a = new A; a->i = 10：\n\n1）A *a：a是一个局部变量，类型为指针，故而操作系统在程序`栈区`开辟4/8字节的空间（0x000m），分配给指针a。==（栈区指针8字节）==\n\n2）new A：`通过new动态的在堆区申请类A大小的空间`（0x000n）。 ==（new在堆上分配A空间）==\n\n3）a = new A：将指针a的<u>内存区域填入栈中类A申请到的地址的地址</u>。即*（0x000m）=0x000n。 ==（指针指向A地址）==\n\n4）==a->i==：先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a->i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。  ==（栈->堆->偏移->赋值）==\n\n \n\n## 8.5.  静态变量什么时候初始化\n\n静态变量存储在虚拟地址空间的数据段和bss段，`C语言`中其在代码执行之前初始化，属于`编译期初始化`。\n\n而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定\n\n**全局或静态对象是有首次用到时才会进行构造，即：**\n\n==全局变量,总是在main函数运行之前初始化==\n\n==局部静态对象当且仅当对象首次用到时进行构造==\n\n## 8.6.  一个类，里面有static，virtual，之类的，来说一说这个类的内存分布\n\n**static修饰符**\n\n1. static修饰成员变量\n\n- <u>对于非静态数据成员，每个类对象都有自己的拷贝</u>。而<u>静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝</u>，`为该类型的所有对象所共享(包括其派生类)`。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。\n\n- 因为静态数据成员在==全局数据区==分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。\n\n2. static修饰成员函数\n\n- 与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此==它不具有this指针==。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。\n\n3. static修饰的成员函数，在==代码区==分配内存。\n\n**C++继承和虚函数**\n\n- C++多态分为静态多态和动态多态。\n\n  > 静态多态是通过<u>重载</u>和<u>模板</u>技术实现，在==编译==的时候确定。\n  >\n  > 动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。\n\n- 动态多态实现有几个条件：\n\n  >  虚函数；\n  >\n  >  一个基类的指针或引用指向派生类的对象；\n\n- 基类指针在调用成员函数(虚函数)时，就会去<u>查找该对象的虚函数表</u>。虚函数表的地址在每个对象的首地址。<u>查找该虚函数表中该函数的指针进行调用</u>。\n\n- 每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。\n\n- 虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，<u>如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</u>\n\n**virtual修饰符**\n\n- 如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。\n\n- 如果该类是virutal继承而来的子类，则该类的`虚函数表指针`==和该类其他成员一起存储==。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。\n\n- 如果类中成员是virtual属性，会隐藏父类对应的属性。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20220305213755495-1587408473.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n## 8.7.  内存溢出和内存泄漏\n\n### 内存溢出\n\n指程序申请内存时，没有足够的内存供申请者使用。内存溢出`就是你要的内存空间超过了系统实际分配给你的空间`，此时系统相当于没法满足你的需求，就会报内存溢出的错误\n\n内存溢出原因：\n\n1. 内存中加载的==数据量过于庞大==，如一次从数据库取出过多数据\n\n2. 递归调用层次太多。==递归==函数在运行时会执行==压栈==操作，当压栈次数太多时，也会导致堆栈溢出。\n\n3. 集合类中有对对象的引用，使用完后==未清空==，使得不能回收\n\n4. 代码中存在死循环或==循环==产生过多重复的对象实体\n5. ==指针或数组越界==。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。\n\n### 内存泄漏\n\n内存泄漏是指由于疏忽或错误造成了`程序未能释放掉不再使用的内存`的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。\n\n内存泄漏的分类：\n\n1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。  ==（堆上内存没有被释放）==\n\n2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。  ==（分配的资源未释放）==\n\n3. ==没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。==  \n\n   > （在公有继承中,基类对派生类及其对象的操作,只能影响到那些从基类继承下来的成员.如果想要用基类对非继承成员进行操作,则要把基类的这个函数定义为虚函数.）\n\n \n\n## 8.8.  为什么要有page cache，操作系统怎么设计的page cache\n\n**Page cache（页面缓存）**\n\n> Page cache 也叫页缓冲或文件缓冲，是由好几个磁盘块构成，大小通常为4k，在64位系统上为8k，构成的几个磁盘块在物理磁盘上不一定连续，文件的组织单位为一页， 也就是一个page cache大小，文件读取是由外存上不连续的几个磁盘块，到buffer cache，然后组成page cache，然后供给应用程序。\n>\n> Page cache在linux读写文件时，它用于`缓存文件的逻辑内容`，从而`加快对磁盘上映像和数据的访问`。具体说是加速对文件内容的访问，buffer cache缓存文件的具体内容——物理磁盘上的磁盘块，这是加速对磁盘的访问。\n\n- CPU如果要访问外部磁盘上的文件，需要首先将这些文件的内容拷贝到内存中，**由于硬件的限制，从磁盘到内存的数据传输速度是很慢的**，<u>如果现在物理内存有空余，干嘛不用这些空闲内存来缓存一些磁盘的文件内容呢</u>，这部分用作缓存磁盘文件的内存就叫做page cache。\n\n- page cache中有一部分磁盘文件的缓存，`因为从磁盘中读取文件比较慢，所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。`在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache项，一个是radix tree（基数树），另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数据结构来通过文件内偏移快速定位Cache 项\n\n- radix tree（基数树）其实就差不多是传统的二叉树，只是在寻找方式上，利用比如一个unsigned int的类型的每一个比特位作为树节点的判断。\n\n![img](https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220304010427367-928071720.png)\n\n## 8.9.  ？逻辑地址、虚拟地址、物理地址\n\n- 物理地址：加载到内存地址寄存器中的地址，==内存单元的真正地址==。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。\n\n- 逻辑地址：由程序产生的与段相关的==偏移地址部分==，`编程中使用的地址`（在非虚拟内存的情况下给一个进程分配一段内存空间）。\n\n- 虚拟内存：虚拟[内存](https://baike.baidu.com/item/内存)是[计算机系统](https://baike.baidu.com/item/计算机系统/7210959)[内存管理](https://baike.baidu.com/item/内存管理/5633616)的一种技术。它使得==[应用程序](https://baike.baidu.com/item/应用程序/5985445)认为==它拥有==连续的可用的==[内存](https://baike.baidu.com/item/内存/103614)（一个连续完整的[地址空间](https://baike.baidu.com/item/地址空间/1423980)），而==实际==上，它通常是被分隔成==多个[物理内存](https://baike.baidu.com/item/物理内存/2502263)碎片==，还有==部分暂时存储在外部[磁盘存储器](https://baike.baidu.com/item/磁盘存储器/2386684)==上，在需要时进行[数据交换](https://baike.baidu.com/item/数据交换/1586256)。\n\n  > 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的 虚拟内存的实际容量 = min（内存和外存容量之和，CPU寻址范围）\n  >\n  > 如：某计算机地址结构为32位，按字节编址，内存大小位512MB，外存大小为2GB，则虚拟内存的最大容量为4GB.(2的32次方B)\n  >\n  > 32位CPU一般有32根地址总线，那么就一共可以寻2^32^个地址=也就是4x1024x1024x1024=4G个地址，1个地址对应1字节的存储单位，对应到内存上就是4GB（4GByte）\n\n\n\n\n\n## 8.10.[ 虚拟内存](https://zhuanlan.zhihu.com/p/96098896)和物理内存怎么对应\n\n### 8.10.1.   页式管理\n\n通过页号在页表中查询对应的内存块号，得到内存块起始地址，再加上偏移地址得到物理地址。\n\n![img](https://img2022.cnblogs.com/blog/2092994/202203/2092994-20220304010542498-1068777910.png)\n\n \n\n### 8.10.2.   段页式挂管理\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220426112120985.png\" alt=\"image-20220426112120985\" style=\"zoom:80%;\" />\n\n### 8.10.3.   快表的使用/高速缓存（cache）\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220426112152511.png\" alt=\"image-20220426112152511\" style=\"zoom:150%;\" />\n\n \n\n### 8.10.4.   请求分页式管理（虚拟内存）\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220426112305082.png\" alt=\"image-20220426112305082\" style=\"zoom: 80%;\" />\n\n## 8.11. OS缺页置换算法\n\n当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：\n\n1. `先进先出(FIFO)算法`：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。  ==（那最早调入的替换掉）==\n\n2. `最近最少使用（LRU）算法`: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。  ==（替换最长时间没有使用的页面）==\n\n3. 最佳置换算法（OPT）算法：最佳置换算法是由 **Belady** 于1966年提出的一种理论上的算法。`每次选择以后永不使用的`， 或许是在最长(未来)时间内不再被访问的页面的页面被淘汰。显然OPT算法是`最优`的，但是在实际操作往往无法预知未来，所以OPT只存在理论而`不能真的实现`，通常用于衡量其他置换算法的优劣。\n\n4. 时钟置换（Clock/NRU）算法：也称为NRU算法（最近未使用算法）是LRU和FIFO的折中算法。\n\n   > ##### **为什么需要 clock 算法？**\n   >\n   > LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。\n   >\n   > 所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。\n   >\n   > 由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。\n   >\n   > ##### **基本思路**\n   >\n   > 需要用到页表项的访问位（access bit），当一个页面被装入内存时，把该位初始化为0，然后如果这个页被访问（读/写）时，硬件把它置为1. 把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）；\n   >\n   > 当发生一个缺页中断，考察指针所指向的最老的页面，若它的访问为为0，则立即淘汰。若访问为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。\n\n当前最常采用的就是LRU算法。\n\n## 页面置换算法\n\n在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。\n\n页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。\n\n页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。\n\n### 1. 最佳\n\n> OPT, <u>Optimal replacement algorithm</u>\n\n所选择的被换出的页面将是<u>最长时间内不再被访问</u>，通常可以保证获得最低的缺页率。\n\n是一种`理论上`的算法，因为无法知道一个页面多长时间不再被访问。\n\n举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：\n\n```\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1\n```\n\n开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。\n\n### 2. 最近最久未使用\n\n> LRU, <u>Least Recently Used</u>\n\n虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将`最近最久未使用`的页面换出。\n\n为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。\n\n因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。\n\n```\n4，7，0，7，1，0，1，2，1，2，6\n```\n\n![image-20220419103701394](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419103701394.png)\n\n#### LRU的实现\n\n```c++\nstruct DLinkedNode{\n    int key, value; //k是为了溯源 hash中删除key\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode():key(0), value(0), prev(nullptr), next(nullptr){}\n    DLinkedNode(int _key, int _value):key(_key),value(_value),prev(nullptr),next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    //虚拟头 虚拟尾\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity):capacity(_capacity), size(0) {\n        //使用虚拟头 和 虚拟尾节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if(!cache.count(key)){\n            return -1;\n        }\n        //如果key存在 先通过哈希定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(!cache.count(key)){\n            //如果key不存在 创建一个新节点\n            DLinkedNode* node  = new DLinkedNode(key, value);\n            cache[key] = node;\n            addToHead(node);\n            size++;\n            if(size>capacity){\n                //超出容量 删除尾部节点\n                DLinkedNode* removed = removeTail();\n                cache.erase(removed->key);\n                delete removed;\n                --size;\n            }\n        }else{\n            //如果key存在 先哈希定位 再修改val 在移动头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    //头部插入新节点\n    void addToHead(DLinkedNode* node){\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    //删除某个节点\n    void removeNode(DLinkedNode* node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    //移动到头部\n    void moveToHead(DLinkedNode* node){\n        removeNode(node);\n        addToHead(node);\n    }\n    //删除尾部节点\n    DLinkedNode* removeTail(){\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```\n\n###  3. 最近未使用\n\n> NRU, <u>Not Recently Used</u>\n\n每个页面都有两个状态位：R 与 M，当页面被`访问`(使用)时设置页面的 R=1，当页面被`修改`时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：\n\n- R=0，M=0\n- R=0，M=1\n- R=1，M=0\n- R=1，M=1\n\n当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。\n\nNRU 优先换出已经被修改的脏页面`（R=0，M=1）`，而不是被频繁使用的干净页面（R=1，M=0）。\n\nNRU 优先换出 RM 小的页面：00 < 01 < 10 < 11；因此已经被修改的脏页面（R=0，M=1）相比被频繁使用的干净页面（R=1，M=0），更优先被换出。\n\n### 4. 先进先出\n\n> FIFO, First In First Out\n\n选择换出的页面是最先进入的页面。\n\n<u>该算法`会将那些经常被访问的页面换出`，导致缺页率升高。</u>\n\n### 5. 第二次机会算法\n\nFIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：\n\n当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。\n\n- 如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；\n\n- 如果是 1，就将 R 位清 0，并把该页面放到链表的尾端（`再来一圈，再给你一次机会`），修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。\n\n![image-20220419103528188](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419103528188.png)\n\n\n\n### 6. 时钟 Clock\n\n第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。\n\n![image-20220419103605224](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220419103605224.png)\n\n\n\n## 8.12. CPU内存的寻址能力？\n\n（CPU寻址范围是2的N次方字节，即2^N^(B)。）\n\n## 8.13.  CPU寻址了解吗?为什么需要虚拟地址空间?\n\n现代处理器使用的是- -种称为虚拟寻址(Virtual Addressing) 的寻址方式。使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址\n\n转换的硬件是CPU中含有一个被称为内存管理单元(Memory Management Unit, MMU) 的硬件。\n\n \n\n**为什么要有虚拟地址空间呢？**\n\n没有虚拟地址空间的时候， 程序都是直接访问和操作的都是物理内存 。\n\n如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。\n\n>直接使用物理内存会产生一些问题\n>\n>1. 内存空间利用率的问题 （内存碎片化）\n>2. 读写内存的安全性问题（访问权限问题）\n>3. 进程间的安全问题\n>4. 内存读写的效率问题\n\n `为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏`，<u>采用了虚拟内存</u>。\n\n**通过虚拟地址访问内存有以下优势：**\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n\n- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页(通常大小为4 KB) 保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n\n- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n  \n\n# 9.    用户态和内核态\n\n## 9.1.  用户态和内核态区别\n\n内核态：`cpu可以访问内存的所有数据`，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。\n\n用户态：`只能受限的访问内存`，且`不允许访问外围设备`，`占用cpu的能力被剥夺`，cpu资源可以被其他程序获取。\n\n \n\n内核从本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。\n\n用户态和内核态是操作系统的两种运行级别，两者最大的区别就是==<u>特权级不同</u>==。\n\n> 用户态拥有`最低`的特权级，内核态拥有`较高`的特权级。\n>\n> 运行在用户态的程序不能直接访问操作系统内核数据结构和程序。\n\n#### 内核态和用户态之间的转换方式主要包括：`系统调用`，`异常`和`中断`。\n\n- 系统调用\n\n  > 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。\n\n- 中断\n\n  > 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\n\n- 异常\n\n  > 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。\n\n1. 当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。\n\n2. 系统调用`实质`就是<u>通</u><u>过指令产生中断</u>，称为<u>软中断</u>。\n\n3. 进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，<u>此时进程陷入内核态</u>，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中，然后设置堆栈指针寄存器的地址为内核栈地址，这样就完成了用户栈向内核栈的切换。\n4. 当进程从内核态切换到用户态时，最后把保存在内核栈中的用户栈地址恢复到CPU栈指针寄存器即可，这样就完成了内核栈向用户栈的切换。\n\n## 9.2.  操作系统为什么要分内核态和用户态\n\n为了`安全性`。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行这些操作。  ==<u>(为了安全别把操作系统干废了)</u>==\n\n由于`需要限制不同的程序之间的访问能力`, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。   ==<u>（程序权限过大，干扰其他）</u>==\n\n> 假设没有这种内核态和用户态之分，程序随随便就能访问<u>硬件资源</u>，比如<u>分配内存</u>，程序能随便读写所有的内存空间，如果程序员不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。\n> 用户程序是不可信的，不管程序员有意还是无意，都容易将系统==<u>干到崩溃</u>==。\n\n## 9.3. ？用户态到内核态的转化原理\n\n### 用户态到内核态的转化原理\n\n#### 1. 用户态切换到内核态的3种方式\n\n- 系统调用\n\n  > 这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。\n  >\n  > Linux 在x86上的系统调用通过 int 80h 实现，用[系统调用号](https://zh.m.wikipedia.org/w/index.php?title=系统调用号&action=edit&redlink=1)来区分入口函数。操作系统实现系统调用的基本过程是：\n  >\n  > 1. 应用程序调用库函数（API）；\n  > 2. API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；\n  > 3. 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；\n  > 4. 系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；\n  > 5. 中断处理函数返回到 API 中；\n  > 6. API 将 EAX 返回给应用程序。\n  >\n  > 应用程序调用系统调用的过程是：\n  >\n  > 1. 把系统调用的编号存入 EAX；\n  > 2. 把函数参数存入其它通用寄存器；\n  > 3. 触发 0x80 号中断（int 0x80）。\n\n- 异常\n\n  > 当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。\n\n- 外围设备的中断\n\n  > 当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。\n\n#### 2. 切换操作\n\n线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换。（**“用户态与内核态的切换”具体带来什么成本？？？**）\n\n从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的`切换操作上来说，涉及的关键步骤是完全一样的`，没有任何区别，都相当于执行了一个中断响应的过程，因为<u>系统调用实际上最终是`中断机制`实现的</u>，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：\n\n- 从当前进程的描述符中提取其内核栈的ss0及esp0信息。\n- 使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。\n- 将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。\n\n#### 3. 在Linux中，上下文切换，进程切换和线程切换之间有什么区别？\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220315112359560.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n上下文切换涉及存储进程或线程的上下文或状态，以便可以在需要时重新加载它，并可以执行\n\n从先前的相同点恢复。这是多任务操作系统的功能，并且允许单个CPU由多个进程共享。\n\n进程切换或进程调度是通过保存当前正在执行的进程的所有状态（包括其寄存器状态，关联的内核状态及其所有虚拟内存配置）来将一个进程更改为另一个进程。\n\n线程切换是指在进程中从一个线程切换到另一个线程。\n\n进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。\n\n因此，在进程之间进行切换的成本比在线程之间进行切换的成本高得多。\n\n> 举一个不太恰当的例子，<u>线程切换就好比你从`主卧走到次卧`，反正主卧和次卧都在同一个房子中(`虚拟地址空间`)，因此你无需换鞋子、换衣服等等。</u>但是<u>进程切换就不一样了，进程切换就好比从`你家到别人家`，这是两个不同的房子`(不同的虚拟地址空间`)，出发时要换好衣服、鞋子等等，到别人家后还要再换鞋子等等。</u>\n>\n> 因此我们可以形象的认为线程是处在同一个屋檐下的，这里的屋檐就是虚拟地址空间，因此线程间切换无需虚拟地址空间的切换；而进程则不同，两个不同进程位于不同的屋檐下，即进程位于不同的虚拟地址空间，因此进程切换涉及到虚拟地址空间的切换，这也是为什么进程切换要比线程切换慢的原因。\n\n#### 4. 为什么虚拟地址切换很慢\n\n现在我们已经知道了进程都有自己的虚拟地址空间，把==虚拟地址转换为物理地址需要查找页表==，`页表查找是一个很慢的过程`，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是==TLB==，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，==页表切换后TLB就失效==了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而==线程切换则不会导致TLB失效==，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。\n\n \n\n## 9.4.  系统调用是什么，你用过哪些系统调用\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203112205908.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n1. 概念：\n\n   - 在计算机中，系统调用（英语：system call），又称为<u>系统呼叫</u>，指<u>运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务</u>。系统调用`提供了用户程序与操作系统之间的接口`（即==系统调用是用户程序和内核交互的接口==）。\n\n   - 操作系统中的状态分为管态（`核心态`）和目态（`用户态`）。\n\n     > <u>大多数系统`交互式`操作需求在`内核`态执行</u>。如设备IO操作或者进程间通信。\n     >\n     > 特权指令：一类==只能在核心态==下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说<u>主要是和`硬件`相关的一些指令</u>。\n     >\n     > 用户程序只在用户态下运行，<u>有时需要访问系统核心功能，这时通过`系统调用接口`使用系统调用</u>。\n\n   - 应用程序<u>有时会需要一些危险的、权限很高的指令</u>，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，<u>所有的资源都由操作系统控制，进程只能向操作系统请求这些资源</u>。`操作系统是这些资源的唯一入口，这个入口就是系统调用`。\n\n2. 系统调用举例：\n\n   <u>对文件进行写操作</u>，程序向打开的文件写入字符串“hello world”，<u>open和write都是系统调用</u>。还有写数据write，创建进程<u>fork，vfork</u>等都是系统调用。**用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。**\n\n   ## 库函数\n\n- `调用库函数是为了使用系统调用`。linux几乎库函数和系统调用一一对应。windows则不然。\n\n- 从宏观上说，`系统调用时内核层，C标准库在应用层`。\n\n- 从细节上来说，`库函数的实现方式，一般都是对系统调用的再次封装`，在linux中，C标准基本是对系统调用的包装\n\n  > 例如我们常见的printf，putc，fwrite等等，其实去看源码可以发现内部都有使用系统调用write函数，相似的例子还有很多，例如文件描述符filefd，与FILE的关系，FILE是一个struct，内部其实封装了filefd，同时包括一个buffer用于缓冲...\n\n## 9.5.  请介绍一下操作系统中的中断\n\n中断是指CPU对系统发生的某个事件做出的一种反应，`CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。`\n\n### 中断一般三类。\n\n> 1. 一种是由==CPU外部==引起的，如I/O中断、时钟中断，\n>\n> 2. 一种是来自==CPU内部事件==或==程序执行中引起的中断==，例如程序非法操作，地址越界、浮点溢出，\n>\n> 3. 最后一种是在程序中使用了==系统调用==引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。\n\n## 9.6.  操作系统中的缺页中断\n\nmalloc()和mmap()等内存分配函数，<u>在分配时`只是建立了进程虚拟地址空间`</u>，<u>并`没有`分配虚拟内存对应的`物理内存`</u>。<u>当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</u>。  \n\n> ==<u>（分配了虚拟的地址空间 但没有分配映射到物理内存，访问时会缺页异常）</u>==\n\n**缺页中断：**在请求分页系统中，可以<u>通过查询页表中的`状态位`来确定所要访问的`页面是否存在于内存`中</u>。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。\n\n缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：\n\n> 1、保护CPU现场\n>\n> 2、分析中断原因\n>\n> 3、转入缺页中断处理程序进行处理\n>\n> 4、恢复CPU现场，继续执行\n\n但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：\n\n> 1、<u>在指令执行期间产生和处理缺页中断信号</u>\n>\n> 2、<u>一条指令在执行期间，可能产生多次缺页中断</u>\n>\n> 3、<u>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</u>。\n\n# 10.  其他\n\n## 10.1. windows消息机制知道吗，请说一说\n\n当用户有操作(鼠标，键盘等)时，系统会将这些事件转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。\n\n####  一、那么消息究竟是What 嘞？\n\n消息系统对于一个win32程序来说十分重要，它是一个程序运行的动力源泉。一个消息，是系统定义的一个32位的值，他唯一的定义了一个事件，向 Windows发出一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序的消息队列（下面会讲到）中，然后应用程序再从消息队列中取出消息并进行相应的响应。在这个处理的过程中，操作系统也会给应用程序“发送消息”，而所谓的发送消息--------实际上就是操作系统调用程序中的一个专门负责处理消息的函数，这个函数称为窗口过程。\n\n​    **消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息**。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做MSG，MSG含有来自windows应用程序消息队列的消息信息，在Windows中MSG结构体定义如下：\n\n```c++\ntypedef struct tagMsg{\n  HWND  hwnd;       //接受该消息的窗口句柄\n  UINT  message;     //消息常量标识符，也就是我们通常所说的消息号\n  WPARAM wParam;   //32位消息的特定附加信息，确切含义依赖于消息值\n  LPARAM lParam;     //32位消息的特定附加信息，确切含义依赖于消息值\n  DWORD  time;       //消息创建时的时间\n  POINT  pt;          //消息创建时的鼠标/光标在屏幕坐标系中的位置\n}MSG;\n```\n\n#### **二、What  is消息队列？**\n\n在Windows编程中，每一个Windows应用程序开始执行后，<u>系统都会为该程序创建一个消息队列</u>，这个消息队列<u>用来存放该应用程序所创建的窗口的信息</u>。例如，当我们按下鼠标右键的时候，这时会产生一个WM_RBUTTONDOWN消息，系统会自动将这个消息放进当前窗口所属的应用程序的消息队列中，等待应用程序的结束。Windows将产生的消息以此放进消息队列中，<u>应用程序则通过一个消息循环不断的从该消息队列中读取消息，并做出响应</u>（后面会详细讲述消息处理过程。。。。）\n\n \n\n#### **三、消息中的家庭成员？**\n\n​    通过前面所罗列的MSG结构体，我们是不是会对消息结构里边含有的东东有了一个比较清楚的认识呢？如果还没有，没关系！！呵呵，那么我再次对那些咋一看就会泪奔的变量做出详细的解释：\n\n​    hwnd - - - 一个32位的窗口句柄（我的PC是32 位的^_^），它表示的是消息所属的窗口。我们通常开发的程序都是窗口应用程序，一般一个消息都是和某个窗口相关联的。比如我们在某个活动窗口按下鼠标右键，此时产生的消息就是发送给该活动窗口的。窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄(窗口、对话框、按钮、编辑框等)。\n\n（补充一下：“句柄”---在Windows程序中，有各种各样的资源，系统在创建这些资源的时候，都会为他们分配内存，并返回标识这些资源的标识号，这个标识号就是句柄）\n\n​    message- - - -一个消息的标识符，用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量。在Windows中消息是由一个数值表示的，不同的消息对应不同的数值。但由于当这些消息种类多到足以挑战我们的IQ，所以聪明的程序开发者便想到将这些数值定义为WM_XXX宏的形式。例如，鼠标左键按下的消息--WM_LBUTTONDOWN，键盘按下消息--WM_KEYDOWN，字符消息--WM_CHAR，等等。。。。消息标识符以常量命名的方式指出消息的含义。当窗口过程接收到消息之后，他就会使用消息标识符来决定如何处理消息。例如、WM_PAINT告诉窗口过程窗体客户区被改变了需要重绘。符号常量指定系统消息属于的类别，其前缀指明了处理解释消息的窗体的类型。\n\n​    wParam和lParam- - - 用于指定消息的附加信息。例如，当我们收到一个键盘按下消息的时候，message成员变量的值就是WM_KEYDOWN，但是用户到底按下的是哪一个按键，我们就得拜托这二位，由他们来告知我们具体的信息。\n\ntime和pt- - -这俩兄弟分别被用来表示消息投递到消息队列中的时间和鼠标当前的位置，一般情况下不怎么使用（但不代表没用）\n\n \n\n#### **四、see see 消息标识符**\n\n系统保留消息标识符的值在0x0000在0x03ff(WM_USER-1)范围。这些值被系统定义消息使用。应用程序不能使用这些值给自己的消息。应用程序消息从WM_USER（0X0400）到0X7FFF，或0XC000到0XFFFF；WM_USER到 0X7FFF范围的消息由应用程序自己使用；0XC000到0XFFFF范围的消息用来和其他应用程序通信，在此只是罗列一些具有标志性的消息值：\n\n> WM_NULL---0x0000  空消息\t0x0001----0x0087  主要是窗口消息。\n>\n> 0x00A0----0x00A9  非客户区消息\t0x0100----0x0108  键盘消息\n>\n> 0x0111----0x0126  菜单消息\t0x0132----0x0138  颜色控制消息\n>\n> 0x0200----0x020A  鼠标消息\t0x0211----0x0213  菜单循环消息\n>\n> 0x0220----0x0230  多文档消息\t0x03E0----0x03E8  DDE消息\n>\n> 0x0400       WM_USER\t0x8000       WM_APP\n>\n> 0x0400----0x7FFF  应用程序自定义私有消息\n\n \n\n#### **五、原来消息也有分类啊**\n\nwindows中的消息虽然很多，但是种类并不繁杂，大体上有3种： `窗口`消息、 `命令`消息、 `控件通知`消息。\n\n> 1. 窗口消息- - - -大概是系统中最为常见的消息，它是指由操作系统和控制其他窗口的窗口所使用的消息。例如CreateWindow、DestroyWindow和MoveWindow等都会激发窗口消息，还有我们在上面谈到的单击鼠标所产生的消息也是一种窗口消息。\n>\n> 2. 命令消息- - - - 这是一种特殊的窗口消息，他用来处理从一个窗口发送到另一个窗口的用户请求，例如按下一个按钮，他就会向主窗口发送一个命令消息。\n>\n> 3. 控件通知消息- - - 其实它是这样滴，当一个窗口内的子控件发生了一些事情，而这些是需要通知父窗口的，此刻它就上场啦。通知消息只适用于标准的窗口控件如按钮、列表框、组合框、编辑框，以及Windows公共控件如树状视图、列表视图等。\n\n例如，单击或双击一个控件、在控件中选择部分文本、操作控件的滚动条都会产生通知消息-------她类似于命令消息，那么控件通知消息就会从控件窗口发送到它的主窗口。但是这种消息的存在并不是为了处理用户命令，而是为了让主窗口能够改变控件，例如加载、显示数据。\n\n再例如，按下一个按钮，他向父窗口发送的消息也可以看作是一个控件通知消息；单击鼠标所产生的消息可以由主窗口直接处理，然后交给控件窗口处理。其中窗口消息及控件通知消息主要由窗口类即直接或间接由CWND类派生类处理。相对窗口消息及控件通知消息而言，命令消息的处理对象范围就广得多，它不仅可以由窗口类处理，还可以由文挡类，文档模板类及应用类所处理。\n\n#### **六、队列消息和非队列消息**\n\n1. 队列消息送到系统消息队列，然后到线程消息队列；\n\n2. 非队列消息直接送给目的窗口过程。\n\n \n\n## 10.2. 微内核与宏内核\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220319171229645.png\" alt=\"image-20220319171229645\" style=\"zoom:150%;\" />\n\n微内核相当于一个信息交换中心，自身可以实现的功能较少，他的主要职责是传递一个请求，一个A模块对其他模块功能的请求；而宏内核相当于一个是一个中央集权控制中心，把内存管理，文件管理等功能全部管理。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220319171241724.png\" alt=\"image-20220319171241724\" style=\"zoom:150%;\" />\n\n**微内核定义：**\n\n内核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。\n\n在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。\n\n**宏内核定义：**\n\n宏内核同样管理着用户程序和硬件之间的系统资源，但是和微内核不一样的是，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。\n\n在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。\n\n \n\n## 10.3. 什么是大端小端以及如何判断大端小端\n\n大端：将表示一个对象的字节在内存中按照从最高有效字节到最低有效字节的顺序存储，即最高有效字节在内存地址最前面的方式，称为大端法\n\n小端：将表示一个对象的字节在内存中按照从最低有效字节到最高有效字节的顺序存储，即最低有效字节在内存地址最前面的方式，称为小端法\n\n我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。\n\n```c++\n//根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储\nint funl(){\n    union test{\n        int i;\n        char c;\n    };\n    \n    test t;\n    t.i = 1;\n    //int i存储四个字节 0x00 0x00 0x00 0x01\n    //联合体变量总是从低地址存储 取c取的是低地址一个字节\n    //如果是大端，则t.c为0x00, 是小端 则t.c为0x01\n    return t.c == 1;\n}\n```\n\n````c++\nint main(){\n  int x = 0x01234567;\n  for (int i = 0; i < sizeof(int); i++)\n    printf(\"%.2x \", ((char *)&x)[i]);\n  printf(\"\\n\");\n  \n  if (((char *)&x)[0] == 0x67){\n    printf(\"little endian!\\n\");\n  }\n else if (((char *)&x)[0] == 0x01){\n   printf(\"big endian\\n\");\n }\n}\n````\n\n\n\n\n\n## 10.4. [说操作系统中的结构体对齐，字节对齐](https://zhuanlan.zhihu.com/p/30007037)\n\n1. 原因：\n\n   - 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。    <u>==内存存取粒度.==</u>\n\n     > 因为大多数处理器有内存存取粒度的限制，比如说32位系统是4字节的存取粒度，只能从地址为4的倍数的内存开始读取数据，所以需要内存对齐，\n\n   - 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。\n\n     > 数据在内存的存放没有规则的话，会给数据的读取增添很大的工作量，所以需要按照对齐规则存放数据，进行内存对齐\n     >\n     > ==需要考虑成员变量定义的先后顺序，可以优化数据存储大小==\n\n2. 规则\n   - 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。\n   - 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。\n   - 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。\n\n3. 定义结构体对齐\n\n   可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。\n\n4. 举例\n\n   ```c++\n   #pragma pack(2)\n   \n   struct AA {\n       int a;    //长度4 > 2 按2对齐；偏移量为0；存放位置区间[0,3]\n       char b;  //长度1 < 2 按1对齐；偏移量为4；存放位置区间[4]\n       short c;   //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]\n       char d;  //长度1 < 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节\n   };\n   ```\n\n   总共10字节，（如果b和d在一起则只占8字节）\n\n#### 字节对齐有什么作用？\n\n字节对齐的作用不仅是`便于cpu快速访问`，同时合理的利用字节对齐可以有效地`节省存储空间`。\n\n对于32位机来说，4字节对齐能够使cpu访问速度提高，比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。所以这要考虑处理器类型，另外还得考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。\n\n## 10.5. 系统将数据从磁盘读到内存的过程\n\n在开始DMA传输时，主机向内存写入DA命令块，向DMA控制器写入该命令块的地址，启动I/O设备。然后，CPU继续其他工作，DMA控制器则继续下去直接操作内存总线，将地址放到总线上开始传输。当整个传输完成后，DMA控制器中断CPU。因此正确的执行顺序应该是\n\n1. 初始化DMA控制器并启动磁盘\n\n2. 从磁盘传输一块数据到内存缓冲区\n\n3. DMA控制器发出中断请求\n\n4. 执行“DMA结束”中断服务程序\n\n\n\n## 10.6.Linux 内核和 Windows 内核有什么区别\n\nWindows 有两个内核，最新的是 `NT 内核`，目前主流的 Windows 产品都是 NT 内核。NT 内核和 Linux 内核非常相似，`没有太大的结构化差异`。\n\n从整体设计上来看，Linux 是==宏内核==，NT 内核属于==混合型内核==。和微内核不同，宏内核和混合类型内核从实现上来看是一个完整的程序。只不过混合类型内核内部也抽象出了微内核的概念，从内核内部看混合型内核的架构更像微内核。\n\n另外 NT 内核和 Linux 内核还存在着许多其他的差异，比如：\n\n- Linux 内核是一个==开源==的内核；\n- 它们支持的==可执行文件格式==不同；\n- 它们用到的==虚拟化技术==不同。\n\n[操作系统内核：Linux 内核和 Windows 内核有什么区别](http://learn.lianglianglee.com/专栏/重学操作系统-完/13  操作系统内核：Linux 内核和 Windows 内核有什么区别？.md)","tags":["面试"],"categories":["基础知识"]},{"title":"二分查找","url":"/2022/03/15/er-fen-cha-zhao-suan-fa/","content":"\n# [二分查找算法](https://www.cnblogs.com/kyoner/p/11080078.html)\n\n## **一、二分查找的框架**\n\n```c++\nint binarySearch(int[] nums, int target) {\n   int left = 0, right = ...;\n\nwhile(...) {\n     int mid = (right + left) / 2;\n     if (nums[mid] == target) {\n       ...\n     } else if (nums[mid] < target) {\n       left = ...\n     } else if (nums[mid] > target) {\n       right = ...\n     }\n   }\n   return ...;\n }\n```\n\n**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。\n\n其中...标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。\n\n另外声明一下，计算 mid 时需要技巧防止溢出，建议写成: **`mid = left + (right - left) / 2`**，本文暂时忽略这个问题。\n\n## **二、寻找一个数（基本的二分搜索）**\n\n这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。\n\n`左闭右闭的模板`\n\n```c++\nint binarySearch(int[] nums, int size, int target) {\n   int left = 0; \n   int right = size - 1; // 注意\n\nwhile(left <= right) { // 注意\n     int mid = (right + left) / 2;\n     if(nums[mid] == target)\n       return mid; \n     else if (nums[mid] < target)\n       left = mid + 1; // 注意\n     else if (nums[mid] > target)\n       right = mid - 1; // 注意\n     }\n   return -1;\n }\n```\n\n1. 为什么 while 循环的条件中是 <=，而不是 < ？\n\n   - 答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n   - 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 nums.length 是越界的。\n   - 我们这个算法中使用的是 [left, right] 两端都闭的区间。**这个区间就是`每次进行搜索`的区间，我们不妨称为「搜索区间」(search space)**。\n   - 什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止\n\n   ```c++\n   if(nums[mid] == target)\n     return mid; \n   ```\n\n   - 但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。\n   - `while(left <= right)的终止条件是 left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 [3, 2]，可见**这时候搜索区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。\n   - while(left < right)的终止条件是 left == right，写成区间的形式就是 [right, right]，或者带个具体的数字进去 [2, 2]，**这时候搜索区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就可能出现错误。\n   - 当然，如果你非要用 while(left < right) 也可以，我们已经知道了出错的原因，就打个补丁好了：\n\n   ```c++\n   //...\n    while(left < right) {\n      // ...\n    }\n    return nums[left] == target ? left : -1; //注意 如果是插入位置 需要先判段left是否越界\n   ```\n\n2. 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？\n\n   - 答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n   - 刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何`确定下一步的搜索区间`呢？\n   - 当然是去搜索 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。\n\n3. 此算法有什么缺陷？\n   - 答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。\n   - 比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。\n   - 这样的需求很常见。你也许会说，找到一个 target 索引，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的时间复杂度了。\n   - 我们后续的算法就来讨论这两种二分查找的算法。（==左闭右开==的 ==插入位置==的 ==刚好大于==的 二分方法）\n\n## 三、寻找左侧边界的二分搜索 \n\n ==//搜索>=target的第一个位置==\n\n直接看代码，其中的标记是需要注意的细节： //正常二分法左闭右开的模板\n\n```c++\nint left_bound(int[] nums, int target) {\n   if (nums.length == 0) return -1;\n   int left = 0;\n   int right = nums.length; // 注意\n\nwhile (left < right) { // 注意\n     int mid = (left + right) / 2;\n     if (nums[mid] == target) {\n       right = mid;\n     } else if (nums[mid] < target) {\n       left = mid + 1;\n     } else if (nums[mid] > target) {\n       right = mid; // 注意\n     }\n   }\n   return left;\n }\n```\n\n1. 为什么 while(left < right) 而不是 <= ?    //==注意 仅仅是因为right的初始化 两种模板没有差别 都可以使用==\n   - 答：用相同的方法分析，因为初始化 right = nums.length 而不是 nums.length - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\n   - while(left < right) 终止的条件是 `left == right`，此时搜索区间 `[left, left) 恰巧为空`，所以可以正确终止。\n\n2. 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n\n   - 答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：\n\n     > ​     target = 2\n     >\n     > pos:            left                        mid      mid+1     right\n     >\n     > nums:          1             2             2            4\n     >\n     > index:          0             1             2            3             4\n\n   - 对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中`小于` 2 的`元素有 1 个`。\n   - 比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。如果 target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。\n   - 综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：\n\n   ```c++\n   while (left < right) {\n      //...\n    }\n    // target 比所有数都大\n    if (left == nums.length) return -1; //[1,2,2,4]搜索8返回left 4，越界\n    // 类似之前算法的处理方式\n    return nums[left] == target ? left : -1;\n   ```\n\n3. 为什么 left = mid + 1，right = mid ？和之前的算法不一样？\n   \n- 答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 `[left, mid) 或 [mid + 1, right)`。(mid已被被搜索判断)\n  \n4. 为什么该算法能够搜索左侧边界？\n\n   - 答：关键在于对于 nums[mid] == target 这种情况的处理：\n\n   ```c++\n   if (nums[mid] == target)\n        right = mid;\n   ```\n\n   - 可见，<u>找到 target 时`不要立即返回`，而是`缩小「搜索区间」的上界 right`，在区间 [left, mid) 中`继续搜索`，即`不断向左收缩`，达到`锁定左侧边界`的目的</u>。\n\n5. 为什么返回 left 而不是 right？\n   \n   - 答：返回left和right都是一样的，因为 while 终止的条件是 left == right。\n\n6. 经测试， 两种写法返回值完全一致\n\n   ````c++\n     //二分法细节 <写法\n     int left_bound(vector<int> nums, int target) {\n       if (nums.size() == 0)\n         return -1;\n       int left = 0;\n       int right = nums.size(); // 注意\n   \n       while (left < right) { // 注意\n         int mid = (left + right) / 2;\n         if (nums[mid] == target) {\n           right = mid;\n         } else if (nums[mid] < target) {\n           left = mid + 1;\n         } else if (nums[mid] > target) {\n           right = mid; // 注意\n         }\n       }\n       // return left;    //返回>=target的左边界位置 [0,nums.size()]\n   \n       // 返回第一个target的位置 没有则返回-1；\n       {\n         if (left == nums.size())\n           return -1; //[1,2,2,4]搜索8返回left 4，越界\n                      // 类似之前算法的处理方式\n         return nums[left] == target ? left : -1;\n       }\n     }\n   \n     //<= 写法 完全一致\n     int left_bound2(vector<int> nums, int target) {\n       if (nums.size() == 0)\n         return -1;\n       int left = 0;\n       int right = nums.size() - 1; // 注意\n   \n       while (left <= right) { // 注意\n         int mid = (left + right) / 2;\n         if (nums[mid] == target) {\n           right = mid - 1;\n         } else if (nums[mid] < target) {\n           left = mid + 1;\n         } else if (nums[mid] > target) {\n           right = mid - 1; // 注意\n         }\n       }\n       // return left; //返回>=target的左边界位置 [0,nums.size()]\n   \n       // 返回第一个target的位置 没有则返回-1；\n       {\n         if (left == nums.size())\n           return -1; //[1,2,2,4]搜索8返回left 4，越界\n                      // 类似之前算法的处理方式\n         return nums[left] == target ? left : -1;\n       }\n     }\n   ````\n\n   \n\n## **四、寻找右侧边界的二分查找 ** \n\n==//> target的第一个位置==\n\n寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：\n\n```c++\nint right_bound(int[] nums, int target) {\n   if (nums.length == 0) return -1;\n   int left = 0, right = nums.length;\n\nwhile (left < right) {\n     int mid = (left + right) / 2;\n     if (nums[mid] == target) {\n       left = mid + 1; // 注意\n     } else if (nums[mid] < target) {\n       left = mid + 1;\n     } else if (nums[mid] > target) {\n       right = mid;\n     }\n   }\n   return left - 1; // 注意\n}\n```\n\n1. 为什么这个算法能够找到右侧边界？\n\n   - 答：类似地，关键点还是这里：\n\n   ```c++\n    if (nums[mid] == target) {\n        left = mid + 1;     //与模板对应一致\n   ```\n\n   - 当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。\n\n2. 为什么最后返回 ==left - 1== 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。\n\n   - 答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。  \n\n     >   target = 2\n     >\n     >pos:            left                        mid      mid+1     right\n     >\n     >nums:          1             2             2            4\n     >\n     >index:          0             1             2            3             4\n\n   - ==至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断==：\n\n   ```c++\n   if (nums[mid] == target) {\n        left = mid + 1;\n        // 这样想: mid = left - 1\n   ```\n\n   - 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] **==一定不等于==** target 了，而 nums[left - 1]**可能是**target。\n   - 至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。\n\n3. 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n\n   - 答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：\n\n   ```c++\n   while (left < right) {\n      // ...\n   }\n   if (left == 0) return -1;  //这个例子搜索0 就是返回left 0\n   return nums[left-1] == target ? (left-1) : -1;\n   ```\n\n4. 经测试，左闭右闭的写法也可以 这点[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)可以佐证\n\n   ````c++\n     //二分法细节 查找右边界\n     //<写法\n     int right_bound(vector<int> nums, int target) {\n       if (nums.size() == 0)\n         return -1;\n       int left = 0, right = nums.size();\n   \n       while (left < right) {\n         int mid = (left + right) / 2;\n         if (nums[mid] == target) {\n           left = mid + 1; // 注意\n         } else if (nums[mid] < target) {\n           left = mid + 1;\n         } else if (nums[mid] > target) {\n           right = mid;\n         }\n       }\n       // return left - 1; //返回>=target的右边界位置 [0,nums.size()]\n   \n       // 返回最后一个target的位置 没有则返回-1；\n       {\n         if (left == 0)\n           return -1; //这个例子搜索0 就是返回left 0\n         return nums[left - 1] == target ? (left - 1) : -1;\n       }\n     }\n   \n     //<=写法\n     int right_bound2(vector<int> nums, int target) {\n       if (nums.size() == 0)\n         return -1;\n       int left = 0, right = nums.size() - 1;\n   \n       while (left <= right) {\n         int mid = (left + right) / 2;\n         if (nums[mid] == target) {\n           left = mid + 1; // 注意\n         } else if (nums[mid] < target) {\n           left = mid + 1;\n         } else if (nums[mid] > target) {\n           right = mid - 1;\n         }\n       }\n       // return left - 1; //返回>=target的右边界位置 [0,nums.size()]\n   \n       // 返回最后一个target的位置 没有则返回-1；\n       {\n         if (left == 0)\n           return -1; //这个例子搜索0 就是返回left 0\n         return nums[left - 1] == target ? (left - 1) : -1;\n       }\n     }\n   ````\n\n   \n\n## **五、最后总结**\n\n先来梳理一下这些细节差异的因果逻辑：\n\n1. 第一个，最基本的二分查找算法：\n\n   >因为我们初始化 right = nums.length - 1\n   >所以决定了我们的「搜索区间」是 [left, right]\n   >所以决定了 while (left <= right)\n   >同时也决定了 left = mid+1 和 right = mid-1\n   >\n   >因为我们只需找到一个 target 的索引即可\n   >所以当 nums[mid] == target 时可以立即返回\n\n   \n\n2. 第二个，寻找左侧边界的二分查找：\n\n   >因为我们初始化 right = nums.length\n   >所以决定了我们的「搜索区间」是 [left, right)\n   >所以决定了 while (left < right)\n   >同时也决定了 left = mid+1 和 right = mid\n   >\n   >因为我们需找到 target 的最左侧索引\n   >所以当 nums[mid] == target 时不要立即返回\n   >而要收紧右侧边界以锁定左侧边界\n\n\n\n3. 第三个，寻找右侧边界的二分查找：\n\n   >因为我们初始化 right = nums.length\n   >所以决定了我们的「搜索区间」是 [left, right)\n   >所以决定了 while (left < right)\n   >同时也决定了 left = mid+1 和 right = mid\n   >\n   >因为我们需找到 target 的最右侧索引\n   >所以当 nums[mid] == target 时不要立即返回\n   >而要收紧左侧边界以锁定右侧边界\n   >\n   >又因为收紧左侧边界时必须 left = mid + 1\n   >所以最后无论返回 left 还是 right，必须减一\n\n- 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。\n\n* 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。\n* 如需要搜索左右边界，只要在 nums[mid] == target 时做修改即可。搜索右侧时需要减一。\n\n\n\n\n\n# 二分题目\n\n### [剑指 Offer II 068. 查找插入位置](https://leetcode-cn.com/problems/N6YdxV/)\n\n难度简单13英文版讨论区\n\n给定一个排序的整数数组 `nums` 和一个整数目标值` target` ，请在数组中找到 `target `，并返回其下标。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 `O(log n)` 的算法。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n```\n\n#### 思路\n\n这是一道典型的找左边界的题目\n\n两种二分法都可以 左边界在于 缩小右边界\n\n#### 代码\n\n1. 两端闭区间写法\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n-1;\n        while(left <= right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] >= target){\n                right = mid - 1;\n            }else left = mid + 1;\n        }\n        return left;\n    }\n}; \n```\n2. 左闭右开\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n;\n        while(left < right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] >= target){\n                right = mid;\n            }else left = mid + 1;\n        }\n        return left;\n    }\n}; \n```\n\n### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)\n\n难度简单288收藏分享切换为英文接收动态反馈\n\n统计一个数字在排序数组中出现的次数。\n\n####  思路\n\n1. 查找左边界 向右数 (两种写法均可)  lower_bound\n2. 查找右边界 向左数 （两种写法均可）upper_bound 但是注意 右边界查找的特性 大于当前值 所以要先--\n\n**示例 1:**\n\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n```\n\n#### 代码\n\n1. 左边界 左闭右闭写法\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int ans = 0;\n        if(nums.size() == 0) return 0;\n        int left = 0, right = nums.size() - 1;\n        while(left <= right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] >= target)\n                right = mid - 1;\n            else left = mid + 1;\n        } \n        while(left <= nums.size() - 1 && nums[left] == target){\n            left++;\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n2. 左边界 左闭右开写法\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int ans = 0;\n        if(nums.size() == 0) return 0;\n        int left = 0, right = nums.size();\n        while(left < right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] >= target)\n                right = mid;\n            else left = mid + 1;\n        } \n        while(left <= nums.size() - 1 && nums[left] == target){\n            left++;\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n3. 右边界 左开右闭写法\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int ans = 0;\n        if(nums.size() == 0) return 0;\n        int left = 0, right = nums.size();\n        while(left < right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] > target)\n                right = mid;\n            else left = mid + 1;\n        } \n        left--;  //注意 右边界搜索的特性 必须-1 \n        while(left >=0 && nums[left] == target){\n            left--;\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n4. 右边界 左闭右开写法\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int ans = 0;\n        if(nums.size() == 0) return 0;\n        int left = 0, right = nums.size() - 1;\n        while(left <= right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] > target)\n                right = mid - 1;\n            else left = mid + 1;\n        } \n        left--;   //注意 右边界搜索的特性 必须-1\n        while(left >=0 && nums[left] == target){\n            left--;\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n### [729. 我的日程安排表 I](https://leetcode-cn.com/problems/my-calendar-i/)\n\n难度中等118\n\n实现一个 `MyCalendar` 类来存放你的日程安排。如果要添加的日程安排不会造成 **重复预订** ，则可以存储这个新的日程安排。\n\n当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 **重复预订** 。\n\n日程可以用一对整数 `start` 和 `end` 表示，这里的时间是半开区间，即 `[start, end)`, 实数 `x` 的范围为，  `start <= x < end` 。\n\n实现 `MyCalendar` 类：\n\n- `MyCalendar()` 初始化日历对象。\n- `boolean book(int start, int end)` 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 `true` 。否则，返回 `false` 并且不要将该日程安排添加到日历中。\n\n \n\n**示例：**\n\n```\n输入：\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\n输出：\n[null, true, false, true]\n```\n\n#### 思路\n\n1. 之前的思路是vector遍历 过于暴力\n2. 和大佬学了一个`有序map调二分查找`的算法 秀\n\n#### 代码\n\n```c++\nclass MyCalendar {\n    map<int, int> all;\npublic:\n    MyCalendar() {}\n    \n    bool book(int start, int end) {\n      if(all.empty()){\n        all[start] = end;\n        return 1;\n      }\n      //好家伙 有序map的二分学一下\n      auto it = all.lower_bound(start);\n      //it == all.end()说明比所有的都打 没找到\n      if(it != all.end() && it->first < end)\n        return 0;\n      //如果it是第一个 直接成立了\n      if(it != all.begin() && start<(--it)->second){\n        return 0;\n      }\n      all[start] = end;\n      return 1;\n    }\n};\n```\n\n### [剑指 Offer II 069. 山峰数组的顶部](https://leetcode-cn.com/problems/B1IidL/)\n\n难度简单80英文版讨论区\n\n符合下列属性的数组 `arr` 称为 **山峰数组**（**山脉数组）** ：\n\n <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220423153910360.png\" alt=\"image-20220423153910360\" style=\"zoom:67%;\" />\n\n**示例 1：**\n\n```\n输入：arr = [0,1,0]\n输出：1\n```\n\n**示例 2：**\n\n```\n输入：arr = [1,3,5,4,2]\n输出：2\n```\n\n#### 二分要灵活\n\n比如说 下面这个写法， \n\n1. 我比较的是左边的，并且每次搜索的区间是左闭右开 mid-1就保证index 不能越界 所以范围是[1, n) 然后对1进行特判\n2. 最后终止的条件是 left = mid + 1 所以需要最终结果在left 上-1  （最后+1-1多试试就好了 奶奶的）\n\n```c++\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n      int n = arr.size();\n      if(arr[0]>arr[1]) return 0;\n      int left = 1, right = n;\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(arr[mid] > arr[mid - 1])\n          left = mid + 1;\n        else right = mid;\n      }\n      return left - 1;\n    }\n};\n\n\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& nums) {\n      int left = 1, right = nums.size() - 1;\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(nums[mid] > nums[mid + 1]) right = mid;\n        else left = mid + 1;\n      }\n      return left;\n    }\n};\n```\n\n\n\n### [剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/)\n\n难度中等26\n\n给定一个只包含整数的有序数组 `nums` ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,1,2,3,3,4,4,8,8]\n输出: 2\n```\n\n**示例 2:**\n\n```\n输入: nums =  [3,3,7,7,10,11,11]\n输出: 10\n```\n\n题目很简单 主要是做一下思考 首先 两种二分写法完全一致 主要是理解一下最后的left和right\n\n#### 解法\n\n`首先 题目明确了不会在两端 因此可以缩小区间 同时避免mid+-越界`\n\n我全是按照左闭右开写的 最后返回的left和right 一定是left == rigth;\n\n注意到 我这种写法是按照 左边界 上升区间判断的 一次 最后在山顶的时候 仍然会执行一次 left = mid + 1;\n\n因此 最终返回的是 left - 1\n\n```c++\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& nums) {\n      int left = 1, right = nums.size() - 1;\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(nums[mid] > nums[mid - 1]) left = mid + 1;\n        else right = mid;\n      }\n      return left - 1;\n    }\n};\n```\n\n下面这种写法 则是按照右边下降区间进行判断的,  最后在山顶会执行一次 right = mid; 没有+1了\n\n所以最后的left 或者说right 就是山顶的index\n\n```c++\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& nums) {\n      int left = 1, right = nums.size() - 1;\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(nums[mid] > nums[mid + 1]) right = mid;\n        else left = mid + 1;\n      }\n      return left;\n    }\n};\n```\n\n#### 解法\n\n1. 首先二分区间的缩小我是根据 mid的奇偶性来判断的 可以画个图来分析下\n2. mid + 1 - 1 随便一写懒得改的，其实可以统一到一个写法 但是无所谓 体现灵活性 可以跟更好的理解搜索区间\n3. 因为用到了mid-1 和 mid+1 防止越界 所以搜索区间都向内缩了一个单位\n4. 因为3.所以需要对首尾进行特判\n\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n      //两端特判\n      if(nums.size() == 1) return nums[0];\n      if(nums[0] != nums[1]) return nums[0];\n      if(nums[nums.size() - 1] != nums[nums.size() - 2]) return nums.back();\n\n      //二分查找\n      int left = 1, right = nums.size() - 1;\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(mid%2){\n          if(nums[mid] == nums[mid - 1]){\n            left = mid + 1;\n          }else\n            right = mid;\n        }else{ //mid是偶数\n          if(nums[mid] == nums[mid + 1]){\n            left = mid + 1;\n          }else right = mid;\n        }\n      }\n      return nums[left];\n    }\n};\n```\n\n和上一道题差不多 最后区间终点的判断 影响返回下标\n\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n      //两端特判\n      if(nums.size() == 1) return nums[0];\n      if(nums[0] != nums[1]) return nums[0];\n      //if(nums[nums.size() - 1] != nums[nums.size() - 2]) return nums.back();\n\n      //二分查找\n      int left = 1, right = nums.size();\n      while(left < right){\n        int mid = left + (right - left) / 2;\n        if(mid%2){\n          if(nums[mid] == nums[mid - 1]){\n            left = mid + 1;\n          }else\n            right = mid;\n        }else{ //mid是偶数\n          //注意这样写 最后在目标出还是会执行一次 + 1 因此最后left是+1的\n          // 1 1 2 2 3 4 4\n          if(nums[mid] != nums[mid - 1]){\n            left = mid + 1;\n          }else right = mid;\n        }\n      }\n      return nums[left - 1];\n    }\n};\n```\n\n其他的On解法就很多了, `所有异或`啊 `快慢指针直到下标异常`啊\n\n## 旋转数组专题\n\n### 总结\n\n旋转数组 经典二分\n\n1. 查找最小值 推荐用 < 开区间的模板 \n\n   > 虽然是开区间 但是 初始值 n - 1 \n\n2. 包含重复值 一般涉及到 left++ 或 right--\n\n### [189. 轮转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n难度中等1406\n\n给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右轮转 1 步: [7,1,2,3,4,5,6]\n向右轮转 2 步: [6,7,1,2,3,4,5]\n向右轮转 3 步: [5,6,7,1,2,3,4]\n```\n\n**示例 2:**\n\n```\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右轮转 1 步: [99,-1,-100,3]\n向右轮转 2 步: [3,99,-1,-100]\n```\n\n##### 额外数组\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> newArr(n);\n        for (int i = 0; i < n; ++i) {\n            newArr[(i + k) % n] = nums[i];\n        }\n        nums.assign(newArr.begin(), newArr.end());\n    }\n};\n```\n##### 三次反转\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(n<2) return;\n        k = k % n;\n        reverseArry(nums, 0, n-1);\n        reverseArry(nums, 0, k-1);\n        reverseArry(nums, k, n-1);\n    }\n\n    void reverseArry(vector<int>& nums, int left, int right){\n        while(left<right){\n            int temp = nums[right];\n            nums[right] = nums[left];\n            nums[left] = temp;\n            left++;\n            right--;\n        }\n    }\n};\n```\n##### 环状替换 最大公约数？\n```c++\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = k % n;\n        int count = gcd(k, n);\n        for (int start = 0; start < count; ++start) {\n            int current = start;\n            int prev = nums[start];\n            do {\n                int next = (current + k) % n;\n                swap(nums[next], prev);\n                current = next;\n            } while (start != current);\n        }\n    }\n};\n```\n\n### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n难度中等702\n\n已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：\n\n- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`\n- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`\n\n注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n\n给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。\n\n你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,4,5,1,2]\n输出：1\n解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n```\n\n**示例 2：**\n\n```\n输入：nums = [4,5,6,7,0,1,2]\n输出：0\n解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n```\n\n\n\n#### 思路\n\n画个这样的图 分情况取讨论\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220325183754754.png\" alt=\"image-20220325183754754\" style=\"zoom:50%;\" />\n\n#### 代码\n\n和右边比较\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0, right = n-1;\n        //取等号大多是为了在while中直return mid，不取等号就跳出while返回l的值\n        while(left <= right){  //如果这里不 = 则最后直接返回nums[left]\n            int mid = left + (right - left) / 2;\n            if(nums[mid]< nums[right])\n                right = mid; //不能mid-1不然会跳过最小 例如 4 5 1 2 3\n            else \n                left = mid + 1;\n        }\n        return nums[left - 1];  //终止区间为[left + 1, right]\n    }\n};\n```\n\n`和左边比较`\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n      int n = nums.size();\n      int left = 0, right = n;\n      while(left < right){\n        int mid = left + (right - left) /2;\n        if(nums[mid] > nums[left])\n          left = mid;\n        else \n          right = mid;\n      }\n      // cout <<left << \" \" << right;\n      //left+1超范围 说明数组是递增的 因此返回第一个\n      return (left + 1 >= n) ?nums[0] :nums[left+1];\n    }\n};\n```\n\n### [154. 寻找旋转排序数组中的最小值 II 重复元素](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n难度困难473\n\n已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：\n\n- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`\n- 若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`\n\n注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n\n给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。\n\n你必须尽可能减少整个过程的操作步骤。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,3,5]\n输出：1\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,2,0,1]\n输出：0\n```\n\n#### 思路\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220325202117864.png\" alt=\"image-20220325202117864\" style=\"zoom: 50%;\" />\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0; \n        int right =  n - 1;\n        //直接 之改成<=也能过\n        while(left < right){\n            int mid = (right - left) / 2 + left;\n            if(nums[mid] < nums[right])\n                right = mid;\n            //看上图的第三种情况\n            else if(nums[mid] == nums[right])  \n                right--;\n            else\n                left = mid + 1;\n        }\n        return nums[left];\n    }\n};\n```\n\n\n\n### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n难度中等1937英文版讨论区\n\n整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。\n\n在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。\n\n给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n```\n\n**示例 2：**\n\n```\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n```\n\n#### 思路\n\n#### 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = (int)nums.size();\n        if (n == 0) return -1;\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = (right-left) / 2 + left;\n            if (nums[mid] == target) return mid;\n            //判断左边一半是否有序\n            if (nums[0] <= nums[mid]) {\n                //target落在左半部分有序区域内\n                if (nums[0] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    //target落在右半部分无序区域内\n                    left = mid + 1;\n                }\n            } else {  //右半部分是有序\n                //target落在右半部分有序区域内\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    left = mid + 1;\n                } else {\n                    //target落在左半部分无序区域内\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};\n```\n\n\n\n### [81. 搜索旋转排序数组 II 包含重复元素](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n难度中等562\n\n已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。\n\n在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。\n\n给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。\n\n你必须尽可能减少整个操作步骤。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n```\n\n#### 思路\n\n对于数组中有重复元素的情况，二分查找时可能会有 nums[left] = nums[mid] = nums[right]，此时无法判断哪个区间有序\n\n例如nums=[3,1,2,3,3,3,3]，target=2，首次二分时无法判断区间 [0,3][0,3] 和区间 [4,6][4,6] 哪个是有序的。\n\n对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool search(vector<int> &nums, int target) {\n        int n = nums.size();\n        if (n == 0) return 0;\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] == target) return true;\n            //这两个都不是 target 所以++--\n            if (nums[left] == nums[mid] && nums[mid] == nums[right]) {\n                ++left;\n                --right;\n            } else if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid])\n                    right = mid - 1;\n                else \n                    left = mid + 1;\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) \n                    left = mid + 1;\n                else \n                    right = mid - 1;\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [面试题 10.03. 搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)\n\n难度中等83\n\n搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。\n\n**示例1:**\n\n```\n 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5\n 输出: 8（元素5在该数组中的索引）\n```\n\n**示例2:**\n\n```\n 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11\n 输出：-1 （没有找到）\n```\n\n#### 思路\n\n和上面的一样\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        if(arr[0]==target)\n            return 0;\n        int l=0;\n        int r=arr.size()-1;\n        int mid=0;\n        while(l<=r){\n            mid=l+(r-l)/2;\n            //mid值==target,则继续往左搜寻，找到最小的索引，最小索引一定不为0\n            if(arr[mid]==target){\n                while(mid>0&&arr[mid-1]==arr[mid])  mid--;\n                return mid;\n            }\n            //说明mid~r是递增序列，判读target是否在中间\n            if(arr[mid]<arr[r]){\n                if(arr[mid]<target&&target<=arr[r]) l=mid+1;\n                else    r=mid-1;\n            }\n            //说明 l~mid 是递增序列，判读target是否在中间\n            else if(arr[mid]>arr[r]){\n                if(arr[l]<=target&&target<arr[mid]) r=mid-1;\n                else l=mid+1;\n            }\n            //arr[mid]==arr[r]说明要么r~0~mid都相等，要么mid~r都相等，无论哪种r 都可以舍去\n            else{\n                r--;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 矩阵二分\n\n### [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n难度中等805收藏分享切换为英文接收动态反馈\n\n给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。\n请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。\n\n你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。\n\n \n\n**示例 1：**\n\n```\n输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n输出：13\n解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13\n```\n\n**示例 2：**\n\n```\n输入：matrix = [[-5]], k = 1\n输出：-5\n```\n\n#### 解法1 归并\n\n时间复杂度：O(klogn)，归并 kk 次，每次堆中插入和弹出的操作时间复杂度均为logn。\n\n空间复杂度O(n)，堆的大小始终为 n。\n\n```c++\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n      int n = matrix.size();\n      auto cmp = [&](pair<int, int>& a, pair<int, int>& b){\n        return matrix[a.first][a.second] > matrix[b.first][b.second];\n      };\n      priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> que(cmp);\n      for(int i = 0; i < n; i++){\n        que.push(pair<int, int>(i, 0));\n      }\n      // 弹出前 k-1 小的值\n      for(int i = 0; i<k-1; i++){\n        pair<int, int> top = que.top();\n        que.pop(); //每次把最小的拿出来\n        int x = top.first, y = top.second;\n        if(y != n-1){\n          que.push(pair<int, int>(x, y+1));\n        }\n      }\n      return matrix[que.top().first][que.top().second];\n    }\n};\n```\n\n#### 解法2 二分 最优\n\n时间复杂度：O(nlog(r−l))，二分查找进行次数为O(log(r−l))，每次操作时间复杂度为 O(n)。\n\n空间复杂度：O(1)。\n\n```c++\n  bool check(vector<vector<int>> &matrix, int mid, int k, int n) {\n    int i = n - 1;\n    int j = 0;\n    int num = 0;\n    //每次对于「猜测」的答案 mid，计算矩阵中有多少数不大于 mid\n    //如果数量不少于 k，那么说明最终答案 x 不大于 mid；\n    //如果数量少于 k，那么说明最终答案 x 大于 mid。\n    while (i >= 0 && j < n) {\n      if (matrix[i][j] <= mid) {\n        num += i + 1;\n        j++;\n      } else {\n        i--;\n      }\n    }\n    return num >= k;\n  }\n\n  int kthSmallest2(vector<vector<int>> &matrix, int k) {\n    int n = matrix.size();\n    int left = matrix[0][0];\n    int right = matrix[n - 1][n - 1];\n    while (left < right) {\n      int mid = left + ((right - left) >> 1);\n      if (check(matrix, mid, k, n)) { //<=mid的个数>=k 找左边界\n        right = mid;                  //向左上角收缩\n      } else {\n        left = mid + 1; //向右下角扩大\n      }\n    }\n    return left;\n  }\n```\n\n### [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)\n\n难度困难264收藏分享切换为英文接收动态反馈\n\n几乎每一个人都用 [乘法表](https://baike.baidu.com/item/乘法表)。但是你能在乘法表中快速找到第`k`小的数字吗？\n\n给定高度`m` 、宽度`n` 的一张 `m * n`的乘法表，以及正整数`k`，你需要返回表中第`k` 小的数字。\n\n**例 1：**\n\n```\n输入: m = 3, n = 3, k = 5\n输出: 3\n解释: \n乘法表:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\n第5小的数字是 3 (1, 2, 2, 3, 3).\n```\n\n**例 2：**\n\n```\n输入: m = 2, n = 3, k = 6\n输出: 6\n解释: \n乘法表:\n1\t2\t3\n2\t4\t6\n\n第6小的数字是 6 (1, 2, 2, 3, 4, 6).\n```\n\n#### 解法1 暴力 sort 或二分 \n\n时间复杂度 Om*n * logm* n  空间 Om*n\t\t\n\nsort略 只记录矩阵二分\n\n```c++\nclass Solution {\npublic:\n    int findKthNumber(int m, int n, int k) {\n      vector<vector<int>> grid(m, vector<int>(n, 0));\n      vector<int> all;\n      for(int i = 0; i<m; i++)\n        grid[i][0] = i+1;\n      for(int j = 0; j<n; j++)\n        grid[0][j] = j+1;\n\n      for(int i = 1; i<m; i++)\n        for(int j = 1; j<n; j++)\n          grid[i][j] = grid[i][0]*grid[0][j];\n          \n      int left = grid[0][0], right = grid[m-1][n-1];\n      while(left < right){\n        int mid = left + (right - left) /2;\n        if(check(grid, mid, m, n, k)){\n          right =  mid;\n        }else\n          left = mid + 1;\n      }\n      return left;\n    }\n\n    bool check(vector<vector<int>>& grid, int mid, int m, int n, int k){\n      int i = m-1;\n      int j = 0;\n      int cnt = 0;\n      while(i >= 0 && j< n){\n        if(grid[i][j] <= mid){\n          cnt += i+1;\n          j++;\n        }else i--;\n      }\n      return cnt >= k;\n    }\n};\n\n```\n\n#### 解法2 二分猜数\n\n```c++\nclass Solution {\npublic:\n    int findKthNumber(int m, int n, int k) {\n      int left = 1, right = m*n;\n      while(left < right){\n        int mid = left + (right - left) /2;\n        if(check(mid, m, n, k))\n          right = mid;\n        else left = mid+1;\n      }\n      return left;\n    }\n\t\t//按行一次数乘法表中比mid小的数的个数\n    bool check(int mid, int m, int n, int k){\n      int cnt = 0;\n      for(int i = 1; i<=m; i++){\n        cnt += min(mid/i, n);\n      }\n      return cnt >= k;\n    }\n};\n\n```\n\n涉及元素极多做不到遍历的二维矩阵里的第K小都可以用二分猜答案的套路，转化为“给定一个数，求矩阵中有多少个数比这个数小”，进而实现二分查找，主站378，719，786，2040题也是类似的思路\n\n\n\n### [719. 找出第 k 小的距离对](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)\n\n难度困难242收藏分享切换为英文接收动态反馈\n\n给定一个整数数组，返回所有数对之间的第 k 个最小**距离**。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。\n\n**示例 1:**\n\n```\n输入：\nnums = [1,3,1]\nk = 1\n输出：0 \n解释：\n所有数对如下：\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\n因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。\n```\n\n#### 解法 二分 + 双指针\n\n```c++\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n      sort(nums.begin(), nums.end());\n      int left = 0, right = nums.back() - nums.front();\n      while(left < right){\n        int mid = left + (right - left) /2;\n        if(check(nums, mid, k))\n          right = mid;\n        else left = mid+1;\n      }\n      return left;\n    }\n\n    bool check(vector<int>& nums, int mid, int k){\n      int cnt = 0, n = nums.size();\n      for(int i = 0, j = 1; i<n-1; i++){\n        while(j<n && nums[j]<=nums[i] + mid) j++;\n        cnt+=j-i-1;\n      }\n      //cout <<cnt <<endl;\n      return cnt >= k;\n    }\n    // 使用map计数是错误的 因为会重复计数 1 1 1 正确因该是0记3次 但是用map会0记6次\n    // bool check(vector<int>& nums, int mid, int k){\n    //   int cnt = 0;\n    //   cout<<mid<<endl;\n    //   for(int i = 0; i<nums.size(); i++){\n    //     int rangeL = nums[i] - mid;\n    //     int rangeR = nums[i] + mid;\n    //     int tempCnt = 0;\n    //     for(int j = rangeL; j<= rangeR; j++){\n    //       tempCnt += mapp[j];\n    //     }\n    //     cnt += tempCnt - 1;\n    //   }\n    //   // cout <<cnt <<endl;\n    //   return cnt >= k;\n    // }\n};\n```\n\n","tags":["算法总结"]},{"title":"前缀和/差分/字典树","url":"/2022/03/15/qian-zhui-he-chai-fen-zi-dian-shu/","content":"\n# 前缀和数组\n\n```c++\nclass PrefixSum {\nprivate:\n  // 前缀和数组\n  \tvector<int> prefix;\n  \npublic:\n  /* 输入一个数组，构造前缀和 */\n  PrefixSum(vector<int> nums) {\n    int n = nums.size();\n    prefix.resize(n+1);\n    // 计算 nums 的累加和\n    for (int i = 1; i <= n; i++) {\n      prefix[i] = prefix[i - 1] + nums[i - 1];\n    }\n  }\n\n  /* 查询闭区间 [i, j] 的累加和 */\n  int query(int i, int j) {\n    return prefix[j + 1] - prefix[i];\n  }\n};\n```\n\n## 一维数组中的前缀和\n\n### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v3/?qno=303&target=gitee&_=1646830143357)[思路](https://leetcode-cn.com/problems/range-sum-query-immutable/#)\n\n给定一个整数数组  `nums`，处理以下类型的多个查询:\n\n1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`\n\n实现 `NumArray` 类：\n\n- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象\n- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )\n\n \n\n**示例 1：**\n\n```\n输入：\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n输出：\n[null, 1, -1, -3]\n\n解释：\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)\nnumArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) \nnumArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n```\n\n#### 代码\n\n```c++\nclass NumArray {\npublic:\n    vector<int> preSum;\n    NumArray(vector<int>& nums) {\n      preSum.resize(nums.size());\n      int sum = 0;\n      for(int i = 0; i<nums.size(); i++){\n        sum+=nums[i];\n        preSum[i] = sum;\n      }\n    }\n    \n    int sumRange(int left, int right) {\n      return left == 0?preSum[right]:(preSum[right] - preSum[left-1]);\n    }\n};\n\n// 简单写法, 避免边界判断\nclass NumArray {\npublic:\n    vector<int> preSum;\n    NumArray(vector<int>& nums) {\n      int n = nums.size();\n      preSum.resize(n+1);\n      for(int i = 1; i<n+1; i++){\n        preSum[i] = preSum[i-1] + nums[i-1];\n      }\n    }\n    \n    int sumRange(int left, int right) {\n      return preSum[right+1] - preSum[left];\n    }\n};\n```\n\n## 二维数组中的前缀和\n\n### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v3/?qno=304&target=gitee&_=1646830216742)[思路](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/#)\n\n给定一个二维矩阵 `matrix`，以下类型的多个请求：\n\n- 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。\n\n实现 `NumMatrix` 类：\n\n- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化\n- `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626332422-wUpUHT-image.png)\n\n```\n输入: \n[\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n输出: \n[null, 8, 11, 12]\n\n解释:\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n```\n\n#### 代码\n\n```c++\n//笨比前缀和\nclass NumMatrix {\npublic:\n    vector<vector<int>> preSum;\n    NumMatrix(vector<vector<int>>& matrix) {\n      int m = matrix.size();\n      int n = matrix[0].size();\n      for(int i = 0; i<m; i++){\n        int sum = 0;\n        vector<int> temp(n+1);\n        for(int j = 1; j<n+1; j++){\n          temp[j] = temp[j-1] + matrix[i][j-1];\n        }\n        //cout<<i<<endl;\n        preSum.push_back(temp);\n      }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n      int ans = 0;\n      int minRow = min(row1, row2);\n      int maxRow = max(row1, row2);\n      int minCol = min(col1, col2);\n      int maxCol = max(col1, col2);\n      for(int i = minRow; i<= maxRow; i++){\n        ans += preSum[i][maxCol+1] - preSum[i][minCol];\n      }\n      return ans;\n    }\n};\n\n//真正的二维前缀和数组\nclass NumMatrix {\npublic:\n    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和\n    vector<vector<int>> preSum;\n    NumMatrix(vector<vector<int>>& matrix) {\n      int m = matrix.size();\n      if(m == 0) return;\n      int n = matrix[0].size();\n      // 构造前缀和矩阵\n      preSum.resize(m+1, vector<int>(n+1));\n      for(int i = 1; i<=m; i++){\n        for(int j = 1; j<=n; j++){\n          // 计算每个矩阵 [0, 0, i, j] 的元素和\n          preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + matrix[i-1][j-1];\n        }\n      }\n    }\n    \n    //速记 前缀和做减法的时候 永远是大的那边需要+1\n    int sumRegion(int row1, int col1, int row2, int col2) {\n      // 计算子矩阵 [x1, y1, x2, y2] 的元素和\n      return preSum[row2 + 1][col2 + 1] - preSum[row1][col2+1] -preSum[row2+1][col1]  + preSum[row1][col1];\n    }\n};\n\n```\n\n## 和为 k 的子数组\n\n### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v3/?qno=560&target=gitee&_=1646835188259)[思路](https://leetcode-cn.com/problems/subarray-sum-equals-k/#)\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的连续子数组的个数。\n\n\n\n**示例 1：**\n\n```\n输入：nums = [1,1,1], k = 2\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3], k = 3\n输出：2\n```\n\n#### 思路\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1645841783-JduBEc-1.png\" alt=\"1.png\" style=\"zoom: 80%;\" />\n\n补充修正：最后一条正确路径应该是3-4-5-6-7\n\n个人理解本质上还是前缀和数组presum[i]与presum[j]的差值双重遍历的优化\n\n重点在于哈希的初始化 \n\n> <u>比如说 从0到某个索引i的前缀和 就是k 也就是从头开始到i的连续子数组和presum[i]就是k，这个时候presum - k 就等于0了，提前把0放一个val = 1就可以统计这个情况了</u>\n>\n> <u>当出现前缀和等于k的时候会把这段算到答案里，不然hashmap[0]默认为0，就会少一个解</u>\n>\n> > `比如1 2 1 target = 2 就不会少`\n> >\n> > `而1 1 1 target = 2 会少一个 情况为前两个1`\n\n#### 代码\n\n```c++\n//笨比的前缀和用法\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n      int n = nums.size();\n      vector<int> preSum(n+1);\n      for(int i = 1; i<=n; i++){\n        preSum[i] = preSum[i-1] + nums[i-1];\n      }\n      int ans = 0;\n      for(int i = 0; i<=n; i++){\n        for(int j = i+1; j<=n; j++){\n          if(preSum[j] - preSum[i] == k){\n            ans++;\n          }\n        }\n      }\n      return ans;\n    }\n};\n\n//遍历\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int count = 0;\n        for (int start = 0; start < nums.size(); ++start) {\n            int sum = 0;\n            for (int end = start; end >= 0; --end) {\n                sum += nums[end];\n                if (sum == k) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};\n\n\n//前缀和的最优解\n//  3 5 2  -2 4  1    k = 5\n//0 3 8 10 8 12 13  -5的个数\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int count = 0;\n        unordered_map<int, int> mapp;\n        mapp[0] = 1; //初始化\n        int sum = 0; \n        for (int i = 0; i < nums.size(); ++i) {\n          sum+=nums[i];\n          int cc = mapp[sum-k];\n          count+=cc;\n          mapp[sum]++;\n        }\n        return count;\n    }\n};\n```\n\n### [剑指 Offer II 011. 0 和 1 个数相同的子数组](https://leetcode-cn.com/problems/A1NYOS/)\n\n难度中等54\n\n给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。\n```\n\n**示例 2:**\n\n```\n输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。\n```\n\n#### 思路\n\n1. 将数组中的0换成-1， 求和为0的最长子数组 转换成前缀和问题\n2. 注意！处理0位置\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int n = nums.size();\n\t    //将数组中的0换成-1， 求和为0的最长子数组 转换成前缀和问题\n        for(int& num : nums) //这样写一定要&\n            if(num == 0) num = -1;\n        unordered_map<int, int> mapp;\n        mapp[0] = -1; //注意！处理0位置\n        int sum = 0;\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            sum += nums[i];\n            if(mapp.count(sum)) //之前也有前缀和 == sum\n                ans = max(ans, i - mapp[sum]);\n            else mapp[sum] = i;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n# 差分数组\n\n**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。\n\n```c++\n// 差分数组工具类\nclass Difference {\nprivate:\n  // 差分数组\n  vector<int> diff;\npublic:\n  /* 输入一个初始数组，区间操作将在这个数组上进行 */\n  Difference(vector<int> nums) {\n   \tint n = nums.size();\n    diff.resize(n);;\n    // 根据初始数组构造差分数组\n    diff[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n      diff[i] = nums[i] - nums[i - 1];\n    }\n  }\n  \n  /* 给闭区间 [i,j] 增加 val（可以是负数）*/\n  void increment(int i, int j, int val) {\n    diff[i] += val;\n    if (j + 1 < diff.size()) {\n      diff[j + 1] -= val;\n    }\n  }\n\n  /* 返回结果数组 */\n  vector<int> result() {\n    vector<int> res(diff.size());\n    // 根据差分数组构造结果数组\n    res[0] = diff[0];\n    for (int i = 1; i < diff.size(); i++) \n      res[i] = res[i - 1] + diff[i];\n    return res;\n  }\n};\n```\n\n### 370. 区间加法\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/title1.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n可以直接用刚才的套路解决\n\n```c++\nvector<int> getModifiedArray(int length, vector<vector<int>> updates) {\n    // nums 初始化为全 0\n    vector<int> nums(length);\n    // 构造差分解法\n    vector<int> diff(length);\n  \t//因为初始全为0 所以不需要如下初始化\n  \t//diff[0] = nums[0];\n  \t//for(int i = 1; i<length; i++){\n    //  \tdiff[i] = nums[i] - nums[i-1];\n    //}\n    for (auto update : updates) {\n        int i = update[0];\n        int j = update[1];\n        int val = update[2];\n        diff[i]+=val;\n      \tif(j+1<length)\n          diff[j+1]-=val;\n    }\n    vector<int> ans;\n  \tfor(int i = 1; i<length; i++){\n\t\t\t\tans[i] = ans[i-1] + diff[i];\n    }\n    return df.result();\n}\n```\n\n### [1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v3/?qno=1109&target=gitee&_=1646842649748)[思路](https://leetcode-cn.com/problems/corporate-flight-bookings/#)\n\n这里有 `n` 个航班，它们分别从 `1` 到 `n` 进行编号。\n\n有一份航班预订表 `bookings` ，表中第 `i` 条预订记录 `bookings[i] = [firsti, lasti, seatsi]` 意味着在从 `firsti` 到 `lasti` （**包含** `firsti` 和 `lasti` ）的 **每个航班** 上预订了 `seatsi` 个座位。\n\n请你返回一个长度为 `n` 的数组 `answer`，里面的元素是每个航班预定的座位总数。\n\n \n\n**示例 1：**\n\n```\n输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n输出：[10,55,45,25,25]\n解释：\n航班编号        1   2   3   4   5\n预订记录 1 ：   10  10\n预订记录 2 ：       20  20\n预订记录 3 ：       25  25  25  25\n总座位数：      10  55  45  25  25\n因此，answer = [10,55,45,25,25]\n```\n\n```c++\nclass Solution {\npublic:\n    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\n      vector<int> ans(n);\n      vector<int> origin(n);\n      vector<int> diff(n);\n      //diff不需要初始化了；\n      for(int i = 0; i<bookings.size(); i++){\n        int left = bookings[i][0]-1; //nmd坑老子\n        int right = bookings[i][1]-1;\n        int val = bookings[i][2];\n        //操作\n        diff[left] += val;\n        if(right + 1 <n){\n          diff[right+1]-=val;\n        } \n      }\n      // for(int i = 0; i<n; i++)\n      //   cout<<diff[i]<<endl;\n      ans[0] = diff[0];\n      for(int i = 1; i<n; i++){\n        ans[i] = ans[i-1] + diff[i];\n      }\n      return ans;\n    }\n};\n```\n\n### [1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=1094&target=gitee)[思路](https://leetcode-cn.com/problems/car-pooling/#)\n\n假设你是一位顺风车司机，车上最初有 `capacity` 个空座位可以用来载客。由于道路的限制，车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**，你可以将其想象为一个向量）。\n\n这儿有一份乘客行程计划表 `trips[][]`，其中 `trips[i] = [num_passengers, start_location, end_location]` 包含了第 `i` 组乘客的行程信息：\n\n- 必须接送的乘客数量；\n- 乘客的上车地点；\n- 以及乘客的下车地点。\n\n这些给出的地点位置是从你的 **初始** 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。\n\n请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`）。\n\n \n\n**示例 1：**\n\n```\n输入：trips = [[2,1,5],[3,3,7]], capacity = 4\n输出：false\n```\n\n**示例 2：**\n\n```\n输入：trips = [[2,1,5],[3,3,7]], capacity = 5\n输出：true\n```\n\n```c++\nclass Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n      vector<int> diff(1001);\n      //diff不用初始化\n      for(int i = 0; i<trips.size(); i++){\n        int left = trips[i][1];\n        int right = trips[i][2] - 1;\n        int val = trips[i][0];\n        //jiajiajia\n        diff[left]+=val;\n        if(right + 1<1001)\n          diff[right+1] -= val;\n      }\n      vector<int> res(1001);\n      res[0] = diff[0];\n      if(res[0]>capacity) return 0;  //不要忘记\n      for(int i = 1; i<1001; i++){\n        res[i] = res[i-1] + diff[i];\n        if(res[i]>capacity)\n          return 0;\n      }\n      return 1;\n    }\n};\n```\n\n# 字典树\n\n### [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)\n\n难度困难450\n\n给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。\n\n \n\n**示例 1:**\n\n```\n输入: n = 13, k = 2\n输出: 10\n解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n```\n\n**示例 2:**\n\n```\n输入: n = 1, k = 1\n输出: 1\n```\n\n**提示:**\n\n- `1 <= k <= n <= 10e9`\n\n思路：\n\n1. 主要到此题数据量较大 不然可以直接使用sort   (对string)\n\n2. 字典树 统计节点个数 判断向下还是向右\n\n   <img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/v2-4af05d4805b7384eee3e7ab496940f75_r.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n   \n\n   - 首先我们初始化 cur = 1\n   - 然后我们让 left = cur，right = cur + 1，此时 right-left 就是第一棵树第一层的节点个数\n   - 接下来 left *= 10, right *= 10，这样就进入到了第二层，此时 right-left 就是第二层的节点个数，以此类推直到 left > n\n   - 但如果我们是统计 109 以内的字典序，进入第三层时，right 不能指向 200 而只能指向 109 (此时`right`也就是题目给定的范围个`n`)，**此时 right-left+1 才是当前层的节点个数**\n\n   假设我们统计完第一棵树的节点数为 node_num\n\n   - 如果 K >= node_num，我们需要继续向后查找，在后面的树中查找第 K-node_num 小的数字，也即更新 cur += 1\n   - 如果 K < node_num，说明第 K 小的数字在子树中，我们需要进入子树继续向下查找，也即更新 cur *= 10\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int findKthNumber(int n, int k) {\n        int curr = 1;\n        k--;\n        while(k>0){\n            //这里的left和right很巧妙的统计了下层节点的个数\n            long long left = curr;\n            long long right = curr + 1;\n            int node_num = 0;\n            // 统计树中每一层的节点个数\n            while(left<=n){\n                node_num += min(right, (long long)(n+1)) - left;\n                left*=10;\n                right*=10; \n            }\n            if(node_num<=k){// 向右查找\n                curr++;\n                k-=node_num;\n            }else{ // 进入子树查找\n                curr*=10;\n                k--;\n            }\n        }\n        return curr;\n    }\n};\n\n```\n\n","tags":["算法总结"]},{"title":"图论","url":"/2022/03/15/tu-lun/","content":"\n# 图论\n\n### [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)\n\n难度中等262收藏分享切换为英文接收动态反馈\n\n给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）\n\n `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_1.jpg)\n\n```\n输入：graph = [[1,2],[3],[3],[]]\n输出：[[0,1,3],[0,2,3]]\n解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/all_2.jpg)\n\n```\n输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n```\n\n#### 思路\n\n1. 类似多叉树的遍历\n2. for内for外两种写法\n\n#### 代码\n\n##### 两种写法\n\n1. ==push pop在for外 但是最后需要pop==\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> path;\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        traverse(graph, 0);\n        return res;\n    }\n\n    void traverse(vector<vector<int>>& graph, int s){\n        path.push_back(s);\n        \n        if(s == graph.size()-1){\n            res.push_back(path);\n            path.pop_back(); //！\n            return;\n        }\n\n        for(int v : graph[s]){\n            traverse(graph, v);\n        }\n        path.pop_back();\n    }\n};\n```\n\n2. <u>==push pop在for内 但是第一个元素需要先压入==</u>\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<int> path;\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        path.push_back(0);  //!\n        traverse(graph, 0);\n        return res;\n    }\n\n    void traverse(vector<vector<int>>& graph, int s){\n        if(s == graph.size()-1){\n            res.push_back(path);\n            return;\n        }\n\n        for(int v : graph[s]){\n            path.push_back(v);\n            traverse(graph, v);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [剑指 Offer II 111. 计算除法](https://leetcode.cn/problems/vlzXQL/)\n\n难度中等13\n\n给定一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。\n\n另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。\n\n返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。\n\n**注意：**输入总是有效的。可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。\n\n \n\n**示例 1：**\n\n```\n输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n解释：\n条件：a / b = 2.0, b / c = 3.0\n问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n```\n\n**示例 2：**\n\n```\n输入：equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n输出：[3.75000,0.40000,5.00000,0.20000]\n```\n\n#### 解法 建邻接表 dfs\n\n```c++\nclass Solution {\n    // equations中每一个equation，代表两者的相互关系已知，\n    // 用有向图保存，将equation中的两者间建边，边的权重分别为两者的商/商的倒数\n    // queries中，首先检查是否都出现过， 再检查是否联通\nprivate:\n    double dfs(unordered_map<string, vector<pair<string, double>>>& graph, unordered_set<string>& visted, string start, string end, double val){\n        if (start == end) \n            return val;\n\n        visted.insert(start); \n        // 遍历当前点能走到的所有点\n        for (auto& node : graph[start]){\n            if (!visted.count(node.first)) { \n                double res = dfs(graph, visted, node.first, end, node.second * val); \n                // res = -1代表该通路无解，如果该通路有解则返回\n                if (res > 0) {\n                    // 可以更新graph，方便下一次查找\n                    // graph[node.first].push_back\n                    return res; \n                }\n            }\n        }\n        return -1;\n    }\n\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        //快速查找的映射，key  是起点，value 是与 {该点联通的点终点, 权重}\n        unordered_map<string, vector<pair<string, double>>> graph; \n        for (int i = 0; i < equations.size(); ++i) { \n            graph[equations[i][0]].push_back({equations[i][1], values[i]});\n            graph[equations[i][1]].push_back({equations[i][0], 1 / values[i]}); \n        }\n\n        vector<double> res(queries.size(), -1.0); \n        unordered_set<string> visted;\n        for (int i = 0; i < queries.size(); ++i) {\n            // 首先两者确认都出现过\n            if (graph.count(queries[i][0]) && graph.count(queries[i][1])) { \n                // 因为是有环图，用visited来防止重复走\n                visted.clear();\n                res[i] = dfs(graph, visted, queries[i][0], queries[i][1], 1); //确定起点和终点，进入递归，起点终点可能相等，默认是 1\n            }\n        }\n        return res;\n    }\n};\n```\n\n\n\n## [环检测和拓扑排序](https://labuladong.gitee.io/algo/2/20/38/)\n\n### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=207&target=gitee)[思路](https://leetcode-cn.com/problems/course-schedule/#)\n\n你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。\n\n在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。\n\n- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。\n\n请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n```\n输入：numCourses = 2, prerequisites = [[1,0]]\n输出：true\n解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。\n```\n\n**示例 2：**\n\n```\n输入：numCourses = 2, prerequisites = [[1,0],[0,1]]\n输出：false\n解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。\n```\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<bool> visited;  //记录的是遍历过的 用于终止遍历 提高效率 不加会超时 用 visited 数组防止走回头路\n    vector<bool> onPath;   //记录每次遍历过的节点，用于查环\n    bool hasCycle;\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        //建图\n        vector<vector<int>> graph(numCourses);\n        for(auto edge: prerequisites){\n            int from = edge[1];\n            int to = edge[0];\n            graph[from].push_back(to);\n        }\n        visited = vector<bool>(numCourses, 0);\n        onPath = vector<bool>(numCourses, 0);\n        hasCycle = false;\n        for(int i = 0; i<numCourses; i++){\n            //遍历所有节点\n            traverse(graph, i);\n        }\n        return !hasCycle;\n    }\n\n    void traverse(vector<vector<int>>& graph, int s){\n        if(onPath[s]) //出现环\n            hasCycle = 1;\n        if(visited[s] || hasCycle)\n            return;\n        //前序代码位置\n        visited[s] = 1;\n        onPath[s] = 1;\n        for(int t : graph[s])\n            traverse(graph, t);\n        //后序遍历位置\n        onPath[s] = 0;\n    }\n};\n```\n\n### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=210&target=gitee)[思路](https://leetcode-cn.com/problems/course-schedule-ii/#)\n\n难度中等582收藏分享切换为英文接收动态反馈\n\n现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。\n\n- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。\n\n返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。\n\n \n\n**示例 1：**\n\n```\n输入：numCourses = 2, prerequisites = [[1,0]]\n输出：[0,1]\n解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。\n```\n\n**示例 2：**\n\n```\n输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n输出：[0,2,1,3]\n解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n```\n\n**示例 3：**\n\n```\n输入：numCourses = 1, prerequisites = []\n输出：[0]\n```\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<bool> visited;\n    vector<bool> onPath;\n    bool hasCycle;\n    vector<int> postOrder;\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        //建图\n        vector<vector<int>> graph(numCourses);\n        for(auto edge: prerequisites){\n            int from = edge[1];\n            int to = edge[0];\n            graph[from].push_back(to);\n        }\n        visited = vector<bool>(numCourses, 0);\n        onPath = vector<bool>(numCourses, 0);\n        hasCycle = false;\n        for(int i = 0; i<numCourses; i++){\n            //遍历所有节点\n            traverse(graph, i);\n        }\n        if(hasCycle)  return vector<int>{};\n        reverse(postOrder.begin(), postOrder.end());  //拓扑排序是后序遍历的反转 注意 后序的常规理解图的后序遍历\n        return postOrder;\n    }\n\n\n    void traverse(vector<vector<int>>& graph, int s){\n        if(onPath[s]) //出现环\n            hasCycle = 1;\n        if(visited[s] || hasCycle)\n            return;\n        //前序代码位置\n        visited[s] = 1;\n        onPath[s] = 1;\n        for(int t : graph[s])\n            traverse(graph, t);\n        //后序遍历位置\n        onPath[s] = 0;\n        postOrder.push_back(s); //记录后序遍历\n    }\n};\n```\n\n## [二分图判定](https://labuladong.gitee.io/algo/2/20/40/)\n\n### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=785&target=gitee)[思路](https://leetcode-cn.com/problems/is-graph-bipartite/#)\n\n难度中等347收藏分享切换为英文接收动态反馈\n\n存在一个 **无向图** ，图中有 `n` 个节点。其中每个节点都有一个介于 `0` 到 `n - 1` 之间的唯一编号。给你一个二维数组 `graph` ，其中 `graph[u]` 是一个节点数组，由节点 `u` 的邻接节点组成。形式上，对于 `graph[u]` 中的每个 `v` ，都存在一条位于节点 `u` 和节点 `v` 之间的无向边。该无向图同时具有以下属性：\n\n- 不存在自环（`graph[u]` 不包含 `u`）。\n- 不存在平行边（`graph[u]` 不包含重复值）。\n- 如果 `v` 在 `graph[u]` 内，那么 `u` 也应该在 `graph[v]` 内（该图是无向图）\n- 这个图可能不是连通图，也就是说两个节点 `u` 和 `v` 之间可能不存在一条连通彼此的路径。\n\n**二分图** 定义：如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B` ，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为 **二分图** 。\n\n如果图是二分图，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi2.jpg)\n\n```\n输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n输出：false\n解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/bi1.jpg)\n\n```\n输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。\n```\n\n#### 思路\n\n对整个图进行交替染色 若可以完全染色 则为二分图\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    // 给图上色 如果可以完全上色 则表示为二分图\n    bool isBipartite(vector<vector<int>>& graph) {\n        bool ok = 1;\n        int n = graph.size();\n        vector<bool> used(n, 0);\n        vector<bool> color(n, 0);\n        for(int v = 0; v<n; v++){\n            if(!used[v])\n                traverse(graph, v, used, color, ok);\n        }\n        return ok;\n    }\n\n    void traverse(vector<vector<int>>& graph, int v, vector<bool>& used, vector<bool>& color, bool& ok){\n        //如果确定不是二分图了 就不用再浪费时间遍历了\n        if(!ok) return;\n        used[v] = 1;\n        for(int w : graph[v]){\n            if(!used[w]){\n                color[w] = !color[v];\n                traverse(graph, w, used, color, ok);\n            }else{\n                if(color[w] == color[v]){\n                    ok = false;\n                }\n            }\n        }\n    }\n};\n```\n\n### [886. 可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=886&target=gitee)[思路](https://leetcode-cn.com/problems/possible-bipartition/#)\n\n难度中等161\n\n给定一组 `n` 人（编号为 `1, 2, ..., n`）， 我们想把每个人分进**任意**大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n\n给定整数 `n` 和数组 `dislikes` ，其中 `dislikes[i] = [ai, bi]` ，表示不允许将编号为 `ai` 和 `bi`的人归入同一组。当可以用这种方法将所有人分进两组时，返回 `true`；否则返回 `false`。\n\n \n\n\n\n**示例 1：**\n\n```\n输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]\n输出：true\n解释：group1 [1,4], group2 [2,3]\n```\n\n**示例 2：**\n\n```\n输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]\n输出：false\n```\n\n**示例 3：**\n\n```\n输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n输出：false\n```\n\n#### 思路\n\n1. 首先构造邻接表（细节， 编号为1-n）\n2. 上色\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    bool ans;\n    vector<bool> color;\n    vector<bool> visited;\n    //注意编号 1-n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        ans = 1;\n        color.resize(n+1);\n        visited = vector<bool>(n+1, 0);\n        vector<vector<int>> dislikess = buildGraph(dislikes,n);\n        for(int i = 1; i<=n; i++){\n            if(!visited[i])\n                traverse(dislikess, i);\n        }\n        return ans;\n    }\n\n    //这是一个双向图 你恨我 我恨你\n    vector<vector<int>> buildGraph(vector<vector<int>>& dislikes, int n){\n        vector<vector<int>> res(n+1);\n        for(int i  = 0; i<dislikes.size(); i++){\n            res[dislikes[i][0]].push_back(dislikes[i][1]);\n            res[dislikes[i][1]].push_back(dislikes[i][0]);\n        }\n        return res;\n    }\n\n    //上色函数 经典 完全一致\n    void traverse(vector<vector<int>>& dislikes, int index){\n       ·\n        visited[index] = 1;\n        for(int newIndex : dislikes[index]){\n            if(!visited[newIndex]){\n                color[newIndex] = !color[index];\n                traverse(dislikes, newIndex);\n            }else{\n                if(color[index] == color[newIndex])\n                    ans = 0;\n            }\n        }\n    }\n};\n```\n\n## 并查集（UNION-FIND）算法\n\n### 模板\n\n```c++\nclass UF {\nprivate:\n\t//连同分量的个数\n\tint cnt;\n\t// 存储每个节点的父节点\n\tvector<int> parent;\n\npublic:\n  // n 为图中节点的个数\n\tUF(int n) {\n\t\tcnt = n;\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tparent[i] = i;\n\t}\n\n\t//联通节点\n\tvoid unionn(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\tif (rootP == rootQ)\n\t\t\treturn;\n\t\tparent[rootQ] = rootP;\n\t\tcnt--;\n\t}\n\n\t// 判断节点 p 和节点 q 是否连通\n\tbool connected(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\treturn rootP == rootQ;\n\t}\n\n\t// 返回节点 x 的连通分量根节点\n\tint find(int x) {\n\t\twhile (parent[x] != x) {\n\t\t\t// 进行路径压缩\n\t\t\tparent[x] = parent[parent[x]];\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\n\t// 返回图中的连通分量个数\n\tint count() { return cnt; }\n};\n```\n\n### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)\n\n难度中等747\n\n有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。\n\n**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n\n给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。\n\n返回矩阵中 **省份** 的数量。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph1.jpg)\n\n```\n输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n输出：2\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/graph2.jpg)\n\n```\n输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n输出：3\n```\n\n#### 思路\n\n1. 标准的并查集题目 模板直接使用\n2. 转换成邻接表dfs\n3. 邻接图 dfs 按相连的逻辑去进行dfs 最优\n\n#### 代码\n\n1. 标准的并查集题目 模板直接使用\n\n```c++\nclass UF {\nprivate:\n\t//连同分量的个数\n\tint cnt;\n\t// 存储每个节点的父节点\n\tvector<int> parent;\n\npublic:\n    // n 为图中节点的个数\n\tUF(int n) {\n\t\tcnt = n;\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tparent[i] = i;\n\t}\n\n\t//联通节点\n\tvoid unionn(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\tif (rootP == rootQ)\n\t\t\treturn;\n\t\tparent[rootQ] = rootP;  //注意这里是parent的合并\n\t\tcnt--;\n\t}\n\n\t// 判断节点 p 和节点 q 是否连通\n\tbool connected(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\treturn rootP == rootQ;\n\t}\n\n\t// 返回节点 x 的连通分量根节点\n\tint find(int x) {\n\t\twhile (parent[x] != x) {\n\t\t\t// 进行路径压缩\n\t\t\tparent[x] = parent[parent[x]];\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\n\t// 返回图中的连通分量个数\n\tint count() { return cnt; }\n};\n\n\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        UF uf(isConnected.size());\n        for(int i = 0; i<isConnected.size(); i++){\n            for(int j = 0; j<isConnected[i].size(); j++){\n                if(isConnected[i][j])\n                    uf.unionn(i, j);\n            }\n        }\n        return uf.count();\n    }\n};\n```\n\n2. 转换成邻接表dfs\n\n```c++\nclass Solution {\npublic:\n    vector<bool> visited;\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        int ans = 0;\n        vector<vector<int>> graph = buildGraph(isConnected);\n        visited = vector<bool>(n, 0);\n        for(int i = 0; i<n; i++){\n            if(!visited[i]){\n                traverse(graph, i);\n                ans++;\n            }\n        }\n        return ans;\n    }\n\n    void traverse(vector<vector<int>>& graph, int index){\n        visited[index] = 1;\n        for(int newIndex : graph[index]){\n            if(!visited[newIndex]){\n                //如果使用全局ans 在此处--是不对的\n                traverse(graph, newIndex); \n            }\n        }\n    }\n\n    vector<vector<int>> buildGraph(vector<vector<int>>& isConnected){\n        vector<vector<int>> res(isConnected.size());\n        for(int i = 0; i<isConnected.size(); i++){\n            for(int j = 0; j<isConnected[i].size(); j++){\n                if(isConnected[i][j] == 1){\n                    res[i].push_back(j);\n                    res[j].push_back(i);\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n3. 邻接图 dfs\n\n```c++\nclass Solution {\npublic:\n    vector<bool> visited;\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        visited =vector<bool>(n, 0);\n        int ans = 0;\n        for(int i = 0; i< n; i++){\n            if(!visited[i]){\n                ans++;\n                dfs(isConnected, i);\n            }\n        }\n        return ans;\n    }\n    void dfs(vector<vector<int>>& isConnected, int nowPro){\n        visited[nowPro] = 1;\n        for(int i = 0; i<isConnected[nowPro].size(); i++){\n            if(!visited[i] && isConnected[nowPro][i] == 1){\n                dfs(isConnected, i);\n            }\n        }\n    }   \n};\n```\n\n\n\n### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=130&target=gitee)[思路](https://leetcode-cn.com/problems/surrounded-regions/#)\n\n难度中等750收藏分享切换为英文接收动态反馈\n\n给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/xogrid.jpg)\n\n```\n输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n```\n\n#### 思路\n\n1. dfs这也是比较常规的 四周开始\n2. 并查集 重点理解如何使用这种数据结构\n\n#### 代码\n\n##### dfs\n\n```c++\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        int m = board.size();\n        if(m == 0) return;\n        int n = board[0].size();\n        vector<vector<bool>> isIsland(m, vector<bool>(n, 0));\n        for(int i = 0; i<m; i++){\n            if(board[i][0] == 'O'){\n                effect(board, i, 0, isIsland);\n            }\n            if(board[i][n-1] == 'O'){\n                effect(board, i, n-1, isIsland);\n            }\n        }\n\n        for(int i = 0; i<n; i++){\n            if(board[0][i] == 'O'){\n                effect(board, 0, i, isIsland);\n            }\n            if(board[m-1][i] == 'O'){\n                effect(board, m-1, i, isIsland);\n            }\n        }\n\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(board[i][j] == 'O' && !isIsland[i][j])\n                    board[i][j] = 'X';\n            }\n        }\n    }\n\n    void effect(vector<vector<char>>& board, int x, int y, vector<vector<bool>>& isIsland){\n        //如果不加入island判断就会陷入死循环\n        if(x < 0 || y<0 || x>= board.size() || y>=board[0].size() || board[x][y]!='O' || isIsland[x][y]){\n            return;\n        }\n        isIsland[x][y] = 1;\n        effect(board, x+1, y, isIsland);\n        effect(board, x-1, y, isIsland);\n        effect(board, x, y+1, isIsland);\n        effect(board, x, y-1, isIsland);\n    }\n};\n```\n\n##### 并查集\n\n`使用node为节点进行连接 将网格上的节点映射到数值上`\n\n```c++\nclass UF{\nprivate:\n   vector<int> parent;\n\npublic:\n    UF(int n){\n        parent.resize(n);\n        for(int i = 0; i<n; i++){\n            parent[i] = i;\n        }\n    }\n\n    void unionn(int p, int q){\n        int rootP = find(p);\n        int rootQ = find(q);\n        if(rootP == rootQ) return;\n        parent[rootP] = rootQ;\n    }\n\n    bool connected(int p, int q){\n        int rootP = find(p);\n        int rootQ = find(q);\n        return rootQ == rootP;\n    }\n\n    int find(int x){\n        while(parent[x]!= x){\n            parent[x] = parent[parent[x]];\n            x = parent[x];\n        }\n        return x;\n    }\n};\n\n\nclass Solution {\npublic:\n    int m;\n    int n;\n\n    void solve(vector<vector<char>>& board) {\n        m = board.size();\n        n = board[0].size();\n        UF uf(m*n+1);\n        int dumpyNode = m*n;\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(board[i][j] == 'O'){\n                    if(i == 0 || j == 0 || i == m-1 || j == n-1)\n                        uf.unionn(dumpyNode, node(i, j));\n                    else{\n                    //里面的和上下左右联通\n                    if(i>0 && board[i-1][j] == 'O')\n                        uf.unionn(node(i, j), node(i-1, j));\n                    if(j>0 && board[i][j-1] == 'O')\n                        uf.unionn(node(i, j), node(i, j-1));\n                    if(i<m-1 && board[i+1][j] == 'O')\n                        uf.unionn(node(i, j), node(i+1, j));\n                    if(j<n-1 && board[i][j+1] == 'O')\n                        uf.unionn(node(i, j), node(i, j+1));\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(uf.connected(node(i, j), dumpyNode))\n                    board[i][j] = 'O';\n                else board[i][j] = 'X';\n            }\n        }\n    }\n\n    int node(int x, int y){\n        return  x*n + y;\n    }\n};\n```\n\n### [剑指 Offer II 118. 多余的边](https://leetcode.cn/problems/7LpjUW/)\n\n难度中等23收藏分享切换为英文接收动态反馈\n\n树可以看成是一个连通且 **无环** 的 **无向** 图。\n\n给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。\n\n请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的边。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676174-hOEVUL-image.png)\n\n```\n输入: edges = [[1,2],[1,3],[2,3]]\n输出: [2,3]\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626676179-kGxcmu-image.png)\n\n```\n输入: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n输出: [1,4]\n```\n\n#### 解法 使用并查集\n\n重复连接的情况下 就直接返回\n\n```c++\nclass UF {\nprivate:\n\t//连同分量的个数\n\tint cnt;\n\t// 存储每个节点的父节点\n\tvector<int> parent;\n\npublic:\n  // n 为图中节点的个数\n\tUF(int n) {\n\t\tcnt = n;\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tparent[i] = i;\n\t}\n\n\t//联通节点\n\tvoid unionn(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\tif (rootP == rootQ)\n\t\t\treturn;\n\t\tparent[rootQ] = rootP;\n\t\tcnt--;\n\t}\n\n\t// 判断节点 p 和节点 q 是否连通\n\tbool connected(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\treturn rootP == rootQ;\n\t}\n\n\t// 返回节点 x 的连通分量根节点\n\tint find(int x) {\n\t\twhile (parent[x] != x) {\n\t\t\t// 进行路径压缩\n\t\t\tparent[x] = parent[parent[x]];\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\n\t// 返回图中的连通分量个数\n\tint count() { return cnt; }\n};\n\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n      UF uni(edges.size() + 1);\n      for(auto edge : edges){\n        int node1 = edge[0], node2 = edge[1];\n        if(!uni.connected(node1, node2))\n          uni.unionn(node1, node2);\n        else return edge;\n      }\n      return vector<int>{};\n    }\n};\n```\n\n# [Kruskal 最小生成树算法](https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w)\n\n所谓最小生成树，就是图中若干边的集合（这个集合为 `mst`，最小生成树的英文缩写），你要保证这些边：\n\n1、包含图中的所有节点。\n\n2、形成的结构是树结构（即不存在环）。\n\n3、权重和最小。\n\n### 1135.最低成本联通所有城市\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514145218925.png\" alt=\"image-20220514145218925\" style=\"zoom: 80%;\" />\n\n#### 思路\n\n每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。\n\n树的判定算法加上按权重排序的逻辑就变成了 Kruskal 算法\n\n#### 代码\n\n```c++\nclass UF {\nprivate:\n\t//连同分量的个数\n\tint cnt;\n\t// 存储每个节点的父节点\n\tvector<int> parent;\n\npublic:\n  // n 为图中节点的个数\n\tUF(int n) {\n\t\tcnt = n;\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tparent[i] = i;\n\t}\n\n\t//联通节点\n\tvoid unionn(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\tif (rootP == rootQ)\n\t\t\treturn;\n\t\tparent[rootQ] = rootP;\n\t\tcnt--;\n\t}\n\n\t// 判断节点 p 和节点 q 是否连通\n\tbool connected(int p, int q) {\n\t\tint rootP = find(p);\n\t\tint rootQ = find(q);\n\t\treturn rootP == rootQ;\n\t}\n\n\t// 返回节点 x 的连通分量根节点\n\tint find(int x) {\n\t\twhile (parent[x] != x) {\n\t\t\t// 进行路径压缩\n\t\t\tparent[x] = parent[parent[x]];\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\n\t// 返回图中的连通分量个数\n\tint count() { return cnt; }\n};\n\nclass Solution {\npublic:\n    int minimumCost(int n, vector<vector<int>>& connections) {\n      UF uni(connections.size() + 1);\n      int mst = 0;\n      auto cmp = [](vector<int>& a, vector<int>& b){ return a[2] < b[2]; };\n      sort(connections.begin(), connections.end(), cmp);\n      for(auto edge : connections){\n        int node1 = edge[0], node2 = edge[1];\n        int weight = edge[2];\n        //判断parent是否相同\n        if(uni.connected(node1, node2))\n          continue;\n       \tmst += weight;\n        uni.unionn(node1, node2);\n      }\n      // 因为节点 0 没有被使用，所以 0 会额外占用一个连通分量\n      return uni.count() == 2 ? mst : -1;\n    }\n};\n```\n\n### [1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)\n\n[labuladong 题解](https://labuladong.github.io/article/?qno=1584)[思路](https://leetcode.cn/problems/min-cost-to-connect-all-points/#)\n\n难度中等204\n\n给你一个`points` 数组，表示 2D 平面上的一些点，其中 `points[i] = [xi, yi]` 。\n\n连接点 `[xi, yi]` 和点 `[xj, yj]` 的费用为它们之间的 **曼哈顿距离** ：`|xi - xj| + |yi - yj|` ，其中 `|val|` 表示 `val` 的绝对值。\n\n请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/d.png)\n\n输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\n输出：20\n解释：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/c.png)\n\n我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。\n注意到任意两个点之间只有唯一一条路径互相到达。\n\n\n\n#### 解法 并查集 Kruskai\n\n```c++\nclass Union{\n  vector<int> parent;\n  int cnt;\npublic:\n  Union(int n){\n    cnt = n;\n    parent.resize(n);\n    for(int i = 0; i<n; i++)\n      parent[i] = i;\n  }\n\n  void unionn(int node1, int node2){\n    int root1 = find(node1);\n    int root2 = find(node2);\n    if(root1 == root2)\n      return;\n    parent[root1] = root2;\n    cnt--;\n  }\n\n  int find(int x){\n    while(parent[x] != x){\n      parent[x] = parent[parent[x]];\n      x = parent[x];\n    }\n    return x;\n  }\n  \n  int count(){return cnt;}\n};\n\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n      int n = points.size();\n      vector<vector<int>> all;\n      for(int i = 0; i<n; i++){\n        for(int j = i+1; j<n; j++){\n          vector<int> temp(3);\n          temp[0] = i;\n          temp[1] = j;\n          int diss = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);\n          temp[2] = diss;\n          all.push_back(temp);\n          // cout<<diss<<\" \";\n        }\n      }\n      // cout<<endl;\n      auto cmp = [](vector<int>& a, vector<int>& b){ return a[2] < b[2]; };\n      sort(all.begin(), all.end(), cmp);\n      Union uni(n);\n      int ans = 0;\n      for(int i = 0; i<all.size(); i++){\n        int node1 = all[i][0];\n        int node2 = all[i][1];\n        int weight = all[i][2];\n        // cout<<weight<<\" \";\n        if(uni.find(node1) == uni.find(node2))\n          continue;\n        uni.unionn(node1, node2);\n        ans += weight;\n      }\n      return ans;\n    }\n};\n```\n\n# 名流问题：邻接矩阵\n\n图有两种存储形式，一种是邻接表，一种是邻接矩阵，邻接表的主要优势是节约存储空间；邻接矩阵的主要优势是可以迅速判断两个节点是否相邻。\n\n对于名人问题，显然会经常需要判断两个人之间是否认识，也就是两个节点是否相邻，所以我们可以用邻接表来表示人和人之间的社交关系。\n\n那么，把名流问题描述成算法的形式就是这样的：\n\n给你输入一个大小为 `n x n` 的二维数组（邻接矩阵） `graph` 表示一幅有 `n` 个节点的图，每个人都是图中的一个节点，编号为 `0` 到 `n - 1`。\n\n如果 `graph[i][j] == 1` 代表第 `i` 个人认识第 `j` 个人，如果 `graph[i][j] == 0` 代表第 `i` 个人不认识第 `j` 个人。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220514162922825.png\" alt=\"image-20220514162922825\" style=\"zoom:67%;\" />\n\n从这个邻接矩阵来看，0认识2 1认识2.。。而2只认识自己 不认识其他人，所以2是名人\n\n### 277. [搜寻名人](https://leetcode-cn.com/problems/find-the-celebrity/)\n\n只告诉你总人数 `n`，同时提供一个 API `knows` 来查询人和人之间的社交关系：\n\n```c++\n// 可以直接调用，能够返回 i 是否认识 j\nbool knows(int i, int j);\n\n// 请你实现：返回「名人」的编号\nint findCelebrity(int n) {\n    // todo\n}\n```\n\n#### 暴力解法\n\n```c++\nclass Solution{\npublic:\n  int findCelebrity(int n){\n    for(int cand = 0; cand < n; cand++){\n      int other;\n      for(other = 0; other<n; other++){\n        if(cand == other) continue;\n        if(knows(cand, other) || !knows(other, cand))\n          break;\n      }\n      if(other == n) //cand下other遍历完 说明满足\n        return cand;\n    }\n    return -1；\n  }\n};\n```\n\n#### 优化解法\n\n##### 排除法\n\n先一次遍历：如果当前认识其他 或者 其他不认识他 那么他肯定不是名人\n\n```c++\nclass Solution{\npublic:\n\tint findCelebrity(int n) {\n    if (n == 1) return 0;\n    // 将所有候选人装进队列\n    queue<int> que;\n    for (int i = 0; i < n; i++) {\n        que.push(i);\n    }\n    // 一直排除，直到只剩下一个候选人停止循环\n    while (que.size() >= 2) {\n        // 每次取出两个候选人，排除一个\n        int cand = que.front();\n      \tque.pop();\n        int other = que.front();\n      \tque.pop();\n        if (knows(cand, other) || !knows(other, cand)) {\n            // cand 不可能是名人，排除，让 other 归队\n            que.push(other);\n        } else {\n            // other 不可能是名人，排除，让 cand 归队\n            que.push(cand);\n        }\n    }\n\n    // 现在排除得只剩一个候选人，判断他是否真的是名人\n    int cand = que.front();\n    que.pop();\n    for (int other = 0; other < n; other++) {\n        if (other == cand) {\n            continue;\n        }\n        // 保证其他人都认识 cand，且 cand 不认识任何其他人\n        if (!knows(other, cand) || knows(cand, other)) {\n            return -1;\n        }\n    }\n    // cand 是名人\n    return cand;\n\t}\n};\n```\n\n```c++\nint findCelebrity(int n) {\n    // 先假设 cand 是名人\n    int cand = 0;\n    for (int other = 1; other < n; other++) {\n        if (!knows(other, cand) || knows(cand, other)) {\n            // cand 不可能是名人，排除\n            // 假设 other 是名人\n            cand = other;\n        } else {\n            // other 不可能是名人，排除\n            // 什么都不用做，继续假设 cand 是名人\n        }\n    }\n\n    // 现在的 cand 是排除的最后结果，但不能保证一定是名人\n    for (int other = 0; other < n; other++) {\n        if (cand == other) continue;\n        // 需要保证其他人都认识 cand，且 cand 不认识任何其他人\n        if (!knows(other, cand) || knows(cand, other)) {\n            return -1;\n        }\n    }\n\n    return cand;\n}\n```\n\n","tags":["算法总结"]},{"url":"/2022/03/15/lian-biao/","content":"# 链表\n\n## 单链表解题套路\n\n### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=21&target=gitee)[思路](https://leetcode-cn.com/problems/merge-two-sorted-lists/#)\n\n难度简单2259\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203121556763.jpeg)\n\n```\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n**示例 2：**\n\n```\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 两个链表的节点数目范围是 `[0, 50]`\n- `-100 <= Node.val <= 100`\n- `l1` 和 `l2` 均按 **非递减顺序** 排列\n\n#### 思路\n\n1. 虚拟头节点占位\n2. while循环&& 交替前进 \n3. [1 2 3] [4 5 6] 这种情况 会先遍历完第一个 然后在后面的if判断中 拼接第二个list\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n      ListNode* pre = new ListNode(0);\n      ListNode* curr = pre;\n      while(list1 && list2){\n        if(list1->val < list2->val){\n          curr->next = list1;\n          list1 = list1->next;\n        }else{\n          curr->next = list2;\n          list2 = list2->next;         \n        }\n        curr = curr->next;\n      }\n      if(list1) curr->next = list1;\n      if(list2) curr->next = list2;\n      return pre->next;\n    }\n};\n```\n\n### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=23&target=gitee)[思路](https://leetcode-cn.com/problems/merge-k-sorted-lists/#)\n\n难度困难1803收藏分享切换为英文接收动态反馈\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n \n\n**示例 1：**\n\n```\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n```\n\n#### 思路\n\n1. 顶堆解法 （笨一点的解法 vector sort）\n2. 循环merger two list\n\n#### 顶堆解法\n\n```c++\nclass Solution {\npublic:\n    struct Status {\n        int val;\n        ListNode *ptr;\n        //return 1 表示左边形参优先级低 靠后放  例如  <  (1, 3) return 1>3 左边优先级高 往前放 就是升序排列 小顶堆\n        bool operator < (const Status &rhs) const {\n            return val > rhs.val;\n        }\n    };\n\n    priority_queue <Status> q;\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        //所有非空链表 压入queue\n        for (auto node: lists) {\n            if (node) q.push({node->val, node});\n        }\n        //注意 这里这样写 一方面可以做到虚拟头的备份\n        //另一方面 可以保证虚拟头被析构\n        ListNode head, *tail = &head;\n        while (!q.empty()) {\n            //顶堆用的时候都是先top 再pop\n            auto f = q.top(); q.pop(); \n            tail->next = f.ptr; \n            tail = tail->next;\n            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\n        }\n        return head.next;\n    }\n};\n```\n\n#### <u>涉及到的知识点</u>\n\n1. 顶堆的一般用法，即先top存储临时变量，再pop\n\n2. [顶堆的自定义数据结构和比较方式](https://www.cnblogs.com/shona/p/12163381.html)\n\n   > 这里用到的就是封装到一个struct ，重载他的<，\n   >\n   > 顶堆的排序方式是按照<进行比较排序，返回为1时，左边形参的优先级低于右边形参 表现为升序 小顶堆\n\n#### 双链表merge解法\n\n```c++\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n        if ((!a) || (!b)) return a ? a : b;\n        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n        while (aPtr && bPtr) {\n            if (aPtr->val < bPtr->val) {\n                tail->next = aPtr; aPtr = aPtr->next;\n            } else {\n                tail->next = bPtr; bPtr = bPtr->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = (aPtr ? aPtr : bPtr);\n        return head.next;\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        ListNode *ans = nullptr;\n        for (size_t i = 0; i < lists.size(); ++i) {\n            ans = mergeTwoLists(ans, lists[i]);\n        }\n        return ans;\n    }\n};\n```\n\n### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)\n\n输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n\n例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。\n\n \n\n**示例：**\n\n```\n给定一个链表: 1->2->3->4->5, 和 k = 2.\n\n返回链表 4->5.\n```\n\n#### 思路\n\n1. 笨解法 一次遍历记录长度，一次遍历计算结果\n2. 一次遍历 fast先走k，然后slow fast 同时前进 直到fast为空\n\n```cpp\nclass Solution {\npublic:\n  \t//两次遍历\n    ListNode* getKthFromEnd(ListNode* head, int k) {\n      int length = 0;\n      ListNode* cpy = head;\n      while(cpy){\n        length++;\n        cpy = cpy->next;\n      }\n      ListNode* node = head;\n      while(node){\n        if(length == k)\n          return node;\n        node = node->next;\n        length--;\n      }\n      return nullptr;\n    }\n\n  \t//一次遍历\n    ListNode* getKthFromEnd(ListNode* head, int k) {\n      ListNode* fast = head;\n      int step = 0;\n      while(fast){\n        step++;\n        fast = fast->next;\n        if(step == k){\n          break;\n        }        \n      }\n      ListNode* slow = head;\n      while(fast){\n        fast = fast->next;\n        slow = slow->next;\n      }\n      return slow;\n    }\n};\n```\n\n### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=19&target=gitee)[思路](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/#)\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203121922903.jpeg)\n\n```\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1], n = 1\n输出：[]\n```\n\n#### 思路\n\n1. 笨比遍历\n2. 一次遍历 但是要注意 ==可能会删除头节点 所以遍历应该使用虚拟头==\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n  \t//笨比遍历法\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* cur = head;\n        int i = 0;\n        while(cur->next != NULL){\n            i++;\n            cur = cur->next;\n        }\n        int j = 0;\n        ListNode* curr = head;\n        while(j<=i-n-1){\n            if (j == i-n-2) curr->next = curr->next->next;\n            j++;\n        }\n        return head;\n    }\n\t//一次遍历法\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n      ListNode* pre = new ListNode(-1);\n      pre->next = head;\n      ListNode* fast = pre;\n      int pos = 0;\n      for(int i = 0; i<n+1; i++)\n        fast = fast->next;\n      ListNode* slow = pre;\n      while(fast){\n        slow = slow->next;\n        fast = fast->next;\n      }\n      slow->next = slow->next->next;\n      return pre->next;\n    }\n};\n```\n\n### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=876&target=gitee)[思路](https://leetcode-cn.com/problems/middle-of-the-linked-list/#)\n\n难度简单505\n\n给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n \n\n**示例 1：**\n\n```\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n```\n\n**示例 2：**\n\n```\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点\n```\n\n#### 思路\n\n1. 笨比\n2. 快慢指针 注意判断条件  ==while(fast && fast->next)==\n\n#### 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        int n = 0;\n        ListNode* cur = head;\n        while (cur != nullptr) {\n            ++n;\n            cur = cur->next;\n        }\n        int k = 0;\n        cur = head;\n        while (k < n / 2) {\n            ++k;\n            cur = cur->next;\n        }\n        return cur;\n    }\n\n    ListNode* middleNode(ListNode* head) {\n      ListNode* slow = head;\n      ListNode* fast = head;\n      while(fast && fast->next){  //刚开始准备重新用！就尼玛用混了 老老实实==nullptr吧\n        fast = fast->next->next;\n        slow = slow->next;\n      }\n      return slow;\n    }\n};\n```\n\n### 链表环问题\n\n#### 1. 判断是否有环\n\n- 哈希\n- 「Floyd 判圈算法」（又称龟兔赛跑算法）\n- 奇葩方法：修改节点的值\n\n**代码**\n\n```c++\n//hash\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_set<ListNode*> sett;\n        ListNode* cur = head;\n        while(cur){\n            if(sett.count(cur)) return 1;\n            sett.insert(cur);\n            cur = cur->next;\n        }\n        return 0;\n    }\n};\n//龟兔赛跑\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head == NULL) return false;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != NULL && fast->next!= NULL)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(fast == slow) return true;\n        }\n        return false;\n    }\n};\n//修改节点值的判圈方法\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n      while(head){\n        if(head->val == '12458256442311234856461')\n          return 1;\n        else head->val = '12458256442311234856461';\n        head = head->next;\n      }\n      return 0;\n    }\n};\n```\n\n#### 2. [环的位置](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：\n\n[![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122004655.jpeg)](https://labuladong.gitee.io/algo/images/双指针/3.jpeg)\n\n`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。\n\n假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。\n\n巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：\n\n[![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122004506.jpeg)](https://labuladong.gitee.io/algo/images/双指针/2.jpeg)\n\n所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。\n\n**代码**\n\n```c++\n// hash\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      unordered_set <ListNode*> set;\n      while(head != NULL){\n        if (set.count(head)) return head;\n          set.insert(head);\n          head = head->next;\n        }\n      return nullptr;\n    }\n};\n//数学\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      ListNode* fast = head;\n      ListNode* slow = head;\n      while(fast && fast->next){\n        fast = fast->next->next;\n        slow = slow->next;\n        if(fast == slow) break;\n      }\n\n      //判断是否有环\n      if(fast == nullptr || fast->next == nullptr)\n        return nullptr;\n\n      fast = head; //重新指向头节点\n      while(slow != fast){\n        fast = fast->next;\n        slow = slow->next;\n      }\n      return slow;\n    }\n};\n```\n\n### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=160&target=gitee)[思路](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/#)\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122026344.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**自定义评测：**\n\n**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n\n- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n- `listA` - 第一个链表\n- `listB` - 第二个链表\n- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n\n#### 思路\n\n1. 笨比hash\n2. 挺神奇的首尾相连\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122027928.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n```c++\nclass Solution {\npublic:\n  \t//笨比hash\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      unordered_set<ListNode*> sett;\n      while(headA){\n        sett.insert(headA);\n        headA = headA->next;\n      }\n      while(headB){\n        if(sett.count(headB))\n          return headB;\n        headB = headB->next;\n      }\n      return nullptr;\n    }\n\t\t//首尾相接\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      if (headA == nullptr || headB == nullptr) {\n        return nullptr;\n      }\n      ListNode *pA = headA, *pB = headB;\n      while (pA != pB) {\n        pA = pA == nullptr ? headB : pA->next;\n        pB = pB == nullptr ? headA : pB->next;\n      }\n      return pA;    \n    }\n};\n```\n\n#### [剑指 Offer II 026. 重排链表](https://leetcode-cn.com/problems/LGjMqU/)\n\n难度中等47英文版讨论区\n\n给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：\n\n` L0 → L1 → … → Ln-1 → Ln `\n请将其重新排列后变为：\n\n```\nL0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n```\n\n不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n**示例 1:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626420311-PkUiGI-image.png)\n\n```\n输入: head = [1,2,3,4]\n输出: [1,4,2,3]\n```\n\n**示例 2:**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1626420320-YUiulT-image.png)\n\n```\n输入: head = [1,2,3,4,5]\n输出: [1,5,2,4,3]\n```\n\n#### 思路\n\n1. 找中点 截断 反转后半部分、\n\n2. - 按照官方题解找中间节点\n     1 2 3 4 5\n     变为\n     1 2 3\n     5 4\n     但是\n     1 2 3 4 5 6\n     变为\n     1 2 3 4\n     6 5\n     这样拼接没什么问题 因为3->4本身就是连接的 无需再更改指向了\n\n   - 也可以 找中间节点的时候 按链表长度的奇偶性返回\n\n     ```c++\n     ListNode* findMiddle(ListNode* head){\n         ListNode* slow = head;\n         ListNode* fast = head;\n         ListNode* preSlow;\n         while(fast && fast->next){\n             preSlow = slow;\n             slow = slow->next;\n             fast = fast->next->next;\n         }\n         //奇数节点返回中间 偶数返回中间前一个\n         return fast == nullptr?preSlow:slow;\n     }\n     ```\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* reversList(ListNode* head){\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        ListNode* last = reversList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return last;\n    }\n\n    ListNode* findMiddle(ListNode* head){\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* preSlow;\n        while(fast && fast->next){\n            preSlow = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        //奇数节点返回中间 偶数返回中间前一个\n        return fast == nullptr?preSlow:slow;\n        //return slow  //没什么问题 因为最终默认指向了 无需更改\n    }\n\n    void mergeList(ListNode* l1, ListNode* l2) {\n        ListNode* l1_tmp;\n        ListNode* l2_tmp;\n        while (l1 != nullptr && l2 != nullptr) {\n            //存储下一个节点\n            l1_tmp = l1->next;\n            l2_tmp = l2->next;\n            //l1指向l2 并更新l1\n            l1->next = l2;\n            l1 = l1_tmp;\n            //l2指向新的l1(也就是l1temp) 并更新l2\n            l2->next = l1;\n            l2 = l2_tmp;\n        }\n    }\n\n    void reorderList(ListNode* head) {\n        ListNode* l1 = head;\n        ListNode* middle = findMiddle(head);\n        ListNode* l2 = reversList(middle->next);\n        middle->next = nullptr;  //切断 并且保证l1的长度>=l2 且长度差最大为1\n        mergeList(l1, l2);\n    }\n};\n```\n\n## 递归反转链表\n\n### [206. 反转整个链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=206&target=gitee)\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122035241.jpeg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122035302.jpeg)\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n#### 思路\n\n1. while循环迭代\n2. 递归反转整个链表\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122221482.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122221914.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122222312.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n\n\n#### 代码\n\n```C++\nclass Solution {\npublic:\n    //while迭代\n    ListNode* reverseList(ListNode* head) {\n      ListNode* cur = head;\n      ListNode* pre = nullptr;\n      ListNode* temp;\n      while(cur){\n        temp = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = temp;\n      }\n      return pre;\n    }\n};\n\nclass Solution {\npublic:\n    //递归\n    ListNode* reverseList(ListNode* head) {\n      //注意head == nullptr是判断传进来的链表为空\n      //注意head->next == nullptr是真正的base case\n      if(head == nullptr || head->next == nullptr)\n        return head;\n      ListNode* last = reverseList(head->next);\n      //nmb 秀到头晕\n      head->next->next = head;\n      head->next = nullptr;\n      return last;\n    }\n};\n```\n\n### 反转链表前 N 个节点\n\n*// 将链表的前 n 个节点反转（n <= 链表长度）*\n\n比如说对于下图链表，执行 `reverseN(head, 3)`：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/6.jpg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n解决思路和反转整个链表差不多，只要稍加修改即可：\n\n#### 代码\n\n```c++\nListNode* successor = nullptr; // 后驱节点\n// 反转以 head 为起点的 n 个节点，返回新的头结点\nListNode* reverseN(ListNode* head, int n) {\n    if (n == 1) {\n        // 记录第 n + 1 个节点\n        successor = head.next;\n        return head;\n    }\n    // 以 head.next 为起点，需要反转前 n - 1 个节点\n    ListNode* last = reverseN(head->next, n - 1);\n    head->next->next = head;\n    // 让反转之后的 head 节点和后面的节点连起来\n    head->next = successor;\n    return last;\n}\n```\n\n#### 具体的区别：\n\n1、base case 变为 `n == 1`，反转一个元素，就是它本身，同时**要记录后驱节点**。\n\n2、刚才我们直接把 `head.next` 设置为 null，因为整个链表反转后原来的 `head` 变成了整个链表的最后一个节点。但现在 `head` 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 `successor`（第 n + 1 个节点），反转之后将 `head` 连接上。\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122323670.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\n\nOK，如果这个函数你也能看懂，就离实现「反转一部分链表」不远了。\n\n\n\n### [92. 反转链表的一部分](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n\n给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n\n示例 1：\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203122331490.jpeg)\n\n输入：head = [1,2,3,4,5], left = 2, right = 4\n输出：[1,4,3,2,5]\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n      if(left == 1)\n        return reverseN(head, right);\n      //前进到反转的起点触发basecase\n      //left和right一起向前移动，right要跟随着left-- \n      //因为right表示的是位置，N的长度应该是移动left为头的 right跟着减的长度\n      head->next = reverseBetween(head->next, left-1, right-1);\n      return head;\n    }\n\n    ListNode* successor; // 后驱节点\n    // 反转以 head 为起点的 n 个节点，返回新的头结点\n    ListNode* reverseN(ListNode* head, int n){\n      if(n == 1){\n        // 记录第 n + 1 个节点\n        successor = head->next;\n        return head;\n      }\n      // 记录第 n + 1 个节点\n      ListNode* last = reverseN(head->next, n-1);\n      head->next->next = head;\n      // 记录第 n + 1 个节点\n      head->next = successor;\n      return last;\n    }\n};\n```\n\n详细的迭代写法\n\n```c++\nclass Solution {\nprivate:\n    void reverseLinkedList(ListNode *head) {\n        // 也可以使用递归反转一个链表\n        ListNode *pre = nullptr;\n        ListNode *cur = head;\n\n        while (cur != nullptr) {\n            ListNode *next = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = next;\n        }\n    }\n\npublic:\n    ListNode *reverseBetween(ListNode *head, int left, int right) {\n        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论\n        ListNode *dummyNode = new ListNode(-1);\n        dummyNode->next = head;\n\n        ListNode *pre = dummyNode;\n        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点\n        // 建议写在 for 循环里，语义清晰\n        for (int i = 0; i < left - 1; i++) {\n            pre = pre->next;\n        }\n\n        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点\n        ListNode *rightNode = pre;\n        for (int i = 0; i < right - left + 1; i++) {\n            rightNode = rightNode->next;\n        }\n\n        // 第 3 步：切断出一个子链表（截取链表）\n        ListNode *leftNode = pre->next;\n        ListNode *curr = rightNode->next;\n\n        // 注意：切断链接\n        pre->next = nullptr;\n        rightNode->next = nullptr;\n\n        // 第 4 步：同第 206 题，反转链表的子区间\n        reverseLinkedList(leftNode);\n\n        // 第 5 步：接回到原来的链表中\n        pre->next = rightNode;\n        leftNode->next = curr;\n        return dummyNode->next;\n    }\n};\n```\n\n## 如何 K 个一组反转链表\n\n### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=25&target=gitee)[思路](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/#)\n\n难度困难1520\n\n给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。\n\n*k* 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n**进阶：**\n\n- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130004385.jpeg)\n\n```\n输入：head = [1,2,3,4,5], k = 2\n输出：[2,1,4,3,5]\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130004388.jpeg)\n\n```\n输入：head = [1,2,3,4,5], k = 3\n输出：[3,2,1,4,5]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2,3,4,5], k = 1\n输出：[1,2,3,4,5]\n```\n\n**示例 4：**\n\n```\n输入：head = [1], k = 1\n输出：[1]\n```\n\n难理解但是写起来相对简单的解法\n\n```c++\nclass Solution {\npublic:\n    /** 反转区间 [a, b) 的元素，注意是左闭右开 */\n    ListNode* reverse(ListNode* a, ListNode* b) {\n      ListNode* pre;\n      ListNode* cur;\n      ListNode* nxt;\n      pre = nullptr; cur = a; nxt = a;\n      // while 终止的条件改一下就行了\n      while (cur != b) {\n        nxt = cur->next;\n        cur->next = pre;\n        pre = cur;\n        cur = nxt;\n      }\n      // 返回反转后的头结点\n      return pre;\n    }\n    ListNode* reverseKGroup(ListNode* head, int k) {\n      if(head == nullptr) return nullptr;\n      ListNode* a;\n      ListNode* b;\n      a = b = head;\n      for(int i = 0; i<k; i++){\n        if(b == nullptr) return head;\n        b = b->next;\n      }\n      ListNode* newHead = reverse(a, b);\n      a->next = reverseKGroup(b, k);\n      return newHead;\n    }\n};\n```\n\n\n\n解释一下 `for` 循环之后的几句代码，注意 `reverse` 函数是反转区间 `[a, b)`，所以情形是这样的：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130047155.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n递归部分就不展开了，整个函数递归完成之后就是这个结果，完全符合题意：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130047037.jpeg\" alt=\"img\" style=\"zoom:50%;\" />\n\n#### 好理解但是写起来困难的解法\n\n```c++\nclass Solution {\npublic:\n    // 翻转一个子链表，并且返回新的头与尾\n    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {\n        //ListNode* prev = tail->next; //这个指向没有任何作用,函数外面添加了指向\n        ListNode* prev;\n        ListNode* p = head;\n\n        //不能使用p!=tail->next,这是因为tail->next指向发生了更改\n        //不能while(p) 因为p只有有链接\n        while (prev != tail) { //pre <- p 这样循环向前移动的\n            ListNode* nex = p->next;\n            p->next = prev;\n            prev = p;\n            p = nex;\n        }\n        return {tail, head};\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* hair = new ListNode(0);\n        hair->next = head;\n        ListNode* pre = hair;\n\n        while (head) {\n            ListNode* tail = pre;\n            // 查看剩余部分长度是否大于等于 k\n            for (int i = 0; i < k; ++i) {\n                tail = tail->next;\n                if (!tail) {\n                    return hair->next;  //不足k，此区域不反转 直接返回\n                }\n            }\n            ListNode* nexHead = tail->next;  //区域外的下一区域的头\n            // 这里是 C++17 的写法，也可以写成\n            // pair<ListNode*, ListNode*> result = myReverse(head, tail);\n            // head = result.first;\n            // tail = result.second;\n            tie(head, tail) = myReverse(head, tail);\n            // 把子链表重新接回原链表\n            pre->next = head;\n            tail->next = nexHead;\n            pre = tail;\n            head = nexHead;\n        }\n        return hair->next;\n    }\n};\n```\n\n## 如何判断回文链表\n\n### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n[labuladong 题解](https://labuladong.gitee.io/plugin-v4/?qno=234&target=gitee)[思路](https://leetcode-cn.com/problems/palindrome-linked-list/#)\n\n难度简单1293\n\n给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130110029.jpeg)\n\n```\n输入：head = [1,2,2,1]\n输出：true\n```\n\n**示例 2：**\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/202203130110233.jpeg)\n\n```\n输入：head = [1,2]\n输出：false\n```\n\n#### 代码\n\n```c++\nclass Solution {\n\tpublic:\n    //辅助容器\n\t  bool isPalindrome(ListNode* head) {\n\t    vector<int> vals;\n\t    while (head != nullptr) {\n\t      vals.emplace_back(head->val);\n\t      head = head->next;\n\t    }\n      //回文判断的双指针写法 记一下\n\t    // for (int i = 0, j = (int)vals.size() - 1; i < j; ++i, --j) {\n\t    //   if (vals[i] != vals[j]) {\n\t    //       return false;\n\t    //   }\n\t    // }\n      int left = 0, right = vals.size()-1;\n      while(left<right){\n        if(vals[left]!= vals[right])\n          return false;\n        left++;\n        right--;\n      }\n\t    return true;\n\t  }\n};\n\nclass Solution {\n  public:\n    //递归模拟双指针\n    ListNode* left;\n    bool isPalindrome(ListNode* head) {\n      left = head;\n      return traverse(head);\n    }\n  \n    bool traverse(ListNode* right){\n      if(right == nullptr) return true;\n      bool res = traverse(right->next);\n      //后序遍历代码\n      res = res && (right->val == left->val);\n      left = left->next;\n      return res;\n    }\n};\n\nclass Solution {\n  public:\n    //双指针 优化 为了秀而秀 秀nm呢\n    bool isPalindrome(ListNode* head) {\n      ListNode* slow;\n      ListNode* fast;\n      slow = fast = head;\n      while(fast && fast->next){\n        slow = slow->next;\n        fast = fast->next->next;\n      }\n      if(fast){ //奇数个元素\n        slow = slow->next;\n      }\n      ListNode* left = head;\n      ListNode* right = reverse(slow);\n      while(right){\n        if(left->val!=right->val)\n          return false;\n        left = left->next;\n        right = right->next;\n      }\n      return true;\n    }\n  \n    ListNode* reverse(ListNode* head){\n      if(head == nullptr || head->next == nullptr) return head;\n      ListNode* last = reverse(head->next);\n      head->next->next = head;\n      head->next = nullptr;\n      return last;\n    }\n};\n```\n\n"},{"title":"位运算","url":"/2022/03/15/wei-yun-suan/","content":"\n## 位操作技巧\n\n### [位运算概览](https://www.runoob.com/w3cnote/bit-operation.html)\n\n| 符号 | 描述 | 运算规则                                                     |\n| :--- | :--- | :----------------------------------------------------------- |\n| &    | 与   | 两个位都为1时，结果才为1                                     |\n| \\|   | 或   | 两个位都为0时，结果才为0                                     |\n| ^    | 异或 | `两个位相同为0，相异为1`                                     |\n| ~    | 取反 | 0变1，1变0                                                   |\n| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |\n| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |\n\n### 有趣的位操作\n\n1. **利用或操作 `|` 和空格将英文字符转换为小写**\n\n```c++\n('a' | ' ') = 'a'\n('A' | ' ') = 'a'\n```\n\n2. **利用与操作 `&` 和下划线将英文字符转换为大写**\n\n```c++\n('b' & '_') = 'B'\n('B' & '_') = 'B'\n```\n\n3. <u>**利用异或操作 `^` 和空格进行英文字符大小写互换**</u>\n\n```c++\n('d' ^ ' ') = 'D'\n('D' ^ ' ') = 'd'\n```\n\n4. <u>**判断两个数是否异号**</u>\n\n```c++\nint x = -1, y = 2;\nboolean f = ((x ^ y) < 0); // true\n\nint x = 3, y = 2;\nboolean f = ((x ^ y) < 0); // false\n```\n\n5. **不用临时变量交换两个数**\n\n```c++\nint a = 1, b = 2;\na ^= b;\nb ^= a;\na ^= b;\n// 现在 a = 2, b = 1\n```\n\n6. **加一**\n\n```c++\nint n = 1;\nn = -~n;\n// 现在 n = 2\n```\n\n7. **减一**\n\n```c++\nint n = 2;\nn = ~-n;\n// 现在 n = 1\n```\n\n### `n & (n-1)` 的运用\n\n**`n & (n-1)` 这个操作是算法中常见的，作用是消除数字 `n` 的二进制表示中的最后一个 1**。\n\n看个图就很容易理解了：\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220401104149833.png\" alt=\"image-20220401104149833\" style=\"zoom: 67%;\" />\n\n其核心逻辑就是，`n - 1` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 `n` 做一次 `&` 运算，就可以仅仅把最后一个 1 变成 0 了。\n\n### `a ^ a = 0` 的运用\n\n<u>异或运算的性质是需要我们牢记的：</u>\n\n<u>一个数和它本身做异或运算结果为 0，即 `a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即 `a ^ 0 = a`。</u>\n\n### `N^=(1<<k)`\n\n<u>将二进制的N的`第k位`置为0</u>\n\n## 一些位运算的题目\n\n### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=191) [思路](https://leetcode-cn.com/problems/number-of-1-bits/#)\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。\n\n \n\n**提示：**\n\n- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的 **示例 3** 中，输入表示有符号整数 `-3`。\n\n \n\n**示例 1：**\n\n```\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n#### 思路\n\nn&(n-1)的应用\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ans = 0;\n        while(n){\n            n = n & (n-1);\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n\n#### [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=231)[思路](https://leetcode-cn.com/problems/power-of-two/#)\n\n难度简单481收藏分享切换为英文接收动态反馈\n\n给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。\n\n如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。\n\n \n\n**示例 1：**\n\n```\n输入：n = 1\n输出：true\n解释：20 = 1\n```\n\n**示例 2：**\n\n```\n输入：n = 16\n输出：true\n解释：24 = 16\n```\n\n#### 思路\n\n2的幂表示为二进制 只有一个1\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    //2的幂在二进制中只有一个1\n    bool isPowerOfTwo(int n) {\n        if(n<=0) return 0;\n        return (n&(n-1)) == 0;\n    }\n};\n```\n\n### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=136)[思路](https://leetcode-cn.com/problems/single-number/#)\n\n难度简单2344英文版讨论区\n\n给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n```\n输入: [2,2,1]\n输出: 1\n```\n\n#### 思路\n\n利用异或的性质a ^ a = 0, a ^ 0 = a 全部异或即可得到唯一的值\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n      int ans = 0;\n      for(int num : nums)\n        ans ^= num;\n      return ans;\n    }\n};\n```\n\n### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=268)[思路](https://leetcode-cn.com/problems/missing-number/#)\n\n难度简单584收藏分享切换为英文接收动态反馈\n\n给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。\n\n\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,0,1]\n输出：2\n解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1]\n输出：2\n解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n```\n\n#### 思路\n\n异或一下即可\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int ans = 0;\n        for(int i = 0; i<nums.size(); i++){\n            ans^=i;\n            ans^=nums[i];\n        }\n        ans^=nums.size();\n        return ans;\n    }\n};\n```\n\n### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)\n\n难度中等597收藏分享切换为英文接收动态反馈英文版讨论区\n\n一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [4,1,4,6]\n输出：[1,6] 或 [6,1]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,10,4,1,4,3,3]\n输出：[2,10] 或 [10,2]\n```\n\n#### 思路\n\n[**我就知道总有人能给我讲明白，nb**](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/shua-bao-leetcode-yi-huo-yun-suan-xiao-b-cc5a/)\n\n- 我们将所有的数据都异或起来，不难理解最后的结果是两个 n = n1 ^ n2(n1和n2是只出现一次的数)\n- 我们对n进行分析，因为n是n1和n2异或得来的，所以n的二进制中第一次出现1的地方就是n1和n2二进制表示中第一次出现不同的情况，我们可以以此作为区分\n- 将数组中的数分成第bit位为1和bit为0的两组\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> singleNumbers(vector<int>& nums) {\n        int find = 0;\n        vector<int> ans(2);\n        for(int num : nums){\n            find^=num;\n        }//所有异或 最终是两个不同数的异或结果\n        \n        int bit = 0;\n        //注意这里的优先级 先1<<bit 在find&\n        while((find& 1<< bit) == 0){  //找到第一个1\n            bit++;\n        }\n        int temp = 1<<bit;  //移到两个数bit不同的位置\n        for(int num:nums){\n            if(num&temp) //包含第bit位为1的数\n                ans[0]^=num;\n            else             //包含第bit位不为1的数\n                ans[1]^=num;\n        }\n        return ans;\n    }\n};\n```\n\n### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)\n\n难度中等316收藏分享切换为英文接收动态反馈英文版讨论区\n\n在一个数组 `nums` 中除`一个数字只出现一次`之外，`其他数字都出现了三次`。请找出那个只出现一次的数字。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,4,3,3]\n输出：4\n```\n\n**示例 2：**\n\n```\n输入：nums = [9,1,7,9,7,9,7]\n输出：1\n```\n\n**限制：**\n\n- `1 <= nums.length <= 10000`\n- `1 <= nums[i] < 2^31`\n\n#### 思路\n\n题目限制32位int遍历每一位 将所有数字的该位 0/1 相加 如果目标数字该位为1，则该位相加不为3的倍数 \n\n利用这个特征可以将数字还原\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for(int i = 0; i<32; i++){\n            int total = 0;\n            for(int num: nums)\n                //右移&1得到每一位\n                total+= (num>>i)&1;\n            if(total%3)\n                //还原这个数 左移回相应的位数 或取回该值\n                ans |= (1<<i);\n        }\n        return ans;\n    }\n};\n```\n\n### [剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode-cn.com/problems/w3tCBm/)\n\n难度简单54\n\n给定一个非负整数 `n` ，请计算 `0` 到 `n` 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。\n\n \n\n**示例 1:**\n\n```\n输入: n = 2\n输出: [0,1,1]\n解释: \n0 --> 0\n1 --> 1\n2 --> 10\n```\n\n**示例 2:**\n\n```\n输入: n = 5\n输出: [0,1,1,2,1,2]\n解释:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n```\n\n#### 思路\n\n1. 笨方法 遍历每个都数\n2. dp 奇数是/2偶数1的个数+1 偶数是/2偶数的个数\n\n#### 代码\n\n笨比遍历\n\n```c++\nclass Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> ans(n+1);\n        for(int i = 0; i<=n; i++){\n            ans[i] = countOne(i);\n        }\n        return ans;\n    }\n\n    int countOne(int num){\n        int ans = 0;\n        while(num){\n            ans++;\n            num &= (num-1);\n        }\n        return ans;\n    }\n};\n```\n\n奇偶关系dp\n\n```c++\nclass Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> ans(n+1);\n        for(int i = 1; i<=n; i++){\n            if((i&1) == 1) //奇数\n                ans[i] = ans[i>>1] + 1;\n            else\n                ans[i] = ans[i>>1];\n        }\n        return ans;\n    }\n};\n```\n\n### [`剑指 Offer II 005. 单词长度的最大乘积`](https://leetcode-cn.com/problems/aseY1I/)\n\n难度中等58\n\n给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。\n\n \n\n**示例 1:**\n\n```\n输入: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"fxyz\",\"abcdef\"]\n输出: 16 \n解释: 这两个单词为 \"abcw\", \"fxyz\"。它们不包含相同字符，且长度的乘积最大。\n```\n\n#### 解法\n\n用一个32位int记录一个单词中出现了哪些字母\n\n相&为0， 说明没有重复的字母\n\n```c++\nclass Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        int n = words.size();\n        vector<int> masks(n);\n        for(int i = 0; i<n; i++){\n            for(auto ch : words[i]){\n                //用二进制中的最多26位，记录每个字母是否存在\n                masks[i] |= 1<<(ch - 'a');\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i<n; i++){\n            for(int j = i+1; j<n; j++){\n                //不存在相同数字\n                if((masks[i] & masks[j]) == 0){\n                    ans = max(int(words[i].size()*words[j].size()), ans);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n位运算优化，因为met 和 meet的int是相同的，所以我们只需要记录meet 及其长度 就可以了，\n\n```c++\nclass Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        unordered_map<int,int> map;\n        int length = words.size();\n        for (int i = 0; i < length; i++) {\n            int mask = 0;\n            string word = words[i];\n            int wordLength = word.size();\n            for (int j = 0; j < wordLength; j++) {\n                mask |= 1 << (word[j] - 'a');\n            }\n            if(map.count(mask)) {\n                if (wordLength > map[mask]) {\n                    map[mask] = wordLength;\n                }\n            } else {\n                map[mask] = wordLength;\n            }\n            \n        }\n        int maxProd = 0;\n        for (auto [mask1, _] : map) {\n            int wordLength1 = map[mask1];\n            for (auto [mask2, _] : map) {\n                if ((mask1 & mask2) == 0) {\n                    int wordLength2 = map[mask2];\n                    maxProd = max(maxProd, wordLength1 * wordLength2);\n                }\n            }\n        }\n        return maxProd;\n    }\n};\n```\n\n### [面试题 05.01. 插入](https://leetcode-cn.com/problems/insert-into-bits-lcci/)\n\n难度简单54收藏分享切换为英文接收动态反馈\n\n给定两个整型数字 `N` 与 `M`，以及表示比特位置的 `i` 与 `j`（`i <= j`，且从 0 位开始计算）。\n\n编写一种方法，使 `M` 对应的二进制数字插入 `N` 对应的二进制数字的第 `i ~ j` 位区域，不足之处用 `0` 补齐。具体插入过程如图所示。\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/1610104070-NuLVQi-05.01.gif)\n\n题目保证从 `i` 位到 `j` 位足以容纳 `M`， 例如： `M = 10011`，则 `i～j` 区域至少可容纳 5 位。\n\n \n\n**示例1:**\n\n```\n 输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6\n 输出：N = 1100(10001001100)\n```\n\n**示例2:**\n\n```\n 输入： N = 0, M = 31(11111), i = 0, j = 4\n 输出：N = 31(11111)\n```\n\n#### 方法\n\n按注释的步骤\n\n```c++\nclass Solution {\npublic:\n    int insertBits(int N, int M, int i, int j) {\n        // 1.把N的i到j位置为0\n        for (int k = i; k <= j; k++) {\n            if (N & (1 << k)) {\n                N ^= (1 << k); //将N的第k位置为0\n            }\n        }\n        // 2.把M的数值左移i位\n        M <<= i;\n        // 3.将N的i到j位加上M\n        return N + M;\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"回溯","url":"/2022/03/15/hui-su/","content":"\n# 回溯\n\n### 回溯模板\n\n```c++\nvoid backtracking(参数) {\n    if (终止条件) {\n        存放结果;\n        return;\n    }\n\n    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n        处理节点;\n        backtracking(路径，选择列表); // 递归\n        回溯，撤销处理结果\n    }\n}\n```\n\n## 1. 组合问题\n\n1. 组合问题 ==每次for都是从startIndex开始==\n2. 每个元素 用一次和用多次体现在 ==backtrack(i+1)==用一次还是==backtrack(i)用多次==上\n3. 组合问题==不需要used数组==，去重也不需要used数组那个判断\n\n### [77. n元素下的k元素组合](https://leetcode-cn.com/problems/combinations/)\n\n给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。\n\n你可以按 **任何顺序** 返回答案。\n\n**示例 1：**\n\n```\n输入：n = 4, k = 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n```\n\n**示例 2：**\n\n```\n输入：n = 1, k = 1\n输出：[[1]]\n```\n\n##### 思路\n\n1. 按回溯模板 直接写 \n2. 注意剪枝操作， 超过k个元素不再进入递归 24ms->8ms\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    int n;\n    int k;\n    vector<int> path;\n    vector<vector<int>> all;\n    vector<vector<int>> combine(int n, int k) {\n        this->n = n;\n        this->k = k;\n        path.clear();\n        all.clear();\n        backtrack(1);\n        return all;\n    }\n    void backtrack(int num){\n        if(path.size() == k){\n            all.push_back(path);\n            return;\n        }\n\t\t\t\t//进行剪枝， 超过k个元素不再进入递归 24ms->8ms\n        for(int i = num; i<=n - (k-path.size()) + 1; i++){\n            path.push_back(i);\n            backtrack(i+1);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n\n给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 *所有* **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n\n`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n\n对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n\n**示例 1：**\n\n```\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n```\n\n**示例 2：**\n\n```\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n```\n\n##### 思路\n\n1. 注意这个题 `单个元素是可以重复使用的` 表现在代码上 for循环内 `backtrack是i 而不是i+1`\n2. sum 和 target 的判断逻辑注意下 \n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> path;\n\n    void backtracking(vector<int>& candidates, int index, int target, int sum){\n      //这里sum和target的判断逻辑注意下\n      if(sum>target) return;\n      if(sum == target) {\n        ans.push_back(path); \n        return;\n      }\n      for(int i = index; i<candidates.size(); i++){\n        path.push_back(candidates[i]);\n        backtracking(candidates, i, target, sum + candidates[i]); //注意 这里的i不加1 不然没有数重复的\n        path.pop_back();\n      }\n    }\n  \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n      backtracking(candidates,0, target, 0);\n      return ans;\n    }\n};\n```\n\n### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)\n\n找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：\n\n- 只使用数字1到9\n- 每个数字 **最多使用一次** \n\n返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n**示例 1:**\n\n```\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n解释:\n1 + 2 + 4 = 7\n没有其他符合的组合了。\n```\n\n**示例 2:**\n\n```\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n解释:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\n没有其他符合的组合了。\n```\n\n##### 思路\n\n1. 结束终止满足两个条件之一 `nowSum >= n || path.size() == k`即可  \n2. 满足条件的结果  `nowSum == n && path.size() == k`\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> all;\n    vector<int> path;\n    int k,n ;\n    vector<vector<int>> combinationSum3(int k, int n) {\n        this->k = k; \n        this->n = n;\n        backtrack(1, 0);\n        return all;\n    }\n\n    void backtrack(int cur, int nowSum){\n        //if(cur>9) return;  //注意这句不能要 不然会 9 45判错 最后cur 10 直接返回掉\n        if(nowSum >= n || path.size() == k){\n            if(nowSum == n && path.size() == k)\n                all.push_back(path);\n            return;\n        }\n\n        for(int i = cur; i<=9; i++){\n            path.push_back(i);\n            backtrack(i+1, nowSum + i);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)\n\n给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。\n\n`candidates` 中的每个数字在每个组合中只能使用 **一次** 。\n\n**注意：**解集不能包含重复的组合。 \n\n \n\n**示例 1:**\n\n```\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n```\n\n**示例 2:**\n\n```\n输入: candidates = [2,5,2,1,2], target = 5,\n输出:\n[\n[1,2,2],\n[5]\n]\n```\n\n##### 思路\n\n1. 结束终止满足两个条件之一 `nowSum >= n || path.size() == k`即可  \n2. 满足条件的结果  `nowSum == n && path.size() == k`\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    //去重操作 数组中包含重复元素 所以要去重\n    //注意 并不需要used数组 used数组只在排列中用到?即(for(int i = 0)的时候用到)\n    vector<vector<int>> all;\n    vector<int> path;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        //排序让相同的元素挨着\n        sort(candidates.begin(), candidates.end());\n        backtrack(candidates, target, 0, 0);\n        return all;\n    }\n\n    void backtrack(vector<int>& candidates, int target, int curIndex, int nowSum){\n        if(nowSum>target) return;\n        if(nowSum == target){\n            all.push_back(path);\n            return;\n        }\n        for(int i = curIndex; i<candidates.size(); i++){\n            // 经典的去重操作 全排列中也用到了\n            if(i>curIndex && candidates[i] == candidates[i-1])\n                continue;\n            path.push_back(candidates[i]);\n            //这里是i+1，每个数字在每个组合中只能使用一次\n            backtrack(candidates, target, i+1,  nowSum+candidates[i]);\n            path.pop_back();\n        }\n    }\n};\n```\n\n\n\n#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)\n\n给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。\n\n题目数据保证答案符合 32 位整数范围。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3], target = 4\n输出：7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n```\n\n**示例 2：**\n\n```\n输入：nums = [9], target = 3\n输出：0\n```\n\n##### 思路\n\n1. 名为组合 实为排列 解法dp\n2. 回溯超时 dp解答\n3. 记忆化dfs 其实就是dp了吧\n\n##### 暴力回溯代码\n\n```c++\nclass Solution {\npublic:\n    int ans;\n    int combinationSum4(vector<int>& nums, int target) {\n        ans = 0;\n        backtrack(nums, 0, target);\n        return ans;\n    }\n\n    void backtrack(vector<int>& nums, int nowSum, int target){\n        if(nowSum>target) return;\n        if(nowSum == target){\n            ans++;\n            return;\n        }\n      \t//可以反向 就是排列了\n        for(int i = 0; i<nums.size(); i++){\n            backtrack(nums, nowSum+nums[i], target);\n        }\n    }\n};\n```\n\n##### 记忆化dfs\n\n```c++\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        return dfs(nums, target);\n    }\n    //备忘录，保存每层递归的计算结果，用于实现记忆化。\n    unordered_map<int, int> memo;\n    //dfs(target)的定义： 用nums中的元素凑成总和为target（每个元素可以使用多次），用多少中凑法。\n    int dfs(vector<int>& nums, int target){\n        if(target == 0)\n            return 1;\n        if(target < 0)\n            return 0;\n        if(memo.count(target) == 1)\n            return memo[target];\n        int res = 0;\n        for(int i = 0; i < nums.size(); i++){\n            res += dfs(nums, target - nums[i]);\n        }\n        memo[target] = res;\n        return res;\n    }\n};\n```\n\n##### dp代码\n\n```c++\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        //使用dp数组，dp[i]代表组合数为i时使用nums中的数能组成的组合数的个数\n        //dp[i]=dp[i-nums[0]]+dp[i-nums[1]]+dp[i=nums[2]]+...\n        //举个例子比如nums=[1,3,4],target=7;\n        //dp[7]=dp[6]+dp[4]+dp[3]\n        //其实就是说7的组合数可以由三部分组成，1和dp[6]，3和dp[4],4和dp[3];\n        vector<unsigned long long> dp(target+1);\n        //是为了算上自己的情况，比如dp[1]可以由dp【0】和1这个数的这种情况组成。\n        dp[0] = 1;\n        for(int i = 1; i<=target; i++){\n            for(int num : nums){\n                //dp用int的话 有一个很傻逼的越界，需要 && dp[i - num] < INT_MAX - dp[i]\n                if(i>=num)  \n                    dp[i] += dp[i-num];\n            }\n        }\n        return dp[target];\n    }\n};\n```\n\n### [93. 复原 IP 地址  虾皮字节  很难](https://leetcode-cn.com/problems/restore-ip-addresses/)\n\n难度中等846收藏分享切换为英文接收动态反馈\n\n**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。\n\n- 例如：`\"0.1.2.201\"` 和` \"192.168.1.1\"` 是 **有效** IP 地址，但是 `\"0.011.255.245\"`、`\"192.168.1.312\"` 和 `\"192.168@1.1\"` 是 **无效** IP 地址。\n\n给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"25525511135\"\n输出：[\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n**示例 2：**\n\n```\n输入：s = \"0000\"\n输出：[\"0.0.0.0\"]\n```\n\n**示例 3：**\n\n```\n输入：s = \"101023\"\n输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```\n\n#### 思路\n\n看代码\n\n#### 代码\n\n```c++\nclass Solution {\nprivate:\n    vector<string> result;// 记录结果\n    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量\n    void backtracking(string& s, int startIndex, int pointNum) {\n        if (pointNum == 3) { // 逗点数量为3时，分隔结束\n            // 判断第四段子字符串是否合法，如果合法就放进result中\n            if (isValid(s, startIndex, s.size() - 1)) {\n                result.push_back(s);\n            }\n            return;\n        }\n        for (int i = startIndex; i < s.size(); i++) {\n            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法\n                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点\n                pointNum++;\n                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2\n                pointNum--;                         // 回溯\n                s.erase(s.begin() + i + 1);         // 回溯删掉逗点\n            } else break; // 不合法，直接结束本层循环\n        }\n    }\n    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法\n    bool isValid(const string& s, int start, int end) {\n        if (start > end) {\n            return false;\n        }\n        if (s[start] == '0' && start != end) { // 0开头的数字不合法\n                return false;\n        }\n        int num = 0;\n        for (int i = start; i <= end; i++) {\n            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法\n                return false;\n            }\n            num = num * 10 + (s[i] - '0');\n            if (num > 255) { // 如果大于255了不合法\n                return false;\n            }\n        }\n        return true;\n    }\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        result.clear();\n        if (s.size() > 12) return result; // 算是剪枝了\n        backtracking(s, 0, 0);\n        return result;\n    }\n};\n```\n\n### [78. 子集](https://leetcode-cn.com/problems/subsets/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=78)[思路](https://leetcode-cn.com/problems/subsets/#)\n\n难度中等1556\n\n给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n\n解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0]\n输出：[[],[0]]\n```\n\n#### 思路\n\n简单回溯\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> path;\n    vector<vector<int>> subsets(vector<int>& nums) {\n        path.clear();\n        ans.clear();\n        ans.push_back(path);//空的先压入\n        backTrack(nums, 0);\n        return ans;\n    }\n\n    void backTrack(vector<int>& nums, int startIndex){\n        if(startIndex>=nums.size()) return;\n        for(int i = startIndex; i<nums.size(); i++){\n            path.push_back(nums[i]);\n            ans.push_back(path);\n            backTrack(nums, i+1);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)\n\n[labuladong 题解](https://labuladong.gitee.io/article/?qno=90)\n\n难度中等783收藏分享切换为英文接收动态反馈\n\n给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,2]\n输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0]\n输出：[[],[0]]\n```\n\n#### 思路\n\n含重复元素的组合去重\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> path;\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        ans.clear();\n        path.clear();\n        ans.push_back(path);\n        sort(nums.begin(), nums.end());\n        backTrack(nums, 0);\n        return ans;\n    }\n\n    void backTrack(vector<int>& nums, int startIndex){\n        if(startIndex>nums.size()) return;\n        for(int i = startIndex; i<nums.size(); i++){\n            if(i>startIndex && nums[i] == nums[i-1])\n                continue;\n            path.push_back(nums[i]);\n            ans.push_back(path);\n            backTrack(nums, i+1);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [`491. 递增子序列  不能sort的去重`](https://leetcode-cn.com/problems/increasing-subsequences/)\n\n难度中等412收藏分享切换为英文接收动态反馈\n\n给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。\n\n数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [4,6,7,7]\n输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [4,4,3,2,1]\n输出：[[4,4]]\n```\n\n#### 思路\n\n1. 去重的产生 比 4 7 6 7 数组，不去重的话 4 7 会出现两次，但是去重不能用sort因为破坏原排列的顺序\n2. 应考虑用哈希 或者其他方式去重 最后去重的话 没有起到剪枝效果\n\n#### 代码\n\n1. 最终暴力去重 sort->unique->erase\n\n```c++\nclass Solution {\npublic:\n    vector<int> path;\n    vector<vector<int>> ans;\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        path.clear();\n        ans.clear();\n        backTrack(nums, 0);\n        sort(ans.begin(), ans.end());\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\n        return ans;\n    }\n\n    void backTrack(vector<int>& nums, int startIndex){\n        if(startIndex>nums.size()){\n            return;\n        }\n\n        for(int i = startIndex; i<nums.size(); i++){\n            if(path.size()>0 && nums[i]<path.back()) continue;\n            path.push_back(nums[i]);\n            if(path.size()>1) ans.push_back(path);\n            backTrack(nums, i+1);\n            path.pop_back();\n        }\n    }\n};\n```\n\n2. 使用单层的set进行去重 注意 set定义在每一层 `作用只在定义的这一层`\n\n```c++\nclass Solution {\npublic:\n    vector<int> path;\n    vector<vector<int>> ans;\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        path.clear();\n        ans.clear();\n        backTrack(nums, 0);\n        // sort(ans.begin(), ans.end());\n        // ans.erase(unique(ans.begin(), ans.end()), ans.end());\n        return ans;\n    }\n\n    void backTrack(vector<int>& nums, int startIndex){\n        if(startIndex>nums.size()) return;\n\n        unordered_set<int> uset; // 使用set对本层元素进行去重\n\n        for(int i = startIndex; i<nums.size(); i++){\n            if(path.size()>0 && nums[i]<path.back() || uset.find(nums[i]) != uset.end())\n                continue;\n            path.push_back(nums[i]);\n            if(path.size()>1) ans.push_back(path);\n            uset.insert(nums[i]);\n            backTrack(nums, i+1);\n            path.pop_back();\n        }\n    }\n};\n```\n\n### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)\n\n难度简单429\n\n输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。\n\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n\n \n\n**示例 1：**\n\n```\n输入：target = 9\n输出：[[2,3,4],[4,5]]\n```\n\n**示例 2：**\n\n```\n输入：target = 15\n输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n```\n\n#### 暴力回溯\n\n时间换空间\n\n```c++ \nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> path;\n    vector<vector<int>> findContinuousSequence(int target) {\n      for(int i = 1; i<target; i++){\n        //path.clear();\n        backtrack(i, target, 0);\n      }\n      return ans;\n    }\n    void backtrack(int startIndex, int target, int nowSum){\n      if(nowSum == target){\n        ans.push_back(path);\n        return;\n      }\n      if(nowSum > target) return;\n\n      path.push_back(startIndex);\n      backtrack(startIndex + 1, target, nowSum + startIndex);\n      path.pop_back();\n    }\n};\n```\n\n\n\n#### 滑动窗口\n\nvector 空间换时间\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> findContinuousSequence(int target) {\n      int left = 1, right = 1;\n      vector<vector<int>> ans;\n      vector<int> window;\n      int winSum = 0;\n      while(right<target){\n        winSum += right;\n        window.push_back(right);\n        while(winSum >= target){\n          if(winSum == target){\n            ans.push_back(vector<int>(window.begin() + left - 1, window.end()));\n          }\n          winSum-=left;\n          left++;\n        }\n        right++;\n      }\n      return ans;\n    }\n};\n```\n\n为啥链表效率特别低 时间长 内存占用大\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> findContinuousSequence(int target) {\n      int left = 1, right = 1;\n      vector<vector<int>> ans;\n      list<int> window;\n      int winSum = 0;\n      while(right<target){\n        winSum += right;\n        window.push_back(right);\n        while(winSum >= target){\n          if(winSum == target){\n            ans.push_back(vector<int>(window.begin(), window.end()));\n          }\n          winSum-=left;\n          window.pop_front();\n          left++;\n        }\n        right++;\n      }\n      return ans;\n    }\n};\n```\n\n## 2. 排列问题\n\n1. 排列问题 ==每次for都是从0开始==\n2. 因为是排列 不能限制顺序 所以不传入index\n3. ==需要used数组==，去重判断重中之重\n\n### [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n\n给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1]\n输出：[[1]]\n```\n\n##### 思路\n\n1. 数组不重复 最简简单单的全排列，基本回溯解法\n2. 不讲五的解法 next_permutation （略）\n\n##### 代码\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> ans;\n    vector<int> path;\n    void backtrack(vector<int>& nums, vector<bool>& used){\n      if(path.size() == nums.size()){\n        ans.push_back(path);\n        return;\n      }\n      for(int i = 0; i<nums.size(); i++){\n        if(used[i]) continue;  //数字不重复使用 需要used数组\n        used[i] = 1;\n        path.push_back(nums[i]);\n        backtrack(nums, used);\n        path.pop_back();\n        used[i] = 0;\n      }\n    }\n\n    vector<vector<int>> permute(vector<int>& nums) {\n      ans.clear();\n      path.clear();\n      vector<bool> used(nums.size(), 0);\n      backtrack(nums, used);\n      return ans;\n    }\n};\n```\n\n### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)\n\n整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[1,3,2]\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,1]\n输出：[1,2,3]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,5]\n输出：[1,5,1]\n```\n\n##### 思路\n\n题目要求实现 next_permutation\n\n> 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。\n>\n> 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。\n>\n> 以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：\n>\n> 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。\n>\n> 当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。\n>\n\n不明白就调试调试\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int i = nums.size() - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--; //从后往前找到第一个增长的点 例子中i指向2\n        }\n        if (i >= 0) {\n            int j = nums.size() - 1;\n            while (j >= 0 && nums[i] >= nums[j]) { //从后往前找到第一个大于nums[i]的点 例子中j指向3\n                j--;\n            }\n            //453621 //此时满足 较小的>2的3替换了2，满足了大排列，而i之后单减\n            swap(nums[i], nums[j]); \n        }\n        //453126\n        reverse(nums.begin() + i + 1, nums.end());\n    }\n};\n```\n\n### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)\n\n给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,1,2]\n输出：\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n##### 思路\n\n1. 重点！重复元素全排列主要是去重问题\n\n   > `(i>0 && !used[i-1] && nums[i] == nums[i-1])`\n\n2. \n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<int> path;\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n      sort(nums.begin(), nums.end());  //去重需要排序 使得相同的元素挨在一起\n      vector<bool> used(nums.size(), 0);\n      backtrack(nums, used);\n      return ans;\n    }\n\n    void backtrack(vector<int>& nums, vector<bool>& used){\n      if(path.size() == nums.size()){\n        ans.push_back(path);\n        return;\n      }\n      for(int i = 0; i<nums.size(); i++){\n        //注意这里的去重判断是重中之重\n        if(used[i] || (i>0 && !used[i-1] && nums[i] == nums[i-1]))  \n          continue;\n        used[i] = 1;\n        path.push_back(nums[i]);\n        backtrack(nums, used);\n        path.pop_back();\n        used[i] = 0;\n      }\n    }\n};\n```\n\n### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)\n\n难度中等368\n\n给定一个字符串 `s` ，通过将字符串 `s` 中的每个字母转变大小写，我们可以获得一个新的字符串。\n\n返回 *所有可能得到的字符串集合* 。以 **任意顺序** 返回输出。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"a1b2\"\n输出：[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]\n```\n\n**示例 2:**\n\n```\n输入: s = \"3z4\"\n输出: [\"3z4\",\"3Z4\"]\n```\n\n##### 思路\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<string> ans;\n    string path;\n    vector<string> letterCasePermutation(string s) {\n      backtrack(s, 0);\n      return ans;\n    }\n\n    void backtrack(string &s, int index){\n      if(index == s.size()){\n        ans.push_back(path);\n        return;\n      }\n      if(!isalpha(s[index])){\n        path+=s[index];\n        backtrack(s, index+1);\n        path.pop_back();\n      }else{\n        path+=(tolower(s[index]));\n        backtrack(s, index+1);\n        path.pop_back();\n  \n        path+=(toupper(s[index]));\n        backtrack(s, index+1);\n        path.pop_back();\n      }\n    }\n};\n```\n\n### [60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)\n\n难度困难641\n\n给出集合 `[1,2,3,...,n]`，其所有元素共有 `n!` 种排列。\n\n按大小顺序列出所有排列情况，并一一标记，当 `n = 3` 时, 所有排列如下：\n\n1. `\"123\"`\n2. `\"132\"`\n3. `\"213\"`\n4. `\"231\"`\n5. `\"312\"`\n6. `\"321\"`\n\n给定 `n` 和 `k`，返回第 `k` 个排列。\n\n \n\n**示例 1：**\n\n```\n输入：n = 3, k = 3\n输出：\"213\"\n```\n\n**示例 2：**\n\n```\n输入：n = 4, k = 9\n输出：\"2314\"\n```\n\n**示例 3：**\n\n```\n输入：n = 3, k = 1\n输出：\"123\"\n```\n\n##### 思路\n\n完全回溯无法通过 要实现==精准剪枝==\n\n##### 代码\n\n```c++\nclass Solution {\npublic:\n  // 普通回溯过不了，需要精准剪枝到第k个叶节点\n  void dsssfs(int n, int k, unordered_set<int> &used, string &tmp,\n              vector<int> &factorial) {\n    if (tmp.size() == n) {\n      return;\n    }\n    int ind =\n        0; // 用来标记当前是第几次循环,直接用i的话有问题，比如说i是3，但是只是第一次循环，那就错了\n    for (int i = 1; i <= n; ++i) {\n      if (used.find(i) != used.end())\n        continue;\n      ++ind;\n      // 需要看当前层切分后每个子节点包含的叶节点个数，所以要减一\n      int size = factorial[n - used.size() - 1];\n\n      if (k > (ind - 1) * size && k <= ind * size) {\n        tmp.push_back(i + '0');\n        used.insert(i);\n        dsssfs(n, k - size * (ind - 1), used, tmp, factorial);\n        // 无需回溯，因为从dfs出来后就已经是结果了\n      }\n    }\n  }\n\n  string getPermutation(int n, int k) {\n    unordered_set<int> used;\n    string tmp;\n    // 提前吧阶乘算出来\n    vector<int> factorial = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};\n    dsssfs(n, k, used, tmp, factorial);\n    return tmp;\n  }\n};\n```\n\n## 3. 分割问题\n\n### [131. 分割回文串  比较难](https://leetcode-cn.com/problems/palindrome-partitioning/)\n\n难度中等1062收藏分享切换为英文接收动态反馈\n\n给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。\n\n**回文串** 是正着读和反着读都一样的字符串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"aab\"\n输出：[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\"\n输出：[[\"a\"]]\n```\n\n#### 代码\n\n```c++\nclass Solution {\nprivate:\n    vector<vector<string>> result;\n    vector<string> path; // 放已经回文的子串\n    void backtracking (const string& s, int startIndex) {\n        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了\n        if (startIndex >= s.size()) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = startIndex; i < s.size(); i++) {\n            if (isPalindrome(s, startIndex, i)) {   // 是回文子串\n                // 获取[startIndex,i]在s中的子串\n                string str = s.substr(startIndex, i - startIndex + 1);\n                path.push_back(str);\n            } else {                                // 不是回文，跳过\n                continue;\n            }\n            backtracking(s, i + 1); // 寻找i+1为起始位置的子串\n            path.pop_back(); // 回溯过程，弹出本次已经填在的子串\n        }\n    }\n    bool isPalindrome(const string& s, int start, int end) {\n        for (int i = start, j = end; i < j; i++, j--) {\n            if (s[i] != s[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\npublic:\n    vector<vector<string>> partition(string s) {\n        result.clear();\n        path.clear();\n        backtracking(s, 0);\n        return result;\n    }\n};\n```\n\n### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)\n\n难度中等892英文版讨论区\n\n**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。\n\n- 例如：`\"0.1.2.201\"` 和` \"192.168.1.1\"` 是 **有效** IP 地址，但是 `\"0.011.255.245\"`、`\"192.168.1.312\"` 和 `\"192.168@1.1\"` 是 **无效** IP 地址。\n\n给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"25525511135\"\n输出：[\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n**示例 2：**\n\n```\n输入：s = \"0000\"\n输出：[\"0.0.0.0\"]\n```\n\n**示例 3：**\n\n```\n输入：s = \"101023\"\n输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```\n\n#### 解法\n\n回溯 类似上述回文串 进行有效判定\n\n```c++\nclass Solution {\npublic:\n    vector<string> ans;\n    vector<string> restoreIpAddresses(string s) {\n        ans.clear();\n        backTrack(s, 0, 0);\n        return ans;\n    }\n\n    void backTrack(string& s, int startIndex, int pointNum){\n        if(pointNum == 3){\n            if(isValid(s, startIndex, s.size() - 1))   \n                ans.push_back(s);\n            return;\n        }\n\n        for(int i = startIndex; i<s.size(); i++){\n            if(isValid(s, startIndex, i)){\n                s.insert(s.begin() + i + 1, '.');\n                pointNum++;\n                backTrack(s, i+2, pointNum);\n                pointNum--;\n                s.erase(s.begin() + i + 1);\n            }\n        }\n    }\n\n    bool isValid(string& s, int start, int end){\n        if(start>end) return 0;\n        if(s[start] == '0' && start != end) return 0;\n        int num = 0;\n        for(int i = start; i<=end; i++){\n            if(s[i]>'9' || s[i]<'0')\n                return 0;\n            num = num * 10 + (s[i] - '0');\n            if(num>255) return 0;\n        }\n        return 1;\n    }\n};\n```\n\n\n\n\n\n## 特殊回溯\n\n个人认为 特殊情况 应用的挺特殊的回溯\n\n### [剑指 Offer II 009. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/ZVAVXX/)\n\n难度中等63\n\n给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。\n\n\n\n**示例 1:**\n\n```\n输入: nums = [10,5,2,6], k = 100\n输出: 8\n解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于100的子数组。\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,2,3], k = 0\n输出: 0\n```\n\n#### 思路\n\n1. 这道题 正确解法 应该是滑动窗口\n\n   > `重点 right - left + 1`\n   >\n   > 比如某次遍历符合题意的子数组为 ABCX，那么在该条件下符合条件的有X，CX，BCX，ABCX共四个（可以进行多个例子，发现个数符合right-left+1）\n\n2. 但是 做这道题的过程中 感觉这个 不跳步的回溯 挺有意思 外层循环backtrack \n\n   其实 好像相当于两层for循环了 卧槽 我真是垃圾\n\n   <u>`其实 也好像有点类似n叉树 有向图的遍历吧？`</u>[图论 | qianxunslimgのblog](https://qianxunslimg.github.io/2022/03/15/tu-lun/)\n\n#### 代码\n\n正确的滑动窗口解法\n\n```c++\nclass Solution {\npublic:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        int multi = 1;\n        int n = nums.size();\n        if(k <= 1) return 0;\n        int left = 0, right = 0;\n        int ans = 0;\n        while(right < n){\n            multi*=nums[right];\n            while(multi>=k){\n                multi/=nums[left];\n                left++;\n            }\n            ans += (right - left + 1); //注意 每次+的是窗口的长度\n            right++;  //这个写在前面也是可以的 只是right - left 不加1\n        }\n        return ans;\n    }\n};\n```\n\n回溯（假）\n\n```c++\nclass Solution {\npublic:\n    int ans;\n    //vector<vector<int>> all;\n    //vector<int> path;\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        ans = 0;\n        for(int i = 0; i<nums.size(); i++){\n            backtrack(nums, i, 1, k);\n        }\n        // cout<<all.size()<<endl;\n        // for(int i = 0; i<all.size(); i++){\n        //     for(int j = 0; j<all[i].size(); j++){\n        //         cout<<all[i][j]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        return ans;\n    }\n\n    void backtrack(vector<int>& nums, int startIndex, int preK, int k){\n        if(startIndex>=nums.size() || preK>=k) return;\n        preK*=nums[startIndex];\n        //path.push_back(nums[startIndex]);\n        if(preK<k){\n          ans++;  \n          //all.push_back(path);\n        }\n        backtrack(nums, startIndex+1, preK, k);\n        preK /= nums[startIndex];\n        //path.pop_back();\n    }\n};\n```\n\n### [剑指 Offer II 085. 生成匹配的括号](https://leetcode-cn.com/problems/IDBivT/)\n\n难度中等28\n\n正整数 `n` 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。\n\n\n\n**示例 1：**\n\n```\n输入：n = 3\n输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n**示例 2：**\n\n```\n输入：n = 1\n输出：[\"()\"]\n```\n\n#### 解法\n\n回溯，回溯终止条件为 左右括号次数用完 和 右括号用的次数大于左括号用的次数\n\n```c++\nclass Solution {\npublic:\n    vector<string> ans;\n    string path;\n    vector<string> generateParenthesis(int n) {\n      backtrack(n, n);\n      return ans;\n    }\n\n    void backtrack(int left, int right){\n      //用完 存储结果\n      if(left == 0 && right == 0){\n        ans.push_back(path);\n        return;\n      }\n      //次数超过 或者 右括号比左括号多\n      if(left < 0 || right < 0 || right < left)\n        return;\n      path += \"(\";\n      backtrack(left - 1, right);\n      path.pop_back();\n      path += \")\";\n      backtrack(left, right - 1);\n      path.pop_back();\n    }\n};\n```\n\n","tags":["算法总结"]},{"title":"滑动窗口","url":"/2022/03/15/hua-dong-chuang-kou/","content":"\n## 滑动窗口模板\n\n框架\n\n```c++\n/* 滑动窗口算法框架 */\nvoid slidingWindow(string s, string t) {\n    unordered_map<char, int> need, window;\n    for (char c : t) need[c]++;\n    \n    int left = 0, right = 0;\n    int valid = 0; \n    while (right < s.size()) {\n        // c 是将移入窗口的字符\n        char c = s[right];\n        // 右移窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        ...\n\n        /*** debug 输出的位置 ***/\n        printf(\"window: [%d, %d)\\n\", left, right);\n        /********************/\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            char d = s[left];\n            // 左移窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n}\n\n```\n\n## 相关题目\n\n### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/) 困难 滑滑滑\n\n````c++\n\nclass Solution {\npublic:\n  string minWindow(string s, string t) {\n    unordered_map<char, int> need, window;\n    for (char c : t)\n      need[c]++;\n    int left = 0, right = 0;\n    int valid = 0;\n    //记录最小覆盖字串的其实索引和长度\n    int start = 0, len = INT_MAX;\n    while (right < s.size()) {\n      // c是移入窗口的字符\n      char c = s[right];\n      right++;\n      // 进行窗口内数据的一系列更新\n      if (need.count(c)) {\n        window[c]++;\n        if (window[c] == need[c])\n          valid++;\n      }\n      //判断左窗口是否需要收缩\n      while (valid == need.size()) { //窗口满足条件\n                                     // 在这里更新最小覆盖子串\n        if (right - left < len) {\n          start = left;\n          len = right - left;\n        }\n        // d 是将移出窗口的字符\n        char d = s[left];\n        // 左移窗口\n        left++;\n        // 进行窗口内数据的一系列更新\n        if (need.count(d)) {\n          if (window[d] == need[d]) {\n            valid--;\n          }\n          window[d]--;\n        }\n      }\n    }\n    return len == INT_MAX ? \"\" : s.substr(start, len);\n  }\n};\n\n````\n\n### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/) 中等 滑滑滑\n\n```c++\n\nclass Solution {\npublic:\n    bool checkInclusion(string t, string s) {\n      unordered_map<char,int> window, need;\n      for(char c : t) need[c]++;\n      int left = 0, right = 0;\n      int valid = 0;\n      while(right < s.size()){\n        //扩大 知道满足 window = need\n        char c = s[right];\n        right++;\n        if(need.count(c)){\n          window[c]++;\n          if(window[c] == need[c])\n            valid++;\n        }\n        //个数满足\n        while(right-left>=t.size()){  //缩减窗口到t的长度\n          if(valid == need.size())\n            return true;\n          char d = s[left];\n          left++;\n          if(need.count(d)){\n            if(window[d] == need[d])\n              valid--;\n            window[d]--;\n          }\n        }\n      }\n      return false;\n    }\n};\n\n```\n\n### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/) 中等 滑滑滑 接着滑\n\n```c++\n\n// class Solution {\n// public:\n//     map<char, int> checkAna;\n//     map<char, int> checkAnb;\n//     vector<int> findAnagrams(string s, string p) {\n//         vector<int> res;\n//         int n = s.size(); \n//         int nn = p.size();\n//         if(isAnagrams(\"abc\", \"bca\")){\n//             cout<<\"check\"<<endl;\n//         }\n//         for(int i = 0; i<n-nn+1; i++){\n//             cout<<s.substr(i, nn) <<endl;\n//             if(isAnagrams(s.substr(i, nn), p))\n//                 res.push_back(i);\n//         }\n//         return res;\n//     }\n//     bool isAnagrams(string a, string b){\n//         checkAna.clear();\n//         checkAnb.clear();\n//         for(int i = 0; i<a.size(); i++){\n//             checkAna[a[i]]++;\n//             checkAnb[b[i]]++;\n//         }\n//         for(auto it = checkAna.begin(); it !=checkAna.end(); it++){\n//             if(it->second != checkAnb[it->first])\n//                 return 0;\n//         }\n//         return 1;\n//     }\n// };\n\n// class Solution {\n// public:\n//     vector<int> findAnagrams(string s, string p) {\n//         vector<int> res;\n//         int n = s.size(); \n//         int nn = p.size();\n//         if(n<nn) return vector<int>();\n//         vector<int> ss(26);\n//         vector<int> pp(26);\n//         //初始化保证窗口初始移动\n//         for(int i = 0; i<nn; i++){\n//             ss[s[i]-'a']++;\n//             pp[p[i]-'a']++;\n//         }\n//         if(ss == pp) res.push_back(0);\n//         for(int i = 0; i<n-nn; i++){\n//             ss[s[i]-'a']--;\n//             ss[s[i+nn]-'a']++;\n//             if(ss == pp) res.push_back(i+1);\n//         }\n//         return res;\n//     }\n// };\n\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n      vector<int> ans;\n      unordered_map<char, int> need, window;\n      for(char c : p) need[c]++;\n      int left = 0, right = 0, valid = 0;\n      while(right<s.size()){\n        char c = s[right];\n        right++;\n        if(need.count(c)){\n          window[c]++;\n          if(window[c] == need[c])\n            valid++;\n        }\n        while(right-left >= p.size()){\n          if(valid == need.size()) ans.push_back(left);\n          char d = s[left];\n          left++;\n          if(need.count(d)){\n            if(need[d] == window[d])\n              valid--;\n            window[d]--;\n          }\n        }\n      }\n      return ans;\n    }\n};\n\n```\n\n\n\n### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) \n\n````c++\n\nclass Solution {\npublic:\n  int lengthOfLongestSubstring(string s) {\n    int ans = 0;\n    int left = 0, right = 0;\n    unordered_map<char, int> window;\n    while (right < s.size()) {\n      char c = s[right];\n      right++;\n      window[c]++;\n      while (window[c] > 1) { //有重复就要从left++ 直到消除当前重复\n        char d = s[left];\n        left++;\n        window[d]--;\n      }\n      ans = max(ans, right - left);\n    }\n    return ans;\n  }\n};\n// class Solution {\n// public:\n//   int lengthOfLongestSubstring(string s) {\n//     if (s.size() == 0)\n//       return 0;\n//     unordered_set<char> lookup;\n//     int maxStr = 0;\n//     int left = 0;\n//     for (int i = 0; i < s.size(); i++) {\n//       while (lookup.find(s[i]) != lookup.end()) {\n//         lookup.erase(s[left]);\n//         left++;\n//       }\n//       maxStr = max(maxStr, i - left + 1);\n//       lookup.insert(s[i]);\n//     }\n//     return maxStr;\n//   }\n// };\n  //int lengthOfLongestSubstring(string s) {\n  //  if (s.size() == 0) {\n  //    return 0;\n  //  }\n  //  vector<string> ss;\n  //  for (int i = 0; i < s.size(); i++) {\n  //    unordered_map<char, int> temp_map;\n  //    for (int j = i; j < s.size(); j++) {\n  //      ++temp_map[s[j]];\n  //      if (temp_map[s[j]] > 1) {\n  //        string sss = s.substr(i, j - i);\n  //        ss.push_back(sss);\n  //        break;\n  //      }\n  //      if (j == s.size() - 1) {\n  //        string sss = s.substr(i, s.size() - i);\n  //        ss.push_back(sss);\n  //      }\n  //    }\n  //  }\n  //  if (ss.size() == 0) {\n  //    return s.size();\n  //  }\n  //  sort(ss.begin(), ss.end(),\n  //       [](string &a, string &b) { return a.size() > b.size(); });\n  //  return ss[0].size();\n  //}\n\n````\n\n### [2024. 考试的最大困扰度](https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/)\n\n一位老师正在出一场由 `n` 道判断题构成的考试，每道题的答案为 true （用 `'T'` 表示）或者 false （用 `'F'` 表示）。老师想增加学生对自己做出答案的不确定性，方法是 **最大化** 有 **连续相同** 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n\n给你一个字符串 `answerKey` ，其中 `answerKey[i]` 是第 `i` 个问题的正确结果。除此以外，还给你一个整数 `k` ，表示你能进行以下操作的最多次数：\n\n- 每次操作中，将问题的正确答案改为 `'T'` 或者 `'F'` （也就是将 `answerKey[i]` 改为 `'T'` 或者 `'F'` ）。\n\n请你返回在不超过 `k` 次操作的情况下，**最大** 连续 `'T'` 或者 `'F'` 的数目。\n\n \n\n**示例 1：**\n\n```\n输入：answerKey = \"TTFF\", k = 2\n输出：4\n解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = \"TTTT\" 。\n总共有四个连续的 'T' 。\n```\n\n**示例 2：**\n\n```\n输入：answerKey = \"TFFT\", k = 1\n输出：3\n解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = \"FFFT\" 。\n或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = \"TFFF\" 。\n两种情况下，都有三个连续的 'F' 。\n```\n\n#### 思路\n\n1. 用框架 但需要使用额外的 On   90ms 10mb\n2. 官方题解 有点类似分治的思想 以T和F都当作最大值基准算一遍 取结果最大值  30ms 10mb\n\n#### 代码\n\n框架  90ms 10mb\n\n```c++\n//滑动窗口 框架\nclass Solution {\npublic:\n    int maxConsecutiveAnswers(string answerKey, int k) {\n        int n = answerKey.size();\n        unordered_map<int, int> window;\n        int left = 0, right = 0;\n        int ans = 0;\n        while(right<n){\n            char c = answerKey[right];\n            right++;\n            window[c]++;\n            //窗口缩小\n            while(window['F']> k && window['T']>k){\n                char d = answerKey[left];\n                left++;\n                window[d]--;\n            }\n            ans = max(window['F']+window['T'], ans);\n        }\n        return ans;\n    }\n};\n```\n\n官方 30ms 10mb\n\n```c++\nclass Solution {\npublic:\n    //ch 假设的最大值字母\n    int maxConsecutiveChar(string& answerKey, int k, char ch) {\n        int n = answerKey.length();\n        int ans = 0;\n        //sum 为另一种 杂质字母的数量\n        for (int left = 0, right = 0, sum = 0; right < n; right++) {\n            sum += answerKey[right] != ch;\n            while (sum > k) {\n                //不断left++ 减小另一个字母数量\n                sum -= answerKey[left++] != ch;\n            }\n            ans = max(ans, right - left + 1);\n        }\n        return ans;\n    }\n\n    int maxConsecutiveAnswers(string answerKey, int k) {\n        return max(maxConsecutiveChar(answerKey, k, 'T'),\n                   maxConsecutiveChar(answerKey, k, 'F'));\n    }\n};\n```\n\n### [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)\n\n难度中等393\n\n给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回 *数组中连续 `1` 的最大个数* 。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2\n输出：6\n解释：[1,1,1,0,0,1,1,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 6。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\n输出：10\n解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\n粗体数字从 0 翻转到 1，最长的子数组长度为 10。\n```\n\n思路\n\n滑动窗口是一个思想 重点在于窗口指针的移动 \n\n所以 哈希只是通用性比较强 在有的情况下是可以替换乃至省去的\n\n代码\n\n模板\n\n```c++\nclass Solution {\npublic:\n    int longestOnes(vector<int>& nums, int k) {\n        int n = nums.size();\n        unordered_map<int,int> window;\n        int left = 0, right = 0;\n        int ans = 0;\n        while(right<n){\n            int c = nums[right];\n            window[c]++;\n            right++;\n            while(window[0]>k){\n                int d = nums[left];\n                left++;\n                window[d]--;\n            }\n            ans = max(ans, window[1] + window[0]);\n        }\n        return ans;\n    }\n};\n```\n\n空间优化版本：只需要维护0的个数就可以了\n\n```c++\nclass Solution {\npublic:\n    int longestOnes(vector<int>& A, int K) {\n        int res = 0, zeros = 0, left = 0;\n        for (int right = 0; right < A.size(); ++right) {\n            if (A[right] == 0) ++zeros;\n            while (zeros > K) {\n                if (A[left++] == 0) --zeros;\n            }\n            res = max(res, right - left + 1);\n        }\n        return res;\n    }\n};\n```\n\n### [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n\n难度中等576\n\n给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。\n\n在执行上述操作后，返回包含相同字母的最长子字符串的长度。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ABAB\", k = 2\n输出：4\n解释：用两个'A'替换为两个'B',反之亦然。\n```\n\n**示例 2：**\n\n```\n输入：s = \"AABABBA\", k = 1\n输出：4\n解释：\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n```\n\n思路\n\n滑动窗口融会贯通，比如这个题 就没想到怎么用map滑\n\n代码\n\n```c++\nclass Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        vector<int> num(26);\n        int n = s.length();\n        int maxn = 0;\n        int left = 0, right = 0;\n        while (right < n) {\n            num[s[right] - 'A']++;\n            //maxn维护窗口最多元素的个数 以进行非最多元素个数的统计判断\n            maxn = max(maxn, num[s[right] - 'A']);\n            if (right - left + 1 - maxn > k) {\n                num[s[left] - 'A']--;\n                left++;\n            }\n            right++;\n        }\n        return right - left;\n    }\n};\n```\n\n### [剑指 Offer II 008. 和大于等于 target 的最短子数组](https://leetcode-cn.com/problems/2VG8Kg/)\n\n难度中等53\n\n给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n\n找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n\n \n\n**示例 1：**\n\n```\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n```\n\n**示例 2：**\n\n```\n输入：target = 4, nums = [1,4,4]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n```\n\n#### 思路\n\n滑动窗口 模板大概还是那个模板 两个while比较好理解\n\n#### 代码\n\n```c++\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int left = 0; \n        int right = 0;\n        int n = nums.size();\n        int sum = 0; \n        int ans = INT_MAX;\n        while(right<n){\n            sum += nums[right];\n            right++;\n            while(sum>=target) {\n                ans = min(ans, right - left);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        return ans == INT_MAX ? 0 : ans;\n    }\n};\n```\n\n### [剑指 Offer II 009. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/ZVAVXX/)\n\n难度中等63\n\n给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [10,5,2,6], k = 100\n输出: 8\n解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于100的子数组。\n```\n\n**示例 2:**\n\n```\n输入: nums = [1,2,3], k = 0\n输出: 0\n```\n\n#### 思路\n\n1. 这道题 正确解法 应该是滑动窗口\n\n   > `重点 right - left + 1`\n   >\n   > 比如某次遍历符合题意的子数组为 ABCX，那么在该条件下符合条件的有X，CX，BCX，ABCX共四个（可以进行多个例子，发现个数符合right-left+1）\n\n2. 但是 做这道题的过程中 感觉这个 不跳步的回溯 挺有意思 外层循环backtrack \n\n   其实 好像相当于两层for循环了 卧槽 我真是垃圾\n   \n   <u>`其实 也好像有点类似n叉树 有向图的遍历吧？`</u>[图论 | qianxunslimgのblog](https://qianxunslimg.github.io/2022/03/15/tu-lun/)\n\n#### 代码\n\n正确的滑动窗口解法\n\n```c++\nclass Solution {\npublic:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        int multi = 1;\n        int n = nums.size();\n        if(k <= 1) return 0;\n        int left = 0, right = 0;\n        int ans = 0;\n        while(right < n){\n            multi*=nums[right];\n            while(multi>=k){\n                multi/=nums[left];\n                left++;\n            }\n            ans += (right - left + 1); //注意 每次+的是窗口的长度\n            right++;  //这个写在前面也是可以的 只是right - left 不加1\n        }\n        return ans;\n    }\n};\n```\n\n回溯（假）\n\n```c++\nclass Solution {\npublic:\n    int ans;\n    //vector<vector<int>> all;\n    //vector<int> path;\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        ans = 0;\n        for(int i = 0; i<nums.size(); i++){\n            backtrack(nums, i, 1, k);\n        }\n        // cout<<all.size()<<endl;\n        // for(int i = 0; i<all.size(); i++){\n        //     for(int j = 0; j<all[i].size(); j++){\n        //         cout<<all[i][j]<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n        return ans;\n    }\n\n    void backtrack(vector<int>& nums, int startIndex, int preK, int k){\n        if(startIndex>=nums.size() || preK>=k) return;\n        preK*=nums[startIndex];\n        //path.push_back(nums[startIndex]);\n        if(preK<k){\n          ans++;  \n          //all.push_back(path);\n        }\n        backtrack(nums, startIndex+1, preK, k);\n        preK /= nums[startIndex];\n        //path.pop_back();\n    }\n};\n```\n\n### [剑指 Offer II 057. 值和下标之差都在给定的范围内](https://leetcode-cn.com/problems/7WqeDu/)\n\n难度中等35\n\n给你一个整数数组 `nums` 和两个整数 `k` 和 `t` 。请你判断是否存在 **两个不同下标** `i` 和 `j`，使得 `abs(nums[i] - nums[j]) <= t` ，同时又满足 `abs(i - j) <= k` 。\n\n如果存在则返回 `true`，不存在返回 `false`。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3,1], k = 3, t = 0\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,0,1,1], k = 1, t = 2\n输出：true\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,5,9,1,5,9], k = 2, t = 3\n输出：false\n```\n\n#### 方法1\n\n滑动窗口 用set进行排序 查找满足条件的最小元素\n\n```c++\nclass Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n      set<int> window;\n      int left = 0, right = 0;\n      while(right < nums.size()){\n        int num = nums[right];\n        right++;\n        \n        //查找set内落在 [num -t, num + t]的元素 也就是>=num-t的第一个元素\n        auto iter = window.lower_bound(max(num, INT_MIN + t) - t);\n        if (iter != window.end() && *iter <= min(num, INT_MAX - t) + t) \n            return true;\n\n        window.insert(num);\n        if(window.size() > k){\n          window.erase(nums[left]);\n          left++;\n        }\n      }\n      return 0;\n    }\n};\n```\n\n#### 方法2\n\n`桶排序`我们可以把输入的元素按桶的个数，假设位t的间隔进行划分。\n划分成：\n第一个桶，存放[0...t]的数,\n第二个桶，存放[t+1...2t],\n...,\n最后一个桶[(n-1)t...nt]。\n\n举个例子:\n若输入t = 3,nums = [1,5,9,1,5,8]，我们按照上面的思路，进行划分，因为0 < nums[0] = 1 < t，于是我们放入第一个桶，t + 1 = 4 < nums[1] = 5 < 2t = 6，于是放入第二个桶，其它同理，最后我们得到分布了数据的三个桶\n\n[0...3]:1,1\n[4...6]:5,5\n[7...9]:9,8\n因为我们是按大小为t来划分每一个桶的，所以如果两个数据落在了一个桶，我们就能够断言其绝对值之差是在t以内。\n\n有一个问题，如果元素分布在两个桶中，那么它们的绝对值之差一定大于t吗？\n显然，不是的。\n\n若其中一个为上边界，另一个为下边界。如|7 - 6| = 1 <t∣7−6∣=1<t，可见分布在相邻桶的元素也可能会存在绝对值之差小于t的情况。\n\n因此，综合上面的解释我们可以确定两种情况下：\n\n任意两个元素落在了一个桶\n分布在相邻桶的元素绝对值之差有可能小于t\n于是乎(借助官方题解的代码)\n\n\n```c++\n// 第一种情况，分布在同一个桶\nif (mp.count(id)) {\n    return true;\n}\n// 第二种情况\n// 判断相邻桶是否已经有元素\n// 若有则判断是否绝对值之差在t内\nif (mp.count(id - 1) && abs(x - mp[id - 1]) <= t) {\n    return true;\n}\nif (mp.count(id + 1) && abs(x - mp[id + 1]) <= t) {\n    return true;\n}\n```\n","tags":["算法总结"]},{"title":"Leetcode高频","url":"/2022/03/14/leetcode-gao-pin/","content":"\n# Leetcode-retag\n\n重新分类 Leetcode 高频题 2021 版\n\n- 题目按照面试频率降序排列\n- 增加难度分类，适合从简单开始学习\n- 增加细分类别，例如单调栈，前缀树等，一道题目可能会有多个类别\n\n# 目录\n- [𐀴 链表](#𐀴-链表)\n    - 单链表\n    - 双链表\n- [𐀴 树](#𐀴-树)\n    - 遍历\n    - 构造\n    - 路径 | 深度 | 翻转\n    - 二叉搜索树\n    - 前缀树\n    - * 线段树\n- [𐀴 栈](#𐀴-栈)\n    - 基础\n    - 单调栈\n- [𐀴 堆](#𐀴-堆)\n    - 基础\n- [𐀴 二分查找](#𐀴-二分查找)\n- [𐀴 位运算](#𐀴-位运算)\n- [𐀴 双指针与滑动窗口](#𐀴-双指针与滑动窗口)\n- [𐀴 矩阵](#𐀴-矩阵)\n- [𐀴 动态规划](#𐀴-动态规划)\n    - 一维\n    - 二维\n- [𐀴 图论](#𐀴-图论)\n    - DFS\n    - BFS\n    - * Dijkstra\n    - 拓扑排序\n- [𐀴 并查集](#𐀴-并查集)\n- [𐀴 设计](#𐀴-设计)\n- [𐀴 贪心](#𐀴-贪心)\n- [𐀴 回溯](#𐀴-回溯)\n- [𐀴 克隆](#𐀴-克隆)\n- [𐀴 数学](#𐀴-数学)\n- [𐀴 \\* 极大极小化](#𐀴-极大极小化)\n- [𐀴 \\* 几何](#𐀴-几何)\n\n## 𐀴 链表\n\n#### 单链表：\n\n###### 简单：\n\n- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)\n- [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)\n- [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n- [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)\n- [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n- [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n- [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n###### 中等\n\n- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)\n- [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)\n- [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)\n- [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n- [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)\n- [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)\n- [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n- [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n- [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)\n- [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)\n- [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n- [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)\n- [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)\n- [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n- [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)\n- [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)\n\n###### 困难\n- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n#### 双链表：\n\n###### 简单：\n\n- [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n- [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n###### 中级\n\n- [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)\n- [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)\n- [1669. 合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists/)\n\n###### 困难\n\n- [23. 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n## 𐀴 树\n\n#### 遍历\n\n###### 简单\n\n- [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n- [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n- [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n- [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n- [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n###### 中等\n\n- [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n- [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n- [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)\n\n#### 构造\n\n###### 简单\n- [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n###### 中等\n- [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n- [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n- [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n- [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n- [1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)\n\n###### 困难\n- [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n#### 路径 | 深度 | 翻转\n\n###### 简单\n\n- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n- [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n- [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n- [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)\n- [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)\n- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n- [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)\n- [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n- [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)\n- [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n###### 中等\n\n- [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n- [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n- [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n- [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)\n- [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n- [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n- [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)\n- [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)\n- [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)\n- [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)\n\n###### 困难\n\n- [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n- [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n#### 二叉搜索树\n\n###### 简单\n\n- [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)\n\n###### 中等\n\n- [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n- [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)\n- [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n- [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n- [230. 二叉搜索树中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n- [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)\n\n#### 字典树\n\n###### 简单\n\n- [720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)\n\n###### 中等\n\n- [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n- [692. 前 K 个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)\n- [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)\n\n###### 困难\n\n- [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)\n\n#### 线段树\n\n###### 中等\n\n- [1353. 最多可以参加的会议数目](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/)\n- [307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)\n\n###### 困难\n\n- [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)\n- [493. 翻转对](https://leetcode-cn.com/problems/reverse-pairs/)\n- [218. 天际线问题](https://leetcode-cn.com/problems/the-skyline-problem/)\n- [715. Range 模块](https://leetcode-cn.com/problems/range-module/)\n- [850. 矩形面积 II](https://leetcode-cn.com/problems/rectangle-area-ii/)\n- [1157. 子数组中占绝大多数的元素](https://leetcode-cn.com/problems/online-majority-element-in-subarray/)\n- [699. 掉落的方块](https://leetcode-cn.com/problems/falling-squares/)\n- [327. 区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)\n\n\n## 𐀴 栈\n\n#### 基础\n\n###### 简单\n\n- [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n- [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)\n- [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n- [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)\n- [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n- [1021. 删除最外层的括号](https://leetcode-cn.com/problems/remove-outermost-parentheses/)\n- [682. 棒球比赛](https://leetcode-cn.com/problems/baseball-game/)\n- [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)\n\n###### 中等\n\n- [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)\n- [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n- [456. 132 模式](https://leetcode-cn.com/problems/132-pattern/)\n- [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)\n- [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n- [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n- [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)\n- [856. 括号的分数](https://leetcode-cn.com/problems/score-of-parentheses/)\n- [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)\n- [385. 迷你语法分析器](https://leetcode-cn.com/problems/mini-parser/)\n- [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)\n- [636. 函数的独占时间](https://leetcode-cn.com/problems/exclusive-time-of-functions/)\n- [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)\n\n###### 困难\n\n- [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)\n- [726. 原子的数量](https://leetcode-cn.com/problems/number-of-atoms/)\n\n\n#### 单调栈\n\n###### 简单\n\n- [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n###### 中等\n\n- [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)\n- [402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)\n- [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)\n- [1124. 表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/)\n\n###### 困难\n\n- [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n- [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)\n- [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)\n\n\n## 𐀴 堆\n\n#### 基础\n\n###### 简单\n\n- [1046. 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)\n- [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)\n\n###### 中等\n\n- [215. 数组中的第 K 个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n- [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n- [692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)\n- [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n- [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n- [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)\n- [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)\n- [973. 最接近原点的 K 个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)\n\n###### 困难\n\n- [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n- [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)\n- [218. 天际线问题](https://leetcode-cn.com/problems/the-skyline-problem/)\n\n\n## 𐀴 二分查找\n\n###### 简单\n\n- [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n- [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)\n- [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n- [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n- [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n- [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n###### 中等\n\n- [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n- [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)\n- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n- [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n- [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n- [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n- [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n- [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n- [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)\n- [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n- [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)\n- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n- [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n- [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n- [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n###### 困难\n\n- [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)\n- [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)\n- [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)\n- [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n## 𐀴 位运算\n\n###### 简单\n\n- [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n- [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)\n- [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)\n- [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)\n- [231. 2的幂](https://leetcode-cn.com/problems/power-of-two/)\n- [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)\n- [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n- [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)\n- [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n###### 中等\n\n- [78. 子集](https://leetcode-cn.com/problems/subsets/)\n- [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n- [1318. 或运算的最小翻转次数](https://leetcode-cn.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/)\n- [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)\n- [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)\n- [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)\n- [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)\n- [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)\n\n## 𐀴 双指针与滑动窗口\n\n###### 简单\n\n- [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)\n- [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n- [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)\n- [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n- [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)\n- [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n- [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)\n- [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n- [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n- [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)\n- [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)\n\n###### 中等\n\n- [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n- [781. 森林中的兔子](https://leetcode-cn.com/problems/rabbits-in-forest/)\n- [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n- [18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n- [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n- [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n- [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)\n- [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)\n- [18. 四数之和](https://leetcode-cn.com/problems/4sum/)\n- [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)\n- [713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)\n\n###### 困难\n\n- [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)\n- [992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/)\n\n## 𐀴 矩阵\n\n###### 简单\n\n- [867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)\n- [832. 翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)\n\n###### 中等\n\n- [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)\n- [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)\n- [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)\n- [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)\n\n## 𐀴 动态规划\n\n### 一维\n\n###### 简单\n\n- [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n- [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)\n- [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n- [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)\n\n###### 中等\n\n- [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)\n- [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)\n- [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n- [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)\n- [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)\n- [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)\n- [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n- [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n- [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n\n###### 困难\n\n- [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n- [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)\n- [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n### 二维\n\n###### 中等\n\n- [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n- [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)\n- [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)\n- [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n- [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)\n- [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)\n- [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n- [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n- [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n\n###### 困难\n\n- [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)\n- [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)\n- [887. 鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)\n- [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)\n- [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)\n- [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)\n\n## 𐀴 图论\n\n### DFS\n\n###### 中等\n\n- [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n- [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)\n- [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)\n- [494. 目标和](https://leetcode-cn.com/problems/target-sum/)\n- [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)\n- [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n- [1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/) \n- [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n- [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n###### 困难\n\n- [679. 24 点游戏](https://leetcode-cn.com/problems/24-game/)\n\n### BFS\n\n###### 简单\n\n- [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)\n\n###### 中等\n\n- [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)\n- [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n- [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)\n- [934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)\n- [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)\n- [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)\n- [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)\n- [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)\n- [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)\n\n###### 困难\n\n- [815. 公交路线](https://leetcode-cn.com/problems/bus-routes/)\n- [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)\n- [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)\n- [773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)\n- [827. 最大人工岛](https://leetcode-cn.com/problems/making-a-large-island/)\n\n### Dijkstra\n\n- [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)\n\n### 拓扑排序\n\n###### 中等\n\n- [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)\n- [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n###### 困难\n\n- [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)\n- [1203. 项目管理](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/)\n\n## 𐀴 并查集\n\n###### 中等\n\n- [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)\n- [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)\n- [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)\n- [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)\n- [1631. 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)\n- [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)\n- [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)\n- [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)\n\n###### 困难\n\n- [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n- [765. 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)\n\n## 𐀴 设计\n\n###### 简单\n\n- [1603. 设计停车系统](https://leetcode-cn.com/problems/design-parking-system/)\n- [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)\n- [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)\n- [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)\n\n###### 中等\n\n- [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n- [341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)\n- [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n- [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n- [622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)\n- [380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)\n\n###### 困难\n\n- [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)\n- [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)\n\n## 𐀴 贪心\n\n###### 中等\n\n- [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)\n- [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)\n- [767. 重构字符串](https://leetcode-cn.com/problems/reorganize-string/)\n- [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)\n- [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)\n\n\n## 𐀴 回溯\n\n###### 中等\n\n- [46. 全排列](https://leetcode-cn.com/problems/permutations/)\n- [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)\n- [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)\n- [78. 子集](https://leetcode-cn.com/problems/subsets/)\n- [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)\n- [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)\n- [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)\n- [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)\n- [77. 组合](https://leetcode-cn.com/problems/combinations/)\n- [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)\n- [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)\n- [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)\n- [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)\n- [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)\n\n###### 困难\n\n- [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)\n- [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)\n- [126. 单词接龙 II](https://leetcode-cn.com/problems/word-ladder-ii/)\n- [1659. 最大化网格幸福感](https://leetcode-cn.com/problems/maximize-grid-happiness/)\n\n## 𐀴 克隆\n\n###### 中等\n\n- [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)\n- [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)\n\n## 𐀴 数学\n\n##### 简单\n\n- [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)\n- [628. 三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)\n- [976. 三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)\n- [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)\n- [1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)\n\n###### 中等\n\n- [29. 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)\n- [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)\n- [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)\n\n###### 困难\n\n- [149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)\n\n\n## 𐀴 极大极小化\n\n###### 简单\n\n- [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)\n\n###### 中等\n\n- [375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)\n- [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)\n- [464. 我能赢吗](https://leetcode-cn.com/problems/can-i-win/)\n- [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)\n\n## 𐀴 几何\n\n###### 简单\n\n- [1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)\n- [1266. 访问所有点的最小时间](https://leetcode-cn.com/problems/minimum-time-visiting-all-points/)\n- [892. 三维形体的表面积](https://leetcode-cn.com/problems/surface-area-of-3d-shapes/)\n\n###### 中等\n\n- [1401. 圆和矩形是否有重叠](https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/)\n- [963. 最小面积矩形 II](https://leetcode-cn.com/problems/minimum-area-rectangle-ii/)\n\n###### 困难\n\n- [587. 安装栅栏](https://leetcode-cn.com/problems/erect-the-fence/)\n- [1515. 服务中心的最佳位置](https://leetcode-cn.com/problems/best-position-for-a-service-centre/)\n","tags":["leetcode"]},{"title":"VMware打开ubantu黑屏无反应","url":"/2021/12/03/vmware-da-kai-ubantu-hei-ping-wu-fan-ying/","content":"\n设置VMware编辑--&gt;首选项--&gt;设备--&gt;启用虚拟打印机 即可\n\n<img src=\"https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/image-20220423000802445.png\" alt=\"image-20220423000802445\" style=\"zoom:67%;\" />\n\n"},{"title":"QT编写串口助手","url":"/2021/12/02/qt-bian-xie-chuan-kou-zhu-shou/","content":"\n***.pro文件中***\n\nQT += serialport\n\n***serial.h:***\n\n```c++\n 1 #ifndef SERIAL_H\n 2 #define SERIAL_H\n 3 \n 4 #include <QMainWindow>\n 5 \n 6 /*-------user--------------------*/\n 7 //port\n 8 #include <QSerialPort>\n 9 //debug\n10 #include <QDebug>\n11 /*-------------------------------*/\n12 \n13 namespace Ui {\n14 class Serial;\n15 }\n16 \n17 class Serial : public QMainWindow\n18 {\n19     Q_OBJECT\n20 \n21 public:\n22     explicit Serial(QWidget *parent = 0);\n23     ~Serial();\n24 \n25 private slots:\n26     //button\n27     void btn_open_port(bool);\n28     void btn_close_port(bool);\n29     void btn_send_data(bool);\n30 \n31     //receive data\n32     void receive_data();\n33 \n34 private:\n35     Ui::Serial *ui;\n36     /*----------funtion-------------------*/\n37     void system_init();\n38     /*----------variable-------------------*/\n39     QSerialPort global_port;\n40 };\n41 \n42 #endif // SERIAL_H\n```\n\nmain.cpp:\n\n```c++\n 1 #include \"serial.h\"\n 2 #include <QApplication>\n 3 \n 4 int main(int argc, char *argv[])\n 5 {\n 6     QApplication a(argc, argv);\n 7     Serial w;\n 8     w.show();\n 9 \n10     return a.exec();\n11 }\n```\n\n***serial.cpp:***\n\n```cpp\n  1 #include \"serial.h\"\n  2 #include \"ui_serial.h\"\n  3 \n  4 Serial::Serial(QWidget *parent) :\n  5     QMainWindow(parent),\n  6     ui(new Ui::Serial)\n  7 {\n  8     ui->setupUi(this);\n  9     //user\n 10     system_init();\n 11 }\n 12 \n 13 Serial::~Serial()\n 14 {\n 15     delete ui;\n 16 }\n 17 \n 18 /*--------------------------------------------------------------------------\n 19  *          funtions\n 20  * -------------------------------------------------------------------------*/\n 21 void Serial::system_init()\n 22 {\n 23     //port config\n 24     global_port.setParity(QSerialPort::NoParity);\n 25     global_port.setDataBits(QSerialPort::Data8);\n 26     global_port.setStopBits(QSerialPort::OneStop);\n 27 \n 28     //connect\n 29     connect(ui->btn_open,&QPushButton::clicked,this,&Serial::btn_open_port);\n 30     connect(ui->btn_close,&QPushButton::clicked,this,&Serial::btn_close_port);\n 31     connect(ui->btn_send,&QPushButton::clicked,this,&Serial::btn_send_data);\n 32     connect(&global_port,&QSerialPort::readyRead,this,&Serial::receive_data);\n 33 }\n 34 /*--------------------------------------------------------------------------\n 35  *          slots\n 36  * -------------------------------------------------------------------------*/\n 37 void Serial::btn_open_port(bool)\n 38 {\n 39     /*--------port name------------------------*/\n 40     qDebug()<<ui->cmb_port_name->currentIndex();//printf 0\n 41 //    int i = 10;\n 42 //    qDebug(\"%d\",i);\n 43     switch (ui->cmb_port_name->currentIndex()) {\n 44     case 0:\n 45         global_port.setPortName(\"COM1\");\n 46         break;\n 47     case 1:\n 48         global_port.setPortName(\"COM2\");\n 49         break;\n 50     case 2:\n 51         global_port.setPortName(\"COM3\");\n 52         break;\n 53     case 3:\n 54         global_port.setPortName(\"COM4\");\n 55         break;\n 56     case 4:\n 57         global_port.setPortName(\"COM5\");\n 58         break;\n 59     case 5:\n 60         global_port.setPortName(\"COM6\");\n 61         break;\n 62     case 6:\n 63         global_port.setPortName(\"COM7\");\n 64         break;\n 65     default:\n 66          global_port.setPortName(\"COM8\");\n 67         break;\n 68     }\n 69     /*--------baud rate-----------------------------*/\n 70     switch (ui->cmb_baud_rate->currentIndex()) {\n 71     case 0:\n 72         global_port.setBaudRate(QSerialPort::Baud115200);\n 73         break;\n 74     case 1:\n 75         global_port.setBaudRate(QSerialPort::Baud57600);\n 76         break;\n 77     case 2:\n 78         global_port.setBaudRate(QSerialPort::Baud38400);\n 79         break;\n 80     case 3:\n 81         global_port.setBaudRate(QSerialPort::Baud19200);\n 82         break;\n 83     case 4:\n 84         global_port.setBaudRate(QSerialPort::Baud9600);\n 85         break;\n 86     case 5:\n 87         global_port.setBaudRate(QSerialPort::Baud4800);\n 88         break;\n 89     case 6:\n 90         global_port.setBaudRate(QSerialPort::Baud2400);\n 91         break;\n 92     default:\n 93         global_port.setBaudRate(QSerialPort::Baud1200);\n 94         break;\n 95     }\n 96     //open\n 97     global_port.open(QIODevice::ReadWrite);\n 98     ui->lab_status->setText(\"Connected\");\n 99     //test\n100 //    global_port.write(\"1\");\n101 }\n102 void Serial::btn_close_port(bool)\n103 {\n104     ui->lab_status->setText(\"Disconnected\");\n105     global_port.close();\n106 }\n107 /*------------sending data---------------------*/\n108 void Serial::btn_send_data(bool)\n109 {\n110    QString data = ui->lint_send_data->text();\n111    QByteArray array = data.toLatin1();//QString--->QByteArray\n112    global_port.write(array);\n113 }\n114 /*-----------receive data-----------------*/\n115 void Serial::receive_data()\n116 {\n117    QByteArray array = global_port.readAll();\n118    qDebug()<<array;\n119    if(ui->checkBox->checkState() == Qt::Checked){\n120       ui->plainTextEdit->insertPlainText(QString(array.toHex(' ').toUpper().append(' ')));\n121    }else {\n122        ui->plainTextEdit->insertPlainText(QString(array));\n123    }\n124 }\n```\n\n***ui:***\n\n![img](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200913005814247-966532200.png)\n\n \n"},{"title":"The difference between join and detach","url":"/2021/12/02/the-difference-between-join-and-detach/","content":"\nA C++ `thread` object generally (but not always) represents a thread of execution, which is an OS or platform concept.\n\nWhen `thread::join()` is called, the calling thread will block until the thread of execution has completed. Basically, this is one mechanism that can be used to know when a thread has finished. When `thread::join()` returns, the OS thread of execution has completed and the C++ `thread` object can be destroyed.\n\nThe `thread::detach()` is called, the thread of execution is \"detached\" from the `thread` object and is no longer represented by a `thread` object - they are two independent things. The C++ `thread` object can be destroyed and the OS thread of execution can continue on. If the program needs to know when that thread of execution has completed, some other mechanism needs to be used. `join()` cannot be called on that `thread` object any more, since it is no longer associated with a thread of execution.\n\nIt is considered an error to destroy a C++ `thread` object while it is still \"joinable\". That is, in order to destroy a C++ `thread` object either `join()` needs to be called (and completed) or `detach()` must be called. If a C++ `thread` object is still joinable when it's destroyed, an exception will be thrown.\n\nSome other ways that a C++ `thread` object will not represent a thread of execution (ie., can be unjoinable):\n\n- A default constructed `thread` object does not represent a thread of execution, so is not joinable.\n- A thread that has been moved from will no longer represent a thread of execution, so is not joinable.\n\n \n\n`join()` doesn't kill the thread. Actually it waits until thread main function returns. So if your thread main function looks like this:\n\n```cpp\nwhile (true) {\n}\n```\n\n`join()` is going to wait forever.\n\n`detatch()` doesn't kill thread either. Actually it tells `std::thread` that this thread should continue to run even when `std::thread` object is destroyed. C++ checks in std::thread destructor that thread is either joined or detached and terminates program if this check fails.\n\nSo if you uncomment first line in `main` function of the following code it will crash. If you uncomment second or third line it will work ok.\n\n```cpp\n#include <thread>\n\nvoid func() {\n}\n\nvoid fail1() {\n    std::thread t(func);\n    // will fail when we try to destroy t since it is not joined or detached\n}\n\nvoid works1() {\n    std::thread t(func);\n    t.join();\n}\n\nvoid works2() {\n    std::thread t(func);\n    t.detach();\n}\n\nint main() {\n    // fail1();\n    // works1();\n    // works2();\n}\n```\n"},{"title":"QT文件操作-遍历","url":"/2021/12/02/qt-wen-jian-cao-zuo-bian-li/","content":"\nQT的路径格式使用 / 或 \\\\\n\n读写文本\n\n```c++\n 1     //写文本\n 2     QFile f(\"F:/src/1.txt\");\n 3     if(!f.open(QIODevice::WriteOnly | QIODevice::Text))\n 4     {\n 5         qDebug() << \"Open failed.\" << endl;\n 6     }\n 7 \n 8     QTextStream txtOutput(&f);\n 9     QString s1(\"123\");\n10     quint32 n1(123);\n11 \n12     txtOutput << s1 << endl;\n13     txtOutput << n1 << endl;\n14 \n15     f.close();\n16 \n17 \n18    //读文本\n19     QFile f(\"F:/src/1.txt\");\n20     if(!f.open(QIODevice::ReadOnly | QIODevice::Text))\n21     {\n22         qDebug() << \"Open failed.\" << endl;\n23     }\n24 \n25     QTextStream txtInput(&f);\n26     QString lineStr;\n27     while(!txtInput.atEnd())\n28     {\n29         lineStr = txtInput.readLine();\n30         qDebug() << lineStr << endl;\n31     }\n32 \n33     f.close();\n```\n\n \n\n查找路径下所有特定文件（和文件夹）\n\n```c++\n 1 void fllemanage::on_pushButton_clicked()\n 2 {\n 3     //    int count = 0;\n 4     //    QString dirpath = \"C:/Users/00/Desktop/git clone/OpenCV-Python-Tutorial/.idea\";\n 5     //    //设置要遍历的目录\n 6     //    QDir dir(dirpath);\n 7     //    qDebug()<<dirpath<<endl;\n 8     //    //设置文件过滤器\n 9     //    QStringList nameFilters;\n10     //    //设置文件过滤格式\n11     //    nameFilters << \"*.xml\";\n12     //    dir.setNameFilters(nameFilters);\n13     //    qDebug()<<dir.entryList()<<endl;\n14     //    qDebug()<<dir.entryInfoList()<<endl;\n15     //    //将过滤后的文件名称存入到files列表中\n16     //    QStringList files = dir.entryList(nameFilters, QDir::Files|QDir::Readable, QDir::Name);\n17     //    for(int i = 0; i<files.size(); i++)\n18     //    {\n19     //        qDebug()<<\"now, it's output from QStringlist\"<<endl;\n20     //        qDebug()<<files[i]<<endl;\n21     //    }\n22 \n23     QStringList list = findALLfiles(\"C:/Users/00/Desktop/vsrun/123\");\n24     //QStringList list = findALLfiles(\"C:/Users/00/Desktop/vsrun\");\n25     //for(int i = 0 ; i <list.size(); i++)\n26       //qDebug() <<list[i]<<endl;\n27     QStringList purposelist;\n28     purposelist = list.filter(\".txt\");\n29     int count = 0;\n30     for (int i = 0; i < purposelist.size(); i++)\n31     {\n32         qDebug() << purposelist[i] << endl;\n33         count++;\n34     }\n35     qDebug() << \"the max file has \" << list.size() << endl;\n36     qDebug() << \"the purpose file has \" << count << endl;\n37 \n38     //新建文件夹（目标文件保存的位置）\n39 //     QDir dir(\"C:/Users/00/Desktop/vsrun\");\n40 //     if(!dir.exists(\"copy to here\")){\n41 //         dir.mkdir(\"copy to here\");\n42 //     }\n43     QString toDir = \"C:/Users/00/Desktop/123\";\n44     //toDir.replace(\"\\\\\",\"/\");\n45 \n46     QDir dir(toDir);\n47     if (!dir.exists(toDir)) {\n48         dir.mkdir(toDir);\n49     }\n50 \n51     QFile destFile(toDir);\n52     bool success = true;\n53     success &= destFile.open(QFile::WriteOnly | QFile::Truncate);\n54 \n55     for (int i = 0; i < purposelist.size(); i++)\n56     {\n57         if (QFile::copy(purposelist[i], toDir)) {  //将文件复制到新的文件路径下\n58             {//QFile::copy(purposelist[i],toDir);\n59                 qDebug() << QStringLiteral(\"复制成功\");\n60             }\n61         }\n62     }\n63 }\n64 \n65 //迭代器遍历所有文件并返回\n66 QStringList fllemanage::findALLfiles(const QString &dir_path) {\n67     QStringList get_files;\n68     QDir dir(dir_path);\n69     if (!dir.exists())\n70     {\n71         qDebug() << \"it is not true dir_path\";\n72     }\n73 \n74     /*设置过滤参数，QDir::NoDotAndDotDot表示不会去遍历上层目录*/\n75     QDirIterator dir_iterator(dir_path, QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);\n76 \n77     while (dir_iterator.hasNext())\n78     {\n79         dir_iterator.next();\n80         QFileInfo file_info = dir_iterator.fileInfo();\n81         QString files = file_info.absoluteFilePath();\n82         get_files.append(files);\n83     }\n84 \n85     return get_files;\n86 }\n```\n\n \n\nQFile copy（报错未实现 QIodevce not opened） \n\n```c++\n    //    copy测试！！！！！！\n    //    QFile src(\"F:/src\");\n    //    QFile dst(\"F:/dst\");\n\n    //    bool success = true;\n    //    success &= src.open( QFile::ReadOnly );\n    //    success &= dst.open( QFile::WriteOnly | QFile::Truncate );\n    //    success &= dst.write( src.readAll() ) >= 0;\n\n    //   QFile::copy(\"F:/src/1.txt\" , \"F:/dst\");\n    //    src.close();\n    //    dst.close();\n```\n\n更新：QFile copy 函数写法：\n\n```c++\nQFile::copy(\"F:/src/1.txt\" , \"F:/dst/2.txt\")；  //（具体文件名 to 具体文件名）\n\n\ncopy函数不能对string类型的路径进行操作，可从QString转string操作再转QString：\n\n```\n\n \n\n```c++\n        std::string pur = purposelist[i].toStdString();//都转换为string\n       // qDebug()<<pur<<endl;\n        std::string sdir = toDir.toStdString();\n        int pos = pur.find_last_of('/'); //找到最后/\n        std::string s(pur.substr(pos+1));\n        sdir.append(\"/\");\n        sdir.append(s);\n        QString qsdir = QString(QString::fromLocal8Bit(sdir.c_str()));\n        qDebug()<<qsdir<<endl;\n \n```\n\n \n"},{"title":"备份程序-遍历","url":"/2021/12/02/bei-fen-cheng-xu-bian-li/","content":"\n```c++\n#include \"fllemanage.h\"\n#include \"ui_fllemanage.h\"\n\nfllemanage::fllemanage(QWidget *parent)\n\t: QWidget(parent)\n\t, ui(new Ui::fllemanage)\n{\n\tui->setupUi(this);\n\n        //copy测试！！！！！！\n//        QFile src(\"F:/src\");\n//        QFile dst(\"F:/dst\");\n\n//        bool success = true;\n//        success &= src.open( QFile::ReadOnly );\n//        success &= dst.open( QFile::WriteOnly | QFile::Truncate );\n//        success &= dst.write( src.readAll() ) >= 0;\n\n//       QFile::copy(\"F:/src/1.txt\" , \"F:/dst/2.txt\");\n//        src.close();\n//        dst.close();\n\n\t//    //写文本\n\t//    QFile f(\"F:/src/1.txt\");\n\t//    if(!f.open(QIODevice::WriteOnly | QIODevice::Text))\n\t//    {\n\t//        qDebug() << \"Open failed.\" << endl;\n\t//    }\n\n\t//    QTextStream txtOutput(&f);\n\t//    QString s1(\"123\");\n\t//    quint32 n1(123);\n\n\t//    txtOutput << s1 << endl;\n\t//    txtOutput << n1 << endl;\n\n\t//    f.close();\n\n\t//   //读文本\n\t//    QFile f(\"F:/src/1.txt\");\n\t//    if(!f.open(QIODevice::ReadOnly | QIODevice::Text))\n\t//    {\n\t//        qDebug() << \"Open failed.\" << endl;\n\t//    }\n\n\t//    QTextStream txtInput(&f);\n\t//    QString lineStr;\n\t//    while(!txtInput.atEnd())\n\t//    {\n\t//        lineStr = txtInput.readLine();\n\t//        qDebug() << lineStr << endl;\n\t//    }\n\n\t//    f.close();\n}\n\nfllemanage::~fllemanage()\n{\n\tdelete ui;\n}\n\nvoid fllemanage::on_pushButton_clicked()\n{\n\t//    int count = 0;\n\t//    QString dirpath = \"C:/Users/00/Desktop/git clone/OpenCV-Python-Tutorial/.idea\";\n\t//    //设置要遍历的目录\n\t//    QDir dir(dirpath);\n\t//    qDebug()<<dirpath<<endl;\n\t//    //设置文件过滤器\n\t//    QStringList nameFilters;\n\t//    //设置文件过滤格式\n\t//    nameFilters << \"*.xml\";\n\t//    dir.setNameFilters(nameFilters);\n\t//    qDebug()<<dir.entryList()<<endl;\n\t//    qDebug()<<dir.entryInfoList()<<endl;\n\t//    //将过滤后的文件名称存入到files列表中\n\t//    QStringList files = dir.entryList(nameFilters, QDir::Files|QDir::Readable, QDir::Name);\n\t//    for(int i = 0; i<files.size(); i++)\n\t//    {\n\t//        qDebug()<<\"now, it's output from QStringlist\"<<endl;\n\t//        qDebug()<<files[i]<<endl;\n\t//    }\n\n    //QStringList list = findALLfiles(\"C:/Users/00/Desktop/vsrun/123\");\n    //QStringList list = findALLfiles(\"C:/Users/00/Desktop/vsrun\");\n    QStringList list = findALLfiles(\"C:/Users/00/Desktop/git clone\");\n                                                                        //for(int i = 0 ; i <list.size(); i++)\n\t  //qDebug() <<list[i]<<endl;\n\tQStringList purposelist;\n    purposelist = list.filter(\".jpg\");\n\tint count = 0;\n\tfor (int i = 0; i < purposelist.size(); i++)\n\t{\n\t\tqDebug() << purposelist[i] << endl;\n\t\tcount++;\n\t}\n\tqDebug() << \"the max file has \" << list.size() << endl;\n\tqDebug() << \"the purpose file has \" << count << endl;\n\n\t//新建文件夹（目标文件保存的位置）\n//     QDir dir(\"C:/Users/00/Desktop/vsrun\");\n//     if(!dir.exists(\"copy to here\")){\n//         dir.mkdir(\"copy to here\");\n//     }\n    QString toDir = \"C:/Users/00/Desktop/123\";\n\n\t//toDir.replace(\"\\\\\",\"/\");\n\n\tQDir dir(toDir);\n\tif (!dir.exists(toDir)) {\n\t\tdir.mkdir(toDir);\n\t}\n\n\tQFile destFile(toDir);\n\tbool success = true;\n\tsuccess &= destFile.open(QFile::WriteOnly | QFile::Truncate);\n\n\tfor (int i = 0; i < purposelist.size(); i++)\n    {\n        std::string pur = purposelist[i].toStdString();//都转换为string\n       // qDebug()<<pur<<endl;\n        std::string sdir = toDir.toStdString();\n\n        int pos = pur.find_last_of('/'); //找到最后/\n        std::string s(pur.substr(pos+1));\n        sdir.append(\"/\");\n\n        sdir.append(s);\n        QString qsdir = QString(QString::fromLocal8Bit(sdir.c_str()));\n        qDebug()<<qsdir<<endl;\n        if (QFile::copy(purposelist[i], qsdir)) {  //将文件复制到新的文件路径下\n            {\n                if(QFile::copy(purposelist[i],toDir))\n                 qDebug() << QStringLiteral(\"复制成功\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n//迭代器遍历所有文件并返回\nQStringList fllemanage::findALLfiles(const QString &dir_path) {\n\tQStringList get_files;\n\tQDir dir(dir_path);\n\tif (!dir.exists())\n\t{\n\t\tqDebug() << \"it is not true dir_path\";\n\t}\n\n\t/*设置过滤参数，QDir::NoDotAndDotDot表示不会去遍历上层目录*/\n\tQDirIterator dir_iterator(dir_path, QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);\n\n\twhile (dir_iterator.hasNext())\n\t{\n\t\tdir_iterator.next();\n\t\tQFileInfo file_info = dir_iterator.fileInfo();\n\t\tQString files = file_info.absoluteFilePath();\n\t\tget_files.append(files);\n\t}\n\n\treturn get_files;\n}\n```\n"},{"title":"垃圾文件助手","url":"/2021/12/02/la-ji-wen-jian-zhu-shou/","content":"\n没看程序，白天搞的雕刻机（呕~~）\n\n强行凑每日一篇，上传一个自己写的垃圾文件助手\n\n可以实现目标文件下的文件名搜寻，并进行删除和复制整理到新文件夹（拉吉如我）\n\n博客园竟然还有文件上传限制。。。github链接：https://github.com/qianxunslimg/QFileManage\n\n"},{"title":"Ui文件和Qt代码的关系(转载自大神Mike江)","url":"/2021/12/02/ui-wen-jian-he-qt-dai-ma-de-guan-xi-zhuan-zai-zi-da-shen-mike-jiang/","content":"\nhttps://blog.csdn.net/tennysonsky/article/details/48030333\n\n \n\n如果现有类与新建ui文件的话。除了修改上述地方外，还要修改UI编译产生的头文件，\n\n修改方法参照Widget自动生成的ui_***.h\n\n"},{"title":"Qt Windows.h 后台按键监测","url":"/2021/12/02/qt-windows-h-hou-tai-an-jian-jian-ce/","content":"\n首先 pro：\n\n```c++\nLIBS +=User32.LIB\n\n\nmain.cpp：\n#include \"hooktest.h\"\n#include \"ui_hooktest.h\"\n#include <QDebug>\n\nLRESULT CALLBACK keyProc(int nCode, WPARAM wParam, LPARAM lParam);\n\nHHOOK keyHook=NULL;\nWPARAM lastkey=0;\nQString lastStr;\n\nint starthook();\nHookTest::HookTest(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::HookTest)\n{\n    ui->setupUi(this);\n        keyHook = SetWindowsHookEx(WH_KEYBOARD_LL, keyProc, GetModuleHandle(NULL), 0);\n\n        MSG msg = { 0 };\n        while (GetMessage(&msg, NULL, 0, 0)) {  //WM_QUIT消息 退出\n        //将虚拟键消息转换为字符消息,虚拟键值                `\n        //VK_UP,VK_DOWN\n        TranslateMessage(&msg);\n        //将消息分发给窗口处理函数\n        DispatchMessage(&msg);\n        }\n}\n\nHookTest::~HookTest()\n{\n    delete ui;\n}\n\nLRESULT CALLBACK keyProc(int nCode, WPARAM wParam, LPARAM lParam){\n    PKBDLLHOOKSTRUCT key = (PKBDLLHOOKSTRUCT)lParam;\n    qDebug()<<key->vkCode<<endl;\n    return CallNextHookEx(keyHook, nCode, wParam, lParam);\n}\n```\n"},{"title":"windows API关闭exe","url":"/2021/12/02/windows-api-guan-bi-exe/","content":"\n# [windows API关闭exe](https://www.cnblogs.com/qianxunslimg/p/14351941.html)\n\n可以直接使用的函数 做个备份 只需要输入要关闭的文件名就好了\n\n```c++\n#include <Windows.h>\n#include <Tlhelp32.h>\n#include <stdio.h>\n#include <winnt.h>\n \nvoid terminateSuwellReader(const char* str)\n{\n    HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);\n \n    //现在我们获得了所有进程的信息。\n    //将从hSnapShot中抽取数据到一个PROCESSENTRY32结构中\n    //这个结构代表了一个进程，是ToolHelp32 API的一部分。\n    //抽取数据靠Process32First()和Process32Next()这两个函数。\n    //这里我们仅用Process32Next()，他的原形是：\n    //BOOL WINAPI Process32Next(HANDLE hSnapshot,LPPROCESSENTRY32 lppe);\n    //我们程序的代码中加入：\n    PROCESSENTRY32* processInfo=new PROCESSENTRY32;\n    // 必须设置PROCESSENTRY32的dwSize成员的值 ;\n    processInfo->dwSize=sizeof(PROCESSENTRY32);\n    int index=0;\n    //这里我们将快照句柄和PROCESSENTRY32结构传给Process32Next()。\n    //执行之后，PROCESSENTRY32 结构将获得进程的信息。我们循环遍历，直到函数返回FALSE。\n    int ID = 0;\n    while(Process32Next(hSnapShot,processInfo)!=FALSE)\n    {\n        index++;\n        int size=WideCharToMultiByte(CP_ACP,0,processInfo->szExeFile,-1,NULL,0,NULL,NULL);\n        char *ch=new char[size+1];\n        if(WideCharToMultiByte(CP_ACP,0,processInfo->szExeFile,-1,ch,size,NULL,NULL))\n        {\n            //使用这段代码的时候只需要改变\"cmd.exe\".将其改成你要结束的进程名就可以了。\n            if(strstr(ch,str))\n            {\n                ID = processInfo->th32ProcessID;\n                HANDLE hProcess;\n                // 现在我们用函数 TerminateProcess()终止进程，这里我们用PROCESS_ALL_ACCESS\n                hProcess=OpenProcess(PROCESS_ALL_ACCESS,TRUE,ID);\n                TerminateProcess(hProcess,0);\n                CloseHandle(hProcess);\n            }\n        }\n    }\n    CloseHandle(hSnapShot);\n    delete processInfo;\n}\n \nint main(){\n    terminateSuwellReader(\"SuwellReader.exe\");\n    return 0;\n}\n```\n\n　　\n","tags":["开发随笔"]},{"title":"c++ 自然排序-window文件排序","url":"/2021/12/02/c-zi-ran-pai-xu-window-wen-jian-pai-xu/","content":"\n### 起因 \n\nmfc的fileDialog读取批量文件 读取出来的文件名是按照字典序排序的\n\n例如文件（举例子 忽略后缀）：1 2 3 4 5 6 7 8 9 10 11 12\n\n字典序：1 10 11 12 2 3 4 5 6 7 8 9 \n\n而很多时候需要按照`windows自然排序`，也就是例子本身 也就是windows按名称排序的顺序\n\n调整好了一个用的`自然排序`比较函数 如下\n\n#### 代码\n\n```c++\n//自然排序\nbool compareNat(const std::string &a, const std::string &b) {\n  if (a.empty())\n    return true;\n  if (b.empty())\n    return false;\n  if (std::isdigit(a[0]) && !std::isdigit(b[0]))\n    return true;\n  if (!std::isdigit(a[0]) && std::isdigit(b[0]))\n    return false;\n  if (!std::isdigit(a[0]) && !std::isdigit(b[0])) {\n    if (std::toupper(a[0]) == std::toupper(b[0]))\n      return compareNat(a.substr(1), b.substr(1));\n    return (std::toupper(a[0]) < std::toupper(b[0]));\n  }\n\n  // Both strings begin with digit --> parse both numbers\n  std::istringstream issa(a);\n  std::istringstream issb(b);\n  int ia, ib;\n  issa >> ia;\n  issb >> ib;\n  if (ia != ib)\n    return ia < ib;\n\n  // Numbers are the same --> remove numbers and recurse\n  std::string anew, bnew;\n  std::getline(issa, anew);\n  std::getline(issb, bnew);\n  return (compareNat(anew, bnew));\n}\nbool judge(const pair<string, string> a, const pair<string, string> b) {\n  return compareNat(a.first, b.first);\n}\n```\n","tags":["开发随笔"]},{"title":"最小堆make_heap(), pop_heap()和push_heap()","url":"/2021/12/02/zui-xiao-dui-make-heap-pop-heap-he-push-heap/","content":"\n![](https://gitee.com/qianxunslimg/my-pic-go-img/raw/master/img/2092994-20211114224004410-1010288954.png)\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\nmake_heap\n在容器范围内，就地建堆，保证最大值在所给范围的最前面，其他值的位置不确定\n\npop_heap\n将堆顶(所给范围的最前面)元素移动到所给范围的最后，并且将新的最大值置于所给范围的最前面\n\npush_heap\n当已建堆的容器范围内有新的元素插入末尾后，应当调用push_heap将该元素插入堆中。\n\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008080;\"> 1</span> #include&lt;iostream&gt;\n<span style=\"color: #008080;\"> 2</span> #include&lt;vector&gt;\n<span style=\"color: #008080;\"> 3</span> #include&lt;ctime&gt;\n<span style=\"color: #008080;\"> 4</span> #include&lt;deque&gt;\n<span style=\"color: #008080;\"> 5</span> #include&lt;list&gt;\n<span style=\"color: #008080;\"> 6</span> #include&lt;algorithm&gt;\n<span style=\"color: #008080;\"> 7</span> #include&lt;queue&gt;\n<span style=\"color: #008080;\"> 8</span> #include&lt;functional&gt;<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">greater使用</span>\n<span style=\"color: #008080;\"> 9</span>  \n<span style=\"color: #008080;\">10</span> <span style=\"color: #0000ff;\">using</span> <span style=\"color: #0000ff;\">namespace</span><span style=\"color: #000000;\"> std;\n</span><span style=\"color: #008080;\">11</span>  \n<span style=\"color: #008080;\">12</span> <span style=\"color: #0000ff;\">void</span> print(vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;<span style=\"color: #000000;\"> a) {\n</span><span style=\"color: #008080;\">13</span>     <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">int</span> i = <span style=\"color: #800080;\">0</span>; i &lt; a.size(); i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">14</span>         cout &lt;&lt; a[i] &lt;&lt; <span style=\"color: #800000;\">\"</span> <span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">15</span> <span style=\"color: #000000;\">    }\n</span><span style=\"color: #008080;\">16</span>     cout &lt;&lt;<span style=\"color: #000000;\"> endl;\n</span><span style=\"color: #008080;\">17</span> <span style=\"color: #000000;\">}\n</span><span style=\"color: #008080;\">18</span>  \n<span style=\"color: #008080;\">19</span> <span style=\"color: #0000ff;\">int</span><span style=\"color: #000000;\"> main() {\n</span><span style=\"color: #008080;\">20</span>  \n<span style=\"color: #008080;\">21</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">堆排序算法（heapsort）\n</span><span style=\"color: #008080;\">22</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">make_heap();\n</span><span style=\"color: #008080;\">23</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">push_heap()\n</span><span style=\"color: #008080;\">24</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">sort_heap()\n</span><span style=\"color: #008080;\">25</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">pop_heap()\n</span><span style=\"color: #008080;\">26</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">堆就是一种特殊的二叉树，最关心的就是根\n</span><span style=\"color: #008080;\">27</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">大根堆，小根堆</span>\n<span style=\"color: #008080;\">28</span>  \n<span style=\"color: #008080;\">29</span>     vector&lt;<span style=\"color: #0000ff;\">int</span>&gt; ivec{<span style=\"color: #800080;\">3</span>,<span style=\"color: #800080;\">4</span>,<span style=\"color: #800080;\">5</span>,<span style=\"color: #800080;\">6</span>,<span style=\"color: #800080;\">7</span>,<span style=\"color: #800080;\">5</span>,<span style=\"color: #800080;\">6</span>,<span style=\"color: #800080;\">7</span>,<span style=\"color: #800080;\">8</span>,<span style=\"color: #800080;\">9</span>,<span style=\"color: #800080;\">1</span>,<span style=\"color: #800080;\">2</span>,<span style=\"color: #800080;\">3</span>,<span style=\"color: #800080;\">4</span><span style=\"color: #000000;\">};\n</span><span style=\"color: #008080;\">30</span> <span style=\"color: #000000;\">    print(ivec);\n</span><span style=\"color: #008080;\">31</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">向量里所有的数据变成一个堆</span>\n<span style=\"color: #008080;\">32</span>  \n<span style=\"color: #008080;\">33</span> <span style=\"color: #000000;\">    make_heap(ivec.begin(), ivec.end());\n</span><span style=\"color: #008080;\">34</span> <span style=\"color: #000000;\">    print(ivec);\n</span><span style=\"color: #008080;\">35</span>  \n<span style=\"color: #008080;\">36</span>     pop_heap(ivec.begin(), ivec.end());<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">最大的数据取走，但是并没s有删除\n</span><span style=\"color: #008080;\">37</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">把最大的数据放在结尾，剩下的元素排成一个堆</span>\n<span style=\"color: #008080;\">38</span> <span style=\"color: #000000;\">    print(ivec);\n</span><span style=\"color: #008080;\">39</span> <span style=\"color: #000000;\">    ivec.pop_back();\n</span><span style=\"color: #008080;\">40</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">push_heap 使用首先要先把数据加在向量里</span>\n<span style=\"color: #008080;\">41</span>  \n<span style=\"color: #008080;\">42</span>     ivec.push_back(<span style=\"color: #800080;\">17</span><span style=\"color: #000000;\">);\n</span><span style=\"color: #008080;\">43</span> <span style=\"color: #000000;\">    make_heap(ivec.begin(), ivec.end());\n</span><span style=\"color: #008080;\">44</span> <span style=\"color: #000000;\">    print(ivec);\n</span><span style=\"color: #008080;\">45</span>  \n<span style=\"color: #008080;\">46</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">sort_heap 把堆变成不是堆,普通的排序</span>\n<span style=\"color: #008080;\">47</span> <span style=\"color: #000000;\">    sort_heap(ivec.begin(), ivec.end());\n</span><span style=\"color: #008080;\">48</span> <span style=\"color: #000000;\">    print(ivec);\n</span><span style=\"color: #008080;\">49</span>  \n<span style=\"color: #008080;\">50</span>     system(<span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">pause</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">);\n</span><span style=\"color: #008080;\">51</span> }</pre>\n</div>\n\n\n![](https://img2020.cnblogs.com/blog/2092994/202111/2092994-20211114224224870-302527741.png)\n","tags":["leetcode"]},{"title":"组合数 防溢出","url":"/2021/12/02/zu-he-shu-fang-yi-chu/","content":"\n<pre><span style=\"color: #008080;\">1</span>  \n<span style=\"color: #008080;\">2</span> <span style=\"color: #0000ff;\">long</span> <span style=\"color: #0000ff;\">long</span> C(<span style=\"color: #0000ff;\">int</span> N, <span style=\"color: #0000ff;\">int</span><span style=\"color: #000000;\"> M) {\n</span><span style=\"color: #008080;\">3</span>     <span style=\"color: #0000ff;\">long</span> <span style=\"color: #0000ff;\">long</span> sum = <span style=\"color: #800080;\">1</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">4</span>     <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> i=<span style=\"color: #800080;\">1</span>;i&lt;=M; i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">5</span>         sum=sum*(N-M+i)/<span style=\"color: #000000;\">i;\n</span><span style=\"color: #008080;\">6</span> <span style=\"color: #000000;\">    }\n</span><span style=\"color: #008080;\">7</span>     <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> sum;\n</span><span style=\"color: #008080;\">8</span> }</pre>\n","tags":["leetcode"]},{"title":"vector<pair>或者有序map","url":"/2021/12/02/vector-pair-huo-zhe-you-xu-map/","content":"\n功能相同\n\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008080;\"> 1</span>   <span style=\"color: #0000ff;\">static</span> <span style=\"color: #0000ff;\">bool</span> sortPair(pair&lt;<span style=\"color: #0000ff;\">int</span>, <span style=\"color: #0000ff;\">int</span>&gt; a, pair&lt;<span style=\"color: #0000ff;\">int</span>, <span style=\"color: #0000ff;\">int</span>&gt;<span style=\"color: #000000;\"> b) {\n</span><span style=\"color: #008080;\"> 2</span>     <span style=\"color: #0000ff;\">return</span> a.second &gt;<span style=\"color: #000000;\"> b.second;\n</span><span style=\"color: #008080;\"> 3</span> <span style=\"color: #000000;\">  }\n</span><span style=\"color: #008080;\"> 4</span>   vector&lt;<span style=\"color: #0000ff;\">string</span>&gt; findRelativeRanks(vector&lt;<span style=\"color: #0000ff;\">int</span>&gt; &amp;<span style=\"color: #000000;\">score) {\n</span><span style=\"color: #008080;\"> 5</span>     vector&lt;<span style=\"color: #0000ff;\">string</span>&gt;<span style=\"color: #000000;\"> res(score.size());\n</span><span style=\"color: #008080;\"> 6</span> \n<span style=\"color: #008080;\"> 7</span>     vector&lt;pair&lt;<span style=\"color: #0000ff;\">int</span>, <span style=\"color: #0000ff;\">int</span>&gt;&gt;<span style=\"color: #000000;\"> pairr;\n</span><span style=\"color: #008080;\"> 8</span> \n<span style=\"color: #008080;\"> 9</span>     <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">int</span> i = <span style=\"color: #800080;\">0</span>; i &lt; score.size(); i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">10</span>       pairr.push_back(pair&lt;<span style=\"color: #0000ff;\">int</span>, <span style=\"color: #0000ff;\">int</span>&gt;<span style=\"color: #000000;\">(i, score[i]));\n</span><span style=\"color: #008080;\">11</span> <span style=\"color: #000000;\">    }\n</span><span style=\"color: #008080;\">12</span> \n<span style=\"color: #008080;\">13</span> <span style=\"color: #000000;\">    sort(pairr.begin(), pairr.end(), sortPair);\n</span><span style=\"color: #008080;\">14</span>     <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">int</span> i = <span style=\"color: #800080;\">0</span>; i &lt; pairr.size(); i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">15</span>       <span style=\"color: #0000ff;\">switch</span><span style=\"color: #000000;\"> (i) {\n</span><span style=\"color: #008080;\">16</span>       <span style=\"color: #0000ff;\">case</span> <span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">:\n</span><span style=\"color: #008080;\">17</span>         res[pairr[i].first] = <span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Gold Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">18</span>         <span style=\"color: #0000ff;\">break</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">19</span>       <span style=\"color: #0000ff;\">case</span> <span style=\"color: #800080;\">1</span><span style=\"color: #000000;\">:\n</span><span style=\"color: #008080;\">20</span>         res[pairr[i].first] = <span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Silver Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">21</span>         <span style=\"color: #0000ff;\">break</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">22</span>       <span style=\"color: #0000ff;\">case</span> <span style=\"color: #800080;\">2</span><span style=\"color: #000000;\">:\n</span><span style=\"color: #008080;\">23</span>         res[pairr[i].first] = <span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Bronze Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">24</span>         <span style=\"color: #0000ff;\">break</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">25</span>       <span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\">:\n</span><span style=\"color: #008080;\">26</span>         res[pairr[i].first] = to_string(i + <span style=\"color: #800080;\">1</span><span style=\"color: #000000;\">);\n</span><span style=\"color: #008080;\">27</span>         <span style=\"color: #0000ff;\">break</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">28</span> <span style=\"color: #000000;\">      }\n</span><span style=\"color: #008080;\">29</span> <span style=\"color: #000000;\">    }\n</span><span style=\"color: #008080;\">30</span>     <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> res;\n</span><span style=\"color: #008080;\">31</span>   }</pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008080;\"> 1</span>     vector&lt;<span style=\"color: #0000ff;\">string</span>&gt; findRelativeRanks(vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;&amp;<span style=\"color: #000000;\"> score) {\n</span><span style=\"color: #008080;\"> 2</span>         <span style=\"color: #0000ff;\">int</span> n=<span style=\"color: #000000;\">score.size();\n</span><span style=\"color: #008080;\"> 3</span>         map&lt;<span style=\"color: #0000ff;\">int</span>,<span style=\"color: #0000ff;\">int</span>,greater&lt;<span style=\"color: #0000ff;\">int</span>&gt;&gt;<span style=\"color: #000000;\">num2index;\n</span><span style=\"color: #008080;\"> 4</span>         <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> i=<span style=\"color: #800080;\">0</span>;i&lt;n;i++)num2index[score[i]]=<span style=\"color: #000000;\">i;\n</span><span style=\"color: #008080;\"> 5</span>         vector&lt;<span style=\"color: #0000ff;\">string</span>&gt;<span style=\"color: #000000;\">ans(n);\n</span><span style=\"color: #008080;\"> 6</span>         <span style=\"color: #0000ff;\">int</span> i=<span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\"> 7</span>         <span style=\"color: #0000ff;\">for</span><span style=\"color: #000000;\">(auto mPair:num2index){\n</span><span style=\"color: #008080;\"> 8</span>             <span style=\"color: #0000ff;\">int</span> index=<span style=\"color: #000000;\">mPair.second;\n</span><span style=\"color: #008080;\"> 9</span>             <span style=\"color: #0000ff;\">if</span>(i==<span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">){\n</span><span style=\"color: #008080;\">10</span>                 ans[index]=<span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Gold Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">11</span>             }<span style=\"color: #0000ff;\">else</span> <span style=\"color: #0000ff;\">if</span>(i==<span style=\"color: #800080;\">1</span><span style=\"color: #000000;\">){\n</span><span style=\"color: #008080;\">12</span>                 ans[index]=<span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Silver Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">13</span>             }<span style=\"color: #0000ff;\">else</span> <span style=\"color: #0000ff;\">if</span>(i==<span style=\"color: #800080;\">2</span><span style=\"color: #000000;\">){\n</span><span style=\"color: #008080;\">14</span>                 ans[index]=<span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Bronze Medal</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">15</span>             }<span style=\"color: #0000ff;\">else</span> ans[index]+=to_string(i+<span style=\"color: #800080;\">1</span><span style=\"color: #000000;\">);\n</span><span style=\"color: #008080;\">16</span>             i++<span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">17</span> <span style=\"color: #000000;\">        }\n</span><span style=\"color: #008080;\">18</span>         <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> ans;\n</span><span style=\"color: #008080;\">19</span>     }</pre>\n</div>\n\n&nbsp;\n\n","tags":["leetcode"]},{"title":"1920. 基于排列构建数组","url":"/2021/12/02/1920-ji-yu-pai-lie-gou-jian-shu-zu/","content":"\n原地修改\n\nclass Solution {\npublic:\n    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        // 第一次遍历编码最终值\n        for (int i = 0; i &lt; n; ++i){\n            nums[i] += 1000 * (nums[nums[i]] % 1000);\n        }\n        // 第二次遍历修改为最终值\n        for (int i = 0; i &lt; n; ++i){\n            nums[i] /= 1000;\n        }\n        return nums;\n    }\n};\n","tags":["leetcode"]},{"title":"priority_queue和tuple","url":"/2021/12/02/priority-queue-tuple-he-lamda/","content":"\n\n\n&nbsp;\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20211115202419249-1916870940.png)\n\n&nbsp;\n\n# 1.顶堆\n\n&nbsp;&nbsp;C++11中，针对顺序容器(如vector、deque、list)，新标准引入了三个新成员：emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部\n\npriority_queue 默认从大到小排序， 从小到大：priority_queue&lt;<span class=\"hljs-type\">int, vector&lt;<span class=\"hljs-type\">int&gt;, greater&lt;<span class=\"hljs-type\">int&gt; &gt; p;</span></span></span>\n\npair举例\n//默认是使用大根堆\npriority_queue&lt;pair&lt;int,int&gt;&gt; pq0;\n//小根堆，按照pair的first排，再按照second排序\npriority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; pq1;\n//大根堆\npriority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,less&lt;pair&lt;int,int&gt;&gt;&gt; pq2;\n\ntuple举例\n//默认是使用大根堆\npriority_queue&lt;tuple&lt;int,int,int&gt;&gt; tp0;\n//小根堆，按照tuple的0元素排，再按照1元素排，最后按2元素排\npriority_queue&lt;tuple&lt;int,int,int&gt;,vector&lt;tuple&lt;int,int,int&gt;&gt;,greater&lt;tuple&lt;int,int,int&gt;&gt;&gt; tp1;\n//大根堆\npriority_queue&lt;tuple&lt;int,int,int&gt;,vector&lt;tuple&lt;int,int,int&gt;&gt;,less&lt;tuple&lt;int,int,int&gt;&gt;&gt; tp2;\n\n# <span class=\"hljs-type\"><span class=\"hljs-type\"><span class=\"hljs-type\">2.元组tuple</span></span></span>\n\ntuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。&nbsp;\n\ntuple获取指定位置的值:\n\n auto d = get&lt;0&gt;(tmp);\n      auto x = get&lt;1&gt;(tmp);\n      auto y = get&lt;2&gt;(tmp);\n","tags":["leetcode"]},{"title":"QT打包程序","url":"/2021/12/02/qt-da-bao-cheng-xu/","content":"\n## 1.发布release版本的QT程序\n\n　　在build release文件夹内找到exe文件，将其单独放在一个自建的空文件夹内\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927165117303-604984762.png)\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927165455009-910788885.png)\n\n&nbsp;\n\n&nbsp;\n\n&nbsp;\n\n## &nbsp;2.cd到含exe的空文件夹\n\n　　在QT命令行cd到含exe的空文件夹，cd /d E:\\QDIR\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927165604874-1233279110.png)![](https://img2020.cnblogs.com/blog/2092994/202009/2092994-20200927165951305-446477392.png)\n\n## 3.使用windeployqt.exe进行打包\n\n首先找到windeployqt.exe的路径&nbsp;\n\n&nbsp;![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927170127591-1210427907.png)\n\n&nbsp;\n\n&nbsp;\n\n输入命令D:\\QT\\5.14.2\\msvc2017_64\\bin\\windeployqt&nbsp;QDIR.exe即完成了打包\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927170421891-1644738339.png)![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927170550570-2063963822.png)\n\n&nbsp;\n\n## &nbsp;附：打包前修改exe图标\n\n## 改变exe的图标\n\n1、下载一个.ico格式的图标（如：bucket and shovel.ico），将bucket and shovel.ico复制到工程目录下。\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927172502714-1388114573.png)\n\n&nbsp;\n\n&nbsp;\n\n2、工程目录下新建一个空白txt文档，文档内添加如下内容\n`IDI_ICON1 ICON DISCARDABLE \"bucket and shovel.ico\"`\n3、将文档后缀修改为.rc（如：bucke.rc, !!注意!!rc文件名不要含空格）&nbsp;\n4、在工程的pro文件添加如下内容\n`RC_FILE = bucket.rc`\n5、重新编译程序，即可发现生成的程序图标变成了bucket.ico\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200927172701527-227417489.png)\n\n&nbsp;\n"},{"title":"QString截断（string截断）","url":"/2021/12/02/qstring-jie-duan-string-jie-duan/","content":"\n#### 最近写一个Qt小程序用到了QString的截断，在绝对路径中取文件的名字，再拼接到新路径中，用到了两个方法：\n\n### 方法一：由于对QString没有深入了解，所以采用的QString--&gt;string--&gt;QString，代码如下：\n\n```c++\nstd::string pur = purposelist[i].toStdString();//都转换为string\n// qDebug()<<pur<<endl;\nstd::string sdir = dstpath.toStdString();\nint pos = pur.find_last_of('/'); //找到最后/\nstd::string s(pur.substr(pos + 1));\nsdir.append(\"/\");\nsdir.append(s);\nQString qsdir = QString(QString::fromLocal8Bit(sdir.c_str()));\nqDebug() << qsdir << endl;\n```\n\n\n\n### 用这种方法出现的问题是，string中的中文字符转到QString会乱码...\n\n&nbsp;\n\n### 方法二：QString直接进行截断拼接\n\n```c++\n//QString截断学习\nQString src(\"E:/qq接收文件/MobileFile/thumb/碎裂收据.jpg\");\nqDebug()<<\"original path: \"<<src<<endl;\nQString dir(\"E:/目标文件夹\");\nqDebug()<<\"the last string '/' pos is \"<<src.lastIndexOf('/')<<endl;\nQString filename = src.right(src.size() - (src.lastIndexOf(\"/\")+1));\nqDebug()<<\"the true filename is \"<<filename<<endl;\n```\n\n### 复盘，刚接触qt的自己好蠢，事实上 qstring可能是c++下最好用的string了\n\nQString存储字符串采用的是Unicode码,每一个字符是一个十六位的QChar, 而不是八位的char, 所以处理中文字符没有问题, 而且一个汉字是一个字符。\n\n#### 函数\n\n**1、append()和prepend()**\n\nappend()在字符串后面添加字符串,prepend()在字符串前面添加字符串。\n\n如下：\n\n```text\nQString str1=\"卖\", str2 = \"拐\";\nstr1 = str1.append(str2);\t//\"卖拐\"\nstr2 = str2.prepend(str1);\t//\"拐卖\"\n```\n\n**2、toUpper()和toLower()**\n\ntoUpper()是将字符串中的字母全部转化为大写字母,toLower()是将所有的字母全部转化为小写字母。\n\n如下：\n\n```text\nQString str1 = \"Hello World\", str2;\nstr2 = str1.toUpper();\t//\"HELLO WORLD\"\nstr2 = str1.toLower();\t//\"hello world\"\n```\n\n**3、cont()、size()和length()**\n\ncount()、size()和length()这三个函数都是返回字符串的个数的,这3个函数是相同的。注意：一个汉字算是一个字符\n\n如下：\n\n```text\nQString str = \"NI 好\";\nN = str.count();\t//N == 3\nN = str.size();\t\t//N == 3\nN = str.length();\t//N == 3\n```\n\n**4、trimmed()和simplified()**\n\ntrimmed()是去掉字符串首尾的空格,simplified()不仅去掉首尾的空格,中间连续的空格也能用一个空格替换。\n\n如下：\n\n```text\nQString str1 = \" Are    you  ok?   \";\nstr2 = str1.trimmed();\t\t//\"Are    you  ok?\"\nstr2 = str1.simplified()\t//\"Are you ok?\"\n```\n\n**5、indexOf()和lastIndexOf()**\n\n查找字符串的位置\n\n如下：\n\n```text\nQString str1 = \"G:\\Qt5Book\\Qt5.9Study\\qw.cpp\";\nN = str1.indexOf(\"5.9\");\t\t\t//N == 13\nN = str1.lastIndexOf(\"\\\\\");\t\t\t//N == 21\n注意：\"\\\"是转义字符,如果要查找\"\\\",需要输入\"\\\\\"\n```\n\n**6、isNull()和isEmpty()**\n\n这两个函数都用来判断字符串是否为空,但是稍微有差别。如果一个空字符串,只有\"\\0\",isNull()返回false,而isEmpty()返回true;只有未赋值的字符串,isNull()才返回true。\n\n如下：\n\n```text\nQString str1, str2=\"\";\nN = str1.isNull();\t//true\t未赋值字符串变量\nN = str2.isNull();\t//false\t只有\"\\0\"的字符串,也不是Null\nN = str1.isEmpty(); //true\nN = str2.isEmpty(); //true\n```\n\n**7、contains()**\n\n判断字符串内是否包含某个字符,可指定是否区分大小写。\n\n如下：\n\n```c++\nQString str1 = \"G:\\Qt5Book\\Qt5.9Study\\qw.cpp\";\nN = str1.contains(\".cpp\", Qt::CaseInsensitive);\t\t//true 不区分大小写\t\nN = str1.contains(\".CPP\", Qt::CaseSensitive);\t\t//false 区分大小写\n```\n\n**8、endsWith()和startsWith()**\n\nstartsWith()判断是否以某个字符串开头,endsWith()表示是否以某个字符串结尾。\n\n如下：\n\n```c++\nQString str1 = \"G:\\Qt5Book\\Qt5.9Study\\qw.cpp\";\nN = str1.endsWith(\".cpp\", Qt::CaseInsensitive);\t\t//true 不区分大小写\t\nN = str1.endsWith(\".CPP\", Qt::CaseSensitive);\t\t//false 区分大小写\nN = str.startsWith(\"g:\");\t\t\t\t\t\t\t//true 缺省为不区分大小写\n```\n\n**9、left()和right()**\n\nleft()表示取一个字符串左边多少个字符,right()表示取一个字符串右边多少个字符。注意：一个汉字被当作一个字符;\n\n```c++\nQString str2, str1=\"学生姓名, 男, 1984-3-4, 汉族, 山东\";\nN = str1.indexOf(\",\");\t\t\t\t\t//N == 4,第一个\",\"出现的位置\nstr2 = str1.left(N);\t\t\t\t\t//str2 == \"学生姓名\"\nN = str1.lastIndexOf(\",\");\t\t\t\t//N ==18,最后一个逗号出现的位置\nstr2 = str1.right(str1.size()-N-1);\t\t//str2 = \"山东\",提取最后一个逗号之间的字符串\n```\n\n**10、section()**\n\n从字符串中提取以se为分隔符,从start到end的字符串。\n\n```c++\nQString str1 = \"G:\\Qt5Book\\Qt5.9Study\\qw.cpp\", str2;\nstr2 = str1.section(\",\",0,0);\t//str2 == \"学生姓名\"\nstr2 = str1.section(\",\",1,1);\t//str2 == \"男\"\nstr2 = str1.section(\",\",0,1);\t//str2 == \"学生姓名,男\"\nstr2 = str1.section(\",\",4,4);\t//str2 == \"山东\"\n```\n\n","tags":["开发随笔"]},{"title":"简单的滑动窗口 643. 子数组最大平均数 I","url":"/2021/12/02/jian-dan-de-hua-dong-chuang-kou-643-zi-shu-zu-zui-da-ping-jun-shu-i/","content":"\n给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。\n\n请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。\n\n任何误差小于 10-5 的答案都将被视为正确答案。\n\n&nbsp;\n\n示例 1：\n\n输入：nums = [1,12,-5,-6,50,3], k = 4\n输出：12.75\n解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n示例 2：\n\n输入：nums = [5], k = 1\n输出：5.00000\n\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008080;\"> 1</span> <span style=\"color: #0000ff;\">class</span><span style=\"color: #000000;\"> Solution {\n</span><span style=\"color: #008080;\"> 2</span> <span style=\"color: #0000ff;\">public</span><span style=\"color: #000000;\">:\n</span><span style=\"color: #008080;\"> 3</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {\n</span><span style=\"color: #008080;\"> 4</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     double res = -10000.0;\n</span><span style=\"color: #008080;\"> 5</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     double sum = 0;\n</span><span style=\"color: #008080;\"> 6</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     double ave;\n</span><span style=\"color: #008080;\"> 7</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     for(int i = 0; i&lt;=nums.size()-k; i++){\n</span><span style=\"color: #008080;\"> 8</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         if( i == 0){\n</span><span style=\"color: #008080;\"> 9</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">             for(int j = 0; j&lt;k; j++){\n</span><span style=\"color: #008080;\">10</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">                 sum+=nums[i+j];\n</span><span style=\"color: #008080;\">11</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">             }\n</span><span style=\"color: #008080;\">12</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         }else{\n</span><span style=\"color: #008080;\">13</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">             sum-=nums[i-1];\n</span><span style=\"color: #008080;\">14</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">             sum+=nums[i+k-1];\n</span><span style=\"color: #008080;\">15</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         }\n</span><span style=\"color: #008080;\">16</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         ave = sum/k;\n</span><span style=\"color: #008080;\">17</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         cout &lt;&lt;ave&lt;&lt;endl;\n</span><span style=\"color: #008080;\">18</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">         res = res&gt;ave?res:ave;\n</span><span style=\"color: #008080;\">19</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     }\n</span><span style=\"color: #008080;\">20</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">     return res;\n</span><span style=\"color: #008080;\">21</span>     <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> }</span>\n<span style=\"color: #008080;\">22</span>     <span style=\"color: #0000ff;\">double</span> findMaxAverage(vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;&amp; nums, <span style=\"color: #0000ff;\">int</span><span style=\"color: #000000;\"> k) {\n</span><span style=\"color: #008080;\">23</span>         <span style=\"color: #0000ff;\">int</span> sum = <span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\">24</span>         <span style=\"color: #0000ff;\">int</span> n =<span style=\"color: #000000;\"> nums.size();\n</span><span style=\"color: #008080;\">25</span>         <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">int</span> i = <span style=\"color: #800080;\">0</span>; i &lt; k; i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">26</span>             sum +=<span style=\"color: #000000;\"> nums[i];\n</span><span style=\"color: #008080;\">27</span> <span style=\"color: #000000;\">        }\n</span><span style=\"color: #008080;\">28</span>         <span style=\"color: #0000ff;\">int</span> maxSum =<span style=\"color: #000000;\"> sum;\n</span><span style=\"color: #008080;\">29</span>         <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">int</span> i = k; i &lt; n; i++<span style=\"color: #000000;\">) {\n</span><span style=\"color: #008080;\">30</span>             sum = sum - nums[i - k] +<span style=\"color: #000000;\"> nums[i];\n</span><span style=\"color: #008080;\">31</span>             maxSum =<span style=\"color: #000000;\"> max(maxSum, sum);\n</span><span style=\"color: #008080;\">32</span> <span style=\"color: #000000;\">        }\n</span><span style=\"color: #008080;\">33</span>         <span style=\"color: #0000ff;\">return</span> static_cast&lt;<span style=\"color: #0000ff;\">double</span>&gt;(maxSum) /<span style=\"color: #000000;\"> k;\n</span><span style=\"color: #008080;\">34</span> <span style=\"color: #000000;\">    }\n</span><span style=\"color: #008080;\">35</span> \n<span style=\"color: #008080;\">36</span> };</pre>\n</div>\n\n&nbsp;\n","tags":["leetcode"]},{"title":"图片平滑器","url":"/2021/12/02/tu-pian-ping-hua-qi/","content":"\n包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度&nbsp;(向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。\n\n示例 1:\n\n输入:\n[[1,1,1],\n [1,0,1],\n [1,1,1]]\n输出:\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n解释:\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008080;\"> 1</span>     vector&lt;vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;&gt; imageSmoother(vector&lt;vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;&gt;&amp;<span style=\"color: #000000;\"> img) {\n</span><span style=\"color: #008080;\"> 2</span>         <span style=\"color: #0000ff;\">const</span> <span style=\"color: #0000ff;\">int</span> n =<span style=\"color: #000000;\"> img.size();\n</span><span style=\"color: #008080;\"> 3</span>         <span style=\"color: #0000ff;\">const</span> <span style=\"color: #0000ff;\">int</span> m = img[<span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">].size();\n</span><span style=\"color: #008080;\"> 4</span>         vector&lt;vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;&gt; ans(n, vector&lt;<span style=\"color: #0000ff;\">int</span>&gt;<span style=\"color: #000000;\">(m));\n</span><span style=\"color: #008080;\"> 5</span>         <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> i = <span style=\"color: #800080;\">0</span>; i &lt; n; ++i){  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">遍历每一个点</span>\n<span style=\"color: #008080;\"> 6</span>             <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> j = <span style=\"color: #800080;\">0</span>; j &lt; m; ++<span style=\"color: #000000;\">j){\n</span><span style=\"color: #008080;\"> 7</span>                 <span style=\"color: #0000ff;\">int</span> sum = <span style=\"color: #800080;\">0</span>, num = <span style=\"color: #800080;\">0</span><span style=\"color: #000000;\">;\n</span><span style=\"color: #008080;\"> 8</span>                 <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> k = -<span style=\"color: #800080;\">1</span>; k &lt;= <span style=\"color: #800080;\">1</span>; ++k){  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">遍历周围的格子</span>\n<span style=\"color: #008080;\"> 9</span>                     <span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">int</span> l = -<span style=\"color: #800080;\">1</span>; l &lt;= <span style=\"color: #800080;\">1</span>; ++l){   <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">判断是否出界</span>\n<span style=\"color: #008080;\">10</span>                         <span style=\"color: #0000ff;\">if</span>(i + k &gt;= <span style=\"color: #800080;\">0</span> &amp;&amp; i + k &lt; n &amp;&amp; j + l &gt;= <span style=\"color: #800080;\">0</span> &amp;&amp; j + l &lt;<span style=\"color: #000000;\"> m){\n</span><span style=\"color: #008080;\">11</span>                             ++num; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">没有出界，格子个数+1</span>\n<span style=\"color: #008080;\">12</span>                             sum += img[i + k][j + l]; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">计算总和</span>\n<span style=\"color: #008080;\">13</span> <span style=\"color: #000000;\">                        }\n</span><span style=\"color: #008080;\">14</span> <span style=\"color: #000000;\">                    }\n</span><span style=\"color: #008080;\">15</span> <span style=\"color: #000000;\">                }\n</span><span style=\"color: #008080;\">16</span>                 ans[i][j] = sum / num; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">计算平均值</span>\n<span style=\"color: #008080;\">17</span> <span style=\"color: #000000;\">            }\n</span><span style=\"color: #008080;\">18</span> <span style=\"color: #000000;\">        }\n</span><span style=\"color: #008080;\">19</span>         <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> ans;\n</span><span style=\"color: #008080;\">20</span>     }</pre>\n</div>\n","tags":["leetcode"]},{"title":"Ubantu搜狗输入法候选汉字乱码","url":"/2021/12/02/ubantu-sou-gou-shu-ru-fa-hou-xuan-han-zi-luan-ma/","content":"\nUbantu搜狗输入法候选汉字乱码\n\n可能原因，自己手贱删除了/etc/apt/sources.list.d中的fcitx的一个列表\n\n&nbsp;\n\n解决方法：\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200813170919380-560000114.png)\n\n&nbsp;\n\n&nbsp;配置当前输入发，将搜狗输入法下移放在第二个位置（MDZZ）\n\n![](https://qianxunslimg.oss-cn-beijing.aliyuncs.com/img/2092994-20200813171020437-1675339877.png)\n\n"},{"title":"vs程序 copy 到Qt的若干错误","url":"/2021/10/02/vs-cheng-xu-copy-dao-qt-de-ruo-gan-cuo-wu/","content":"\n# [vs程序 copy 到Qt的若干错误](https://www.cnblogs.com/qianxunslimg/p/14347565.html)\n\n打杂人的苦恼：\n\n- 发票太多ofd的 sunny只要pdf的 ofd只能用某个国产软件打开\n- 某国产软件过于拉跨，无法直接转为pdf 只能认为截图 word 另存为...\n- ofd的编码格式搞清楚有点费劲 但是想到了一个笨方法\n  1. 调用某软件打开ofd文档\n  2. 整体截图 使用opencv提取roi为发票区域\n  3. 基于QT强大的模块化能力 直接存储为pdf\n\n\n\n唉 在vs下学习了一些基础的操作 打算到qt下编写（当时还没有用qtvstools），不熟悉qtCreator 出现了一些问题\n\n#### 菜归菜，还是学到一些东西\n\n1. 首先是windows.h在qt下的使用  LIBS +=User32.LIB\n\n2. 离谱的 dependent error .h does not exist  \n\n   看网上说的是.pro文件存在缓存？解决方案：瞎jb乱摁\n\n   通过以下步骤乱搞：\n\n   ​\t   （1）ctrl A ctrlX .pro文件，编译，ctrl v编译\n\n   ​\t\t（2）删除相关头文件及代码的使用，重新添加并编译（傻逼操作）\n\n3. 无法解析的外部符号 __imp_DeleteObject 等等， 解决方法\n\n　　#pragma comment(lib, \"Gdi32.lib\")\n\n4. Cmd命令无法进行直接调用  system(\"start C:\\\\Users\\\\00\\\\Desktop\\\\发票\\\\1.24-\\\\思巴克72.ofd\");\n\n   解决方法：使用QProcess运行cmd命令  https://blog.csdn.net/vample/article/details/78872587\n\n啊呸，直接打开文件搞什么逼逼赖赖\n\n```c++\nQString fileName = \"C:\\\\Users\\\\00\\\\Desktop\\\\发票\\\\1.24-\\\\思巴克72.ofd\";\nQFile file(fileName);\nif(file.exists()){\n    QDesktopServices::openUrl(QUrl::fromLocalFile(fileName));\n}\n```\n\n　　\n","tags":["开发随笔"]},{"title":"MFC读取多个文件","url":"/2021/09/26/mfc-du-qu-duo-ge-wen-jian/","content":"\n#### 起因\n\n本身软件的文件读取逻辑是csv存储工程测点路径 然后根据路径去指定目录下找指定格式的文件读取 这个文件逻辑也是我们的采集设备采集完成后，结果文件的保存逻辑\n\n奈何甲方使用习惯不同，习惯ctrl A全选 所有文件放在一个文件夹下和csv匹配，只好添加此逻辑\n\n实现过程中，按照网上的方法，发现mfc的CFileDialog读取多个文件有个最大数量的限制，选的多，实际读取到的并不全\n\n#### 解决方法\n\n设置CFileDialog的相关属性\n\n```c++\n  allDisp.clear();\n  if (!m_sparkFile) // liu的文件逻辑\n  {\n    // dlg.InitList(strFileName, m_listSource);\n    CFileDialog alldlg(TRUE, NULL, NULL,\n                       OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |\n                           OFN_ALLOWMULTISELECT | OFN_EXPLORER,\n                       _T(\"Disp(*disp)|*.disp||\"));\n    //添加这些\n\t\t//////////////////////////////////////////\n    DWORD MAXFILE = 4000;\n    alldlg.m_ofn.nMaxFile = MAXFILE;\n    char *pc = new char[MAXFILE];\n    alldlg.m_ofn.lpstrFile = pc;\n    alldlg.m_ofn.lpstrFile[0] = NULL;\n\t\t//////////////////////////////////////////\n    \n    if (IDOK != alldlg.DoModal())\n      return;\n\n    POSITION pos = alldlg.GetStartPosition();\n\n    while (pos) {\n      allDisp.insert(alldlg.GetNextPathName(pos));\n    }\n    dispPath = alldlg.GetPathName();\n  }\n```\n\n","tags":["开发随笔"]},{"title":"opencv添加汉字","url":"/2021/09/26/opencv-tian-jia-han-zi/","content":"\n#### 起因\n\nopencv的mat图片上 如果添加非中午字符 或者英文的话 使用opencv自带的putText就可以满足需求\n\n但是添加汉字的话 putText就会出现问题\n\n可以使用如下函数 在mat上添加汉字\n\n#### 函数\n\n```c++\nvoid putTextZH(Mat &dst, const char *str, Point org, Scalar color, int fontsize,\n               const char *fn, bool italic, bool underline) {\n  CV_Assert(dst.data != 0 && (dst.channels() == 1 || dst.channels() == 3));\n\n  int x, y, r, b;\n  //坐标点大于图像宽和高直接返回\n  if (org.x > dst.cols || org.y > dst.rows)\n    return;\n  x = org.x < 0 ? -org.x : 0;\n  y = org.y < 0 ? -org.y : 0;\n\n  LOGFONTA lf;\n  lf.lfHeight = -fontsize;        //字体高度\n  lf.lfWidth = 0;                 //平均宽度\n  lf.lfEscapement = 0;            //字符排列角度\n  lf.lfOrientation = 0;           //字符本身旋转的角度\n  lf.lfWeight = 2;                //设置字体线条的宽度\n  lf.lfItalic = italic;           //斜体\n  lf.lfUnderline = underline;     //下划线\n  lf.lfStrikeOut = 0;             //是否字符中央加横线\n  lf.lfCharSet = DEFAULT_CHARSET; //字符集\n  lf.lfOutPrecision = 0;          //字体的精确度\n  lf.lfQuality = PROOF_QUALITY;   //字体质量\n  lf.lfPitchAndFamily = 0;        //选择字体的间距和字体家族\n  strcpy_s(lf.lfFaceName, fn);    //字体的名称\n\n  HFONT hf = CreateFontIndirectA(&lf);\n  HDC hdc = CreateCompatibleDC(0);\n  HFONT holdfont = (HFONT)SelectObject(hdc, hf);\n\n  int strBaseW = 0, strBaseH = 0;\n  int singleRow = 0;\n  char buf[1 << 12];\n  strcpy_s(buf, str);\n  char *bufT[1 << 12]; //这个用于分隔字符串后剩余的字符，可能会超出。\n\n  //处理多行\n  {\n    int nnh = 0;\n    int cw, ch;\n\n    const char *ln = strtok_s(buf, \"\\n\", bufT);\n    while (ln != 0) {\n      GetStringSize(hdc, ln, &cw, &ch);\n      strBaseW = max(strBaseW, cw);\n      strBaseH = max(strBaseH, ch);\n\n      ln = strtok_s(0, \"\\n\", bufT);\n      nnh++;\n    }\n    singleRow = strBaseH;\n    strBaseH *= nnh;\n  }\n\n  if (org.x + strBaseW < 0 || org.y + strBaseH < 0) {\n    SelectObject(hdc, holdfont);\n    DeleteObject(hf);\n    DeleteObject(hdc);\n    return;\n  }\n\n  r = org.x + strBaseW > dst.cols ? dst.cols - org.x - 1 : strBaseW - 1;\n  b = org.y + strBaseH > dst.rows ? dst.rows - org.y - 1 : strBaseH - 1;\n  org.x = org.x < 0 ? 0 : org.x;\n  org.y = org.y < 0 ? 0 : org.y;\n\n  BITMAPINFO bmp = {0};\n  BITMAPINFOHEADER &bih = bmp.bmiHeader;\n  int strDrawLineStep = strBaseW * 3 % 4 == 0\n                            ? strBaseW * 3\n                            : (strBaseW * 3 + 4 - ((strBaseW * 3) % 4));\n\n  bih.biSize = sizeof(BITMAPINFOHEADER);\n  bih.biWidth = strBaseW;\n  bih.biHeight = strBaseH;\n  bih.biPlanes = 1;\n  bih.biBitCount = 24;\n  bih.biCompression = BI_RGB;\n  bih.biSizeImage = strBaseH * strDrawLineStep;\n  bih.biClrUsed = 0;\n  bih.biClrImportant = 0;\n\n  void *pDibData = 0;\n  HBITMAP hBmp = CreateDIBSection(hdc, &bmp, DIB_RGB_COLORS, &pDibData, 0, 0);\n\n  CV_Assert(pDibData != 0);\n  HBITMAP hOldBmp = (HBITMAP)SelectObject(hdc, hBmp);\n\n  // color.val[2], color.val[1], color.val[0]\n  SetTextColor(hdc, RGB(255, 255, 255));\n  SetBkColor(hdc, 0);\n  // SetStretchBltMode(hDC, COLORONCOLOR);\n\n  strcpy_s(buf, str);\n  const char *ln = strtok_s(buf, \"\\n\", bufT);\n  int outTextY = 0;\n  while (ln != 0) {\n    TextOutA(hdc, 0, outTextY, ln, strlen(ln));\n    outTextY += singleRow;\n    ln = strtok_s(0, \"\\n\", bufT);\n  }\n  uchar *dstData = (uchar *)dst.data;\n  int dstStep = dst.step / sizeof(dstData[0]);\n  unsigned char *pImg =\n      (unsigned char *)dst.data + org.x * dst.channels() + org.y * dstStep;\n  unsigned char *pStr = (unsigned char *)pDibData + x * 3;\n  for (int tty = y; tty <= b; ++tty) {\n    unsigned char *subImg = pImg + (tty - y) * dstStep;\n    unsigned char *subStr = pStr + (strBaseH - tty - 1) * strDrawLineStep;\n    for (int ttx = x; ttx <= r; ++ttx) {\n      for (int n = 0; n < dst.channels(); ++n) {\n        double vtxt = subStr[n] / 255.0;\n        int cvv = vtxt * color.val[n] + (1 - vtxt) * subImg[n];\n        subImg[n] = cvv > 255 ? 255 : (cvv < 0 ? 0 : cvv);\n      }\n\n      subStr += 3;\n      subImg += dst.channels();\n    }\n  }\n\n  SelectObject(hdc, hOldBmp);\n  SelectObject(hdc, holdfont);\n  DeleteObject(hf);\n  DeleteObject(hBmp);\n  DeleteDC(hdc);\n}\n```\n\n#### 调用\n\n```C++\n  Mat imText;\n  if (m_colorMap) {\n    imText = Mat(text_size, CV_8UC3, Scalar(255, 255, 255));\n  } else if (m_colorMap == 0) {\n    imText = Mat(text_size, CV_8UC1, Scalar(255));\n  }\n\n  origin.x = 0;\n  origin.y = text_size.height - 6;\n\n  char *p = (char *)text.data();\n  putTextZH(imText, p, Point(origin.x + 20, 4), Scalar(120, 120, 120), 22,\n            \"微软雅黑\", 0, 0);\n```\n\n","tags":["开发随笔"]},{"title":"vector clear() 方法 内存释放问题","url":"/2021/09/01/vector-clear-fang-fa-nei-cun-shi-fang-wen-ti/","content":"\n\n\n<div class=\"com-markdown-collpase-main\">\n<div class=\"rno-markdown J-articleContent\">\n<pre class=\"prism-token token  language-javascript\">自己查到的三处说法的对比：</pre>\n<pre class=\"prism-token token  language-javascript\">一、转自知道的答案：https<span class=\"token operator\">:<span class=\"token operator\">/<span class=\"token operator\">/zhidao<span class=\"token punctuation\">.baidu<span class=\"token punctuation\">.com<span class=\"token operator\">/question<span class=\"token operator\">/<span class=\"token number\">323662520.html<span class=\"token operator\">?qq<span class=\"token operator\">-pf<span class=\"token operator\">-to<span class=\"token operator\">=pcqq<span class=\"token punctuation\">.c2c#</span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<pre class=\"prism-token token  language-javascript\"><span class=\"token function\">vector，clear<span class=\"token punctuation\">(<span class=\"token punctuation\">)<span class=\"token function\">并不真正释放内存<span class=\"token punctuation\">(这是为优化效率所做的事<span class=\"token punctuation\">)<span class=\"token function\">，clear实际所做的是为vector中所保存的所有对象调用析构函数<span class=\"token punctuation\">(如果有的话<span class=\"token punctuation\">)<span class=\"token punctuation\">,然后初始化size这些东西，让觉得把所有的对象清除了。\n　　真正释放内存是在vector的析构函数里进行的，所以一旦超出vector的作用域（如函数返回<span class=\"token punctuation\">)，首先它所保存的所有对象会被析构，然后会调用allocator中的deallocate函数回收对象本身的内存。\n　　所以，某些编译器clear后还能访问到对象数据（因为它根本没清除），在一些比较新的<span class=\"token constant\">C<span class=\"token operator\">++<span class=\"token function\">编译器上<span class=\"token punctuation\">(例如<span class=\"token constant\">VS2008<span class=\"token punctuation\">)<span class=\"token function\">，当进行数组引用时<span class=\"token punctuation\">(例如a<span class=\"token punctuation\">[<span class=\"token number\">2<span class=\"token punctuation\">]这种用法<span class=\"token punctuation\">)<span class=\"token punctuation\">,<span class=\"token constant\">STL库中会有一些check函数根据当前容器的size值来判断下标引用是否超出范围，如果超出，则会执行这样一句：\n　　<span class=\"token function\">_THROW<span class=\"token punctuation\">(out_of_range<span class=\"token punctuation\">, <span class=\"token string\">\"invalid vector&lt;T&gt; subscript\"<span class=\"token punctuation\">)<span class=\"token punctuation\">;\n　　即抛出一个越界异常，clear后没有捕获异常，程序在新编译器编译后就会崩溃掉。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n<pre class=\"prism-token token  language-javascript\"><span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">-分割线<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--<span class=\"token operator\">--</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n\n\n二、转自博客：https://www.cnblogs.com/summerRQ/articles/2407974.html\n\nvector ： C++ STL中的顺序容器，封装数组\n\n1. vector容器的内存自增长&nbsp;\n\n与其他容器不同，其内存空间只会增长，不会减小。先来看看\"C++ Primer\"中怎么说：为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。\n\n关于vector的内存空间，有两个函数需要注意：size()成员指当前拥有的元素个数；capacity()成员指当前(容器必须分配新存储空间之前)可以存储的元素个数。reserve()成员可以用来控制容器的预留空间。vector另外一个特性在于它的内存空间会自增长，每当vector容器不得不分配新的存储空间时，会以加倍当前容量的分配策略实现重新分配。例如，当前capacity为50，当添加第51个元素时，预留空间不够用了，vector容器会重新分配大小为100的内存空间，作为新连续存储的位置。\n\n2.&nbsp;vector内存释放\n\n由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。\n\n如果需要空间动态缩小，可以考虑使用deque。如果非vector不可，可以用swap()来帮助你释放内存。具体方法如下：\n\n<pre class=\"prism-token token  language-javascript\">vector<span class=\"token operator\">&lt;int<span class=\"token operator\">&gt; nums<span class=\"token punctuation\">; \nnums<span class=\"token punctuation\">.<span class=\"token function\">push_back<span class=\"token punctuation\">(<span class=\"token number\">1<span class=\"token punctuation\">)<span class=\"token punctuation\">;\nnums<span class=\"token punctuation\">.<span class=\"token function\">push_back<span class=\"token punctuation\">(<span class=\"token number\">1<span class=\"token punctuation\">)<span class=\"token punctuation\">;\nnums<span class=\"token punctuation\">.<span class=\"token function\">push_back<span class=\"token punctuation\">(<span class=\"token number\">2<span class=\"token punctuation\">)<span class=\"token punctuation\">;\nnums<span class=\"token punctuation\">.<span class=\"token function\">push_back<span class=\"token punctuation\">(<span class=\"token number\">2<span class=\"token punctuation\">)<span class=\"token punctuation\">; \nvector<span class=\"token operator\">&lt;int<span class=\"token operator\">&gt;<span class=\"token punctuation\">(<span class=\"token punctuation\">)<span class=\"token punctuation\">.<span class=\"token function\">swap<span class=\"token punctuation\">(nums<span class=\"token punctuation\">)<span class=\"token punctuation\">; <span class=\"token comment\">//或者nums.swap(vector&lt;int&gt; ())</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n\n\n或者如下所示，使用一对大括号，意思一样的：\n\n<pre class=\"prism-token token  language-javascript\"><span class=\"token comment\">//加一对大括号是可以让tmp退出{}的时候自动析构\n<span class=\"token punctuation\">{ \n    std<span class=\"token operator\">:<span class=\"token operator\">:vector<span class=\"token operator\">&lt;int<span class=\"token operator\">&gt; tmp <span class=\"token operator\">=   nums<span class=\"token punctuation\">;  \n    nums<span class=\"token punctuation\">.<span class=\"token function\">swap<span class=\"token punctuation\">(tmp<span class=\"token punctuation\">)<span class=\"token punctuation\">; \n<span class=\"token punctuation\">}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n\n\n&nbsp;swap()是交换函数，使vector离开其自身的作用域，从而强制释放vector所占的内存空间，总而言之，释放vector内存最简单的方法是vector&lt;int&gt;.swap(nums)。当时如果nums是一个类的成员，不能把vector&lt;int&gt;.swap(nums)写进类的析构函数中，否则会导致double free or corruption (fasttop)的错误，原因可能是重复释放内存。标准解决方法如下：\n\n<pre class=\"prism-token token  language-javascript\">template <span class=\"token operator\">&lt; <span class=\"token keyword\">class <span class=\"token class-name\">T <span class=\"token operator\">&gt;\n<span class=\"token keyword\">void <span class=\"token function\">ClearVector<span class=\"token punctuation\">( <span class=\"token parameter\">vector<span class=\"token operator\">&lt; <span class=\"token constant\">T <span class=\"token operator\">&gt;<span class=\"token operator\">&amp; vt <span class=\"token punctuation\">) \n<span class=\"token punctuation\">{\n    vector<span class=\"token operator\">&lt; <span class=\"token constant\">T <span class=\"token operator\">&gt; vtTemp<span class=\"token punctuation\">; \n    veTemp<span class=\"token punctuation\">.<span class=\"token function\">swap<span class=\"token punctuation\">( vt <span class=\"token punctuation\">)<span class=\"token punctuation\">;\n<span class=\"token punctuation\">}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n\n\n3. 利用vector释放指针\n\n如果vector中存放的是指针，那么当vector销毁时，这些指针指向的对象不会被销毁，那么内存就不会被释放。如下面这种情况，vector中的元素时由new操作动态申请出来的对象指针：\n\n<pre class=\"prism-token token  language-javascript\">#include <span class=\"token operator\">&lt;vector<span class=\"token operator\">&gt; \nusing namespace std<span class=\"token punctuation\">; \nvector<span class=\"token operator\">&lt;<span class=\"token keyword\">void <span class=\"token operator\">*<span class=\"token operator\">&gt; v<span class=\"token punctuation\">;</span></span></span></span></span></span></span></span></pre>\n\n\n每次new之后调用v.push_back()该指针，在程序退出或者根据需要，用以下代码进行内存的释放：&nbsp;\n\n<pre class=\"prism-token token  language-javascript\"><span class=\"token keyword\">for <span class=\"token punctuation\">(vector<span class=\"token operator\">&lt;<span class=\"token keyword\">void <span class=\"token operator\">*<span class=\"token operator\">&gt;<span class=\"token operator\">:<span class=\"token operator\">:iterator it <span class=\"token operator\">= v<span class=\"token punctuation\">.<span class=\"token function\">begin<span class=\"token punctuation\">(<span class=\"token punctuation\">)<span class=\"token punctuation\">; it <span class=\"token operator\">!= v<span class=\"token punctuation\">.<span class=\"token function\">end<span class=\"token punctuation\">(<span class=\"token punctuation\">)<span class=\"token punctuation\">; it <span class=\"token operator\">++<span class=\"token punctuation\">) \n    <span class=\"token keyword\">if <span class=\"token punctuation\">(<span class=\"token constant\">NULL <span class=\"token operator\">!= <span class=\"token operator\">*it<span class=\"token punctuation\">) \n    <span class=\"token punctuation\">{\n        <span class=\"token keyword\">delete <span class=\"token operator\">*it<span class=\"token punctuation\">; \n        <span class=\"token operator\">*it <span class=\"token operator\">= <span class=\"token constant\">NULL<span class=\"token punctuation\">;\n    <span class=\"token punctuation\">}\nv<span class=\"token punctuation\">.<span class=\"token function\">clear<span class=\"token punctuation\">(<span class=\"token punctuation\">)<span class=\"token punctuation\">;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>\n\n\n三、转自博客：https://blog.csdn.net/hk_john/article/details/72463318\n\n最近经常用到vector容器，发现它的clear（）函数有点意思，经过验证之后进行一下总结。\n\nclear（）函数的调用方式是，vector&lt;datatype&gt; temp（50）;//定义了50个datatype大小的空间。temp.clear();\n\n作用：将会清空temp中的所有元素，包括temp开辟的空间（size），但是capacity会保留，即不可以以temp[1]这种形式赋初值，只能通过temp.push_back(value)的形式赋初值。\n\n同样对于vector&lt;vector&lt;datatype&gt; &gt; temp1（50）这种类型的变量，使用temp1.clear()之后将会不能用temp1[1].push_back(value)进行赋初值，只能使用temp1.push_back(temp)；的形式。\n\n下面的代码是可以运行的。\n\n<pre class=\"prism-token token  language-javascript\"></pre>\n\n1.  #include &lt;iostream&gt;\n2.  #include&lt;vector&gt;\n    3.4.  using namespace std;\n    5.6.  int main(){\n    7.8.  vector&lt;vector&lt;int&gt;&gt; test(50);\n3.  vector&lt;int&gt; temp;\n4.  test[10].push_back(1);\n5.  cout&lt;&lt;test[10][0]&lt;&lt;endl;\n6.  test.clear();\n    13.14.15.  for(int i=0;i&lt;51;i++)\n7.  test.push_back(temp);\n    17.18.  system(\"pause\");\n8.  return 0;\n9.  }\n\n但是这样是会越界错误的。\n\n<pre class=\"prism-token token  language-javascript\"></pre>\n\n1.  #include &lt;iostream&gt;\n2.  #include&lt;vector&gt;\n    3.4.  using namespace std;\n    5.6.  int main(){\n    7.8.  vector&lt;vector&lt;int&gt;&gt; test(50);\n3.  vector&lt;int&gt; temp;\n4.  test[10].push_back(1);\n5.  cout&lt;&lt;test[10][0]&lt;&lt;endl;\n6.  test.clear();\n    13.14.  for(int i=0;i&lt;50;i++)\n7.  test[i].push_back(1);\n    16.17.  system(\"pause\");\n8.  return 0;\n9.  }\n\n并且即使我们使用\n\n<pre class=\"prism-token token  language-javascript\"></pre>\n\n1.  for(int i=0;i&lt;100;i++)\n2.  test[i].push_back(1);\n\n都是可以的，因为size已经被清除了。\n","tags":["开发随笔"]},{"title":"BMP的保存","url":"/2021/08/26/bmp-de-bao-cun/","content":"\n#### 说明\n\n1. 做一个实际工程应用的项目 甲方是将图片拖到cad里进行观看 因此就要求比例尺等的信息保存 cad支持的只有tif和bmp，而我的软件的成图是基于opencv的 opencv的imwrite还是过于粗糙，因此查阅整理了一个完整bmp的函数\n2. bmp的头信息是很复杂的，并不是单纯的改个文件名就可以，这也是为什么 mfc的icon那么难搞 网上找遍格式转换的网站 只有那么一两个的转换结果可以使用（简直折磨）\n3. bmp格式这里不加赘述了 可以惨开[这个](https://blog.csdn.net/u012877472/article/details/50272771)\n\n#### 实现\n\nbmp.h\n\n```c++\n#ifndef BMP_H\n#define BMP_H\ntypedef unsigned char LBYTE;  //\ntypedef unsigned short LWORD; //\ntypedef unsigned int LDWORD;\ntypedef long LLONG; //\n\n#pragma pack(2)\ntypedef struct {\n  LWORD bfType;\n  LDWORD bfSize;\n  LWORD bfReserved1;\n  LWORD bfReserved2;\n  LDWORD bfOffBits;\n} LBITMAPFILEHEADER;\n// #pragma pack(pop)\n\ntypedef struct {\n  LDWORD biSize;\n  LLONG biWidth;\n  LLONG biHeight;\n  LWORD biPlanes;\n  LWORD biBitCount;\n  LDWORD biCompression;\n  LDWORD biSizeImage;\n  LLONG biXPelsPerMeter;\n  LLONG biYPelsPerMeter;\n  LDWORD biClrUsed;\n  LDWORD biClrImportant;\n} LBITMAPINFOHEADER;\n\ntypedef struct {\n  LBYTE rgbBlue;\n  LBYTE rgbGreen;\n  LBYTE rgbRed;\n  LBYTE rgbReserved;\n} LRGBQUAD;\n\ntypedef struct {\n  unsigned char *buf;\n  int width_x;\n  int height_y;\n  int deepth;\n  LRGBQUAD *palette;\n} LBmpbase;\n\n// bool saveBmp(char*, unsigned char*, int, int, int, RGBQUAD*);\n// Bmpbase readbmp(char*);\n/*bool saveBmp(char *, unsigned char *, int, int, int, LRGBQUAD *);*/\n\nbool SaveBmp(char *fileName, unsigned char *imgBuffer, int imWidth,\n             int imHeight, int x_scale, int y_scale, int m_colorTable);\n#endif\n\n```\n\nbmp.cpp\n\n参数说明，其他参数没有什么好说明的 从英文可以看出来 以此是文件名，图像的data, 宽 高 宽比例尺 高比例尺 \n\n最后一个参数是灰度彩色的标志位 `0表示灰度图 ` 非0为彩色\n\n```c++\n#include \"stdafx.h\"\n\n//\n#include \"bmp.h\"\n\nbool SaveBmp(char *fileName, unsigned char *imgBuffer, int imWidth,\n             int imHeight, int x_scale, int y_scale, int m_colorTable) {\n  if (!imgBuffer) {\n    return 0;\n  }\n  int biBitCount;\n\n  if (m_colorTable) {\n    biBitCount = 24;\n  } else if (m_colorTable == 0) {\n    biBitCount = 8;\n  }\n  int colorTablesize;\n  if (m_colorTable) {\n    colorTablesize = 0;\n  } else if (m_colorTable == 0) {\n    colorTablesize = 1024;\n  }\n  //颜色表大小，以字节为单位，灰度图颜色表大小1024，彩色图为0\n  int lineByte = (imWidth * biBitCount / 8 + 3) / 4 * 4;\n  FILE *fp = fopen(fileName, \"wb\");\n  if (!fp) {\n    return 0;\n  }\n  LBITMAPFILEHEADER filehead;\n  filehead.bfType = 0x4D42;\n  filehead.bfSize = sizeof(LBITMAPFILEHEADER) + sizeof(LBITMAPINFOHEADER) +\n                    colorTablesize + lineByte * imHeight;\n  filehead.bfReserved1 = 0;\n  filehead.bfReserved2 = 0;\n  filehead.bfOffBits = 54 + colorTablesize;\n  //写位图文件头进文件\n  fwrite(&filehead, sizeof(LBITMAPFILEHEADER), 1, fp);\n\n  //申请位图文件信息头结构变量， 填写文件信息头信息\n  LBITMAPINFOHEADER infoHead;\n  infoHead.biBitCount = biBitCount;\n  infoHead.biClrImportant = 0;\n  infoHead.biClrUsed = 0;\n  infoHead.biSize = 40;\n  infoHead.biWidth = imWidth;\n  infoHead.biHeight = imHeight;\n  infoHead.biPlanes = 1;\n  infoHead.biCompression = BI_RGB;\n  infoHead.biSizeImage = lineByte * imHeight;\n  infoHead.biXPelsPerMeter = x_scale;\n  infoHead.biYPelsPerMeter = y_scale;\n  fwrite(&infoHead, sizeof(LBITMAPINFOHEADER), 1, fp);\n\n  if (m_colorTable == 0) {\n    LRGBQUAD *pColorTable = new LRGBQUAD[256];\n\n    for (int i = 0; i < 256; i++) {\n      pColorTable[i].rgbBlue = i;\n      pColorTable[i].rgbGreen = i;\n      pColorTable[i].rgbRed = i;\n      pColorTable[i].rgbReserved = 0;\n    }\n    fwrite(pColorTable, sizeof(LRGBQUAD), 256, fp); //彩色图 无需写入颜色表\n  }\n\n  //写位图数据进文件\n  fwrite(imgBuffer, imHeight * lineByte, 1, fp);\n\n  fclose(fp);\n  return 1;\n}\n```\n\n#### 调用\n\n其实还有一个注意的点就是 `bmp还涉及到一个反转的问题` 从opencv的mat格式 存储为bmp是需要对mat进行一下`反转`\n\n我的调用图下\n\n```c++\n    Mat res;\n    flip(img, res, 0); // bmp需要垂直反转\n\n    CString strID;\n    strID.Format(\"_%ld.bmp\", m_conTab.GetCurSel() + 1);\n    strFileName.Replace(\".bmp\", strID);\n    if (i == 0 || i == 2) {\n      //深度图按设定的比例尺保存\n      SaveBmp((LPSTR)(LPCTSTR)strFileName, res.data, m_pView->m_dwWidth,\n              m_pView->m_dwHeight,\n              round((double)1000 * m_xactualScale / m_nHScales[i]),\n              round((double)1000 * m_yactualScale / m_nVScales[i]), m_colorMap);\n    } else {\n      //频率和hv图片等比保存\n      SaveBmp((LPSTR)(LPCTSTR)strFileName, res.data, m_pView->m_dwWidth,\n              m_pView->m_dwHeight,\n              round((double)1000 * m_xactualScale / m_nHScales[i]),\n              round((double)1000 * m_xactualScale / m_nHScales[i]), m_colorMap);\n    }\n```\n\n","tags":["开发随笔"]},{"title":"Qt样式表导入","url":"/2021/07/26/qt-yang-shi-biao-dao-ru/","content":"\n```c++\n#include \"select.h\"\n#include <QtWidgets/QApplication>\nint main(int argc, char *argv[]) {\n  QApplication a(argc, argv);\n  select1 w;\n\n  QFile qssFile(\n      \"D://qq received//select//select//lightblue.css\"); //资源文件\":/css.qss\"\n  qssFile.open(QFile::ReadOnly);\n  if (qssFile.isOpen()) {\n    QString qss = QLatin1String(qssFile.readAll()); //读取\n    qApp->setStyleSheet(qss);                       //设置\n    qssFile.close();\n  }\n\n  w.show();\n  return a.exec();\n}\n```\n\n另外 qt有一个样式表生成的小工具 quicreator 可以自行查找","tags":["开发随笔"]},{"title":"串口发送问题","url":"/2021/04/20/chuan-kou-fa-song-wen-ti/","content":"\n串口发送hex命令为char型的十六进制命令，并用到了CRC16校验，分别取校验结果数据的高低位\n\n10进制int型数据转16进制，并取高低位：\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\n\n#define TABLE_METHOD    1\nstatic const uint8_t CRCHi[] = {\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n    0x00, 0xC1, 0x81, 0x40\n};\n\nstatic const uint8_t CRCLo[] = {\n    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,\n    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,\n    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,\n    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,\n    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,\n    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,\n    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,\n    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,\n    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,\n    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,\n    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,\n    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,\n    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,\n    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,\n    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,\n    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,\n    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,\n    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,\n    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,\n    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,\n    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,\n    0x41, 0x81, 0x80, 0x40\n};\n\nuint16_t CRC16( uint8_t *Frame, uint16_t Len )\n{\n    uint8_t        ucCRCHi = 0xFF;\n    uint8_t        ucCRCLo = 0xFF;\n    int                iIndex;\n\n    while( Len-- )\n    {\n        iIndex = ucCRCLo ^ *( Frame++ );\n        ucCRCLo = ( uint8_t )( ucCRCHi ^ CRCHi[iIndex] );\n        ucCRCHi = CRCLo[iIndex];\n    }\n    return ( uint16_t )( ucCRCHi << 8 | ucCRCLo );\n}\n\n\nint main(int argc, char const *argv[]) {\n  char a[] = {0x01,0x02,0x03, 0x0d};\n  char* temp = a;\n  uint16_t c = CRC16((uint8_t *)temp, 4);\n  cout<< c <<endl;\n  int cL= c%256 & 0xff;   //校验结果的低位\n  int cH = c/ 256 & 0xff; //校验结果的高位\n}\n```\n\n　　后续只需对得到的高低位数据进行强制类型转换就可以插入到命令字符串中发送了~\n","tags":["开发随笔"]}]